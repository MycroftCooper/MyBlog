<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Unity3D 2D射击小游戏移动幻影的实现</title>
    <link href="/2022/03/01/Unity3D%202D%E8%AE%BE%E8%AE%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%A7%BB%E5%8A%A8%E5%B9%BB%E5%BD%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/01/Unity3D%202D%E8%AE%BE%E8%AE%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%A7%BB%E5%8A%A8%E5%B9%BB%E5%BD%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>本片文章是对<a href="https://www.bilibili.com/video/bv1sY411V7tx%E8%A7%86%E9%A2%91%E4%B8%AD%E7%A7%BB%E5%8A%A8%E5%B9%BB%E5%BD%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AE%B2%E8%A7%A3%E6%95%99%E7%A8%8B%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%8E%BBB%E7%AB%99%E7%BB%99%E6%88%91%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%E9%B8%AD%EF%BC%81">https://www.bilibili.com/video/bv1sY411V7tx视频中移动幻影是如何实现的一个讲解教程，欢迎大家去B站给我一键三连鸭！</a></p><p>这个项目的整个代码和资源已经上传到了GitHub，大家可以去看一下<br>链接：<a href="https://github.com/MycroftCooper/TigerShooting2DGame">https://github.com/MycroftCooper/TigerShooting2DGame</a></p><h1 id="1-效果分析"><a href="#1-效果分析" class="headerlink" title="1. 效果分析"></a>1. 效果分析</h1><p>![移动拖影](/images/Unity3D 2D设计小游戏移动幻影的实现/移动拖影.gif)</p><p>![image-20220302233640359](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220302233640359.png)</p><p>根据上图的移动幻影效果，我们可以分析出，它应该具有以下几个功能：</p><ol><li>在小老虎冲刺的时候，产生幻影</li><li>幻影的精灵图片应该是那一帧小老虎的动作</li><li>幻影要能定时消失</li><li>幻影的透明度要低于正常的精灵</li></ol><h1 id="2-素材准备"><a href="#2-素材准备" class="headerlink" title="2. 素材准备"></a>2. 素材准备</h1><p>根据以上的四个功能，我们可以知道，实际上幻影的效果可以直接用精灵去实现。</p><p>首先我们需要准备好小老虎翻滚的帧动画，并且实现翻滚的功能(此处略过)<br>![image-20220305001822640](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220305001822640.png)然后我们创建一个幻影的预制体，并为它加上精灵渲染器组件，如下图所示(想要有几个幻影就复制几个预制体)</p><p>![image-20220303000051726](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220303000051726.png)</p><p>![image-20220303000107408](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220303000107408.png)</p><p>其中精灵是哪张图片无所谓，反正最后要用代码去动态的控制，其中的材质也是精灵图片的默认材质，如下图所示：<br>![image-20220304233846358](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220304233846358.png)</p><h1 id="2-功能实现"><a href="#2-功能实现" class="headerlink" title="2. 功能实现"></a>2. 功能实现</h1><h2 id="2-1-产生幻影"><a href="#2-1-产生幻影" class="headerlink" title="2.1 产生幻影"></a>2.1 产生幻影</h2><p>这个功能很简单，就是把预制体移动到小老虎的位置坐标，然后让材质的透明度提升到半透明状态即可：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 小老虎的动画控制器</span><br><span class="hljs-keyword">private</span> PlayerAnimaController anim;    <br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddGhost</span>(<span class="hljs-params">SpriteRenderer sr</span>)</span> &#123;<br>  <span class="hljs-comment">// 把幻影位置设置为小老虎的位置坐标</span><br>  sr.transform.position = anim.transform.position;<br>  <span class="hljs-comment">// 通过材质的颜色设置，使幻影半透明(更改透明度alpha值)</span><br>  sr.material.color = <span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0.6f</span>);<br>  <span class="hljs-comment">// 使幻影的反转与小老虎一样</span><br>  sr.flipX = anim.IsFlip;<br>  <span class="hljs-comment">// 使幻影的精灵图片与当前小老虎的一致</span><br>  sr.sprite = anim.sr.sprite;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-按时间产生与消失"><a href="#2-2-按时间产生与消失" class="headerlink" title="2.2 按时间产生与消失"></a>2.2 按时间产生与消失</h2><p>想要让三个幻影从小老虎翻滚开始，按照固定的时间间隔产生，再按照相同的时间间隔消失，这个有很多种方法可以做到。<br>能立马想到的有：协程，计时器(Timer)等等。<br>但实际上，我使用的是DoTween里的动画队列Sequence。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> DG.Tweening;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> ghostInterval;<span class="hljs-comment">// 幻影出现的时间间隙</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fadeTime;<span class="hljs-comment">// 幻影消失的时间间隙</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowGhost</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 初始化一个动画队列</span><br>Sequence s = DOTween.Sequence();<br>  <br>  <span class="hljs-comment">// 产生幻影的动画队列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>Transform currentGhost = transform.GetChild(i);<br>    SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>    s.AppendCallback(() =&gt; AddGhost(sr));<br>    s.AppendInterval(ghostInterval);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 幻影消失的动画队列</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>    Transform currentGhost = transform.GetChild(i);<br>    SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>    s.AppendCallback(() =&gt; sr.material.DOColor(<span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0</span>), fadeTime));<br>    s.AppendInterval(fadeTime);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>DoTween是一个非常好用且免费的Unity插件，它一般用于解决补间动画的程序控制，在Unity资源商店就可以获得，后面我也会出一期对应的教程！</p></blockquote><h1 id="3-源代码"><a href="#3-源代码" class="headerlink" title="3. 源代码"></a>3. 源代码</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> DG.Tweening;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GhostTrail</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">private</span> PlayerAnimaController anim;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> ghostInterval;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fadeTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>            Transform currentGhost = transform.GetChild(i);<br>            SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>            sr.color = <span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">1f</span>);<br>            sr.material.color = <span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0f</span>);<br>        &#125;<br>        anim = FindObjectOfType&lt;PlayerAnimaController&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowGhost</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Sequence s = DOTween.Sequence();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>            Transform currentGhost = transform.GetChild(i);<br>            SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>            s.AppendCallback(() =&gt; AddGhost(sr));<br>            s.AppendInterval(ghostInterval);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>            Transform currentGhost = transform.GetChild(i);<br>            SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>            s.AppendCallback(() =&gt; sr.material.DOColor(<span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0</span>), fadeTime));<br>            s.AppendInterval(fadeTime);<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddGhost</span>(<span class="hljs-params">SpriteRenderer sr</span>)</span> &#123;<br>        sr.transform.position = anim.transform.position;<br>        sr.material.color = <span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0.6f</span>);<br>        sr.flipX = anim.IsFlip;<br>        sr.sprite = anim.sr.sprite;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="5-后语"><a href="#5-后语" class="headerlink" title="5. 后语"></a>5. 后语</h1><p>这个小项目还有其它很多小技术点，感觉后面可以再跟大家分享一下！你们有说明想要交流的也可以直接跟我留言鸭！<br>B站账号：<a href="https://space.bilibili.com/172549987?spm_id_from=333.1007.0.0">https://space.bilibili.com/172549987?spm_id_from=333.1007.0.0</a><br>CSDN账号：<a href="https://blog.csdn.net/qq_44705559?spm=1001.2101.3001.5343">https://blog.csdn.net/qq_44705559?spm=1001.2101.3001.5343</a><br>GitHub账号：<a href="https://github.com/MycroftCooper">https://github.com/MycroftCooper</a><br>个人博客：<a href="https://mycroftcooper.github.io/">https://mycroftcooper.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>游戏实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏实现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 2D射击小游戏瞄准线的实现</title>
    <link href="/2022/03/01/Unity3D%202D%E5%B0%84%E5%87%BB%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9E%84%E5%87%86%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/01/Unity3D%202D%E5%B0%84%E5%87%BB%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9E%84%E5%87%86%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>本片文章是对<a href="https://www.bilibili.com/video/bv1sY411V7tx%E8%A7%86%E9%A2%91%E4%B8%AD%E7%9E%84%E5%87%86%E7%BA%BF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AE%B2%E8%A7%A3%E6%95%99%E7%A8%8B%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%8E%BBB%E7%AB%99%E7%BB%99%E6%88%91%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%E9%B8%AD%EF%BC%81">https://www.bilibili.com/video/bv1sY411V7tx视频中瞄准线是如何实现的一个讲解教程，欢迎大家去B站给我一键三连鸭！</a></p><p>这个项目的整个代码和资源已经上传到了GitHub，大家可以去看一下<br>链接：<a href="https://github.com/MycroftCooper/TigerShooting2DGame">https://github.com/MycroftCooper/TigerShooting2DGame</a></p><h1 id="1-效果分析"><a href="#1-效果分析" class="headerlink" title="1. 效果分析"></a>1. 效果分析</h1><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220222715775.png" srcset="/img/loading.gif" alt="image-20220220222715775"></p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/%E7%9E%84%E5%87%86%E7%BA%BF.gif" srcset="/img/loading.gif" alt="瞄准线"></p><p>根据视频中的瞄准线效果，我们可以分析出，它应该具有以下几个功能：</p><ol><li>准星会时刻和玩家鼠标保持位置一致</li><li>瞄准线的另一头始终要在枪上</li><li>当准星放在敌人身上，瞄准线和准星会变红</li><li>当开火时准星会有所变化</li></ol><h1 id="2-素材准备"><a href="#2-素材准备" class="headerlink" title="2. 素材准备"></a>2. 素材准备</h1><p>根据以上四个功能，我们就可以知道，其实这个瞄准线的效果应该是分为瞄准线和准星两部分的<br>所以，我们分别准备好这两部分的素材：<br><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220223426285.png" srcset="/img/loading.gif" alt="image-20220220223426285"></p><p>其中Line为瞄准线，而Sight为准星。</p><h2 id="2-1-瞄准线-Line"><a href="#2-1-瞄准线-Line" class="headerlink" title="2.1 瞄准线 Line"></a>2.1 瞄准线 Line</h2><p>瞄准线的素材有两种：</p><ol><li>红线：瞄准敌人时使用</li><li>白线：没瞄上敌人时使用</li></ol><p>准线是要做成预制体放在游戏里的，所以一张图导入Unity后按照Sprite去切就没问题</p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220223646127.png" srcset="/img/loading.gif" alt="image-20220220223646127"></p><p>因为是像素游戏，所以记得正确设置<strong>单位像素数</strong>，<strong>网格类型</strong>和<strong>过滤模式</strong>，设置如下：<br><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220224440440.png" srcset="/img/loading.gif" alt="image-20220220224440440"></p><p>在切的时候需要注意的是，瞄准线的长度我们想让它是可变的，而且是从固定的一段开始伸缩。所以在用精灵切片的时候需要做两件事：设置<strong>平铺边界</strong>(绿色线)和<strong>锚点</strong>(设到左边)，如下图所示：<br><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220224315712.png" srcset="/img/loading.gif" alt="image-20220220224315712"></p><p>如此一来，瞄准线的素材图就导入成功了，接下来就是：</p><ol><li>创建一个预制体</li><li>添加一个精灵渲染器</li><li>将精灵设为刚刚切好的一个瞄准线的精灵图片</li><li>设置绘制模式(只有设置成平铺才能任意伸缩)</li><li>设置图层顺序(设成-2就能保证瞄准线总是在图层的最前面了)</li></ol><p>如下图所示：</p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220224836597.png" srcset="/img/loading.gif" alt="image-20220220224836597"></p><p>瞄准线的素材就准备完毕啦！</p><h2 id="2-2-准星Sight"><a href="#2-2-准星Sight" class="headerlink" title="2.2 准星Sight"></a>2.2 准星Sight</h2><p>准星有四种素材：</p><ol><li>Sight_Off：没瞄到敌人且没开火的准星</li><li>Sight_Off_Fire：没瞄到敌人还开火的准星</li><li>Sight_On：瞄到敌人但没开火的准星</li><li>Sight_On_Fire：瞄到敌人还开火的准星</li></ol><p>准星实际上有两种实现方法：</p><ol><li>也做成游戏物体加入场景中</li><li>切换游戏光标，让游戏的默认光标变为准星</li></ol><p>这里我们采用第二种方法吧，第一种大家肯定是会的。</p><p>准星的素材图片最好不要使用精灵，而是有一种专门给准星用的格式：光标(Texture 2D)<br>这种格式的图片无法切图，所以最好把准星的图片自己提前切好再导入，如下图所示：</p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220225325559.png" srcset="/img/loading.gif" alt="image-20220220225325559"></p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220225352696.png" srcset="/img/loading.gif" alt="image-20220220225352696"></p><p>这样准星的素材我们也导入完毕了！</p><h2 id="2-3-素材管理代码"><a href="#2-3-素材管理代码" class="headerlink" title="2.3 素材管理代码"></a>2.3 素材管理代码</h2><p>因为在游戏的过程中，我们会根据开火情况和瞄准情况来反复更换准星和瞄准线，所以可以写一份代码来专门管理这两种瞄准线和四种准星的素材。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SightResouses</span> &#123;<br>  <span class="hljs-comment">// 用List存储读取的瞄准线(精灵 Sprite)</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Sprite&gt; spritesList = <br>          <span class="hljs-keyword">new</span> List&lt;Sprite&gt;(Resources.LoadAll&lt;Sprite&gt;(<span class="hljs-string">&quot;Line&quot;</span>));<br>  <br>  <span class="hljs-comment">// 用字典存储读取的准星(2D纹理 Texture2D)</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Texture2D&gt; textureList = <br>          <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Texture2D&gt;&#123;<br>            &#123;<span class="hljs-string">&quot;Sight_On&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_On&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_Off&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_Off&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>)&#125;,<br>        &#125;;<br>  <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Sprite <span class="hljs-title">GetResouseSprite</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> =&gt;<br>            spritesList.Find(x =&gt; x.name == name);<br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_On &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_On&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_On_Fire &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_Off &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_Off&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_Off_Fire &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sprite Sight_On_Line &#123; <span class="hljs-keyword">get</span> =&gt; GetResouseSprite(<span class="hljs-string">&quot;Sight_On_Line&quot;</span>); &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sprite Sight_Off_Line &#123; <span class="hljs-keyword">get</span> =&gt; GetResouseSprite(<span class="hljs-string">&quot;Sight_Off_Line&quot;</span>); &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>放在预制体里的瞄准线是 <strong>精灵 Sprite</strong><br>作为光标素材的准星是 <strong>2D纹理 Texture2D</strong></p></blockquote><p>这样，通过静态类SightResouses，我们就可以轻松的拿到需要的素材了</p><h1 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3. 功能实现"></a>3. 功能实现</h1><p>根据之前的效果分析，我们接下来拆分一下功能：</p><ol><li>我们需要知道鼠标当前的位置<br>让瞄准线伸缩到合适长度<br>让瞄准线指向光标(准星)</li><li>我们需要知道当前是否处于开火状态<br>并且根据开火状态改变瞄准线与准星的素材资源</li><li>我们需要知道当前是否处于瞄准敌人的状态<br>并且根据瞄准状态改变瞄准线与准星的素材资源</li></ol><p>那么我们就一个一个的去实现吧！</p><h2 id="3-1-伸缩并指向"><a href="#3-1-伸缩并指向" class="headerlink" title="3.1 伸缩并指向"></a>3.1 伸缩并指向</h2><p>要想正确的将瞄准线伸缩指向光标，我们需要一下信息：</p><ol><li>光标现在在哪(获取光标屏幕坐标-&gt;转换坐标得到世界坐标)</li><li>瞄准线现在的原点在哪(瞄准线会挂在枪上，所以直接取transform.position就好)</li></ol><p>有了两点就可以确定一条直线了！</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Vector2 MousePos;<span class="hljs-comment">// 光标世界坐标</span><br><span class="hljs-keyword">public</span> Vector2 SightPos;<span class="hljs-comment">// 准星原点坐标</span><br><span class="hljs-keyword">public</span> Vector2 StartPosOffset;<span class="hljs-comment">// 瞄准线起点偏移值</span><br><span class="hljs-keyword">public</span> Vector2 CollisionOffset;<span class="hljs-comment">// 光标与准星中心的偏移值</span><br><br><span class="hljs-comment">// 更新当前光标位置</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateMousePos</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 获取光标屏幕坐标</span><br>Vector3 screenMousePos = <span class="hljs-keyword">new</span> Vector3(Input.mousePosition.x, Input.mousePosition.y, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 转换坐标得到世界坐标</span><br>MousePos = Camera.main.ScreenToWorldPoint(screenMousePos);<br>  <span class="hljs-comment">// 光标坐标加上偏移值就是准星的中心</span><br>SightPos = MousePos + CollisionOffset;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> LineWide = <span class="hljs-number">0.15f</span>;<br><span class="hljs-keyword">private</span> SpriteRenderer sightLineRenderer;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateLine</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 根据当前瞄准线原点位置加上偏移量(从枪中间移到枪口),就是瞄准线的起点</span><br>  Vector2 pos = transform.parent.position + (Vector3)StartPosOffset;<br>  <span class="hljs-comment">// 获取两点间距离</span><br>  <span class="hljs-built_in">float</span> d = Vector2.Distance(pos, SightPos);<br>  <span class="hljs-comment">// 设置精灵渲染器的平铺尺寸来伸缩瞄准线</span><br>  sightLineRenderer.size = <span class="hljs-keyword">new</span> Vector2(d + <span class="hljs-number">0.2f</span>, LineWide);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：为什么要有两个偏移值？<br>StartPosOffset：<br>实际上是瞄准线的起点偏移值，瞄准线的父物体是枪，如果不设这个偏移值，瞄准线就会从枪中心而不是枪口延申出来<br>CollisionOffset：<br>实际上是瞄准线的终点偏移值，准星的锚点我们希望它在图片正中间，但是当它作为光标使用时，它的锚点在左上角，所以需要进行偏移</p></blockquote><p>现在我们可以做到瞄准线根据鼠标所在的位置来正确伸缩了！</p><p>那么，指向怎么实现？这里的代码我放在了瞄准线的父物体，枪的控制代码中了，但也不难，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lookAtSight</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 获取准星的世界坐标</span><br>Vector2 SightPos = SC.SightPos;<br>  <span class="hljs-comment">// 先让轴指向准星</span><br>transform.LookAt(<span class="hljs-keyword">new</span> Vector3(SightPos.x, SightPos.y));<br>  <span class="hljs-comment">// 再y轴旋转-90度</span><br>transform.Rotate(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">-90</span>, <span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:为什么要旋转-90度？<br>因为 transform.LookAt() 本质上是让本物体的Z轴正方向指向目标点<br>可我们是2D游戏，Z轴正方向会垂直于游戏画面，就看不见了，所以得旋转一下</p></blockquote><p>这样，我们就完成了指向</p><p>伸缩和指向两个功能都是实线啦！</p><h2 id="3-2-状态检测与素材替换"><a href="#3-2-状态检测与素材替换" class="headerlink" title="3.2 状态检测与素材替换"></a>3.2 状态检测与素材替换</h2><p>接下来我们需要实现的是：</p><ol><li>瞄准状态的检测:有没有瞄着敌人？</li><li>开火状态的检测:有没有在开火？</li><li>根据状态进行素材替换</li></ol><p>先看<strong>开火状态的检测</strong>，这个简单，看看鼠标的输入就行，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsOnFire;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateOnFire</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 判断有没有按着开火键</span><br><span class="hljs-keyword">if</span> (Input.GetButton(<span class="hljs-string">&quot;Fire1&quot;</span>)) &#123;<br>IsOnFire = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 更新瞄准器素材</span><br>updateSightResouses();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>  <span class="hljs-comment">// 没按着而且不在开火状态，就不重复换素材了</span><br><span class="hljs-keyword">if</span> (!IsOnFire) <span class="hljs-keyword">return</span>;<br>IsOnFire = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 更新瞄准器素材</span><br>updateSightResouses();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：为啥是Input.GetButton，不是说要看鼠标的输入吗？<br>这个啊，这个叫虚拟输入轴，快去我以前的文章学习一下吧：<br><a href="https://mycroftcooper.github.io/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/">https://mycroftcooper.github.io/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/</a></p></blockquote><p>再看<strong>瞄准状态的检测</strong>，这个得用到Physics2D.OverlapCircle，是一种简单的射线检测方式，API如下：<a href="https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics2D.OverlapCircle.html">Physics2D.OverlapCircle</a><br>可以去看看这位老哥写的相关教程：<a href="http://www.voycn.com/article/unity2djiancefangfaoverlapcircleyuraycastxiangjie">http://www.voycn.com/article/unity2djiancefangfaoverlapcircleyuraycastxiangjie</a><br>如果想更加系统化的了解射线检测，可以取看看我之前写的这个文章：<br><a href="https://mycroftcooper.github.io/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/">https://mycroftcooper.github.io/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/</a></p><p>总而言之，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsOnEntity;<br><span class="hljs-keyword">public</span> LayerMask EnemiesLayer;<br><span class="hljs-keyword">public</span> Vector2 CollisionOffset;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> collisionRadius = <span class="hljs-number">0.25f</span>;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateOnEntity</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-comment">// 判断有没有瞄着敌人</span><br>Collider2D entity = Physics2D.OverlapCircle((Vector2)MousePos + CollisionOffset, collisionRadius, EnemiesLayer);<br><span class="hljs-keyword">if</span> (entity != <span class="hljs-literal">null</span> &amp;&amp; entity.tag == <span class="hljs-string">&quot;Enemies&quot;</span>) &#123;<br><span class="hljs-keyword">if</span> (IsOnEntity) <span class="hljs-keyword">return</span>;<br>IsOnEntity = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 更新瞄准器素材</span><br>updateSightResouses();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!IsOnEntity) <span class="hljs-keyword">return</span>;<br>IsOnEntity = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 更新瞄准器素材</span><br>updateSightResouses();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你想在编辑器中看到你的射线检测范围，可以使用如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span> &#123;<br>Gizmos.color = debugCollisionColor;<br>Gizmos.DrawWireSphere(SightPos, collisionRadius);<br>&#125;<br></code></pre></td></tr></table></figure><p>完成后如下图所示：<br><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220234824204.png" srcset="/img/loading.gif" alt="image-20220220234824204"></p><p>绿圈圈就是你的射线检测范围啦(我这里没改偏移量有点偏，你们记得根据自己的精度需要去设置哦)</p><p>这样以来，瞄准线状态的检测就算完成啦，接下来进行素材替换的实现，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateSightResouses</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">if</span> (IsOnEntity) &#123;<br>sightLineRenderer.sprite = SightResouses.Sight_On_Line;<br><span class="hljs-keyword">if</span> (IsOnFire) &#123;<br>      Cursor.SetCursor(SightResouses.Sight_On_Fire, hotSpot, CursorMode.Auto);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Cursor.SetCursor(SightResouses.Sight_On, hotSpot, CursorMode.Auto);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    sightLineRenderer.sprite = SightResouses.Sight_Off_Line;<br>    <span class="hljs-keyword">if</span> (IsOnFire) &#123;<br>      Cursor.SetCursor(SightResouses.Sight_Off_Fire, hotSpot, CursorMode.Auto);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Cursor.SetCursor(SightResouses.Sight_Off, hotSpot, CursorMode.Auto);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之前写的素材管理代码用上了吧！</p><p>如此一来，整个瞄准线的功能就实现了，可以把它挂到枪上咯！</p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220235416020.png" srcset="/img/loading.gif" alt="image-20220220235416020"></p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220235337492.png" srcset="/img/loading.gif" alt="image-20220220235337492"></p><h1 id="4-源代码"><a href="#4-源代码" class="headerlink" title="4. 源代码"></a>4. 源代码</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SightController</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SightResouses</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">Sprite</span>&gt; spritesList</span> = <span class="hljs-keyword">new</span> List&lt;Sprite&gt;(Resources.LoadAll&lt;Sprite&gt;(<span class="hljs-string">&quot;Line&quot;</span>));<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Texture2D&gt; textureList = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Texture2D&gt;&#123;<br>            &#123;<span class="hljs-string">&quot;Sight_On&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_On&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_Off&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_Off&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>)&#125;,<br>        &#125;;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Sprite <span class="hljs-title">GetResouseSprite</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> =&gt;<br>            spritesList.Find(x =&gt; x.name == name);<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_On &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_On&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_On_Fire &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_Off &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_Off&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_Off_Fire &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sprite Sight_On_Line &#123; <span class="hljs-keyword">get</span> =&gt; GetResouseSprite(<span class="hljs-string">&quot;Sight_On_Line&quot;</span>); &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sprite Sight_Off_Line &#123; <span class="hljs-keyword">get</span> =&gt; GetResouseSprite(<span class="hljs-string">&quot;Sight_Off_Line&quot;</span>); &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Vector2 MousePos;<br>    <span class="hljs-keyword">public</span> Vector2 SightPos;<br>    <span class="hljs-keyword">public</span> Vector2 StartPosOffset;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123;<br>        IsOnFire = <span class="hljs-literal">false</span>;<br>        IsOnEntity = <span class="hljs-literal">false</span>;<br>        sightLineRenderer = GetComponentInChildren&lt;SpriteRenderer&gt;();<br>        sightLineRenderer.sprite = SightResouses.Sight_Off_Line;<br>        Cursor.SetCursor(SightResouses.Sight_Off, hotSpot, CursorMode.Auto);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br>        updateSight();<br>        updateLine();<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 准星相关</span><br>    [<span class="hljs-meta">Header(<span class="hljs-meta-string">&quot;Sight&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Vector2 hotSpot;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsOnFire;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsOnEntity;<br><br>    [<span class="hljs-meta">Header(<span class="hljs-meta-string">&quot;Collision&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> LayerMask EnemiesLayer;<br>    <span class="hljs-keyword">public</span> Vector2 CollisionOffset;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> collisionRadius = <span class="hljs-number">0.25f</span>;<br>    <span class="hljs-keyword">private</span> Color debugCollisionColor = Color.green;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateSight</span>(<span class="hljs-params"></span>)</span> &#123;<br>        updateMousePos();<br>        updateOnEntity();<br>        updateOnFire();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateMousePos</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Vector3 screenMousePos = <span class="hljs-keyword">new</span> Vector3(Input.mousePosition.x, Input.mousePosition.y, <span class="hljs-number">0</span>);<br>        MousePos = Camera.main.ScreenToWorldPoint(screenMousePos);<br>        SightPos = MousePos + CollisionOffset;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateSightResouses</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (IsOnEntity) &#123;<br>            sightLineRenderer.sprite = SightResouses.Sight_On_Line;<br>            <span class="hljs-keyword">if</span> (IsOnFire) &#123;<br>                Cursor.SetCursor(SightResouses.Sight_On_Fire, hotSpot, CursorMode.Auto);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Cursor.SetCursor(SightResouses.Sight_On, hotSpot, CursorMode.Auto);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sightLineRenderer.sprite = SightResouses.Sight_Off_Line;<br>            <span class="hljs-keyword">if</span> (IsOnFire) &#123;<br>                Cursor.SetCursor(SightResouses.Sight_Off_Fire, hotSpot, CursorMode.Auto);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Cursor.SetCursor(SightResouses.Sight_Off, hotSpot, CursorMode.Auto);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateOnFire</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (Input.GetButton(<span class="hljs-string">&quot;Fire1&quot;</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (IsOnFire) <span class="hljs-keyword">return</span>;<br>            IsOnFire = <span class="hljs-literal">true</span>;<br>            updateSightResouses();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!IsOnFire) <span class="hljs-keyword">return</span>;<br>        IsOnFire = <span class="hljs-literal">false</span>;<br>        updateSightResouses();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateOnEntity</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Collider2D entity = Physics2D.OverlapCircle((Vector2)MousePos + CollisionOffset, collisionRadius, EnemiesLayer);<br>        <span class="hljs-keyword">if</span> (entity != <span class="hljs-literal">null</span> &amp;&amp; entity.tag == <span class="hljs-string">&quot;Enemies&quot;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (IsOnEntity) <span class="hljs-keyword">return</span>;<br>            IsOnEntity = <span class="hljs-literal">true</span>;<br>            updateSightResouses();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!IsOnEntity) <span class="hljs-keyword">return</span>;<br>        IsOnEntity = <span class="hljs-literal">false</span>;<br>        updateSightResouses();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Gizmos.color = debugCollisionColor;<br>        Gizmos.DrawWireSphere(SightPos, collisionRadius);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 准线相关</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> LineWide = <span class="hljs-number">0.15f</span>;<br>    <span class="hljs-keyword">private</span> SpriteRenderer sightLineRenderer;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateLine</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Vector2 pos = transform.parent.position + (Vector3)StartPosOffset;<br><br>        <span class="hljs-built_in">float</span> d = Vector2.Distance(pos, SightPos);<br>        sightLineRenderer.size = <span class="hljs-keyword">new</span> Vector2(d + <span class="hljs-number">0.2f</span>, LineWide);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>别忘了父物体枪械上的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void look<span class="hljs-constructor">AtSight()</span> &#123;<br>  <span class="hljs-comment">// 获取准星的世界坐标</span><br>Vector2 SightPos = SC.SightPos;<br>  <span class="hljs-comment">// 先让轴指向准星</span><br>transform.<span class="hljs-constructor">LookAt(<span class="hljs-params">new</span> Vector3(SightPos.<span class="hljs-params">x</span>, SightPos.<span class="hljs-params">y</span>)</span>);<br>  <span class="hljs-comment">// 再y轴旋转-90度</span><br>transform.<span class="hljs-constructor">Rotate(<span class="hljs-params">new</span> Vector3(0, -90, 0)</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然想放在瞄准线的控制代码里也行，如果不需要枪械也同步旋转的话。</p><h1 id="5-后语"><a href="#5-后语" class="headerlink" title="5. 后语"></a>5. 后语</h1><p>这个小项目还有其它很多小技术点，感觉后面可以再跟大家分享一下！你们有说明想要交流的也可以直接跟我留言鸭！<br>B站账号：<a href="https://space.bilibili.com/172549987?spm_id_from=333.1007.0.0">https://space.bilibili.com/172549987?spm_id_from=333.1007.0.0</a><br>CSDN账号：<a href="https://blog.csdn.net/qq_44705559?spm=1001.2101.3001.5343">https://blog.csdn.net/qq_44705559?spm=1001.2101.3001.5343</a><br>GitHub账号：<a href="https://github.com/MycroftCooper">https://github.com/MycroftCooper</a><br>个人博客：<a href="https://mycroftcooper.github.io/">https://mycroftcooper.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>游戏实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏实现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏设计文档</title>
    <link href="/2021/12/12/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2021/12/12/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是游戏设计文档-GDD"><a href="#1-1-什么是游戏设计文档-GDD" class="headerlink" title="1.1 什么是游戏设计文档(GDD)"></a>1.1 什么是游戏设计文档(GDD)</h2><p><strong>游戏设计文档</strong> (game design document <strong>GDD</strong> )，是在游戏开发的筹备阶段，需要准备的一系列文档的统称。<br>一般是在确立项目时需要准备好GDD，是用来和同事，老板，乃至投资者画饼的有效工具。</p><p>GDD没有官方统一格式<br>每个游戏设计师都可以根据自己的喜好和项目的需要去编写GDD<br>本文只是对自己理解的GDD进行总结与分享</p><p><strong>组成:</strong><br>GDD一般分为以下三个部分：</p><ol><li>简要设计文档</li><li>详细设计文档</li><li>游戏流程表</li></ol><p>以上每种文档在游戏的筹备和开发阶段都各有自己的独特用处。<br>三种文档都是以前一种为基础，逐步编写，最后都汇总至GDD中。</p><h2 id="1-2-GDD的长度"><a href="#1-2-GDD的长度" class="headerlink" title="1.2 GDD的长度"></a>1.2 GDD的长度</h2><p>GDD的长度取决于游戏的复杂程度。<br>手机游戏的GDD 30 页就够了，但平台游戏GDD一般都会超过300页。<br>GDD的长度应该在正好能够精确地描述游戏的前提下尽量精简。</p><h2 id="1-3-基础注意事项"><a href="#1-3-基础注意事项" class="headerlink" title="1.3 基础注意事项"></a>1.3 基础注意事项</h2><p>你得保证文档的可读性</p><ul><li>使用正确的语法、别写错别字、用对标点符号等</li><li>正文要使用合适的字体<ul><li>一个文档里不要使用多于两种字体</li><li><strong>标题字号</strong> 最好别小于22<br><strong>正文字号</strong> 保持在12点上下比较合适</li><li>建议使用几种基本字体<br>比如宋体、黑体、雅黑等</li></ul></li><li>注意语义简单清晰，最好读起来像说明书</li><li>可以制作展示用幻灯片</li></ul><blockquote><p>请记住:<br>游戏文档的目的始终都是为了沟通: 和玩家沟通、和团队沟通，以及和发行商沟通。<br>沟通越明晰顺畅，同事和合伙人就越容易被你的创意鼓舞。</p></blockquote><h1 id="2-简要设计文档"><a href="#2-简要设计文档" class="headerlink" title="2. 简要设计文档"></a>2. 简要设计文档</h1><p>简要设计文档是游戏的一个概括总览。<br>它会让很多人过目，包括你工作室的同事和发行商那边的搭档。<br>所以这个单页文档既要充实，又要精彩生动，而且一定要简短(不超过一页纸)。</p><p>它一般会包含以下信息:</p><ul><li>游戏名称</li><li>游戏系统</li><li>目标玩家群体</li><li>游戏故事概要(着重描述可玩性)</li><li>游戏玩法的独特性</li><li>独特的卖点</li><li>竞品游戏</li></ul><h2 id="2-1-目标玩家群体"><a href="#2-1-目标玩家群体" class="headerlink" title="2.1 目标玩家群体"></a>2.1 目标玩家群体</h2><p>该内容可以按照ESRB分级对玩家群体的分类去讨论。</p><blockquote><p>ESRB委员会是美国一个非盈利性的独立机构<br>他们会强制对美国和加拿大的娱乐软件进行定级，并对广告和在线隐私保护进行审核。<br>类似于漫画业的漫画法典管理局，ESRB 的创立也是为了协同相关家长，针对游戏中的内容和道德水平提供定位准则。<br>不过ESRB的分级制度更加类似于MPAA(美国电影协会)的电影分级( G、PG、PG-13、 R、X)。<br>游戏在被ESRB审核之后，都会根据其内容获得一个字母分级。</p></blockquote><p>ESRB目前分以下6级。</p><ul><li>eC(幼儿):<br>此级别不会包含父母认为不合适的内容。</li><li>E(所有人):<br>此级别可能包含少量的幻想、卡通或者轻微的暴力，或者有轻度的不民管的。</li><li>E10(10岁以上的所有人):<br>此级别可能会包含更多的幻想、卡通或轻微的暴力，不良语言和暗示性主题。</li><li>T(青少年):<br>此级别通常会包含暴力、暗示性主题、粗鲁的幽默、极少的血，很少的粗话。</li><li>M(成熟，17岁以上):<br>此级别通常会有强烈的暴力、 血腥、性、粗话。</li><li>AO(仅限成人，18岁以上):<br>此级别通常有强烈的暴力、明显的性和裸体场景</li></ul><p>国内目前还没有对应的游戏分级机制。</p><h2 id="2-4-独特的卖点"><a href="#2-4-独特的卖点" class="headerlink" title="2.4 独特的卖点"></a>2.4 独特的卖点</h2><p>独特的卖点就是游戏包装盒背面那些“大圆点” 后面的宣传语。</p><p>一款游戏独特的卖点：<br>一般来说， 写5个卖点最合适<br><strong>不应该是：</strong></p><ul><li>“炫丽的图像”和“动人的故事”或“ 获奖游戏的续作”这种宣传语</li><li>详述游戏细节的长篇大论</li></ul><p><strong>应该是：</strong></p><ul><li>那些能让你的游戏脱颖而出的独特品质。</li><li>能让玩家对游戏产生兴奋感的简短明快的词句</li></ul><p>下面有一些 不错的例子。</p><ul><li>多人游戏模式，可进行多达256名玩家间的协同游戏。</li><li>收录1000多首流行乐队曲目。</li><li>开放的游戏世界，拥有200个关卡可供玩家任意探索。</li><li>用镭甲坦克、恶骨蝎、火蚁钢车来横扫你的敌人吧!</li><li>感受 虚幻5 引擎带来的无与伦比的物理仿真效果和前所未有的视觉特效!</li></ul><h2 id="2-3-竞品游戏"><a href="#2-3-竞品游戏" class="headerlink" title="2.3 竞品游戏"></a>2.3 竞品游戏</h2><p>竞品游戏是指：那些已经面世的和你的设计理念相似的游戏。</p><p>列出竞争产品有助于文档的阅读者理解游戏的大概方向。<br>不过，列出来的竞争游戏一定要是 非常有名的,或者是广受好评的,这样才能方便他人快速理解定位你设计的游戏</p><h1 id="3-详细设计文档"><a href="#3-详细设计文档" class="headerlink" title="3. 详细设计文档"></a>3. 详细设计文档</h1><p>详细设计文档是种重量级设计文档,它所展示的是整个游戏的精髓所在</p><blockquote><p>十页设计文档并不是硬性规定要求写正好10页,而是要覆盖十个方面<br>只要完整地呈现出游戏设计概要就成,少几页多几页都没问题</p></blockquote><p><strong>目的:</strong><br>为了让阅读者快速了解最终产品维形同时又不必为那些枯燥的细枝末节而分神。</p><p><strong>重要性:</strong><br>详细设计文档是GDD中最重要的部分因为那些潜在投资者会通过这份文档来判断游戏前景。</p><h2 id="3-1-内容概述"><a href="#3-1-内容概述" class="headerlink" title="3.1 内容概述"></a>3.1 内容概述</h2><ol><li><p>封面</p><ul><li>游戏Logo/宣传图</li><li>游戏名称</li><li>文档信息<ul><li>文档编号</li><li>更新日期</li><li>作者</li><li>联系方式</li></ul></li></ul></li><li><p>目录大纲</p></li><li><p>GDD版本记录<br>用来追踪日期更新和编辑者</p></li><li><p>游戏基础信息</p><ul><li>游戏名</li><li>游戏系统</li><li>目标游戏群体</li><li>目标平台(需要的硬件)</li><li>计划发行日期</li><li>游戏LOGO</li></ul></li><li><p>游戏总览</p><ul><li>故事背景概述<ul><li>世界观概述</li><li>游戏设定</li></ul></li><li>剧情概述</li><li>流程概述(玩家阶段性目标等)</li><li>游戏的核心思想</li></ul></li><li><p>游戏可玩性</p><ul><li>玩法分析<ul><li>核心玩法(最好有情景举例)</li><li>其他玩法</li></ul></li><li>游戏交互分析<br>玩家的操作概况，列举玩家要执行的特定操作。<br>可以展示一张图片，显示用到的手柄、触屏 或是 标记了对应操作键位的键盘</li><li>游戏系统分析</li><li>游戏成长性分析</li><li>技术要求<ul><li>需要的开发工具</li><li>技术难点</li><li>游戏硬件要求</li></ul></li></ul></li><li><p>游戏视听风格与体验分析</p><ul><li><p>游戏体验分析</p></li><li><p>美术风格类型</p><ul><li>同类型游戏/影视作品</li><li>风格参考图</li><li>技术难点</li></ul></li><li><p>音频风格</p><ul><li>同类型游戏/影视作品</li><li>风格参考音频</li><li>技术难点</li></ul></li></ul></li><li><p>游戏角色设计</p><ul><li>角色设定</li><li>角色概念图</li><li>角色背景故事</li><li>角色交互(操控方式)</li></ul></li><li><p>游戏场景设计</p><ul><li>游戏大地图</li><li>场景设计列表</li></ul></li><li><p>后续可扩展内容与计划</p></li><li><p>营利性分析</p></li></ol><h2 id="3-2-注意事项"><a href="#3-2-注意事项" class="headerlink" title="3.2 注意事项"></a>3.2 注意事项</h2><ul><li>给游戏玩法配上清晰图表</li><li>多用简短、有力的语句</li><li>借助专业术语清晰表答意图</li><li>和类似游戏进行比较，即使是些老游戏</li><li>把当下流行卖座的游戏作为竞品</li><li>多贴一些令人激动的概念图</li><li>多用PPT或类似软件来做<br>这样做出的文档容易分享，可以很方便地用于游戏宣讲会，或者打印出来作为会议参考资料。</li></ul><p>其实，不管做什么文档，能让人愿意读总是第一要务，所以一定要把文档写得妙趣横生。<br>在写详细设计文档时，要明确这么一点 <strong>“文档的受众是什么人?”</strong><br>给自己办公室同事看的文档和给市场部准备的文档，肯定会有天壤之别。</p><h1 id="4-游戏流程表"><a href="#4-游戏流程表" class="headerlink" title="4. 游戏流程表"></a>4. 游戏流程表</h1><p>游戏流程表( <strong>Beat chart</strong> )是一个针对游戏内关卡(场景，章节或者其它随便什么算得上是游戏阶段性的东西)的统计表格。<br>它个很称手的工具，除了能帮你完善GDD以外，更可作为游戏结构的“映射”表。<br>相较于文档，它其实更适合用电子表格去实现。</p><h2 id="4-1-内容概述"><a href="#4-1-内容概述" class="headerlink" title="4.1 内容概述"></a>4.1 内容概述</h2><p>以关卡制游戏来说，每一关的流程表都需要下面这些元素。<br>(当然可以根据具体的项目设置不同的字段)</p><ul><li><p>关卡名称</p></li><li><p>这一关涉及的剧情</p></li><li><p>这一关的主要玩法 </p></li><li><p>角色成长</p></li><li><p>大概过关时间</p></li><li><p>关卡的美术需求</p></li><li><p>关卡中出现的敌人或Boss</p></li><li><p>关卡的机关，陷阱</p></li><li><p>关卡里的奖励内容</p></li><li><p>新的技能、武器或者装备</p></li><li><p>关卡/场景背景音乐</p></li></ul><p>下面是《萤火》里第一关的流程表。</p><table><thead><tr><th>关卡名称</th><th>1-0 森林边缘</th></tr></thead><tbody><tr><td>剧情</td><td>Hannah离开奶奶家，进入妖精森林，踏上了寻找妖精的道路</td></tr><tr><td>成长</td><td>玩家学会游戏的基本操作，掌握萤火虫和相机的核心玩法</td></tr><tr><td>美术需求</td><td>前中后三层背景，关卡特殊瓦片地图</td></tr><tr><td>机关</td><td>妖精图腾，蒸汽弹簧，捕兽夹，地刺</td></tr><tr><td>技能</td><td>拍照技能，移动技能，旋转技能</td></tr><tr><td>背景音乐</td><td>森林边缘-1</td></tr></tbody></table><h2 id="4-2-注意事项"><a href="#4-2-注意事项" class="headerlink" title="4.2 注意事项"></a>4.2 注意事项</h2><ul><li>注意把控游戏内容的节奏<br>不能扎堆出现，也不能过于分散</li><li>当心单调感<br>关卡之间的内容不能高度重复<br>可以通过以下几种方式降低单调感：<ul><li>更改视听风格(美术，音频内容)</li><li>打乱内容随机组合</li></ul></li><li>出现的新机制需要有对应的提示</li><li>注意故事性与游戏性的平衡</li><li>关卡内的奖励需要合理<br>尽量让玩家在游戏进度75%的时候获得所有的内容</li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p><strong>GDD文档</strong> 会勾勒出游戏中将会呈现的方方面面，可以说，它定义了整个游戏。</p><p>技术团队根据 <strong>GDD文档</strong> 输出 <strong>TDD</strong>，也就是用来构建游戏的技术设计文档。<br>如果最开始GDD里就没提到某项功能，那么之后很可能就没办法轻松添加到游戏里了。</p><p>虽然写GDD需要耗费大量时间和精力，但没有人会想看它，甚至团队成员也不想读。<br>因为GDD又臭又长，里面的信息质量也良莠不齐一有的非常实用， 有的形同“天书”。</p><p>但是这份文档对你和同事都有帮助。<br>如果只用脑子来记这些方案，那么我敢保证，随着任务的不断增多，你会忙得无法实施它们，甚至完全忘了过去<br>这些精彩的创意。</p><p>无需多言，GDD 是个非常重要的文档，游戏开发过程中，整个团队都指着它呢。</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-编辑器扩展-辅助显示</title>
    <link href="/2021/11/07/Unity-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95-%E8%BE%85%E5%8A%A9%E7%BA%BF/"/>
    <url>/2021/11/07/Unity-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95-%E8%BE%85%E5%8A%A9%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>自定义编辑器相关类</p><ul><li><p>EditorGUI</p></li><li><p>EditorGUILayout</p></li><li><p>Handles扩展</p></li></ul><h1 id="2-Gizmos辅助线"><a href="#2-Gizmos辅助线" class="headerlink" title="2. Gizmos辅助线"></a>2. Gizmos辅助线</h1><p><a href="https://blog.csdn.net/dengshunhao/article/details/83001076">https://blog.csdn.net/dengshunhao/article/details/83001076</a></p><p><a href="https://docs.unity.cn/cn/current/Manual/GizmosAndHandles.html">https://docs.unity.cn/cn/current/Manual/GizmosAndHandles.html</a></p><h2 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a>2.1 描述</h2><p>Gizmos辅助图标用于协助在 Scene 视图中进行视觉调试或设置。</p><p>Unity本身的编辑器中就自带很多Gizmos辅助线，详细的可以看<a href="https://docs.unity.cn/cn/current/Manual/GizmosMenu.html">Gizmos菜单官方文档</a></p><blockquote><p>注意：</p><ul><li>所有Gizmos辅助线的绘制都必须在 <a href="https://docs.unity.cn/cn/current/ScriptReference/MonoBehaviour.OnDrawGizmos.html">OnDrawGizmos</a> 或 <a href="https://docs.unity.cn/cn/current/ScriptReference/MonoBehaviour.OnDrawGizmosSelected.html">OnDrawGizmosSelected</a> 函数中实现</li><li>脚本必须继承Mono</li></ul></blockquote><p>这两个方法的区别是：</p><ul><li><a href="https://docs.unity.cn/cn/current/ScriptReference/MonoBehaviour.OnDrawGizmos.html">OnDrawGizmos</a><br>每一帧都会调用，其中渲染的所有辅助线都可以选择。</li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/MonoBehaviour.OnDrawGizmosSelected.html">OnDrawGizmosSelected</a><br>仅在选择了附加此脚本的对象时才调用</li></ul><h2 id="2-2-Gizmos-API"><a href="#2-2-Gizmos-API" class="headerlink" title="2.2 Gizmos API"></a>2.2 Gizmos API</h2><ul><li>常用静态变量</li></ul><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos-color.html">color</a></td><td>为接下来绘制的辅助图标设置颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos-exposure.html">exposure</a></td><td>设置包含 LightProbe 辅助图标的曝光校正的纹理。值从纹理中间的红色通道进行采样。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos-matrix.html">matrix</a></td><td>设置 Unity Editor 用于绘制 Gizmos 的 Matrix4x4。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos-probeSize.html">probeSize</a></td><td>设置灯光探测小控件的比例。此比例将用于渲染预览球体。</td></tr></tbody></table><ul><li>常用静态方法</li></ul><table><thead><tr><th>方法名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawCube.html">DrawCube</a></td><td>使用 center 和 size 绘制一个实心盒体。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawFrustum.html">DrawFrustum</a></td><td>绘制一个摄像机视锥体，并且将当前设置的 Gizmos.matrix 用于其位置和旋转。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawGUITexture.html">DrawGUITexture</a></td><td>在该场景中绘制一个纹理。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawIcon.html">DrawIcon</a></td><td>在 Scene 视图中的某个位置绘制一个图标。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawLine.html">DrawLine</a></td><td>绘制一条从 A坐标 到 B坐标 的线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawMesh.html">DrawMesh</a></td><td>绘制一个网格。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawRay.html">DrawRay</a></td><td>绘制一条从 from 开始到 from + direction 的射线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawSphere.html">DrawSphere</a></td><td>使用 center 和 radius 绘制一个实心球体。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawWireCube.html">DrawWireCube</a></td><td>使用 center 和 size 绘制一个线框盒体。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawWireMesh.html">DrawWireMesh</a></td><td>绘制一个线框网格。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawWireSphere.html">DrawWireSphere</a></td><td>使用 center 和 radius 绘制一个线框球体。</td></tr></tbody></table><h2 id="2-3-使用案例"><a href="#2-3-使用案例" class="headerlink" title="2.3 使用案例"></a>2.3 使用案例</h2><p>效果展示图：<br><img src="/images/Unity-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95-%E8%BE%85%E5%8A%A9%E7%BA%BF/image-20211108001109538.png" srcset="/img/loading.gif" alt="image-20211108001109538"></p><h3 id="2-3-1-绘制直线"><a href="#2-3-1-绘制直线" class="headerlink" title="2.3.1 绘制直线"></a>2.3.1 绘制直线</h3><p><code>Gizmos.DrawLine(Vector3 A , Vector B);</code><br>绘制一条从 A坐标 到 B坐标 的线</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.color = Color.green;<br>    Gizmos.DrawLine( obj1.transform.position , obj2.transform.position );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-2-绘制射线"><a href="#2-3-2-绘制射线" class="headerlink" title="2.3.2 绘制射线"></a>2.3.2 绘制射线</h3><p><code>Gizmos.DrawRay(Vector3 A, Vector3.up * 10);</code><br>绘制一条从A点出发，向上10个单位长度的射线</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.color = Color.gray;<br>    Gizmos.DrawRay(obj.transform.position, Vector3.up * <span class="hljs-number">10</span>);  <span class="hljs-comment">//10 是长度</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-2-绘制立方体"><a href="#2-3-2-绘制立方体" class="headerlink" title="2.3.2 绘制立方体"></a>2.3.2 绘制立方体</h3><p><code>Gizmos.DrawCube(Vector3 A , Vector3.one);</code></p><p> 在 坐标A 绘制一个（1,1,1）大小的立方体</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.color = Color.red;<br>    Gizmos.DrawCube(Vector3.up , Vector3.one);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-6-绘制球体"><a href="#2-3-6-绘制球体" class="headerlink" title="2.3.6 绘制球体"></a>2.3.6 绘制球体</h3><p><code>Gizmos.DrawSphere(Vector A, float radius);</code><br>在 坐标A 绘制一个半径为 radius 的球体</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.color = Color.red;<br>    Gizmos.DrawSphere(Vector3.zero , <span class="hljs-number">1f</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-5-绘制图片"><a href="#2-3-5-绘制图片" class="headerlink" title="2.3.5 绘制图片"></a>2.3.5 绘制图片</h3><p><code>Gizmos.DrawIcon(Vector3 A, string IconPath);</code><br>在坐标A处生成 IconPath 路径下的图片作为Icon</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.DrawIcon(Vector3.zero , <span class="hljs-string">&quot;002IMgZLzy6Mro7r94Ka2&amp;690.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>此图片要放到Assets下的  Gizmos文件夹里才行。</p></blockquote><h1 id="3-Handles控制柄"><a href="#3-Handles控制柄" class="headerlink" title="3. Handles控制柄"></a>3. Handles控制柄</h1><p><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.html">https://docs.unity.cn/cn/current/ScriptReference/Handles.html</a></p><p><a href="https://qianxi.blog.csdn.net/article/details/83000972">https://qianxi.blog.csdn.net/article/details/83000972</a></p><h2 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a>3.1 描述</h2><p>Handles控制柄是 Unity 用于操作场景视图中的项的 3D 控件。</p><p>内置的 Handle GUI 有很多，如通过变换组件定位、缩放和旋转对象的熟悉的工具。<br>不过，您也可以自行定义 Handle GUI，以与自定义组件编辑器结合使用。<br>此类 GUI 对于编辑以程序方式生成的场景内容、“不可见”项和相关对象的组（如路径点和位置标记）非常实用。</p><p>您还可以使用覆盖在场景视图上的 2D 按钮和其他控件来补充场景中的 3D 手柄 GUI。<br>这是通过将标准 Unity GUI 调用封装在 <a href="https://docs.unity.cn/cn/current/ScriptReference/Editor.OnSceneGUI.html">Editor.OnSceneGUI</a> 函数中的 <a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.BeginGUI.html">Handles.BeginGUI</a> 和 <a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.EndGUI.html">Handles.EndGUI</a> 对中完成的。</p><p>可以使用 <a href="https://docs.unity.cn/cn/current/ScriptReference/HandleUtility.GUIPointToWorldRay.html">HandleUtility.GUIPointToWorldRay</a> 和 <a href="https://docs.unity.cn/cn/current/ScriptReference/HandleUtility.WorldToGUIPoint.html">HandleUtility.WorldToGUIPoint</a> 在 2D GUI 与 3D 世界坐标之间转换坐标。</p><h2 id="3-2-Handles-API"><a href="#3-2-Handles-API" class="headerlink" title="3.2 Handles API"></a>3.2 Handles API</h2><ul><li>静态变量</li></ul><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-centerColor.html">centerColor</a></td><td>用于表示某物体中心的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-color.html">color</a></td><td>控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-inverseMatrix.html">inverseMatrix</a></td><td>所有控制柄操作的矩阵的逆矩阵。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-lighting.html">lighting</a></td><td>控制柄是否亮起</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-lineThickness.html">lineThickness</a></td><td>控制柄线厚度（只读）</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-matrix.html">matrix</a></td><td>所有控制柄的矩阵。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-preselectionColor.html">preselectionColor</a></td><td>用于突出显示鼠标指针下当前未选中的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-secondaryColor.html">secondaryColor</a></td><td>用于一般物体的柔和色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-selectedColor.html">selectedColor</a></td><td>用于当前处于活动状态的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-xAxisColor.html">xAxisColor</a></td><td>用于操纵某物体 X 坐标的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-yAxisColor.html">yAxisColor</a></td><td>用于操纵某物体 Y 坐标的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-zAxisColor.html">zAxisColor</a></td><td>用于操纵某物体 Z 坐标的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-zTest.html">zTest</a></td><td>控制柄的 zTest。</td></tr></tbody></table><ul><li>变量</li></ul><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-currentCamera.html">currentCamera</a></td><td>当前摄像机(控制柄移动范围在摄像机视野内)</td></tr></tbody></table><ul><li>静态函数</li></ul><table><thead><tr><th>方法名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ArrowHandleCap.html">ArrowHandleCap</a></td><td>绘制一个类似于移动工具所用箭头的箭头。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.BeginGUI.html">BeginGUI</a></td><td>在 3D 手柄 GUI 内开始一个 2D GUI 块。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Button.html">Button</a></td><td>创建一个 3D 按钮。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.CircleHandleCap.html">CircleHandleCap</a></td><td>绘制一个圆形手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ClearCamera.html">ClearCamera</a></td><td>清除摄像机。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ConeHandleCap.html">ConeHandleCap</a></td><td>绘制一个锥体手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.CubeHandleCap.html">CubeHandleCap</a></td><td>绘制一个立方体手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.CylinderHandleCap.html">CylinderHandleCap</a></td><td>绘制一个圆柱体手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Disc.html">Disc</a></td><td>创建一个可使用鼠标拖动的 3D 圆盘。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DotHandleCap.html">DotHandleCap</a></td><td>绘制一个圆点手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawAAConvexPolygon.html">DrawAAConvexPolygon</a></td><td>绘制使用点数组指定的抗锯齿凸多边形。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawAAPolyLine.html">DrawAAPolyLine</a></td><td>绘制使用点数组和宽度指定的抗锯齿线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawBezier.html">DrawBezier</a></td><td>绘制通过给定切线的起点和终点的纹理化贝塞尔曲线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawCamera.html">DrawCamera</a></td><td>在矩形内绘制一个摄像机。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawDottedLine.html">DrawDottedLine</a></td><td>绘制一条从 p1 到 p2 的虚线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawDottedLines.html">DrawDottedLines</a></td><td>绘制一系列虚线段。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawGizmos.html">DrawGizmos</a></td><td>为给定摄像机绘制 Gizmos 的子集（在后处理之前或之后）。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawLine.html">DrawLine</a></td><td>从p1至p2绘制一条线段</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawLines.html">DrawLines</a></td><td>绘制一系列线段。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawPolyLine.html">DrawPolyLine</a></td><td>绘制一条穿过 points 列表的线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawSelectionFrame.html">DrawSelectionFrame</a></td><td>绘制一个面向选择框的摄像机。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawSolidArc.html">DrawSolidArc</a></td><td>在 3D 空间中绘制一个圆扇形（饼图）。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawSolidDisc.html">DrawSolidDisc</a></td><td>在 3D 空间中绘制一个实心平面圆盘。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawSolidRectangleWithOutline.html">DrawSolidRectangleWithOutline</a></td><td>在 3D 空间中绘制一个实心轮廓矩形。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawTexture3DSDF.html">DrawTexture3DSDF</a></td><td>Draws a 3D texture using Signed Distance Field rendering mode in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawTexture3DSlice.html">DrawTexture3DSlice</a></td><td>Draws a 3D texture using Slice rendering mode in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawTexture3DVolume.html">DrawTexture3DVolume</a></td><td>Draws a 3D texture using Volume rendering mode in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawWireArc.html">DrawWireArc</a></td><td>Draws a circular arc in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawWireCube.html">DrawWireCube</a></td><td>使用 center 和 size 绘制一个线框盒体。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawWireDisc.html">DrawWireDisc</a></td><td>Draws the outline of a flat disc in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.EndGUI.html">EndGUI</a></td><td>结束一个 2D GUI 块并返回到 3D 手柄 GUI。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.FreeMoveHandle.html">FreeMoveHandle</a></td><td>创建一个不受约束的移动手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.FreeRotateHandle.html">FreeRotateHandle</a></td><td>创建一个不受约束的旋转手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.GetMainGameViewSize.html">GetMainGameViewSize</a></td><td>获取主游戏视图的宽度和高度。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Label.html">Label</a></td><td>在 3D 空间中创建一个文本标签。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.MakeBezierPoints.html">MakeBezierPoints</a></td><td>返回表示贝塞尔曲线的点数组。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.PositionHandle.html">PositionHandle</a></td><td>创建一个位置手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.RadiusHandle.html">RadiusHandle</a></td><td>创建一个场景视图半径手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.RectangleHandleCap.html">RectangleHandleCap</a></td><td>绘制一个矩形手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.RotationHandle.html">RotationHandle</a></td><td>创建一个场景视图旋转手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ScaleHandle.html">ScaleHandle</a></td><td>创建一个场景视图缩放手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ScaleSlider.html">ScaleSlider</a></td><td>创建一个定向缩放滑动条。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ScaleValueHandle.html">ScaleValueHandle</a></td><td>创建一个缩放单个浮点的 3D 手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.SetCamera.html">SetCamera</a></td><td>设置当前摄像机，以便所有手柄和辅助图标均使用相应设置进行绘制。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ShouldRenderGizmos.html">ShouldRenderGizmos</a></td><td>确定是否绘制 Gizmos。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Slider.html">Slider</a></td><td>创建一个沿着一个轴移动的 3D 滑动条。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Slider2D.html">Slider2D</a></td><td>创建一个沿两个轴定义的平面移动的 3D 滑动条。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.SnapToGrid.html">SnapToGrid</a></td><td>将每个 Transform.position 四舍五入到 EditorSnap.move 的最接近倍数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.SnapValue.html">SnapValue</a></td><td>如果对齐为 active，则将 value 四舍五入到 snap 的最接近倍数。注意，snap 只能为正数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.SphereHandleCap.html">SphereHandleCap</a></td><td>绘制一个球体手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.TransformHandle.html">TransformHandle</a></td><td>创建变换手柄。</td></tr></tbody></table><h2 id="3-3-使用案例"><a href="#3-3-使用案例" class="headerlink" title="3.3 使用案例"></a>3.3 使用案例</h2><h3 id="3-3-0-准备"><a href="#3-3-0-准备" class="headerlink" title="3.3.0 准备"></a>3.3.0 准备</h3><p>Scripts文件夹中创建C#脚本”MyHandles”,在Editor文件夹中创建C#脚本”HandleInspector”,将下小图标保存到Img文件夹中。 </p><h3 id="3-3-1-绘制半径操作柄"><a href="#3-3-1-绘制半径操作柄" class="headerlink" title="3.3.1 绘制半径操作柄"></a>3.3.1 绘制半径操作柄</h3><ul><li><code>Handles.Label(Vector3 position,string name);</code><br>在position位置绘制内容为name的标签</li><li><code>float RadiusHandle (Quaternion rotation, Vector3 position, float radius);</code><br>在position位置以rotation为角度绘制半径为radius的半径操作柄</li></ul><p>在MyHandles.cs脚本中添加一个变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> areaRadius; <span class="hljs-comment">//半径</span><br></code></pre></td></tr></table></figure><p>然后打开HandlesInspector.cs脚本添加：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.<br><span class="hljs-keyword">using</span> UnityEditor;<br><br>[<span class="hljs-meta">CustomEditor(typeof(MyHandles))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HandlesInspector</span>:<span class="hljs-title">Editor</span><br>&#123;<br>    MyHandles myHandles;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        myHandles=(MyHandles)target;<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInspectorGUI</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        DrawDefaultInspector();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSceneGUI</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//第一个参数为在场景中显示的位置(以物体的中心位置为基准)</span><br>        <span class="hljs-comment">//第二个参数为显示的名字</span><br>        <span class="hljs-comment">//用于在场景中显示设置的名字</span><br>        Handles.Label(myHandles.transform.position+<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),<span class="hljs-string">&quot;MyHandles&quot;</span>);<br><br>        <span class="hljs-comment">//第一个参数为该旋转操作柄的初始旋转角度</span><br>        <span class="hljs-comment">//第二个参数为操作柄显示的位置(以物体的旋转位置为基准)</span><br>        <span class="hljs-comment">//第三个参数为设置操作柄的半径</span><br>        <span class="hljs-comment">//用于在场景中显示半径操作柄</span><br>        myHandles.areaRadius = Handles.RadiusHandle(Quaternion.identity,myHandles.transform.position,myHandles.areaRadius);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将这两个脚本保存，回到Unity中创建一个空物体，并为其添加 MyHandles.cs 脚本。就可以实现了</p><p><strong>作用：</strong><br>多用于制作AI，用于判断和指定AI影响范围用的。</p><h3 id="3-3-2-绘制缩放操作柄"><a href="#3-3-2-绘制缩放操作柄" class="headerlink" title="3.3.2 绘制缩放操作柄"></a>3.3.2 绘制缩放操作柄</h3><ul><li><code>float ScaleValueHandle (float value, Vector3 position, Quaternion rotation, float size, Handles.CapFunction capFunction, float snap);</code><ul><li>value 该操作柄操作的值</li><li>position 操作柄的绘制位置</li><li>rotation 操作柄的指向</li><li>size 操作柄的大小</li><li>操作柄的显示方式(本质上是个函数指针)：<ul><li>ArrowCap 箭头</li><li>RectangleCap 矩形</li><li>CircleCap 圆形</li><li>等等</li></ul></li><li>snap 对齐增量(可以理解为单位长度，不会有比该值还小的值变化)</li></ul></li></ul><p>打开 MyHandles.cs 脚本，添加如下变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> size;<span class="hljs-comment">//大小</span><br></code></pre></td></tr></table></figure><p>然后为 HandlesInspector.cs 脚本添加如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">myHandles.size = Handles.ScaleValueHandle(<br>myHandles.size,<br>myHandles.transform.position,<br>Quaternion.identity,<br>myHandles.size,<br>Handles.ArrowCap,<br><span class="hljs-number">0.5f</span><br>);<br></code></pre></td></tr></table></figure><p><strong>作用：</strong><br>多用于绘制一些自定义的操作，比如Unity的粒子系统就用到了好多自定义的操作柄，比如粒子系统的Shape参数就用到了该函数的第五个参数来绘制：</p><h3 id="3-3-3-绘制位置操作柄"><a href="#3-3-3-绘制位置操作柄" class="headerlink" title="3.3.3 绘制位置操作柄"></a>3.3.3 绘制位置操作柄</h3><p>MyHandles.cs 脚本，添加如下变量： </p><p>然后为 HandlesInspector.cs 脚本添加如下代码：</p><h3 id="3-3-4-绘制旋转操作柄"><a href="#3-3-4-绘制旋转操作柄" class="headerlink" title="3.3.4 绘制旋转操作柄"></a>3.3.4 绘制旋转操作柄</h3><h3 id="3-3-5-绘制连接线"><a href="#3-3-5-绘制连接线" class="headerlink" title="3.3.5 绘制连接线"></a>3.3.5 绘制连接线</h3><h3 id="3-3-6-绘制贝塞尔曲线"><a href="#3-3-6-绘制贝塞尔曲线" class="headerlink" title="3.3.6 绘制贝塞尔曲线"></a>3.3.6 绘制贝塞尔曲线</h3><p><img src="/images/Unity-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95-%E8%BE%85%E5%8A%A9%E7%BA%BF/image-20211108233412915.png" srcset="/img/loading.gif" alt="image-20211108233412915"></p><p>在Editor文件夹下创建脚本  HandlerTest  如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> UnityEditor;<br> <br>[<span class="hljs-meta">CustomEditor(typeof(Arraw))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HandlerTest</span> : <span class="hljs-title">Editor</span> &#123;<br> <br>    Vector3[] positions;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSceneGUI</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">float</span> width = HandleUtility.GetHandleSize(Vector3.zero) * <span class="hljs-number">0.5f</span>;<br>        Arraw arraw = (Arraw)target;<br> <br>        Handles.DrawBezier(arraw.transform.position, Vector3.zero, <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>), <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>), Color.yellow, <span class="hljs-literal">null</span>, width);<br>        <span class="hljs-comment">//参数1 开始点坐标， 参数2，结束点坐标， 参数3 开始切线位置， 参数 4，结束切线位置， 参数 5 线的颜色 ，参数六 线的宽度</span><br> <br> <br>        <span class="hljs-keyword">if</span> (GUI.changed)<br>        &#123;<br>            EditorUtility.SetDirty(arraw);<br>        &#125;<br> <br>    &#125;<br>&#125;<br> <br> <br>Arraw脚本如下，将其拖拽到需要画线的对象即可<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Arraw</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-7-控制操作柄的显示"><a href="#3-3-7-控制操作柄的显示" class="headerlink" title="3.3.7 控制操作柄的显示"></a>3.3.7 控制操作柄的显示</h3>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>编辑器扩展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>编辑器扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#反射</title>
    <link href="/2021/10/28/C%E4%BA%95%E5%8F%8D%E5%B0%84/"/>
    <url>/2021/10/28/C%E4%BA%95%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="0-基础概念"><a href="#0-基础概念" class="headerlink" title="0. 基础概念"></a>0. 基础概念</h1><h2 id="0-1-什么是反射"><a href="#0-1-什么是反射" class="headerlink" title="0.1 什么是反射"></a>0.1 什么是反射</h2><p>Reflection，中文翻译为反射。<br>这是.Net中获取运行时类型信息的方式。</p><blockquote><p>官方定义：<br>审查元数据并收集关于它的类型信息的能力。<br>元数据（编译以后的最基本数据单元）<br>就是一大堆的表，当编译程序集或者模块时，编译器会创建一个类定义表，一个字段定义表，和一个方法定义表等。</p></blockquote><p>.Net的应用程序的结构由以下几个部分组成：</p><ul><li><p>程序集(Assembly)</p></li><li><p>模块(Module)</p></li><li><p>类型(class)</p></li></ul><p><img src="/images/C%E4%BA%95%E5%8F%8D%E5%B0%84/image-20211028142215838.png" srcset="/img/loading.gif" alt="image-20211028142215838"></p><p>而反射的层次模型也类似上述结构：</p><ul><li>程序集反射</li><li>类型反射</li><li>类型成员反射</li></ul><p><img src="/images/C%E4%BA%95%E5%8F%8D%E5%B0%84/image-20211028142543443.png" srcset="/img/loading.gif" alt="image-20211028142543443"></p><p>而反射提供一种编程的方式，让程序员可以在程序运行期获得这几个组成部分的相关信息。</p><ul><li><p>Assembly类<br>可以获得正在运行的装配件信息，也可以动态的加载装配件，以及在装配件中查找类型信息，并创建该类型的实例。</p></li><li><p>Type类<br>可以获得对象的类型信息，此信息包含对象的所有要素：方法、构造器、属性等等<br>通过Type类可以得到这些要素的信息，并且调用。</p></li><li><p>MethodInfo<br>包含方法的信息，通过这个类可以得到方法的名称、参数、返回值等等<br>并且可以调用。</p></li></ul><p>诸如此类，还有FieldInfo、EventInfo等等，这些类都包含在System.Reflection命名空间下。</p><h2 id="0-2-命名空间与装配件的关系"><a href="#0-2-命名空间与装配件的关系" class="headerlink" title="0.2 命名空间与装配件的关系"></a>0.2 命名空间与装配件的关系</h2><ul><li>命名空间类似与Java的包，但又不完全等同<br>因为Java的包必须按照目录结构来放置，命名空间则不需要。</li><li>装配件是.Net应用程序执行的最小单位，编译出来的.dll、.exe都是装配件。</li></ul><p>装配件和命名空间的关系不是一一对应，也不互相包含<br>一个装配件里面可以有多个命名空间，一个命名空间也可以在多个装配件中存在。</p><p>例如：</p><p>装配件A：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span>  <span class="hljs-title">N1</span><br>&#123;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">AC1</span>  &#123;…&#125;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">AC2</span>  &#123;…&#125;<br>&#125;<br><span class="hljs-keyword">namespace</span>  <span class="hljs-title">N2</span><br>&#123;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">AC3</span>  &#123;…&#125;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">AC4</span>&#123;…&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>装配件B：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span>  <span class="hljs-title">N1</span><br>&#123;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">BC1</span>  &#123;…&#125;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">BC2</span>  &#123;…&#125;<br>&#125;<br><span class="hljs-keyword">namespace</span>  <span class="hljs-title">N2</span><br>&#123;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">BC3</span>  &#123;…&#125;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">BC4</span>&#123;…&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个装配件中都有N1和N2两个命名空间，而且各声明了两个类，这样是完全可以的</p><p>然后我们在一个应用程序中引用装配件A<br>那么在这个应用程序中，我们能看到N1下面的类为AC1和AC2，N2下面的类为AC3和AC4。</p><p>接着我们去掉对A的引用，加上对B的引用<br>那么我们在这个应用程序下能看到的N1下面的类变成了BC1和BC2，N2下面也一样。</p><p>如果我们同时引用这两个装配件<br>那么N1下面我们就能看到四个类：AC1、AC2、BC1和BC2。</p><p>装配件是一个类型 “居住” 的地方，那么在一个程序中要使用一个类，就必须告诉编译器这个类住在哪儿，编译器才能找到它，也就是说必须引用该装配件。</p><p>那么如果在编写程序的时候，也许不确定这个类在哪里，仅仅只是知道它的名称，就不能使用了吗？<br>答案是可以，这就是反射了，就是在程序运行的时候提供该类型的地址，而去找到它。</p><h2 id="0-3-使用反射的情景"><a href="#0-3-使用反射的情景" class="headerlink" title="0.3 使用反射的情景"></a>0.3 使用反射的情景</h2><p>举个例子来说明：<br>很多软件开发者喜欢在自己的软件中留下一些接口，其他人可以编写一些插件来扩充软件的功能。</p><p>比如我有一个媒体播放器，我希望以后可以很方便的扩展识别的格式，那么我声明一个接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span>  <span class="hljs-title">IMediaFormat</span><br>&#123;<br>   <span class="hljs-built_in">string</span>  Extension  &#123;<span class="hljs-keyword">get</span>;&#125;<br>   <span class="hljs-function">Decoder  <span class="hljs-title">GetDecoder</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口中包含一个Extension属性，这个属性返回支持的扩展名。<br>另一个方法返回一个解码器的对象（这里我假设了一个Decoder的类，这个类提供把文件流解码的功能，扩展插件可以派生之），通过解码器对象我就可以解释文件流。</p><p>那么我规定所有的解码插件都必须派生一个解码器，并且实现这个接口，在GetDecoder方法中返回解码器对象，并且将其类型的名称配置到我的配置文件里面。</p><p>这样的话，我就不需要在开发播放器的时侯知道将来扩展的格式的类型，只需要从配置文件中获取现在所有解码器的类型名称，而动态的创建媒体格式的对象，将其转换为IMediaFormat接口来使用。</p><p>这就是一个反射的典型应用。</p><h1 id="1-反射的用途"><a href="#1-反射的用途" class="headerlink" title="1. 反射的用途"></a>1. 反射的用途</h1><p><strong>反射的作用：</strong></p><ul><li><p>它允许在运行时查看属性（attribute）信息。</p></li><li><p>它允许审查集合中的各种类型，以及实例化这些类型。</p></li><li><p>它允许延迟绑定的方法和属性（property）。</p></li><li><p>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</p></li><li><p>可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型</p></li><li><p>应用程序需要在运行时从某个特定的程序集中载入一个特定的类型，以便实现某个任务时可以用到反射。</p></li><li><p>反射主要应用于类库，这些类库需要知道一个类型的定义，以便提供更多的功能。</p></li></ul><p><strong>应用要点：</strong></p><ul><li>使用反射动态绑定需要牺牲 性能</li><li>有些元数据信息是不能通过反射获取的</li><li>某些反射类型是专门为那些clr 开发编译器的开发使用的<br>所以你要意识到不是所有的反射类型都是适合每个人的。</li></ul><h1 id="2-反射的使用"><a href="#2-反射的使用" class="headerlink" title="2. 反射的使用"></a>2. 反射的使用</h1><h2 id="2-1-使用反射-获取程序集"><a href="#2-1-使用反射-获取程序集" class="headerlink" title="2.1 使用反射 获取程序集"></a>2.1 使用反射 获取程序集</h2><p>该操作属于反射层级的第一层，程序集反射。</p><h2 id="2-2-使用反射-获取类型"><a href="#2-2-使用反射-获取类型" class="headerlink" title="2.2 使用反射 获取类型"></a>2.2 使用反射 获取类型</h2><p>该操作属于反射层级的第二层，类型反射。</p><h3 id="通过实例获取类型信息"><a href="#通过实例获取类型信息" class="headerlink" title="通过实例获取类型信息"></a>通过实例获取类型信息</h3><p>这个时侯我仅仅是得到这个实例对象<br>得到的方式也许是一个object的引用，也许是一个接口的引用<br>但是我并不知道它的确切类型，我需要了解<br>那么就可以通过调用System.Object上声明的方法GetType来获取实例对象的类型对象。</p><p>比如在某个方法内，我需要判断传递进来的参数是否实现了某个接口，如果实现了，则调用该接口的一个方法：</p><ul><li>判断是否是继承了某类</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> className = <span class="hljs-string">&quot;Text.TexeClass&quot;</span>;<br>Type myType = Type.GetType(className);<br><span class="hljs-keyword">if</span> (myType != <span class="hljs-literal">null</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;确实继承Text.TexeClass类&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断是否继承了某接口</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Process</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> processObj</span>)</span><br><span class="hljs-function"></span>&#123;<br>Type t  =  processsObj.GetType();<br><span class="hljs-keyword">if</span>(t.GetInterface(“ITest”)  !=<span class="hljs-literal">null</span>  )<br>        Console.WriteLine(<span class="hljs-string">&quot;确实实现了ITest接口&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过类型名称字符串获取类型信息"><a href="#通过类型名称字符串获取类型信息" class="headerlink" title="通过类型名称字符串获取类型信息"></a>通过类型名称字符串获取类型信息</h3><p> <code>Type t = Type.GetType(“System.String”);</code></p><p>在本装配件中类型可以只写类型名称</p><blockquote><p>注意<br>要查找一个类，必须指定它所在的装配件<br>或者在已经获得的Assembly实例上面调用GetType。</p></blockquote><p>一个例外是 <strong>mscorlib.dll</strong>，这个装配件中声明的类型也可以省略装配件名称。<br>.Net装配件编译的时候，默认都引用了mscorlib.dll，除非在编译的时候明确指定不引用它</p><p>比如：</p><ul><li><strong>System.String</strong> 是在 <strong>mscorlib.dll</strong> 中声明的<br><code>Type t = Type.GetType(“System.String”)</code>是正确的</li><li><strong>System.Data.DataTable</strong> 是在 <strong>System.Data.dll</strong> 中声明的<br><code>Type.GetType(“System.Data.DataTable”)</code>就只能得到空引用。<br><code>Type t = Type.GetType(&quot;System.Data.DataTable,System.Data,Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;);</code>这样才可以</li></ul><h2 id="2-3-使用反射-动态创建对象"><a href="#2-3-使用反射-动态创建对象" class="headerlink" title="2.3 使用反射 动态创建对象"></a>2.3 使用反射 动态创建对象</h2><p>该操作属于反射层级的第二层，类型反射。</p><p>使用反射动态创建对象有两种方法：</p><ul><li>使用 <strong>Activator.CreateInstance</strong></li><li>使用 <strong>Assembly.CreateInstance</strong></li></ul><p>但实际上在底层都是使用 <strong>Activator.CreateInstance</strong> 来动态创建对象，所以只需要掌握一种即可，下面的内容都是 使用 <strong>Activator.CreateInstance</strong> 来动态创建对象</p><h3 id="无参数构造"><a href="#无参数构造" class="headerlink" title="无参数构造"></a>无参数构造</h3><p>System.Activator提供了方法来根据类型动态创建对象</p><p>比如创建一个DataTable：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Type t = Type.GetType(<span class="hljs-string">&quot;System.Data.DataTable,System.Data,Version=1.0.3300.0,  Culture=neutral,  PublicKeyToken=b77a5c561934e089&quot;</span>);<br>DataTable table = (DataTable)Activator.CreateInstance(t);<br></code></pre></td></tr></table></figure><h3 id="有参数构造"><a href="#有参数构造" class="headerlink" title="有参数构造"></a>有参数构造</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span>  <span class="hljs-title">TestSpace</span>  <br>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">TestClass</span><br>    &#123;<br>        <span class="hljs-keyword">private</span>  <span class="hljs-built_in">string</span>  _value;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">TestClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>  <span class="hljs-keyword">value</span></span>)  </span><br><span class="hljs-function"></span>        &#123;<br>            _value=<span class="hljs-keyword">value</span>;<br>      &#125;<br>  &#125;<br>&#125;<br>Type t = Type.GetType(“TestSpace.TestClass”);<br>Object[] constructParms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123;“hello”&#125;;  <span class="hljs-comment">//构造器参数</span><br>TestClass obj = (TestClass)Activator.CreateInstance(t,constructParms);<br></code></pre></td></tr></table></figure><p>把参数按照顺序放入一个Object数组中即可</p><h2 id="2-4-使用反射-操作类成员"><a href="#2-4-使用反射-操作类成员" class="headerlink" title="2.4 使用反射 操作类成员"></a>2.4 使用反射 操作类成员</h2><p>该操作属于反射层级的第三层，类型成员反射。</p><p>该操作有三种方法</p><ol><li>使用Type类的InvokeMember()方法<br><a href="https://blog.csdn.net/zxcvb036/article/details/114693060">方法一案例</a></li><li>使用FieldInfo,MethodInfo…等类的Invoke方法</li><li>通过使用委托对反射进行优化</li><li>使用.NET 4.0出现了一个新的关键字：dynamic</li></ol><p>综合考虑下来，代码精简度以及耗费时间，建议尽量使用dynamic关键字来处理反射。</p><p>下面主要讨论 方法2 与 方法4</p><h3 id="2-4-1-方法2"><a href="#2-4-1-方法2" class="headerlink" title="2.4.1 方法2"></a>2.4.1 方法2</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">TestSpace</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span>  <br>    &#123;<br>        <span class="hljs-keyword">private</span>  <span class="hljs-built_in">string</span>  _value;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestClass</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br><span class="hljs-function"></span>            =&gt; _value = <span class="hljs-keyword">value</span>;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Value  <br>        &#123;<br>            <span class="hljs-keyword">set</span> &#123;_value=<span class="hljs-keyword">value</span>;&#125;<br>            <span class="hljs-keyword">get</span> <br>            &#123;<br>   <span class="hljs-keyword">if</span>(_value==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;NULL&quot;</span>;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>  _value;<br>   &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetValue</span>(<span class="hljs-params">stringprefix</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span>(_value==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;NULL&quot;</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>  prefix+<span class="hljs-string">&quot; : &quot;</span>+_value;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一个简单的TestClass类，包含：</p><ul><li>一个默认构造函数</li><li>一个有参数的构造函数</li><li>一个_value字段</li><li>一个Value属性</li><li>一个GetValue的方法</li></ul><ol><li><p>获取程序集</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Assembly ass = Assembly.Load(<span class="hljs-string">&quot;TestDll&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取类型信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Type myType = ass.GetType(<span class="hljs-string">&quot;TestSpace.TestClass&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>根据类型创建对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span>[] constuctParms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[]&#123;<span class="hljs-string">&quot;timmy&quot;</span>&#125;;<br><span class="hljs-built_in">object</span> dObj = Activator.CreateInstance(myType,constuctParms);<br></code></pre></td></tr></table></figure></li><li><p>操作类成员</p></li></ol><ul><li><p>类字段<br>使用 <strong>FieldInfo 类</strong> 访问修改类对象的字段<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.fieldinfo?view=net-5.0">官方文档</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 获取对象指定字段</span><br>FieldInfo mfi = myType.GetField(<span class="hljs-string">&quot;_value&quot;</span>);<br><span class="hljs-comment">// 获取字段值</span><br>mfi.GetVaL();<br><span class="hljs-comment">// 更改字段值</span><br>mfi.SetVal(dObj,<span class="hljs-string">&quot;ok&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>类属性<br>使用 <strong>PropertyInfo 类</strong> 访问修改类对象的属性<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.propertyinfo?view=net-5.0">官方文档</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">PropertyInfo mpi = myType.GetProperty(<span class="hljs-string">&quot;Value&quot;</span>,<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>));<br>mpi.SetValue(dObj,<span class="hljs-string">&quot;ok&quot;</span>,<span class="hljs-literal">null</span>);<br>PropertyInfo mpi2 = myType.GetProperty(<span class="hljs-string">&quot;Value&quot;</span>);<br>Console.WriteLine(mpi2.GetValue(dObj,<span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure></li><li><p>类方法<br>使用 <strong>MethodInfo 类</strong> 调用类对象的方法<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.methodinfo?view=net-5.0">官方文档</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//获取方法的信息</span><br>MethodInfo method = myType.GetMethod(<span class="hljs-string">&quot;GetValue&quot;</span>);<br><span class="hljs-comment">//调用方法的一些标志位，这里的含义是Public并且是实例方法，这也是默认的值</span><br>BindingFlags flag = BindingFlags.Public | BindingFlags.Instance;<br><span class="hljs-comment">//GetValue方法的参数</span><br><span class="hljs-built_in">object</span>[] parameters = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[]&#123;<span class="hljs-string">&quot;Hello&quot;</span>&#125;;<br><span class="hljs-comment">//调用方法，用一个object接收返回值</span><br><span class="hljs-built_in">object</span> returnValue = method.Invoke(dObj,flag,Type.DefaultBinder,parameters,<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="2-4-2-方法4-关键字dynamic"><a href="#2-4-2-方法4-关键字dynamic" class="headerlink" title="2.4.2 方法4 - 关键字dynamic"></a>2.4.2 方法4 - 关键字dynamic</h3></li></ul><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/using-type-dynamic">官方文档</a></p><p><a href="https://www.cnblogs.com/gygtech/p/9915367.html">教程</a></p><blockquote><p>性能较好，速度快</p></blockquote><ol><li><p>获取程序集</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Assembly ass = Assembly.Load(<span class="hljs-string">&quot;TestDll&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取类型信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Type myType = ass.GetType(<span class="hljs-string">&quot;TestSpace.TestClass&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>根据类型创建对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span>[] constuctParms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[]&#123;<span class="hljs-string">&quot;timmy&quot;</span>&#125;;<br><span class="hljs-built_in">dynamic</span> dObj = Activator.CreateInstance(myType,constuctParms);<br></code></pre></td></tr></table></figure></li><li><p>操作类成员</p><p>使用了 dynamic 后可以和普通对象一样通过.使用类对象成员</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">dObj._value = <span class="hljs-string">&quot;good&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="2-6-动态创建委托"><a href="#2-6-动态创建委托" class="headerlink" title="2.6 动态创建委托"></a>2.6 动态创建委托</h2></li></ol><p>​    委托是C#中实现事件的基础，有时候不可避免的要动态的创建委托，实际上委托也是一种类型：System.Delegate，所有的委托都是从这个类派生的<br>​    System.Delegate提供了一些静态方法来动态创建一个委托，比如一个委托：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">TestSpace</span>  <br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">string</span> <span class="hljs-title">TestDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span>  <br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestClass</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetValue</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br><span class="hljs-function"></span>            =&gt; <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">TestClass obj = <span class="hljs-keyword">new</span> TestClass();<br><span class="hljs-comment">//获取类型，实际上这里也可以直接用typeof来获取类型</span><br>Type t = Type.GetType(“TestSpace.TestClass”);<br><span class="hljs-comment">//创建代理，传入类型、创建代理的对象以及方法名称</span><br>TestDelegate method =(TestDelegate)Delegate.CreateDelegate(t,obj,”GetValue”);<br>String returnValue = method(“hello”);<br></code></pre></td></tr></table></figure><h1 id="3-反射中主要用到的类"><a href="#3-反射中主要用到的类" class="headerlink" title="3. 反射中主要用到的类"></a>3. 反射中主要用到的类</h1><p>System.reflection命名空间包含的几个类，允许你反射（解析）这些元数据表的代码  </p><ul><li><strong>System.Reflection.Assembly</strong><br>使用Assembly定义和加载程序集<br>加载在程序集清单中列出模块,以及从此程序集中查找类型并创建该类型的实例。</li><li><strong>System.Reflection.MemberInfo</strong></li><li><strong>System.Reflection.EventInfo</strong><br>了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等,添加或移除事件处理程序</li><li><strong>System.Reflection.FieldInfo</strong><br>了解字段的名称、访问修饰符(如public或private)和实现详细信息(如static)等<br>并获取或设置字段值。</li><li><strong>System.Reflection.MethodBase</strong></li><li><strong>System.Reflection.ConstructorInfo</strong><br>使用ConstructorInfo了解构造函数的名称、参数、访问修饰符(如pulic 或private)和实现详细信息(如abstract或virtual)等。</li><li><strong>System.Reflection.MethodInfo</strong><br>了解方法的名称、返回类型、参数、访问修饰符(如pulic 或private)和实现详细信息(如abstract或virtual)等。</li><li><strong>System.Reflection.PropertyInfo</strong><br>了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等,获取或设置属性值</li><li><strong>System.Type</strong></li><li><strong>ParameterInfo</strong><br>了解参数的名称、数据类型、是输入参数还是输出参数<br>以及参数在方法签名中的位置等。</li><li><strong>Module</strong><br>了解包含模块的程序集以及模块中的类等<br>还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。</li></ul><h2 id="3-1-System-Type-类"><a href="#3-1-System-Type-类" class="headerlink" title="3.1 System.Type 类"></a>3.1 System.Type 类</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.type?view=net-5.0#constructors">官方文档</a></p><p>通过这个类可以访问任何给定数据类型的信息。</p><p>System.Type 类对于反射起着核心的作用。<br>但它是一个抽象的基类,Type有与每种数据类型对应的派生类,我们使用这个派生类的对象的方法、字段、属性来查找有关该类型的所有信息。</p><h3 id="获取Type的方法"><a href="#获取Type的方法" class="headerlink" title="获取Type的方法"></a>获取Type的方法</h3><p>获取给定类型的Type引用有3种常用方式:</p><ul><li>使用 <strong>typeof运算符</strong><br><code>Type t = typrof(string);</code><br>该字符串必须指定类型的完整名称（包括其命名空间）</li><li>使用对象 <strong>GetType()方法</strong><br><code>string s; Type t = s.GetType();</code></li><li>使用Type <strong>静态方法GetType()</strong><br><code>Type t  = Type.GetType(&quot;System.String&quot;);</code></li></ul><h3 id="Type类的常用属性"><a href="#Type类的常用属性" class="headerlink" title="Type类的常用属性"></a>Type类的常用属性</h3><table><thead><tr><th>属性名称</th><th>属性类型</th><th>含义</th></tr></thead><tbody><tr><td>Name</td><td>string</td><td>数据类型名</td></tr><tr><td>FullName</td><td>string</td><td>数据类型的完全限定名(包括命名空间名)</td></tr><tr><td>Namespace</td><td>string</td><td>定义数据类型的命名空间名</td></tr><tr><td>IsAbstract</td><td>bool</td><td>指示该类型是否是抽象类型</td></tr><tr><td>IsArray</td><td>bool</td><td>指示该类型是否是数组</td></tr><tr><td>IsClass</td><td>bool</td><td>指示该类型是否是类</td></tr><tr><td>IsEnum</td><td>bool</td><td>指示该类型是否是枚举</td></tr><tr><td>IsInterface</td><td>bool</td><td>指示该类型是否是接口</td></tr><tr><td>IsPublic</td><td>bool</td><td>指示该类型是否是公有的</td></tr><tr><td>IsSealed</td><td>bool</td><td>指示该类型是否是密封类</td></tr><tr><td>IsValueType</td><td>bool</td><td>指示该类型是否是值类型</td></tr></tbody></table><h3 id="Type类的方法"><a href="#Type类的方法" class="headerlink" title="Type类的方法"></a>Type类的方法</h3><ul><li><code>GetConstructor()</code><br><code>GetConstructors()</code><br>返回ConstructorInfo类型,用于取得该类的构造函数的信息</li><li><code>GetEvent()</code><br><code>GetEvents()</code><br>返回EventInfo类型,用于取得该类的事件的信息</li><li><code>GetField()</code><br><code>GetFields()</code><br>返回FieldInfo类型,用于取得该类的字段(成员变量)的信息</li><li><code>GetInterface()</code><br><code>GetInterfaces()</code><br>返回InterfaceInfo类型,用于取得该类实现的接口的信息</li><li><code>GetMember()</code><br><code>GetMembers()</code><br>返回MemberInfo类型,用于取得该类的所有成员的信息</li><li><code>GetMethod()</code><br><code>GetMethods()</code><br>返回MethodInfo类型,用于取得该类的方法的信息</li><li><code>GetProperty()</code><br><code>GetProperties()</code><br>返回PropertyInfo类型,用于取得该类的属性的信息可以调用这些成员<br>其方式是调用Type的InvokeMember()方法,或者调用MethodInfo, PropertyInfo和其他类的Invoke()方法。</li></ul><h2 id="3-2-System-Reflection-Assembly类"><a href="#3-2-System-Reflection-Assembly类" class="headerlink" title="3.2 System.Reflection.Assembly类"></a>3.2 System.Reflection.Assembly类</h2><p>Assembly类可以获得程序集的信息,也可以动态的加载程序集,以及在程序集中查找类型信息,并创建该类型的实例。</p><p>使用Assembly类可以降低程序集之间的耦合,有利于软件结构的合理化。</p><h3 id="获取Assembly对象的方法"><a href="#获取Assembly对象的方法" class="headerlink" title="获取Assembly对象的方法"></a>获取Assembly对象的方法</h3><ul><li><p>通过程序集名称返回Assembly对象<br><code>Assembly ass = Assembly.Load(&quot;ClassLibrary831&quot;);</code><br>load方法有多个重载，还可以通过流的方式获取程序集</p></li><li><p>通过DLL文件名称返回Assembly对象<br><code>Assembly ass = Assembly.LoadFile(&quot;ClassLibrary831.dll&quot;);</code><br>LoadFile这个方法的参数是程序集的绝对路径，通过点击程序集shift+鼠标右键复制路径即可。<br>在项目中，主要用来取相对路径，因为很多项目的程序集会被生成在一个文件夹里，此时取相对路径不容易出错。</p></li><li><p>通过Assembly获取程序集中类<br><code>Type t = ass.GetType(&quot;ClassLibrary831.NewClass&quot;);</code></p><blockquote><p>//参数必须是完全类名：命名空间+类名</p></blockquote></li><li><p>通过Assembly获取程序集中所有的类<br><code>Type[] t = ass.GetTypes();</code></p></li></ul><h1 id="4-反射的性能"><a href="#4-反射的性能" class="headerlink" title="4. 反射的性能"></a>4. 反射的性能</h1><p><a href="https://zhuanlan.zhihu.com/p/268547492">反射性能测试</a></p><p>使用反射来调用类型或者触发方法，或者访问一个字段或者属性时clr 需要做更多的工作(校验参数，检查权限等等)所以速度是非常慢的。</p><p>所以尽量不要使用反射进行编程。</p><p>对于打算编写一个动态构造类型（晚绑定）的应用程序，可以采取以下的几种方式进行代替：</p><ul><li>通过类的继承关系。<br>让该类型从一个编译时可知的基础类型派生出来，在运行时生成该类型的一个实例，将对其的引用放到其基础类型的一个变量中，然后调用该基础类型的虚方法。</li><li>通过接口实现。<br>在运行时，构建该类型的一个实例，将对其的引用放到其接口类型的一个变量中，然后调用该接口定义的虚方法。</li><li>通过委托实现。<br>让该类型实现一个方法，其名称和原型都与一个在编译时就已知的委托相符。<br>在运行时先构造该类型的实例，然后在用该方法的对象及名称构造出该委托的实例，接着通过委托调用你想要的方法。<br>这个方法相对与前面两个方法所作的工作要多一些，效率更低一些。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/reflection">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/reflection</a></p><p><a href="https://zhuanlan.zhihu.com/p/41282759">https://zhuanlan.zhihu.com/p/41282759</a></p><p><a href="https://www.sohu.com/a/363591840_468635">https://www.sohu.com/a/363591840_468635</a></p><p><a href="https://www.cnblogs.com/vaevvaev/p/6995639.html">https://www.cnblogs.com/vaevvaev/p/6995639.html</a></p><p><a href="https://www.cnblogs.com/loveleaf/p/9923970.html">https://www.cnblogs.com/loveleaf/p/9923970.html</a></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF-0入门基础</title>
    <link href="/2021/10/19/UGF0-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/10/19/UGF0-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是UGF"><a href="#1-什么是UGF" class="headerlink" title="1. 什么是UGF"></a>1. 什么是UGF</h1><p><img src="/images/UGF0-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/gameframework-16345550925232.png" srcset="/img/loading.gif" alt="【第一章】开启 Game Framework 之旅 - 第1张  | Game Framework"></p><h1 id="2-安装UGF包"><a href="#2-安装UGF包" class="headerlink" title="2. 安装UGF包"></a>2. 安装UGF包</h1><p>在<a href="https://gameframework.cn/download/">下载页面</a>下载最新版 Game Framework（说好不用 git 就不用），当前使用的版本是 2020.07.10，下载后，可以获得一个叫做 GameFramework_2020_07_10.unitypackage 的 Unity 插件包。</p><p><img src="/images/UGF0-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/GameFrameworkUnityPackage.png" srcset="/img/loading.gif" alt="【第一章】开启 Game Framework 之旅 - 第2张  | Game Framework"></p><blockquote><p>建议时刻考虑使用较新版本的 Game Framework，较新的版本出了新增特性和修正一些 BUG 之外，还会不断地优化框架自身逻辑的内存开销。</p></blockquote><p>将插件的全部内容导入刚创建的工程。</p><p><img src="/images/UGF0-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/ImportUnityPackage.png" srcset="/img/loading.gif" alt="【第一章】开启 Game Framework 之旅 - 第3张  | Game Framework"></p><h1 id="3-工程结构"><a href="#3-工程结构" class="headerlink" title="3. 工程结构"></a>3. 工程结构</h1><p>GameFramework 文件夹是框架的全部内容，其中：</p><ul><li>Libraries<br>存放 GameFramework.dll 核心框架和一些框架必需的第三方库（当前只有一个开源 zip 压缩算法库）</li><li>Prefabs<br>存放 GameFramework.prefab 预制体，用于快速创建一个游戏框架启动场景</li><li>Scripts<br>存放 UnityGameFramework 的全部 Runtime 和 Editor 代码</li></ul><p>Example 文件夹是一个示例目录，其中：</p><ul><li>Example.unity<br>是一个含有 GameFramework.prefab 预制体的空场景，作为游戏启动的场景</li><li>ProcedureExample.cs<br>是一个示例流程代码文件，示例将以这个流程作为启动流程。</li></ul><p>打开 Example/Example.unity 场景，此时 Hierarchy 窗口显示了 Game Framework 的各个组成组件。</p><p><img src="/images/UGF0-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/HierarchyView.png" srcset="/img/loading.gif" alt="【第一章】开启 Game Framework 之旅 - 第5张  | Game Framework"></p><h1 id="4-组件的获取"><a href="#4-组件的获取" class="headerlink" title="4. 组件的获取"></a>4. 组件的获取</h1><p>在 Game Framework 中，获取一个内置组件的代码是这样的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 获取 Base 组件</span><br>BaseComponent baseComponent = UnityGameFramework.Runtime.GameEntry.GetComponent&lt;BaseComponent&gt;(); <br><span class="hljs-comment">// 使用刚刚获取的 Base 组件</span><br>baseComponent.EditorResourceMode = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>每次这么用，有点繁琐。一般把 Game Framework 的组件封装为能够全局静态访问的属性。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">UnityGameFramework.Runtime</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameEntry</span><br>    &#123;<br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取游戏基础组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BaseComponent Base<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取配置组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigComponent Config<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取数据结点组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataNodeComponent DataNode<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取数据表组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataTableComponent DataTable<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取调试组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DebuggerComponent Debugger<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取下载组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DownloadComponent Download<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取实体组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EntityComponent Entity<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取事件组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EventComponent Event<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取文件系统组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FileSystemComponent FileSystem<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取有限状态机组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FsmComponent Fsm<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取本地化组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalizationComponent Localization<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取网络组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NetworkComponent Network<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取对象池组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectPoolComponent ObjectPool<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取流程组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcedureComponent Procedure<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取资源组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ResourceComponent Resource<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取场景组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SceneComponent Scene<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取配置组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SettingComponent Setting<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取声音组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SoundComponent Sound<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取界面组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UIComponent UI<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取网络组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebRequestComponent WebRequest<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitBuiltinComponents</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Base = GameEntry.GetComponent&lt;BaseComponent&gt;();<br>            Config = GameEntry.GetComponent&lt;ConfigComponent&gt;();<br>            DataNode = GameEntry.GetComponent&lt;DataNodeComponent&gt;();<br>            DataTable = GameEntry.GetComponent&lt;DataTableComponent&gt;();<br>            Debugger = GameEntry.GetComponent&lt;DebuggerComponent&gt;();<br>            Download = GameEntry.GetComponent&lt;DownloadComponent&gt;();<br>            Entity = GameEntry.GetComponent&lt;EntityComponent&gt;();<br>            Event = GameEntry.GetComponent&lt;EventComponent&gt;();<br>            FileSystem = GameEntry.GetComponent&lt;FileSystemComponent&gt;();<br>            Fsm = GameEntry.GetComponent&lt;FsmComponent&gt;();<br>            Localization = GameEntry.GetComponent&lt;LocalizationComponent&gt;();<br>            Network = GameEntry.GetComponent&lt;NetworkComponent&gt;();<br>            ObjectPool = GameEntry.GetComponent&lt;ObjectPoolComponent&gt;();<br>            Procedure = GameEntry.GetComponent&lt;ProcedureComponent&gt;();<br>            Resource = GameEntry.GetComponent&lt;ResourceComponent&gt;();<br>            Scene = GameEntry.GetComponent&lt;SceneComponent&gt;();<br>            Setting = GameEntry.GetComponent&lt;SettingComponent&gt;();<br>            Sound = GameEntry.GetComponent&lt;SoundComponent&gt;();<br>            UI = GameEntry.GetComponent&lt;UIComponent&gt;();<br>            WebRequest = GameEntry.GetComponent&lt;WebRequestComponent&gt;();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将其放到Assets/GameFramework/Scripts/Runtime/Base/GameEntryInit.cs路径下即可。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>UGF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦片地图</title>
    <link href="/2021/10/15/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/"/>
    <url>/2021/10/15/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="0-瓦片地图基础知识"><a href="#0-瓦片地图基础知识" class="headerlink" title="0. 瓦片地图基础知识"></a>0. 瓦片地图基础知识</h1><h2 id="0-1-什么是瓦片地图"><a href="#0-1-什么是瓦片地图" class="headerlink" title="0.1 什么是瓦片地图"></a>0.1 什么是瓦片地图</h2><p><strong>TileMap</strong>是<strong>Unity5.5a实验版</strong>加入的新功能，就像他的字面意思「瓦片地图」。</p><p>但说起来这个技术并不“新”了，成熟的2D引擎（诸如gamemaker，RpgMaker），都带有自己自己的tile编辑器的，第三方的编辑工具如Tiled使用起来也是比较方便的，Tile编辑器界的老牌开源编辑器<strong>Tiled</strong>，很多引擎也提供Tiled导入的支持。</p><p>TileMap 是有助于快速搭建整体关卡的利器。如果没有它，开发者要么只有用最笨的方法手动逐一搭建，要么自己写编辑器，要么借助于第三方编辑软件，而这三种方法其实对初学者都不是很友好。</p><h2 id="0-2-瓦片地图的构成"><a href="#0-2-瓦片地图的构成" class="headerlink" title="0.2 瓦片地图的构成"></a>0.2 瓦片地图的构成</h2><p>Tilemap用起来其实就和现实中画画一样，它由以下五个基本部分组成：</p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/048ecfd4d364b947e663778075201a10.webp" srcset="/img/loading.gif" alt="教程｜Unity中使用Tilemap快速创建2D游戏世界"></p><ul><li>Sprite(精灵)：<br>纹理的容器。<br>大型纹理图集可以转换为精灵图集(Sprite Sheet)。</li><li>Tile(瓦片)：<br>包含一个精灵，以及二个属性，颜色和碰撞体类型。<br>使用瓦片就像在画布上画画一样，画画时可以设置一些颜色和属性。</li><li>Palette(调色板)：<br>当你在画布(Canvas)上画画时，会需要一个位置来保存绘画的结果。<br>类似地，调色板(Palette)的功能就是保存瓦片，将它们绘制到网格上。</li><li>Brush(笔刷)：<br>用于将画好的东西绘制到画布上。<br>使用Tilemap时，可以在多个笔刷中任意选择，绘制出线条、方块等各种形状。</li><li>Tilemap（瓦片地图）：<br>类似Photoshop中的图层，我们可以在Tilemap上画上Tile。</li></ul><p>Tilemap部分其它工具：</p><ul><li>Grid(网格)：<br>用于控制网格属性的组件。<br>Tilemap是Grid的子对象。<br>Grid类似于UI Canvas(UI画布)。</li><li>Tilemap渲染器(Tilemap Renderer)：<br>用于控制Tile在Tilemap上的渲染，控制诸如排序、材质和遮罩等。</li></ul><h1 id="1-瓦片地图的初级使用"><a href="#1-瓦片地图的初级使用" class="headerlink" title="1.  瓦片地图的初级使用"></a>1.  瓦片地图的初级使用</h1><h2 id="1-1-创建流程"><a href="#1-1-创建流程" class="headerlink" title="1.1 创建流程"></a>1.1 创建流程</h2><ol><li>创建瓦片地图：<br>在层级窗口中，依次点击Create-&gt;2D Object-&gt;Tilemap 新建Tilemap<br>这将自动创建两个GameObject对象，一个是名为Grid的父对象，上面带有Grid组件。<br>另一个是名为Tilemap的子对象，它在Grid对象下，带有Tilemap和Tilemap Renderer组件。</li><li>创建调色板<br>依次点击Window-&gt;Tile Palette打开调色板窗口。<br>在调色板窗口中，选择Create New Palette。设置名字和属性，然后指定保存位置。</li><li>创建笔刷<br>向调色板加入新瓦片，拖动精灵到调色板中，会打开一个新窗口，询问瓦片的保存位置。<br>你也可以通过精灵图集拖动多个瓦片。</li><li>创建完成，开始在场景中绘制:<br>瓦片加入调色板后，就可以用笔刷绘制场景了。</li></ol><h2 id="1-2-瓦片绘制工具"><a href="#1-2-瓦片绘制工具" class="headerlink" title="1.2 瓦片绘制工具"></a>1.2 瓦片绘制工具</h2><p>TilePalette(瓦片调色板) 中可以找到用来绘制Tile的绘图工具：</p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/v2-8a08957217a3f92111564ae63a2c95ca_1440w.jpg" srcset="/img/loading.gif" alt="img"></p><p>从左至右依次为：</p><ul><li>选择工具<br>用来选择Tile资源更改属性。</li><li>移动工具<br>用于移动选中的Tile资源。</li><li>矩形工具<br>用于绘制矩形块，并由选定的Tile资源来填充。</li><li>选取工具<br>用于选取要绘制的Tile资源，按下左键并拖拽可以一次选取多个Tile。</li><li>擦除工具<br>用于擦除Tile资源。</li><li>填充工具<br>用于将选定区域填充为选定的Tile资源。</li></ul><p>TilePalette面板上有一个Edit，如果选上的话可以编辑在TilePalette面板中的Tile资源。</p><h2 id="1-3-瓦片地图的物理碰撞"><a href="#1-3-瓦片地图的物理碰撞" class="headerlink" title="1.3 瓦片地图的物理碰撞"></a>1.3 瓦片地图的物理碰撞</h2><p>在Tilemap中添加碰撞体十分简单，只要给Tilemap对象加入一个Tilemap Collider 2D组件即可。<br>可以看到，这个组件自动为该Tilemap上的所有瓦片都加入了碰撞体。</p><p>我们可以通过再添加Composite Collider来优化这里的碰撞体，Rigidbody 2D组件会随着Composite Collider自动添加。<br>因为平台不会移动，所以要记得将Rigidbody 2D上的Body Type属性设置为Static。<br>最后在Tilemap Collider 2D上勾选Used By Composite，在整个平台周围生成一个复合碰撞体。<br>设置好后的检视窗口如下所示。</p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/9f55e8791de25dc19ee01f6e8f07721d.webp" srcset="/img/loading.gif" alt="教程｜Unity中使用Tilemap快速创建2D游戏世界"></p><p>这样我们的Tilemap部分就完成了。</p><h2 id="1-4-注意事项"><a href="#1-4-注意事项" class="headerlink" title="1.4 注意事项"></a>1.4 注意事项</h2><h3 id="1-4-1-瓦片匹配问题"><a href="#1-4-1-瓦片匹配问题" class="headerlink" title="1.4.1 瓦片匹配问题"></a>1.4.1 瓦片匹配问题</h3><ul><li><strong>发生情景：</strong><br>在创建Tilemap及一个palette后，我们想把已有的美术资源(Jungle_Tileset.png)做成瓦片，在对图片进行切片、拖入Palette后、进行绘制地图时会发现，<strong>瓦片并不与Scene场景内的unit单元格匹配</strong>。<br>例如下图:</li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/1688704-20190926162210739-1102159657.png" srcset="/img/loading.gif" alt="img"></p><ul><li><p><strong>问题原因：</strong><br>原因在于我们对图片进行切片时，<strong>Pixels Per Unit</strong> 数值的问题。</p></li><li><p><strong>问题分析：</strong><br>它的含义是<strong>每个unit单元格所能容纳该图片的多少个像素</strong>。上图依次为Pixels Per Unit为不同值时每个瓦片与Scene场景下一个Unit的比例。拿Pixels Per Unit=43来说，其含义是每个unit只够装下43个像素，而我们的美术图片（左）像素为1024x1024，算下来每个瓦片有128像素，我们却只给每个Unit43像素，所以从最右边图片我们可以看出大概9个unit才可以放下一个瓦片。</p></li><li><p><strong>如何解决：</strong><br>对每张将要被做成瓦片的美术资源进行Pixels Per Unit的计算。如本例最合理的数值为 1024/8 = 128</p><blockquote><p>非瓦片的Sprite直接拖拽进入Scene进行缩放操作即可。</p></blockquote></li></ul><h3 id="1-4-2-Tiles的选择问题"><a href="#1-4-2-Tiles的选择问题" class="headerlink" title="1.4.2 Tiles的选择问题"></a>1.4.2 Tiles的选择问题</h3><ul><li><strong>发生情景：</strong><br>在导入2d-extras包后，我们可以在Project内右键添加各类Tiles（见下图）。假如我们要做一个<strong>带有Animation的瓦片</strong>，是否直接可以直接使用AnimationTile类型呢？答案是肯定的，但完美的做法是按需使用。</li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/1688704-20190926162233932-2092282446.png" srcset="/img/loading.gif" alt="img"></p><ul><li><p><strong>问题原因：</strong></p><p>AnimatedTile的RuleTile的功能存在差异</p><ul><li><p>AnimatedTile：</p><ul><li>瓦片数目：对单块瓦片进行操作</li><li>动画速度：MinimumSpeed ~ MaximumSpeed</li><li>起始时间：Start Time</li></ul></li><li><p>RuleTile</p><p>(前提是设置瓦片output类型为Animation)：</p><ul><li>瓦片数目：多片，且能同时实现规则瓦片功能</li><li>动画速度：Speed</li><li>GameObject：同时实现PrefabBrush功能</li></ul></li></ul></li><li><p><strong>总结：</strong><br>对于带有Animation的瓦片，我们应该<strong>按需选择Tile的类型</strong>。<br>例如：不同启用时间的地刺，我们应当选择AnimatedTile进而调节StartTime参数；<br>例如：较长的瀑布，我们应该选用RuleTile，既能实现Animation效果又能方便画多个瓦片；<br>例如：蜡烛，我们想实现燃烧动画不一致，就应当采用AnimatedTile进而调节两个Speed参数等等。<br>但总的来说，<strong>RuleTile集成了几类extra瓦片的基础功能</strong>，较为常用。</p></li></ul><h3 id="1-4-3-快捷键"><a href="#1-4-3-快捷键" class="headerlink" title="1.4.3 快捷键"></a>1.4.3 快捷键</h3><ul><li>旋转绘制中的瓦片的方向：<br>[ ] 键</li><li>删除当前绘制的瓦片：<br>按住shift+左键点击</li></ul><h1 id="2-瓦片地图-的-API"><a href="#2-瓦片地图-的-API" class="headerlink" title="2. 瓦片地图 的 API"></a>2. 瓦片地图 的 API</h1><h2 id="2-1-编辑器中的属性"><a href="#2-1-编辑器中的属性" class="headerlink" title="2.1 编辑器中的属性"></a>2.1 编辑器中的属性</h2><h3 id="2-1-1-TileMap"><a href="#2-1-1-TileMap" class="headerlink" title="2.1.1 TileMap"></a>2.1.1 TileMap</h3><p>tilemap组件是一个存储和处理瓦片资源以便创建2D关卡系统。<br>此组件将所需信息放置在组件的瓦片上传输到其他相关组件。<br>例如Tilemap Render和Tilemap Colider2D。</p><ul><li>Animation Frame Rate：<br>unity播放图块的速率。（如果将其设置为2，则unity以2倍速度播放Tile动画）</li><li>Color：<br>使用选定的颜色在此Tilemap上为Tile着色。设置为白色时，unity渲染图块时不着色。</li><li>Tile Anchor：<br>Tile在此Tilemap上的锚定偏移。调整位置值以偏移图块 在关联网格上的像元位置。</li><li>Orientation：<br>Tilemap上Tile的方向。如果您需要在特定平面上（特别是在3D视图中）定向图块，使用此项。</li><li>Position：<br>显示当前方向矩阵的位置偏移。</li><li>Rotation：<br>当前方向矩阵的旋转。</li><li>Scale：<br>当前方向矩阵的比例。</li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/image-20211018225517471.png" srcset="/img/loading.gif" alt="image-20211018225517471"></p><h3 id="2-1-2-Tilemap-Renderer"><a href="#2-1-2-Tilemap-Renderer" class="headerlink" title="2.1.2 Tilemap Renderer"></a>2.1.2 Tilemap Renderer</h3><ul><li><p>Material：<br>定义用于渲染精灵纹理的材质。</p></li><li><p>Sort Order：<br>设置所选瓦片地图上的瓦片排序方向。</p></li><li><p>Mode：<br>设置渲染模式。</p><ul><li>Chunk ：<br>渲染器按位置对瓦片进行分组，并将瓦片的精灵一起批处理以进行渲染。可获得最佳渲染性能</li><li>Individual：<br>渲染器单独渲染每个瓦片，同时还会考虑他们的位置和排序顺序。<br>此模式使瓦片上的精灵能够与场景中的其他渲染器或与自定义排序轴进行交互</li></ul></li><li><p>Detect Chunk Culling Bounds：<br>确定渲染器如何检测用于剔除瓦片地图块的边界。<br>这些边界可扩展瓦片地图块的边界，以确保在剔除过程中不会裁剪过大的精灵。</p><ul><li>Auto：渲染器会自动检查瓦片使用的精灵，以确定要使用的扩展剔除边界</li><li>Manual：用于扩展边界与剔除瓦片地图块的值是手动设置的，而不使用Editor的自动检测功能</li></ul></li><li><p>Chunk Culling Bounds：<br>输入剔除边界的扩展值。</p></li><li><p>Sorting Layer：<br>设置瓦片地图的排序图层(sorting layer）。<br>从下拉框中选择现有的排序图层，或创建新的排序图层。</p></li><li><p>Order in Layer：<br>设置瓦片地图在其排序图层中的渲染优先级。首先渲染编号较低的图层。<br>编号较高的图层叠加在前者之上。</p></li><li><p>Mask Interaction：<br>设置地图渲染器在于精灵交互时的行为方式。</p><ul><li>None：<br>瓦片地图渲染器不与场景中的任何精灵遮罩交互</li><li>Visible Inside Mask：<br>瓦片地图在精灵遮罩覆盖瓦片地图的地方是可见的，而在遮罩外部不可见</li><li>Visible Outside Mask：<br>瓦片地图在精灵遮罩外部是不可见的，而在遮罩内部不可见。<br>精灵遮罩会隐藏其要覆盖的精灵部分</li></ul></li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/image-20211018225453019.png" srcset="/img/loading.gif" alt="image-20211018225453019"></p><h2 id="2-2-编程用API"><a href="#2-2-编程用API" class="headerlink" title="2.2 编程用API"></a>2.2 编程用API</h2><p><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.html">https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.html</a></p><h3 id="2-2-1-Tilemap"><a href="#2-2-1-Tilemap" class="headerlink" title="2.2.1 Tilemap"></a>2.2.1 Tilemap</h3><h4 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h4><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Grid.html">Grid</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-layoutGrid.html">layoutGrid</a></td><td>获取与此Tilemap关联的网格。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/BoundsInt.html">BoundsInt</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-localBounds.html">localBounds</a></td><td>以本地空间大小返回 Tilemap 的边界。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/BoundsInt.html">BoundsInt</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-cellBounds.html">cellBounds</a></td><td>以单元格大小返回 Tilemap 的边界。</td></tr><tr><td>Vector3Int origin</td><td>Tilemap 的原点（以单元格位置为单位）。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Vector3Int.html">Vector3Int</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-size.html">size</a></td><td>Tilemap 的大小（以单元格为单位）。</td></tr><tr><td>Vector3 <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-tileAnchor.html">tileAnchor</a></td><td>Tilemap 的锚点。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-orientation.html">orientation</a></td><td>Tilemap 的排列方向。</td></tr><tr><td>bool enabled</td><td>启用的 Behaviour 可更新，禁用的 Behaviour 不可更新。</td></tr><tr><td>Vector3 <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout-cellGap.html">cellGap</a></td><td>布局中各个单元格之间的间隙大小。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout-cellLayout.html">cellLayout</a></td><td>单元格的布局。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout-cellSize.html">cellSize</a></td><td>布局中每个单元格的大小。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout-cellSwizzle.html">cellSwizzle</a></td><td>布局的单元格重排。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Object-hideFlags.html">hideFlags</a></td><td>该对象应该隐藏、随场景一起保存还是由用户修改？</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Color.html">Color</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-color.html">color</a></td><td>Tilemap 层的颜色</td></tr></tbody></table><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="添加瓦片"><a href="#添加瓦片" class="headerlink" title="添加瓦片"></a>添加瓦片</h5><ul><li><p><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.SetTile.html">SetTile</a><br>在Tilemap中指定的单元格添加瓦片。<br><code>void SetTile (Vector3Int position, Tilemaps.TileBase tile); </code></p></li><li><p><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.SetTiles.html">SetTiles</a><br>在Tilemap中指定的一组单元格添加一组瓦片。<br><code>void SetTiles(Vector3Int[] positionArray, TileBase[] tileArray);</code></p></li><li><p><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.SetTilesBlock.html">SetTilesBlock</a><br>在Tilemap中指定的一个范围块内添加一组瓦片。<br><code> void SetTilesBlock(BoundsInt position, TileBase[] tileArray);</code></p><blockquote><p>比SetTiles更有效率，是批处理</p></blockquote></li><li><p><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.BoxFill.html">BoxFill</a><br>在瓦片地图上使用给定瓦片进行框填。<br>从给定坐标开始，然后从开始到结束（含）填充边界。<br><code>void BoxFill (Vector3Int position, Tilemaps.TileBase tile, int startX, int startY, int endX, int endY);</code></p><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td>position</td><td>瓦片在 <a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.html">Tilemap</a> 上的位置。</td></tr><tr><td>tile</td><td>要放置的 <a href="https://docs.unity.cn/cn/current/Manual/Tilemap-ScriptableTiles-TileBase.html">Tile</a>。</td></tr><tr><td>startX</td><td>填充范围的 X 坐标下限。</td></tr><tr><td>startY</td><td>填充范围的 Y 坐标下限。</td></tr><tr><td>endX</td><td>填充范围的 X 坐标上限。</td></tr><tr><td>endY</td><td>填充范围的 Y 坐标上限。</td></tr></tbody></table></li><li><p><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.FloodFill.html">FloodFill</a><br>从给定坐标开始，在瓦片地图上使用要放置的给定瓦片进行灌填(油漆桶)。<br><code>void FloodFill (Vector3Int position, Tilemaps.TileBase tile);</code></p><blockquote><p>BoxFill是范围内填充<br>FloodFill是剩下范围全部填充</p></blockquote></li><li><p><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.InsertCells.html">InsertCells</a><br>在Tilemap中指定位置插入很多瓦片<br><code>void InsertCells (Vector3Int position, Vector3Int insertCells);</code><br>参数:</p><ul><li>position 单元格坐标</li><li>Vector3Int insertCells 插入瓦片参数<ul><li> numColumns：插入列数</li><li> numRows：插入行数</li><li> numLayers：插入层数</li></ul></li></ul></li></ul><h5 id="查询瓦片"><a href="#查询瓦片" class="headerlink" title="查询瓦片"></a>查询瓦片</h5><ul><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.GetTile.html">GetTile</a><br>获取指定单元格的瓦片对象。<br><code> Tilemaps.TileBase GetTile(Vector3Int position);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.GetSprite.html">GetSprite</a><br>获取指定单元格的瓦片使用的精灵对象。<br><code> Sprite GetSprite(Vector3Int position);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.ContainsTile.html">ContainsTile</a><br>瓦片地图中是否存在该瓦片<br><code>bool ContainsTile(TileBase tileAsse);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.HasTile.html">HasTile</a><br>瓦片地图的指定位置是否存在该瓦片<br><code> bool HasTile(Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetCellCenterLocal.html">GetCellCenterLocal</a><br>获取瓦片地图逻辑中心的本地坐标。<br><code>Vector3 GetCellCenterLocal (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetCellCenterWorld.html">GetCellCenterWorld</a><br>获取瓦片地图逻辑中心的世界坐标。<br><code>Vector3 GetCellCenterWorld (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetColliderType.html">GetColliderType</a><br>根据给定的瓦片地图中某个单元格的 XYZ 坐标，获取瓦片的碰撞体类型。<br><code>Tilemaps.Tile.ColliderType GetColliderType (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetColor.html">GetColor</a><br>根据给定的瓦片地图中某个单元格的 XYZ 坐标，获取瓦片的颜色。<br><code>Color GetColor (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetTileFlags.html">GetTileFlags</a><br>获取给定位置处的 Tile 的 TileFlags。<br><code>Tilemaps.TileFlags GetTileFlags (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetUsedTilesCount.html">GetUsedTilesCount</a><br>获取 Tilemap 中使用的不同 tiles 的总数。<br><code>int GetUsedTilesCount ();</code></li></ul><h5 id="修改瓦片"><a href="#修改瓦片" class="headerlink" title="修改瓦片"></a>修改瓦片</h5><ul><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.SetColliderType.html">SetColliderType</a><br>根据给定的瓦片地图中某个单元格的 XYZ 坐标，设置瓦片的碰撞体类型。<br><code>void SetColliderType (Vector3Int position, Tilemaps.Tile.ColliderType colliderType);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.SetColor.html">SetColor</a><br>根据给定的瓦片地图中某个单元格的 XYZ 坐标，设置瓦片的颜色。<br><code>void SetColor (Vector3Int position, Color color);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.SetTileFlags.html">SetTileFlags</a><br>将 TileFlags 设置到给定位置处的 Tile 上。<br><code>void SetTileFlags (Vector3Int position, Tilemaps.TileFlags flags);</code></li></ul><h5 id="更新瓦片"><a href="#更新瓦片" class="headerlink" title="更新瓦片"></a>更新瓦片</h5><ul><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.RefreshTile.html">RefreshTile</a><br>更新指定位置的瓦片。<br><code>void RefreshTile(Vector3Int position);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.RefreshAllTiles.html">RefreshAllTiles</a><br>更新瓦片地图中的所有瓦片。<br><code>void RefreshAllTiles ();</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.SwapTile.html">SwapTile</a><br>将所有指定类型的瓦片置换为新的瓦片对象并刷新<br><code>void SwapTile(Tilemaps.TileBase changeTile, Tilemaps.TileBase newTile);</code><ul><li>changeTile：旧瓦片</li><li>newTile：新瓦片</li></ul></li></ul><h5 id="删除瓦片"><a href="#删除瓦片" class="headerlink" title="删除瓦片"></a>删除瓦片</h5><ul><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.ClearAllTiles.html">ClearAllTiles</a><br>清除瓦片地图内所有瓦片。<br><code>void ClearAllTiles();</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.DeleteCells.html">DeleteCells</a><br>删除指定范围内的瓦片<br><code>void DeleteCells(Vector3Int position, Vector3Int deleteCells);</code><br>Vector3Int deleteCells:<ul><li>列数</li><li>行数</li><li>层级</li></ul></li></ul><h5 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h5><ul><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.CellToLocal.html">CellToLocal</a><br>将单元格位置转换为本地空间位置。<br><code> Vector3 CellToLocal(Vector3Int cellPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.CellToWorld.html">CellToWorld</a><br>将单元格位置转换为世界空间位置。<br><code>Vector3 CellToWorld (Vector3Int cellPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.LocalToCell.html">LocalToCell</a><br>将本地位置转换为单元格位置。<br><code>Vector3Int LocalToCell (Vector3 localPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.WorldToCell.html">WorldToCell</a><br>将世界位置转换为单元格位置。<br><code> Vector3Int WorldToCell (Vector3 worldPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.GetBoundsLocal.html">GetBoundsLocal</a><br>返回该位置的单元格的本地边界。<br><code>Bounds GetBoundsLocal (Vector3Int cellPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.GetLayoutCellCenter.html">GetLayoutCellCenter</a><br>获取 Grid 的设置布局的单元格默认中心坐标(世界坐标)。<br><code>Vector3 GetLayoutCellCenter ();</code></li></ul><p><strong>注意</strong>：<br>所有坐标转换方法都是依赖于tilemap实例的父实例(<a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.html">GridLayout</a>)<br>需要如下方法才能使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">GridLayout gridLayout = transform.parent.GetComponent&lt;GridLayout&gt;();<br>Vector3Int cellPosition = gridLayout.LocalToCell(transform.localPosition);<br>transform.localPosition = gridLayout.CellToLocal(cellPosition);<br></code></pre></td></tr></table></figure><h3 id="2-2-2-Tile"><a href="#2-2-2-Tile" class="headerlink" title="2.2.2 Tile"></a>2.2.2 Tile</h3><p>Tilemap 中默认瓦片的类。</p><p>该类从 TileBase 继承，代表将放置在 Tilemap 中的默认瓦片。它实现 TileBase.GetTileData，以在瓦片地图中简单渲染 Sprite。</p><h4 id="常用变量-1"><a href="#常用变量-1" class="headerlink" title="常用变量"></a>常用变量</h4><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-color.html">color</a></td><td>Tile 的 颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-flags.html">flags</a></td><td>Tile 的 TileFlags。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-gameObject.html">gameObject</a></td><td>Tile 的 GameObject。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-sprite.html">sprite</a></td><td>要在 Tile 处渲染的 Sprite。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-transform.html">transform</a></td><td>Tile 的 Transform matrix。</td></tr></tbody></table><blockquote><p>注意：<br>transform是矩阵，不是一般游戏对象的transform组件</p></blockquote><p>以上五个属性合一块一封装就是<a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.TileData.html">TileData</a>了</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile.GetTileData.html">GetTileData</a><br>检索 Tile 的瓦片渲染数据。<br><code>void GetTileData (Vector3Int position, Tilemaps.ITilemap tilemap, ref Tilemaps.TileData tileData);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.TileBase.RefreshTile.html">RefreshTile</a><br>瓦片刷新时调用<br><code>void RefreshTile (Vector3Int position, Tilemaps.ITilemap tilemap);</code></li></ul><blockquote><p>注意：<br>以上俩方法都是静态方法，不能通过实例调用，要通过类名调用</p></blockquote><h3 id="2-2-3-编程案例"><a href="#2-2-3-编程案例" class="headerlink" title="2.2.3 编程案例"></a>2.2.3 编程案例</h3><p>使用程序动态生成使用三种瓦片的瓦片地图</p><p><strong>瓦片种类有三种：</strong><br><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/image-20211018224634727.png" srcset="/img/loading.gif" alt="image-20211018224634727"></p><p>代码如下:</p><p><strong>瓦片地图生成：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Tilemaps;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MapSystem</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Vector2Int mapSize;<span class="hljs-comment">//瓦片地图大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> desertRate = <span class="hljs-number">0.2f</span>;<span class="hljs-comment">//沙漠地块所占比例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> gobiRate = <span class="hljs-number">0.4f</span>;<span class="hljs-comment">//戈壁地块所占比例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> oasisRate = <span class="hljs-number">0.4f</span>;<span class="hljs-comment">//绿洲地块所占比例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> mixingAreaSize = <span class="hljs-number">2</span>;<span class="hljs-comment">//交接混合地块宽度</span><br><br>    <span class="hljs-keyword">private</span> LandBlock[][] landBlocks;<br>    <span class="hljs-keyword">private</span> Tilemap tilemap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span>=&gt; tilemap = gameObject.GetComponent&lt;Tilemap&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> =&gt; initMap();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//初始化地图</span></span><br><span class="hljs-function"></span>    &#123;<br>        tilemap.ClearAllTiles();<span class="hljs-comment">//先清空瓦片地图中的所有瓦片</span><br>        tilemap.size = <span class="hljs-keyword">new</span> Vector3Int(mapSize.x,mapSize.y,<span class="hljs-number">0</span>);<span class="hljs-comment">//设置瓦片地图大小</span><br>        landBlocks = <span class="hljs-keyword">new</span> LandBlock[mapSize.y][];<span class="hljs-comment">//准备数据结构与瓦片地图的瓦片绑定</span><br>        GridLayout gridLayout = transform.parent.GetComponentInParent&lt;GridLayout&gt;();<span class="hljs-comment">//获取瓦片地图的父对象，网格布局</span><br><br>        <span class="hljs-comment">//求三种地块(瓦片)所占的列数</span><br>        <span class="hljs-built_in">int</span> desertCol = (<span class="hljs-built_in">int</span>) (mapSize.x * desertRate);<br>        <span class="hljs-built_in">int</span> gobiCol = (<span class="hljs-built_in">int</span>)(mapSize.x * gobiRate);<br>        <span class="hljs-built_in">int</span> oasisCol = mapSize.x - desertCol - gobiCol;<br><br>        <span class="hljs-comment">//开始生成瓦片地图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;mapSize.y;i++)<br>        &#123;<br>            landBlocks[i] = <span class="hljs-keyword">new</span> LandBlock[mapSize.x];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;j&lt;mapSize.x;j++)<br>            &#123;<br>                <span class="hljs-comment">// 初始化瓦片</span><br>                Tile tile = ScriptableObject.CreateInstance&lt;Tile&gt;();<br>                <span class="hljs-comment">// 初始化瓦片单元格地址(逻辑地址)</span><br>                Vector3Int index = <span class="hljs-keyword">new</span> Vector3Int(i, j, <span class="hljs-number">0</span>);<br>                <span class="hljs-comment">// 将瓦片添加到瓦片地图中</span><br>                tilemap.SetTile(index, tile);<br>                <span class="hljs-comment">// 获取该瓦片的世界坐标</span><br>                Vector3 position = gridLayout.CellToWorld(index);<br>                <br>                <span class="hljs-comment">// 根据当前列数生成地块(地块数据与瓦片绑定)</span><br>                LandBlock landBlock;<br>                <span class="hljs-keyword">if</span>(j &lt; desertCol - mixingAreaSize)<br>                    landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Desert, tile);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &lt; desertCol)<br>                    <span class="hljs-keyword">if</span>(Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>) &lt; <span class="hljs-number">0.5</span>)<br>                        landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Desert, tile);<br>                    <span class="hljs-keyword">else</span><br>                        landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Gobi, tile);<br>                <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &lt; desertCol + gobiCol - mixingAreaSize)<br>                    landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Gobi, tile);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &lt; desertCol + gobiCol)<br>                    <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>) &lt; <span class="hljs-number">0.5</span>)<br>                        landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Gobi, tile);<br>                    <span class="hljs-keyword">else</span><br>                        landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Oasis, tile);<br>                <br>                <span class="hljs-keyword">else</span><br>                    landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Oasis, tile);<br>                <br>                landBlocks[i][j] = landBlock;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 更新瓦片地图的所有瓦片，地图初始化完成</span><br>        tilemap.RefreshAllTiles();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>地块数据类:</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Tilemaps;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LandBlock</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">Sprite</span>&gt; spriteList</span> = <span class="hljs-keyword">new</span> List&lt;Sprite&gt;(Resources.LoadAll&lt;Sprite&gt;(<span class="hljs-string">&quot;img/Entity/LandBlocks&quot;</span>));<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> BlockType &#123; Desert, Gobi, Oasis &#125;;<span class="hljs-comment">// 地块类型: 沙漠，戈壁，绿洲</span><br><br>    <span class="hljs-keyword">public</span> Vector3Int index;   <span class="hljs-comment">// 逻辑坐标</span><br>    <span class="hljs-keyword">public</span> Vector3 position; <span class="hljs-comment">// 位置</span><br>    <span class="hljs-keyword">public</span> Tile tile;<br><br>    <span class="hljs-keyword">private</span> BlockType type;<br>    <span class="hljs-keyword">public</span> BlockType Type &#123;<span class="hljs-keyword">get</span> =&gt; type;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LandBlock</span>(<span class="hljs-params">Vector3Int index, Vector3 position, BlockType type, Tile tile</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.index = index;<br>        <span class="hljs-keyword">this</span>.position = position;<br>        <span class="hljs-keyword">this</span>.type = type;<br>        <span class="hljs-keyword">this</span>.tile = tile;<br>        setSprite();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSprite</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//更改瓦片精灵</span></span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">string</span> spriteName = type.ToString() + <span class="hljs-string">&quot;Block&quot;</span>;<br>        tile.sprite = spriteList.Find(p =&gt; p.name == spriteName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>Tile 瓦片的实例化不能使用new，会报错。<br>需要使用 ScriptableObject.CreateInstance 才行，例如:<br>Tile tile = ScriptableObject.CreateInstance<Tile>();</p></blockquote><p><strong>效果如下:</strong><br><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/image-20211018224757712.png" srcset="/img/loading.gif" alt="image-20211018224757712"></p><p>这样就可以程序化生成地图了</p><h1 id="3-2d-extras中的高级瓦片"><a href="#3-2d-extras中的高级瓦片" class="headerlink" title="3. 2d-extras中的高级瓦片"></a>3. 2d-extras中的高级瓦片</h1><p><a href="https://github.com/Unity-Technologies/2d-extras">https://github.com/Unity-Technologies/2d-extras</a></p><p>为了提高开发速度，Unity创建了名为2d-extras的GitHub代码库，这里面的工具都是基于Tilemap制作，有很多实用的瓦片和笔刷，下面介绍几个2d-extras中的实用工具。</p><h2 id="3-1-规则瓦片-Rule-Tile"><a href="#3-1-规则瓦片-Rule-Tile" class="headerlink" title="3.1 规则瓦片(Rule Tile)"></a>3.1 规则瓦片(Rule Tile)</h2><p>2d-extras中最重要的工具之一就是规则瓦片(Rule Tile)。</p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/ec8959c409eb917d54061b5f05b8c566.webp" srcset="/img/loading.gif" alt="教程｜Unity中使用Tilemap快速创建2D游戏世界"></p><p>不用这个工具的话，我们每次在Tilemap上绘制时，都要从调色板选取特定瓦片再进行绘制。<br>如果你想要绘制相邻瓦片，例如一个拐角，你需要从调色板上一次次选取不同瓦片进行绘制。这种方法效率不高。但有了规则瓦片，你可以为相邻瓦片设置一组规则，它将自动选择最合适的瓦片进行绘制。</p><p><strong>规则瓦片属性：</strong></p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/76bbd201-b852-4f4d-8bd5-08395bc2575e_image5.png" srcset="/img/loading.gif" alt="img"></p><p>规则图块属性包括：</p><ul><li><strong>默认精灵</strong></li><li><strong>默认游戏对象</strong>：<br>可以保留为空白</li><li><strong>默认碰撞器</strong>：<br>指定了瓦片的碰撞检测模式，有两种:<ul><li>精灵模式:按精灵形状进行碰撞检测</li><li>网格模式:按瓦片地图的单元网格形状进行碰撞检测</li></ul></li></ul><p>您添加的每个磁贴都有其他属性：</p><ul><li><strong>Rule</strong> ：<br>这决定了规则的类型。选项是<strong>固定</strong>（默认行为）、<strong>镜像</strong>（跨 X 或 Y 轴）或<strong>旋转</strong>。镜像和旋转是指 3x3 网格的配置，本节稍后会详细介绍。</li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/8c3a789f-e96e-4fec-85c8-04e0f8d9006d_image7.png" srcset="/img/loading.gif" alt="img"></p><p>上图的两个 Rotated 规则完成了 8 个 设定瓦片规则的工作。</p><ul><li><strong>游戏对象</strong></li><li><strong>碰撞器</strong>：<br>更改特定图块的碰撞器以覆盖默认碰撞器。</li><li><strong>输出</strong>：<br>这决定了瓷砖如何放置到场景中。<br>您可以从<strong>Single</strong> 、<strong>Random</strong>或<strong>Animation 中进行选择</strong>。<ul><li>Single ：单个瓦片(普通瓦片)。将使用选定的瓦片。</li><li>Random：随机瓦片。将在一组定义的瓦片之间进行选择</li><li>Animation ：动画瓦片。将播放指定图块的动画。</li></ul></li><li><strong>3x3 网格</strong>：<br>用于设定规则，规则可以根据周围瓦片的属性来决定中心瓦片的属性<br>比如说地块的拼接和转交等功能</li><li><strong>瓦片选择</strong>：<br>在该规则下使用的瓦片</li></ul><h2 id="3-2-预制件笔刷"><a href="#3-2-预制件笔刷" class="headerlink" title="3.2 预制件笔刷"></a>3.2 预制件笔刷</h2><p>在2d-extras中，还加入了预制件笔刷(Prefab Brush)。它能用预制件而不是瓦片来绘制画面。预制件可以是3D对象、粒子效果或是动画对象。要想创建自己的预制件笔刷，只要在项目窗口点击Create -&gt; Prefab Brush即可。然后选取刚创建的预制件笔刷，指定想要画出的预制件。如果你添加了不止一个预制件，它会在这些预制件中随机选取进行绘制。</p><h1 id="4-相关参考"><a href="#4-相关参考" class="headerlink" title="4. 相关参考"></a>4. 相关参考</h1><p><a href="https://zhuanlan.zhihu.com/p/34714804">https://zhuanlan.zhihu.com/p/34714804</a></p><p><a href="https://www.cnblogs.com/SouthBegonia/p/11592554.html">https://www.cnblogs.com/SouthBegonia/p/11592554.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>2D</tag>
      
      <tag>瓦片地图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯法</title>
    <link href="/2021/10/09/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2021/10/09/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0-回溯法理论基础"><a href="#0-回溯法理论基础" class="headerlink" title="0. 回溯法理论基础"></a>0. 回溯法理论基础</h1><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p><strong>回溯函数也就是递归函数，指的都是一个函数</strong>。</p><p><strong>回溯法的理解:</strong><br>回溯法解决的问题都可以抽象为树形结构。<br>回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。<br>递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。</p><p><strong>回溯法的效率：</strong><br>回溯法并不是什么高效的算法，因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。<br>如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><h2 id="0-1-回溯法解决的问题"><a href="#0-1-回溯法解决的问题" class="headerlink" title="0.1 回溯法解决的问题"></a>0.1 回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li><strong>组合问题：</strong><br>N个数里面按一定规则找出k个数的集合</li><li><strong>切割问题：</strong><br>一个字符串按一定规则有几种切割方式</li><li><strong>子集问题：</strong><br>一个N个数的集合里有多少符合条件的子集</li><li><strong>排列问题：</strong><br>N个数按一定规则全排列，有几种排列方式</li><li><strong>棋盘问题：</strong><br>N皇后，解数独等等</li></ul><blockquote><p>排列与组合:</p><ul><li><strong>组合是不强调元素顺序的</strong></li><li><strong>排列是强调元素顺序</strong></li></ul><p>例如：<br>{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p><p><strong>组合无序，排列有序</strong></p></blockquote><h2 id="0-2-回溯法模板"><a href="#0-2-回溯法模板" class="headerlink" title="0.2 回溯法模板"></a>0.2 回溯法模板</h2><p><strong>回溯函数：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数)<br></code></pre></td></tr></table></figure><p><strong>函数终止条件：</strong></p><p>既然是树形结构，那么遍历树形结构一定要有终止条件，所以回溯也有要终止条件。</p><p>从树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><p>所以回溯函数终止条件伪代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">if (终止条件) &#123;<br>    存放结果;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>回溯搜索的遍历过程：</strong></p><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p>如图：</p><p><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95/20210130173631174.png" srcset="/img/loading.gif" alt="回溯算法理论基础"></p><p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p><p>回溯函数遍历过程伪代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>    处理节点;<br>    backtracking(路径，选择列表); // 递归<br>    回溯，撤销处理结果<br>&#125;<br></code></pre></td></tr></table></figure><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p><p>backtracking这里自己调用自己，实现递归。</p><p><strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong><br>这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p><strong>最终模板:</strong><br>回溯算法模板框架如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p><h2 id="0-3-回溯法相关题型目录"><a href="#0-3-回溯法相关题型目录" class="headerlink" title="0.3 回溯法相关题型目录"></a>0.3 回溯法相关题型目录</h2><h3 id="0-3-1-组合问题"><a href="#0-3-1-组合问题" class="headerlink" title="0.3.1 组合问题"></a>0.3.1 组合问题</h3><h3 id="0-3-2-切割问题"><a href="#0-3-2-切割问题" class="headerlink" title="0.3.2 切割问题"></a>0.3.2 切割问题</h3><h3 id="0-3-3-子集和问题"><a href="#0-3-3-子集和问题" class="headerlink" title="0.3.3 子集和问题"></a>0.3.3 子集和问题</h3><h3 id="0-3-4-排列问题"><a href="#0-3-4-排列问题" class="headerlink" title="0.3.4 排列问题"></a>0.3.4 排列问题</h3><h3 id="0-3-5-去重问题"><a href="#0-3-5-去重问题" class="headerlink" title="0.3.5 去重问题"></a>0.3.5 去重问题</h3><h3 id="0-3-6-棋盘问题"><a href="#0-3-6-棋盘问题" class="headerlink" title="0.3.6 棋盘问题"></a>0.3.6 棋盘问题</h3><ul><li>N皇后</li><li>解数独</li></ul><h1 id="1-组合问题"><a href="#1-组合问题" class="headerlink" title="1. 组合问题"></a>1. 组合问题</h1><h2 id="1-1-k个数的组合"><a href="#1-1-k个数的组合" class="headerlink" title="1.1 k个数的组合"></a>1.1 k个数的组合</h2><p><a href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a></p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><p><strong>解:</strong></p><p>可剪枝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span>(<span class="hljs-params">self,n, k</span>):</span><br>        self.output = <span class="hljs-built_in">list</span>()<br>        self.k = k<br>        self.n = n<br>        self.backtracking(<span class="hljs-built_in">list</span>(), <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> self.output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtracking</span>(<span class="hljs-params">self, resoult,index</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(resoult) == self.k:<br>           self.output.append(<span class="hljs-built_in">list</span>(resoult))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index, self.n+<span class="hljs-number">1</span>):<br>            resoult.append(i)<br>            self.backtracking(resoult, i+<span class="hljs-number">1</span>)<br>            resoult.pop()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2021/10/03/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2021/10/03/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0-贪心基础"><a href="#0-贪心基础" class="headerlink" title="0. 贪心基础"></a>0. 贪心基础</h1><h2 id="0-1-贪心理论入门"><a href="#0-1-贪心理论入门" class="headerlink" title="0.1 贪心理论入门"></a>0.1 贪心理论入门</h2><p>在贪心系列开篇词<a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于贪心算法，你该了解这些！ (opens new window)</a>中，我们就讲解了大家对贪心的普遍疑惑。</p><p><strong>什么是贪心算法:</strong><br>如果找出局部最优并可以推出全局最优，就是贪心，如果局部最优都没找出来，就不是贪心。</p><p><strong>贪心算法的套路:</strong><br>贪心无套路，也没有框架之类的，需要多看多练培养感觉才能想到贪心的思路。</p><p><strong>贪心算法的步骤:</strong><br>贪心算法一般分为如下三步：</p><ol><li>将问题分解为若干个子问题</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ol><h2 id="0-2-贪心题目目录"><a href="#0-2-贪心题目目录" class="headerlink" title="0.2 贪心题目目录"></a>0.2 贪心题目目录</h2><h3 id="0-2-1-贪心简单题"><a href="#0-2-1-贪心简单题" class="headerlink" title="0.2.1 贪心简单题"></a>0.2.1 贪心简单题</h3><p>以下三道题目就是简单题，靠常识。</p><ul><li>[分发饼干](# 1. 分发糖果)</li><li>[K次取反后最大化的数组和](# 2. K次取反后最大化的数组和)</li><li>[柠檬水找零](# 3. 柠檬水找零)</li></ul><h3 id="0-2-2-贪心中等题"><a href="#0-2-2-贪心中等题" class="headerlink" title="0.2.2 贪心中等题"></a>0.2.2 贪心中等题</h3><p>贪心中等题，靠常识可能就有点想不出来了。<br>开始初现贪心算法的难度与巧妙之处。</p><ul><li>[摆动序列](# 4. 摆动序列)</li><li>[单调递增的数字](# 5. 单调递增的数字)</li></ul><p><strong>两个维度权衡问题：</strong><br>在出现两个维度相互影响的情况时<br>两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。</p><ul><li>[分发糖果](# 6. 分发糖果)</li><li>[根据身高重建队列](# 7. 根据身高重建队列)</li></ul><h3 id="0-2-3-贪心难题"><a href="#0-2-3-贪心难题" class="headerlink" title="0.2.3 贪心难题"></a>0.2.3 贪心难题</h3><p>这里的题目如果没有接触过，其实是很难想到的，甚至接触过，也一时想不出来，所以题目不要做一遍，要多练！</p><p><strong>区间问题：</strong><br>关于区间问题，各种覆盖各种去重</p><ul><li>[用最少数量的箭引爆气球](# 8. 用最少数量的箭引爆气球)</li><li>[无重叠区间](# 9. 无重叠区间)</li><li>[合并区间](# 10. 合并区间)</li><li>[划分字母区间](# 11. 划分字母区间)</li></ul><p><strong>其他难题：</strong></p><p><a href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">贪心算法：最大子序和 (opens new window)</a><br>其实是动态规划的题目，但贪心性能更优，很多同学也是第一次发现贪心能比动规更优的题目。</p><p><a href="https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html">贪心算法：加油站 (opens new window)</a><br>可能以为是一道模拟题，但就算模拟其实也不简单，需要把while用的很娴熟。但其实是可以使用贪心给时间复杂度降低一个数量级。</p><p>最后贪心系列压轴题目<br><a href="https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html">贪心算法：我要监控二叉树！ (opens new window)</a><br>不仅贪心的思路不好想，而且需要对二叉树的操作特别娴熟，这就是典型的交叉类难题了。</p><h1 id="1-分发饼干"><a href="#1-分发饼干" class="headerlink" title="1. 分发饼干"></a>1. 分发饼干</h1><p><a href="https://leetcode-cn.com/problems/assign-cookies/">https://leetcode-cn.com/problems/assign-cookies/</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。<br>但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；<br>并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。<br>如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。<br>你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2,3], s = [1,1]</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: </span><br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2], s = [1,2,3]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: </span><br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><p><strong>解:</strong></p><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20211004181228698.png" srcset="/img/loading.gif" alt="image-20211004181228698"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContentChildren</span>(<span class="hljs-params">self, g, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(g) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        g = <span class="hljs-built_in">sorted</span>(g)<br>        s = <span class="hljs-built_in">sorted</span>(s)<br>        output = <span class="hljs-number">0</span><br>        sP = <span class="hljs-number">0</span><br>        gP = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> gP &lt; <span class="hljs-built_in">len</span>(g) <span class="hljs-keyword">and</span> sP &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[sP] &gt;= g[gP]:<br>                output += <span class="hljs-number">1</span><br>                gP += <span class="hljs-number">1</span><br>            sP += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="2-K-次取反后最大化的数组和"><a href="#2-K-次取反后最大化的数组和" class="headerlink" title="2. K 次取反后最大化的数组和"></a>2. K 次取反后最大化的数组和</h1><p><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/</a></p><p>给定一个整数数组 A，我们<strong>只能</strong>用以下方法修改该数组：<br>我们选择某个索引 <code>i</code> 并将 <code>A[i]</code> 替换为 <code>-A[i]</code>，然后总共重复这个过程 <code>K</code> 次。<br>（我们可以多次选择同一个索引 <code>i</code>。）</p><p>以这种方式修改数组后，返回数组可能的最大和。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], K = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">5</span><br>解释：选择索引 (<span class="hljs-number">1</span>,) ，然后 <span class="hljs-keyword">A</span> 变为 [<span class="hljs-number">4</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], K = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br>解释：选择索引 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>) ，然后 <span class="hljs-keyword">A</span> 变为 [<span class="hljs-number">3,1,0,2</span>]。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：A = [2,<span class="hljs-string">-3</span>,<span class="hljs-string">-1</span>,5,<span class="hljs-string">-4</span>], K = 2<br>输出：13<br>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,<span class="hljs-string">-1</span>,5,4]。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= K &lt;= 10000</code></li><li><code>-100 &lt;= A[i] &lt;= 100</code></li></ol><p><strong>解:</strong><br>贪心的思路</p><ul><li>局部最优：<br>让绝对值大的负数变为正数，当前数值达到最大</li><li>整体最优：<br>整个数组和达到最大。</li></ul><p>局部最优可以推出全局最优。</p><p>那么如果将负数都转变为正数了，K依然大于0，此时的问题是：<br>一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。</p><p>那么又是一个贪心：</p><ul><li>局部最优：<br>只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了）</li><li>全局最优：<br>整个 数组和 达到最大。</li></ul><p>那么本题的解题步骤为：</p><ul><li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li><li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li><li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li><li>第四步：求和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largestSumAfterKNegations</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        output = <span class="hljs-number">0</span><br>        nums = <span class="hljs-built_in">sorted</span>(nums, key=<span class="hljs-built_in">abs</span>, reverse=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 将A按绝对值从大到小排列</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> k != <span class="hljs-number">0</span>:<br>                nums[i] = -nums[i]<br>                k -= <span class="hljs-number">1</span><br>            output += nums[i]<br>        <span class="hljs-keyword">if</span> k != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> k%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            output = output - nums[-<span class="hljs-number">1</span>]*<span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="3-柠檬水找零"><a href="#3-柠檬水找零" class="headerlink" title="3. 柠檬水找零"></a>3. 柠檬水找零</h1><p><a href="https://leetcode-cn.com/problems/lemonade-change/">https://leetcode-cn.com/problems/lemonade-change/</a></p><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。<br>顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。<br>你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bills = [5,5,5,10,20]<br>输出：true<br>解释：<br>前<span class="hljs-number"> 3 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 3 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>第<span class="hljs-number"> 4 </span>位顾客那里，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，并返还<span class="hljs-number"> 5 </span>美元。<br>第<span class="hljs-number"> 5 </span>位顾客那里，我们找还一张<span class="hljs-number"> 10 </span>美元的钞票和一张<span class="hljs-number"> 5 </span>美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bills = [5,5,10,10,20]<br>输出：false<br>解释：<br>前<span class="hljs-number"> 2 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 2 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>对于接下来的<span class="hljs-number"> 2 </span>位顾客，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，然后返还<span class="hljs-number"> 5 </span>美元。<br>对于最后一位顾客，我们无法退回<span class="hljs-number"> 15 </span>美元，因为我们现在只有两张<span class="hljs-number"> 10 </span>美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">bills</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">bills</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bills.length &lt;= 105</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code> </li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lemonadeChange</span>(<span class="hljs-params">self, bills</span>):</span><br>        changeDict = &#123;<span class="hljs-number">5</span>:<span class="hljs-number">0</span>, <span class="hljs-number">10</span>:<span class="hljs-number">0</span>, <span class="hljs-number">20</span>:<span class="hljs-number">0</span>&#125;<br>        <span class="hljs-keyword">for</span> money <span class="hljs-keyword">in</span> bills:<br>            changeDict[money] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> money == <span class="hljs-number">5</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> money == <span class="hljs-number">10</span>:<br>                <span class="hljs-keyword">if</span> changeDict[<span class="hljs-number">5</span>] == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                changeDict[<span class="hljs-number">5</span>] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> changeDict[<span class="hljs-number">5</span>] == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">if</span> changeDict[<span class="hljs-number">10</span>] &gt; <span class="hljs-number">0</span>:<br>                    changeDict[<span class="hljs-number">10</span>] -= <span class="hljs-number">1</span><br>                    changeDict[<span class="hljs-number">5</span>] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> changeDict[<span class="hljs-number">5</span>] &lt; <span class="hljs-number">3</span>:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                    changeDict[<span class="hljs-number">5</span>] -= <span class="hljs-number">3</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="4-摆动序列"><a href="#4-摆动序列" class="headerlink" title="4. 摆动序列"></a>4. 摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong><br>第一个差（如果存在的话）可能是正数或负数。<br>仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度完成此题?</p><p><strong>解:</strong></p><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20211004181259464.png" srcset="/img/loading.gif" alt="image-20211004181259464"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wiggleMaxLengthByGreedy</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>        MaxLength = <span class="hljs-number">1</span><br>        state = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">if</span>  state != <span class="hljs-number">1</span>:<br>                    MaxLength += <span class="hljs-number">1</span><br>                    state = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> nums[i] &lt; nums[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">if</span> state != -<span class="hljs-number">1</span>:<br>                    MaxLength += <span class="hljs-number">1</span><br>                    state = -<span class="hljs-number">1</span>           <br>        <span class="hljs-keyword">return</span> MaxLength<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    nums = [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>    s = Solution()<br>    print(s.wiggleMaxLengthByGreedy(nums))<br></code></pre></td></tr></table></figure><h1 id="5-单调递增的数字"><a href="#5-单调递增的数字" class="headerlink" title="5. 单调递增的数字"></a>5. 单调递增的数字</h1><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">https://leetcode-cn.com/problems/monotone-increasing-digits/</a></p><p>给定一个非负整数 <code>N</code>，找出小于或等于 <code>N</code> 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是单调递增的。）</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: N = 10</span><br><span class="hljs-section">输出: 9</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: N = 1234</span><br><span class="hljs-section">输出: 1234</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: N = 332</span><br><span class="hljs-section">输出: 299</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong> <code>N</code> 是在 <code>[0, 10^9]</code> 范围内的一个整数。</p><p><strong>解:</strong></p><p><strong>贪心算法三步走:</strong></p><ol><li><p>将问题分解为若干个子问题:<br>把求整个递增的数字这个全局问题，分解为求这个数字每位是什么的子问题</p></li><li><p>求解每一个子问题的最优解:<br>将传入数字n每位拆开放进数组<strong>numStr</strong>中 <strong>倒序</strong> 查看<br>当查看到第 [i] 位时：</p><ul><li>若 <strong>numStr[i] &gt;= numStr[i-1]</strong> ：<br>则仍满足递增<br>第i位不做修改</li><li>若 <strong>numStr[i] &lt; numStr[i-1]</strong> ：<br>则不满足递增<br>第[i]位取最大值9(贪心)<br>第[i-1]位值-1(满足该值 &lt;= n)</li></ul></li><li><p>将局部最优解堆叠成全局最优解<br>当 [i] 位发生改变时，要正序向后查看，之前已经求得的局部最优解是否仍然满足递增要求。<br>需要正序遍历 第 [i] 位 到 最后一位数</p><ul><li><p>若 <strong>numStr[j] &lt;= numStr[j-1]</strong> ：<br>则仍满足递增，第i位不做修改</p></li><li><p>若 <strong>numStr[j] &gt; numStr[j-1]</strong> ：<br>则不满足递增，第[i]位取最大值9(贪心)</p><p>最终把整个数组重新合并为数字，就是全局最优解</p></li></ul></li></ol><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">monotoneIncreasingDigits</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">10</span>:<br>            <span class="hljs-keyword">return</span> n<br>        numStr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(n))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(numStr)-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(numStr[i]) &gt;= <span class="hljs-built_in">int</span>(numStr[i-<span class="hljs-number">1</span>]):<br>                <span class="hljs-keyword">continue</span><br>            numStr[i] = <span class="hljs-string">&#x27;9&#x27;</span><br>            numStr[i-<span class="hljs-number">1</span>] = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(numStr[i-<span class="hljs-number">1</span>]) - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(numStr)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(numStr[j]) &lt; <span class="hljs-built_in">int</span>(numStr[j-<span class="hljs-number">1</span>]):<br>                    numStr[j] = <span class="hljs-string">&#x27;9&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(numStr))<br></code></pre></td></tr></table></figure><h1 id="6-分发糖果"><a href="#6-分发糖果" class="headerlink" title="6. 分发糖果"></a>6. 分发糖果</h1><p><a href="https://leetcode-cn.com/problems/candy/">https://leetcode-cn.com/problems/candy/</a></p><p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,0,2]</span><br>输出：<span class="hljs-number">5</span><br>解释：你可以分别给这三个孩子分发 <span class="hljs-number">2</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span> 颗糖果。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：你可以分别给这三个孩子分发 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">1</span> 颗糖果。<br>     第三个孩子只得到 <span class="hljs-number">1</span> 颗糖果，这已满足上述两个条件。<br></code></pre></td></tr></table></figure><p><strong>解：</strong></p><p><strong>将问题分解为若干个子问题：</strong><br>设学生 A 和学生 B 左右相邻，A 在 B 左边；</p><ul><li>左规则：<br>当 ratings_B&gt;ratings_A 时，B 的糖比 A 的糖数量多</li><li>右规则：<br>当 ratings_A&gt;ratings_B时，A 的糖比 B 的糖数量多</li></ul><blockquote><p>相邻的学生中，评分高的学生必须获得更多的糖果 等价于 所有学生满足左规则且满足右规则。</p></blockquote><p><strong>求解每一个子问题的最优解：</strong></p><ol><li><p>从左至右遍(正序)历学生成绩 ratings<br>假设 第[i+1]个学生的成绩比第[i]个更高<br>则给第[i+1]个学生比第[i]个多一颗糖<br>否则都只给一颗糖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(ratings)):<br>    <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>]:<br>        rightOder[i] = rightOder[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>从右至左遍(倒序)历学生成绩 ratings<br>假设 第[j]个学生的成绩比第[j+1]个更高<br>则给第[j]个学生比第[j+1]个多一颗糖<br>否则都只给一颗糖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ratings)-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> ratings[j] &gt; ratings[j+<span class="hljs-number">1</span>]:<br>leftOder[j] = leftOder[j+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>将局部最优解堆叠成全局最优解:</strong><br>最终，取以上 2 轮遍历 <code>leftOder</code> 和 <code>rightOder</code> 对应学生糖果数的 <strong>最大值</strong> ，这样则 <strong>同时满足左规则和右规则</strong> ，即得到每个同学的最少糖果数量</p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)：<br>遍历三遍数组即可得到结果</li><li>空间复杂度 O(N)<br>需要借用left，right的线性额外空间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">candy</span>(<span class="hljs-params">self, ratings</span>):</span><br>        leftOder = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(ratings)<br>        rightOder = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(ratings)<br>        output = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(ratings)):<br>            <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>]:<br>                rightOder[i] = rightOder[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ratings)-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> ratings[j] &gt; ratings[j+<span class="hljs-number">1</span>]:<br>                leftOder[j] = leftOder[j+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ratings)):<br>            output += <span class="hljs-built_in">max</span>(leftOder[k],rightOder[k])<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="7-根据身高重建队列"><a href="#7-根据身高重建队列" class="headerlink" title="7. 根据身高重建队列"></a>7. 根据身高重建队列</h1><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。<br>每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。<br>返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[5,2]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span><br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 <span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span> 是重新构造后的队列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[6,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[1,4]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[6,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 2000</code></li><li><code>0 &lt;= hi &lt;= 106</code></li><li><code>0 &lt;= ki &lt; people.length</code></li><li>题目数据确保队列可以被重建</li></ul><p><strong>解:</strong></p><p><strong>思路:</strong></p><ol><li>先由高到低排序<br>确定一个贪心维度 people [i][0]</li><li>再根据 people [i][1] 来插入数组<br>确定另一个贪心维度，满足前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人的要求</li></ol><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度O(nlogn + n^2)</li><li>空间复杂度O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reconstructQueue</span>(<span class="hljs-params">self, people</span>):</span><br>        self.quickSort(people,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(people)-<span class="hljs-number">1</span>)<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(people)):<br>            <span class="hljs-keyword">if</span> people[i][<span class="hljs-number">1</span>] &gt; i:<br>                output.append(people[i])<br>            output.insert(people[i][<span class="hljs-number">1</span>] ,people[i])<br>        <span class="hljs-keyword">return</span> output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cmp</span> (<span class="hljs-params">self, A, B</span>):</span><br>        <span class="hljs-keyword">if</span> A[<span class="hljs-number">0</span>] &gt; B[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> A[<span class="hljs-number">0</span>] &lt; B[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> A[<span class="hljs-number">1</span>] &gt; B[<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">self, arr, left, right</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span><br>        l = left<br>        r = right<br>        t = arr[l]<br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.cmp(arr[r], t):<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &gt;= r: <span class="hljs-keyword">break</span><br>            arr[l] = arr[r]<br>            l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> self.cmp(arr[l], t):<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &gt;= r: <span class="hljs-keyword">break</span><br>            arr[r] = arr[l]<br>            r -= <span class="hljs-number">1</span><br>        arr[l] = t<br>        self.quickSort(arr,left,l-<span class="hljs-number">1</span>)<br>        self.quickSort(arr,l+<span class="hljs-number">1</span>,right)<br></code></pre></td></tr></table></figure><h1 id="8-用最少数量的箭引爆气球"><a href="#8-用最少数量的箭引爆气球" class="headerlink" title="8. 用最少数量的箭引爆气球"></a>8. 用最少数量的箭引爆气球</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><p>在二维空间中有许多球形的气球。<br>对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。<br>由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。<br>开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。<br>在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被引爆。<br>可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。<br>我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 <code>points</code> ，其中 <code>points [i] = [xstart,xend]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[10,16]</span>,<span class="hljs-comment">[2,8]</span>,<span class="hljs-comment">[1,6]</span>,<span class="hljs-comment">[7,12]</span>]</span><br>输出：2<br>解释：对于该样例，x = 6 可以射爆 <span class="hljs-comment">[2,8]</span>,<span class="hljs-comment">[1,6]</span> 两个气球，以及 x = 11 射爆另外两个气球<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[5,6]</span>,<span class="hljs-comment">[7,8]</span>]</span><br>输出：4<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[4,5]</span>]</span><br>输出：2<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[1,2]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[2,3],[2,3]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= points.length &lt;= 104</code></li><li><code>points[i].length == 2</code></li><li><code>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</code></li></ul><p><strong>解:</strong></p><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20211005182117165.png" srcset="/img/loading.gif" alt="image-20211005182117165"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMinArrowShots</span>(<span class="hljs-params">self, points</span>):</span><br>        points.sort(key=<span class="hljs-keyword">lambda</span> x: [x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]])<br>        output = <span class="hljs-number">1</span><br>        rightBolder = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> left, right <span class="hljs-keyword">in</span> points[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> left &lt;= rightBolder: <span class="hljs-comment"># 有交集</span><br>                rightBolder = <span class="hljs-built_in">min</span>(rightBolder,right)<br>            <span class="hljs-keyword">else</span>:<br>                output += <span class="hljs-number">1</span><br>                rightBolder = right<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="9-无重叠区间"><a href="#9-无重叠区间" class="headerlink" title="9. 无重叠区间"></a>9. 无重叠区间</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意:</strong></p><ol><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[3,4]</span>, <span class="hljs-comment">[1,3]</span> ]</span><br><br>输出: 1<br><br>解释: 移除 <span class="hljs-comment">[1,3]</span> 后，剩下的区间没有重叠。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span> ]</span><br><br>输出: 2<br><br>解释: 你需要移除两个 <span class="hljs-comment">[1,2]</span> 来使剩下的区间没有重叠。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span> ]</span><br><br>输出: 0<br><br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。<br></code></pre></td></tr></table></figure><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eraseOverlapIntervals</span>(<span class="hljs-params">self, intervals</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(intervals) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        intervals.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])<br>        rightBolder = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        counter = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> left,right <span class="hljs-keyword">in</span> intervals[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> left &gt;= rightBolder:<br>                counter += <span class="hljs-number">1</span><br>                rightBolder = right<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(intervals) - counter<br></code></pre></td></tr></table></figure><h1 id="10-合并区间"><a href="#10-合并区间" class="headerlink" title="10. 合并区间"></a>10. 合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a></p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。<br>请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">self, intervals</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(intervals) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [[]]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(intervals) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> intervals<br>        intervals.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>])<br>        output = <span class="hljs-built_in">list</span>()<br>        leftBounder = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        rightBounder = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> left,right <span class="hljs-keyword">in</span> intervals[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> left &gt; rightBounder:<br>                output.append([leftBounder,rightBounder])<br>                leftBounder = left<br>            leftBounder = <span class="hljs-built_in">min</span>(leftBounder,left)<br>            rightBounder = <span class="hljs-built_in">max</span>(rightBounder,right)<br>        output.append([leftBounder,rightBounder])<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="11-划分字母区间"><a href="#11-划分字母区间" class="headerlink" title="11. 划分字母区间"></a>11. 划分字母区间</h1><p><a href="https://leetcode-cn.com/problems/partition-labels/">https://leetcode-cn.com/problems/partition-labels/</a></p><p>字符串 <code>S</code> 由小写字母组成。<br>我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。<br>返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">S</span> = <span class="hljs-string">&quot;ababcbacadefegdehijhklij&quot;</span><br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>解释：<br>划分结果为 <span class="hljs-string">&quot;ababcbaca&quot;</span>, <span class="hljs-string">&quot;defegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span>。<br>每个字母最多出现在一个片段中。<br>像 <span class="hljs-string">&quot;ababcbacadefegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><p><strong>解:</strong></p><p>先获得每个出现字符的区间，再将重合区间合并，最后剩下的区间数就是答案(同第十题合并区间)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partitionLabels</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [[<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> [[<span class="hljs-number">1</span>]]<br>        charDict = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> charDict.keys():<br>                charDict[s[i]][<span class="hljs-number">1</span>] = i<br>            <span class="hljs-keyword">else</span>:<br>                charDict[s[i]] = [i,i]<br>        charInterval = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> charDict.values():<br>            charInterval.append(key)<br>        charInterval.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>])<br>        leftBoundar = charInterval[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        rightBounder = charInterval[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> left,right <span class="hljs-keyword">in</span> charInterval[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> left &gt; rightBounder:<br>                output.append(rightBounder - leftBoundar + <span class="hljs-number">1</span>)<br>                leftBoundar = left<br>            rightBounder = <span class="hljs-built_in">max</span>(rightBounder,right)<br>        output.append(rightBounder - leftBoundar + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="12-最大子序和"><a href="#12-最大子序和" class="headerlink" title="12. 最大子序和"></a>12. 最大子序和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-100000</span>]<br>输出：<span class="hljs-string">-100000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>解:</strong></p><ul><li>局部最优：<br>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</li><li>全局最优：<br>选取最大“连续和”</li></ul><p><strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums</span>):</span><br>        result = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            count += i<br>            <span class="hljs-keyword">if</span> count &gt; result:<br>                result = count<br>            <span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">0</span>:<br>                count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="13-加油站"><a href="#13-加油站" class="headerlink" title="13. 加油站"></a>13. 加油站</h1><p><a href="https://leetcode-cn.com/problems/gas-station/">https://leetcode-cn.com/problems/gas-station/</a></p><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong> </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: <br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]<br><br>输出: 3<br><br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: <br>gas  = [2,3,4]<br>cost = [3,4,3]<br><br>输出: -1<br><br>解释:<br>你不能从<span class="hljs-number"> 0 </span>号或<span class="hljs-number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从<span class="hljs-number"> 2 </span>号加油站出发，可以获得<span class="hljs-number"> 4 </span>升汽油。 此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>升汽油<br>你无法返回<span class="hljs-number"> 2 </span>号加油站，因为返程需要消耗<span class="hljs-number"> 4 </span>升汽油，但是你的油箱只有<span class="hljs-number"> 3 </span>升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canCompleteCircuit</span>(<span class="hljs-params">self, gas, cost</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(gas) &lt; <span class="hljs-built_in">sum</span>(cost):<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        start = <span class="hljs-number">0</span><br>        curSum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gas)):<br>            curSum += gas[i] - cost[i]<br>            <span class="hljs-keyword">if</span> curSum &lt; <span class="hljs-number">0</span>:<br>                curSum = <span class="hljs-number">0</span><br>                start = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> start<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-堆</title>
    <link href="/2021/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <url>/2021/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-堆的简介"><a href="#1-堆的简介" class="headerlink" title="1. 堆的简介"></a>1. 堆的简介</h1><p><strong>堆的常用方法：</strong></p><ul><li>构建优先队列</li><li>支持堆排序<br><a href="https://mycroftcooper.github.io/2021/09/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">堆排序</a></li><li>快速找出一个集合中的最小值（或者最大值）</li></ul><p><strong>堆分为两种：</strong></p><ul><li>最大堆(大顶堆)<br>父节点的值比每一个子节点的值都要大<br>根节点总是最大值<br>可以用于降序排序</li><li>最小堆(小顶堆)<br>父节点的值比每一个子节点的值都要小<br>根节点总是最小值<br>可用于升序排序</li></ul><p>例子：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002013943710.png" srcset="/img/loading.gif" alt="image-20211002013943710"></p><p>这是一个最大堆，，因为每一个父节点的值都比其子节点要大。<code>10</code> 比 <code>7</code> 和 <code>2</code> 都大。<code>7</code> 比 <code>5</code> 和 <code>1</code>都大。</p><blockquote><p><strong>注意：</strong><br>堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。<br>在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。<br>唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。</p></blockquote><h1 id="2-堆和树的区别"><a href="#2-堆和树的区别" class="headerlink" title="2. 堆和树的区别"></a>2. 堆和树的区别</h1><p>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。<br>我们来看一下两者的主要差别：</p><ul><li><p><strong>节点的顺序</strong></p><ul><li><p>二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。</p></li><li><p>在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p></li></ul></li><li><p><strong>内存占用</strong></p><ul><li>普通树占用的内存空间比它们存储的数据要多，必须为节点对象以及左/右子节点指针分配内存。</li><li>堆仅仅使用一个数据来存储数组，且不使用指针。</li></ul></li><li><p><strong>平衡</strong></p><ul><li>二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到**O(log n)**。</li><li>堆实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。<br>因为堆中数据的组织方式可以保证<strong>O(log n)</strong> 的性能。</li></ul></li><li><p><strong>搜索</strong></p><ul><li>在二叉树中搜索会很快</li><li>但是在堆中搜索会很慢<br>在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</li></ul></li></ul><h1 id="3-堆的存储-数组"><a href="#3-堆的存储-数组" class="headerlink" title="3. 堆的存储(数组)"></a>3. 堆的存储(数组)</h1><p>用数组来实现树相关的数据结构也许看起来有点古怪，但是它在时间和空间上都是很高效的。</p><p>我们准备将上面例子中的树这样存储：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[ <span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span> ]<br></code></pre></td></tr></table></figure><p>就这么多！我们除了一个简单的数组以外，不需要任何额外的空间。</p><h2 id="3-1-索引公式"><a href="#3-1-索引公式" class="headerlink" title="3.1 索引公式"></a>3.1 索引公式</h2><p>节点在数组中的位置index 和它的父节点以及子节点的索引之间有一个映射关系。<br>如果 <code>i</code> 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：</p><p><strong>基础公式：</strong></p><ul><li>parent(i) = (i - 1) // 2</li><li>left(i)   = 2i + 1</li><li>right(i)  = 2i + 2</li></ul><blockquote><p><strong>使用公式时需要注意：</strong></p><ul><li><code>right(i)</code> 就是简单的 <code>left(i) + 1</code><br>左右节点总是处于相邻的位置。</li><li>根节点<code>(10)</code>没有父节点，因为 <code>-1</code> 不是一个有效的数组索引。<br>同样，节点 <code>(2)</code>，<code>(5)</code>和<code>(1)</code> 没有子节点，因为这些索引已经超过了数组的大小<br>所以我们在使用这些索引值的时候需要保证是有效的索引值。</li></ul></blockquote><p>这些公式允许我们不使用指针就可以找到任何一个节点的父节点或者子节点。</p><h2 id="3-2-节点数公式"><a href="#3-2-节点数公式" class="headerlink" title="3.2 节点数公式"></a>3.2 节点数公式</h2><p>理解数组索引和节点位置之间的关系非常重要。<br>这里有一个更大的堆，它有15个节点被分成了4层：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002013923396.png" srcset="/img/loading.gif" alt="image-20211002013923396"></p><p>由上图可以看到，数组中父节点总是在子节点的前面。</p><p><strong>公式:</strong></p><ul><li><strong>如果一个堆有 n 个节点，那么它的高度是</strong> </li></ul><p>​                        <img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002160854520.png" srcset="/img/loading.gif" alt="image-20211002160854520"></p><p>这是因为我们总是要将这一层完全填满以后才会填充新的一层。<br>上面的例子有 15 个节点，所以它的高度是 <code>floor(log2(15)) = floor(3.91) = 3</code>。</p><p>如果最下面的一层已经填满，那么那一层包含 <em>2^h</em> 个节点。</p><ul><li><p><strong>树中这一层以上所有的节点数目为</strong> </p><p>​    <img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002160918051.png" srcset="/img/loading.gif" alt="image-20211002160918051"></p></li></ul><p>同样是上面这个例子，最下面的一层有8个节点，实际上就是 <code>2^3 = 8</code>。<br>前面的三层一共包含7的节点，即：<code>2^3 - 1 = 8 - 1 = 7</code>。</p><ul><li><p><strong>所以整个堆中的节点数目为：</strong></p><p>​        <img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002160929502.png" srcset="/img/loading.gif" alt="image-20211002160929502"></p></li></ul><p>上面的例子中，<code>2^4 - 1 = 16 - 1 = 15</code></p><p><strong>叶节点总是位于数组的 <em>n//2</em> 和 <em>n-1</em> 之间</strong></p><p><strong>注意：</strong><br>你可以在普通二叉树中按照下面的方式组织数据，但是在堆中不可以：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014009799.png" srcset="/img/loading.gif" alt="image-20211002014009799"></p><p>在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014025394.png" srcset="/img/loading.gif" alt="image-20211002014025394"></p><blockquote><p><strong>注意：</strong></p><ul><li>你可以使用普通树来模拟堆，但是那对空间是极大的浪费。</li><li>并不是每一个堆都是一个有序数组！要将堆转换成有序数组，需要使用堆排序。</li></ul></blockquote><h1 id="4-堆的常用操作"><a href="#4-堆的常用操作" class="headerlink" title="4. 堆的常用操作"></a>4. 堆的常用操作</h1><p>有两个原始操作用于保证插入或删除节点以后堆是一个有效的最大堆或者最小堆：</p><ul><li><code>shiftUp()</code>:<br>如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置。<br>这样是这个节点在数组的位置上升。</li><li><code>shiftDown()</code>:<br>如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动。<br>这个操作也称作“堆化（heapify）”。</li></ul><p>shiftUp 或者 shiftDown 是一个递归的过程，所以它的时间复杂度是 **O(log n)**。</p><p>基于这两个原始操作还有一些其他的操作：</p><ul><li><p><code>peek()</code> ：<br>不用删除节点就返回最大值（最大堆）或者最小值（最小堆）。<br>时间复杂度 <strong>O(1)</strong> 。</p></li><li><p><code>insert(value)</code>:<br>在堆的尾部添加一个新的元素，然后使用 <code>shiftUp</code> 来修复对。</p></li><li><p><code>remove()</code>:<br>移除并返回最大值（最大堆）或者最小值（最小堆）。<br>为了将这个节点删除后的空位填补上，需要将最后一个元素移到根节点的位置，然后使用 <code>shiftDown</code> 方法来修复堆。</p></li><li><p><code>removeAtIndex(index)</code>:<br>和 <code>remove()</code> 一样，差别在于可以移除堆中任意节点，而不仅仅是根节点。<br>当它与子节点比较位置不时无序时使用 <code>shiftDown()</code>，如果与父节点比较发现无序则使用 <code>shiftUp()</code>。</p></li><li><p><code>replace(index, value)</code>：<br>将一个更小的值（最小堆）或者更大的值（最大堆）赋值给一个节点。<br>由于这个操作破坏了堆属性，所以需要使用 <code>shiftUp()</code> 来修复堆属性。</p></li></ul><p>上面所有的操作的时间复杂度都是 **O(log n)**，因为 shiftUp 和 shiftDown 都很费时。</p><p>还有少数一些操作需要更多的时间：</p><ul><li><code>search(value)</code>:<br>堆不是为快速搜索而建立的，但是 <code>replace()</code> 和 <code>removeAtIndex()</code> 操作需要找到节点在数组中的index，所以你需要先找到这个index。<br>时间复杂度：**O(n)**。</li><li><code>buildHeap(array)</code>:<br>通过反复调用 <code>insert()</code> 方法将一个（无序）数组转换成一个堆。<br>如果你足够聪明，你可以在 <strong>O(n)</strong> 时间内完成。</li><li>堆排序：<br>由于堆就是一个数组，我们可以使用它独特的属性将数组从低到高排序。<br>时间复杂度：**O(n lg n)**。</li></ul><blockquote><p><strong>注意：</strong><br>到目前为止，堆的常用操作还是使用 <code>insert()</code> 插入一个新的元素，和通过 <code>remove()</code>移除最大或者最小值。<br>两者的时间复杂度都是**O(log n)**。<br>其其他的操作是用于支持更高级的应用，比如说建立一个优先队列。</p></blockquote><h2 id="4-1-插入"><a href="#4-1-插入" class="headerlink" title="4.1 插入"></a>4.1 插入</h2><p>我们通过一个插入例子来看看插入操作的细节。<br>我们将数字 <code>16</code> 插入到这个堆中：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014040987.png" srcset="/img/loading.gif" alt="image-20211002014040987"></p><p>堆的数组是： <code>[ 10, 7, 2, 5, 1 ]</code>。</p><p>第一股是将新的元素插入到数组的尾部。<br>数组变成：<code>[ 10, 7, 2, 5, 1, 16 ]</code></p><p>相应的树变成了：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014105489.png" srcset="/img/loading.gif" alt="image-20211002014105489"></p><p><code>16</code> 被添加最后一行的第一个空位。</p><p>不行的是，现在堆属性不满足，因为 <code>2</code> 在 <code>16</code> 的上面，我们需要将大的数字在上面（这是一个最大堆）<br>为了恢复堆属性，我们需要交换 <code>16</code> 和 <code>2</code>。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014115401.png" srcset="/img/loading.gif" alt="image-20211002014115401"></p><p>现在还没有完成，因为 <code>10</code> 也比 <code>16</code> 小。<br>我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。<br>这就是所谓的 <strong>shift-up</strong>，每一次插入操作后都需要进行。<br>它将一个太大或者太小的数字“浮起”到树的顶部。</p><p>最后我们得到的堆：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014125610.png" srcset="/img/loading.gif" alt="image-20211002014125610"></p><p>现在每一个父节点都比它的子节点大。</p><h2 id="4-2-删除根节点"><a href="#4-2-删除根节点" class="headerlink" title="4.2 删除根节点"></a>4.2 删除根节点</h2><p>我们将这个树中的 <code>(10)</code> 删除：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014040987.png" srcset="/img/loading.gif" alt="image-20211002014040987"></p><p>现在顶部有一个空的节点，怎么处理？</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014148719.png" srcset="/img/loading.gif" alt="image-20211002014148719"></p><p>当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014158542.png" srcset="/img/loading.gif" alt="image-20211002014158542"></p><p>现在来看怎么 <strong>shift-down</strong> <code>(1)</code>。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换 <code>7</code> 和 <code>2</code>。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换 <code>7</code> 和 <code>1</code>，现在树变成了：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014205304.png" srcset="/img/loading.gif" alt="image-20211002014205304"></p><p>继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014212991.png" srcset="/img/loading.gif" alt="image-20211002014212991"></p><h2 id="4-3-删除任意节点"><a href="#4-3-删除任意节点" class="headerlink" title="4.3 删除任意节点"></a>4.3 删除任意节点</h2><p>绝大多数时候你需要删除的是堆的根节点，因为这就是堆的设计用途。<br>但是，删除任意节点也很有用。</p><p>这是 <code>remove()</code> 的通用版本，它可能会使用到 <code>shiftDown</code> 和 <code>shiftUp</code>。</p><p>我们还是用前面的例子，删除 <code>(7)</code>:</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014040987.png" srcset="/img/loading.gif" alt="image-20211002014040987"></p><p>对应的数组是：<code>[ 10, 7, 2, 5, 1 ]</code></p><p>移除一个元素会破坏最大堆或者最小堆属性，我们需要将删除的元素和最后一个元素交换：<br><code>[ 10, 1, 2, 5, 7 ]</code></p><p>最后一个元素就是我们需要返回的元素；然后调用 <code>removeLast()</code> 来将它删除。<br> <code>(1)</code> 比它的子节点小，所以需要 <code>shiftDown()</code> 来修复。</p><p>然而，shift down 不是我们要处理的唯一情况。也有可能我们需要 shift up。考虑一下从下面的堆中删除 <code>(5)</code> 会发生什么：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014236057.png" srcset="/img/loading.gif" alt="image-20211002014236057"></p><h1 id="5-代码实现堆"><a href="#5-代码实现堆" class="headerlink" title="5. 代码实现堆"></a>5. 代码实现堆</h1><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,isBigTop</span>):</span><br>        self.heapList = <span class="hljs-built_in">list</span>()<br>        self.isBigTop = isBigTop<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTop</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.heapList) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> self.heapList[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__swap</span>(<span class="hljs-params">self,index1,index2</span>):</span><br>        t = self.heapList[index1]<br>        self.heapList[index1] = self.heapList[index2]<br>        self.heapList[index2] = t<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__shitfUp</span>(<span class="hljs-params">self,index</span>):</span><br>        <span class="hljs-keyword">while</span> index &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> (self.heapList[(index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>] &lt; self.heapList[index] <span class="hljs-keyword">and</span> self.isBigTop)\<br>                <span class="hljs-keyword">or</span>\<br>                (self.heapList[(index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>] &gt; self.heapList[index] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.isBigTop):<br>                self.__swap((index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>,index)<br>                index = (index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br>            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__shiftDown</span>(<span class="hljs-params">self,index</span>):</span><br>        <span class="hljs-keyword">if</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">len</span>(self.heapList):<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> self.isBigTop:<br>            <span class="hljs-keyword">while</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(self.heapList):<br>                <span class="hljs-keyword">if</span> self.heapList[index] &lt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span>\<br>                   self.heapList[index] &lt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]:<br>                    <span class="hljs-keyword">if</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span> &gt;= <span class="hljs-built_in">len</span>(self.heapList) <span class="hljs-keyword">or</span> \<br>                       self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] &gt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]:<br>                        self.__swap(index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,index)<br>                        index = index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        self.__swap(index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>,index)<br>                        index = index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">while</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(self.heapList):<br>                <span class="hljs-keyword">if</span> self.heapList[index] &gt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span>\<br>                   self.heapList[index] &gt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]:<br>                    <span class="hljs-keyword">if</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span> &gt;= <span class="hljs-built_in">len</span>(self.heapList) <span class="hljs-keyword">or</span>\<br>                       self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] &lt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]:<br>                        self.__swap(index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,index)<br>                        index = index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        self.__swap(index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>,index)<br>                        index = index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, num</span>):</span><br>        self.heapList.append(num)<br>        self.__shitfUp(<span class="hljs-built_in">len</span>(self.heapList) - <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self, index</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.heapList) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt; <span class="hljs-built_in">len</span>(self.heapList)-<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(self.heapList)-<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> self.heapList.pop()<br>        self.__swap(index,<span class="hljs-built_in">len</span>(self.heapList) - <span class="hljs-number">1</span>)<br>        output = self.heapList.pop()<br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            self.__shiftDown(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            pIndex = (index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br>            lIndex = <span class="hljs-number">2</span>*index+<span class="hljs-number">1</span><br>            rIndex = lIndex + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> pIndex &gt;= <span class="hljs-number">0</span>:<br>                self.__shitfUp(index)<br>            <span class="hljs-keyword">if</span> lIndex &lt; <span class="hljs-built_in">len</span>(self.heapList) <span class="hljs-keyword">or</span> rIndex &lt; <span class="hljs-built_in">len</span>(self.heapList):<br>                self.__shiftDown(index)<br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    numList = [ <span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span> ]<br>    h = Heap(<span class="hljs-literal">True</span>)<br>    h.heapList = numList<br>    h.push(<span class="hljs-number">10</span>)<br>    print(h.heapList)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2021/09/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/09/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h1><h2 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类"></a>0.1 算法分类</h2><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li></ul><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20190306165258970-1789860540.png" srcset="/img/loading.gif" alt="img"></p><h2 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h2><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20180402133438219-1946132192.png" srcset="/img/loading.gif" alt="img"></p><h2 id="0-3-相关概念"><a href="#0-3-相关概念" class="headerlink" title="0.3 相关概念"></a>0.3 相关概念</h2><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机</li></ul><p>内执行时所需存储空间的度量，它也是数据规模n的函数。 </p><h1 id="1-快速排序（Quick-Sort）"><a href="#1-快速排序（Quick-Sort）" class="headerlink" title="1. 快速排序（Quick Sort）"></a>1. 快速排序（Quick Sort）</h1><h2 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h2 id="1-2-动图演示"><a href="#1-2-动图演示" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h2><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20171015230936371-1413523412.gif" srcset="/img/loading.gif" alt="快速排序img"></p><h2 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr,left,right</span>):</span><br>    <span class="hljs-keyword">if</span> left &gt;= right:<br>        <span class="hljs-keyword">return</span><br>    l = left<br>    r = right<br>    t = arr[l]<br>    <span class="hljs-keyword">while</span> l &lt; r:<br>        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> arr[r] &gt; t:<br>            r -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> l &lt; r:<br>            arr[l] = arr[r]<br>            l += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> arr[l] &lt; t:<br>            l += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> l &lt; r:<br>            arr[r] = arr[l]<br>            r -= <span class="hljs-number">1</span><br>    arr[l] = t<br>    quickSort(arr,left,l-<span class="hljs-number">1</span>)<br>    quickSort(arr,l+<span class="hljs-number">1</span>,right)<br></code></pre></td></tr></table></figure><h2 id="1-4-相关题型"><a href="#1-4-相关题型" class="headerlink" title="1.4 相关题型"></a>1.4 相关题型</h2><p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></p><h1 id="2-归并排序（Merge-Sort）"><a href="#2-归并排序（Merge-Sort）" class="headerlink" title="2. 归并排序（Merge Sort）"></a>2. 归并排序（Merge Sort）</h1><h2 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。</p><p>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>将已有序的子序列合并，得到完全有序的序列；<br>即先使每个子序列有序，再使子序列段间有序。<br>若将两个有序表合并成一个有序表，称为2-路归并。 </p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><p>归并排序是一种稳定的排序方法。<br>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。</p><p>代价是需要额外的内存空间。</p><h2 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a>2.2 动图演示</h2><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20171015230557043-37375010.gif" srcset="/img/loading.gif" alt="归并排序img"></p><h2 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-comment"># 递归划分</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    mid = <span class="hljs-built_in">len</span>(arr)//<span class="hljs-number">2</span><br>    leftArr = mergeSort(arr[:mid])<br>    rightArr = mergeSort(arr[mid:])<br><br>    <span class="hljs-comment"># 回溯治理</span><br>    mergeArr = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(leftArr) != <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(rightArr) != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(leftArr) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rightArr) != <span class="hljs-number">0</span>:<br>                mergeArr.append(rightArr.pop(<span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rightArr) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(leftArr) != <span class="hljs-number">0</span>:<br>                mergeArr.append(leftArr.pop(<span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> rightArr[<span class="hljs-number">0</span>] &gt; leftArr[<span class="hljs-number">0</span>]:<br>            mergeArr.append(rightArr.pop(<span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">else</span>:<br>            mergeArr.append(leftArr.pop(<span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> mergeArr<br></code></pre></td></tr></table></figure><h2 id="2-4-相关题型"><a href="#2-4-相关题型" class="headerlink" title="2.4 相关题型"></a>2.4 相关题型</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></p><h1 id="3-堆排序（Heap-Sort）"><a href="#3-堆排序（Heap-Sort）" class="headerlink" title="3. 堆排序（Heap Sort）"></a>3. 堆排序（Heap Sort）</h1><h2 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p><p>关于堆的介绍请看：<br><a href="">数据结构-堆</a></p><p>堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：<br>即子结点的键值或索引总是小于（或者大于）它的父节点。</p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h2 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h2><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20171015231308699-356134237.gif" srcset="/img/loading.gif" alt="堆排序img"></p><h2 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums, indexA, indexB</span>):</span><br>    t = nums[indexA]<br>    nums[indexA] = nums[indexB]<br>    nums[indexB] = t<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildBigTopHeap</span>(<span class="hljs-params">nums</span>):</span><br>    index = (<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>        shiftDown(nums,i,<span class="hljs-built_in">len</span>(nums))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shiftDown</span>(<span class="hljs-params">nums,index,lenth</span>):</span><br>    leftP = index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span><br>    rightP = leftP+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> leftP &gt;= lenth:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> rightP &gt;= lenth:<br>        maxNum = nums[leftP]<br>    <span class="hljs-keyword">else</span>:<br>        maxNum = <span class="hljs-built_in">max</span>(nums[leftP], nums[rightP])<br>    <span class="hljs-keyword">if</span> nums[index] &lt; maxNum:<br>        <span class="hljs-keyword">if</span> maxNum == nums[leftP]:<br>            swap(nums,index,leftP)<br>            shiftDown(nums,leftP,lenth)<br>        <span class="hljs-keyword">else</span>:<br>            swap(nums,index,rightP)<br>            shiftDown(nums,rightP,lenth)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">incHeapSort</span>(<span class="hljs-params">nums</span>):</span><br>    buildBigTopHeap(nums)<br>    lenth = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">while</span> lenth &gt; <span class="hljs-number">1</span>:<br>        lenth -= <span class="hljs-number">1</span><br>        swap(nums,<span class="hljs-number">0</span>,lenth)<br>        shiftDown(nums,<span class="hljs-number">0</span>,lenth)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    nums = [<span class="hljs-number">16</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">8</span>]<br>    incHeapSort(nums)<br>    print(nums)<br></code></pre></td></tr></table></figure><h2 id="3-4-相关题型"><a href="#3-4-相关题型" class="headerlink" title="3.4 相关题型"></a>3.4 相关题型</h2><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></p>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/09/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/09/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="0-动态规划理论基础"><a href="#0-动态规划理论基础" class="headerlink" title="0. 动态规划理论基础"></a>0. 动态规划理论基础</h1><h2 id="0-1-动态规划理论入门"><a href="#0-1-动态规划理论入门" class="headerlink" title="0.1 动态规划理论入门"></a>0.1 动态规划理论入门</h2><p><strong>定义:</strong><br>动态规划，英文：Dynamic Programming，简称DP。<br>如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p><strong>与贪心算法的区别:</strong></p><ul><li>动态规划:<br>每一个状态一定是由上一个状态推导出来的</li><li>贪心算法:<br>没有状态推导，从局部直接选最优的</li></ul><p>例如：<br>有N件物品和一个最多能背重量为W 的背包。<br>第i件物品的重量是weight[i]，得到的价值是value[i] 。<br><strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p><p>所以贪心解决不了动态规划的问题。</p><h2 id="0-2-动态规划的解题步骤"><a href="#0-2-动态规划的解题步骤" class="headerlink" title="0.2 动态规划的解题步骤"></a>0.2 动态规划的解题步骤</h2><p><strong>分为以下五步：</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="0-3-题目目录"><a href="#0-3-题目目录" class="headerlink" title="0.3 题目目录"></a>0.3 题目目录</h2><h3 id="0-3-1-一维动态规划"><a href="#0-3-1-一维动态规划" class="headerlink" title="0.3.1 一维动态规划"></a>0.3.1 一维动态规划</h3><ul><li>[斐波那契数列](# 1. 斐波那契数列)</li><li>[泰波那契数列](# 2. 泰波那契数列)</li><li>[爬楼梯 I](# 3. 爬楼梯 I)</li><li>[爬楼梯 II](# 4. 爬楼梯 II)</li><li>[跳跃问题 I](# 5. 跳跃问题 I)</li><li>[跳跃问题 II](# 6. 跳跃问题 II)</li><li><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍 I</a></li><li><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></li><li><a href="https://leetcode-cn.com/problems/delete-and-earn/">删除并获得点数</a></li><li><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">最佳观光组合</a></li></ul><h3 id="0-3-2-二维动态规划"><a href="#0-3-2-二维动态规划" class="headerlink" title="0.3.2 二维动态规划"></a>0.3.2 二维动态规划</h3><ul><li><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></li><li><a href="">下降路径最小和</a></li><li><a href="">不同路径 I</a></li><li><a href="">不同路径 II</a></li><li><a href="">杨辉三角</a></li><li><a href="">三角形最小路径和</a></li><li><a href="">摆动序列和</a></li></ul><h3 id="0-3-3-子序列问题"><a href="#0-3-3-子序列问题" class="headerlink" title="0.3.3 子序列问题"></a>0.3.3 子序列问题</h3><h3 id="0-3-4-回文串与编辑问题"><a href="#0-3-4-回文串与编辑问题" class="headerlink" title="0.3.4 回文串与编辑问题"></a>0.3.4 回文串与编辑问题</h3><h3 id="0-3-5-股票问题"><a href="#0-3-5-股票问题" class="headerlink" title="0.3.5 股票问题"></a>0.3.5 股票问题</h3><h3 id="0-3-6-背包问题"><a href="#0-3-6-背包问题" class="headerlink" title="0.3.6 背包问题"></a>0.3.6 背包问题</h3><h3 id="0-3-7-前缀和问题"><a href="#0-3-7-前缀和问题" class="headerlink" title="0.3.7 前缀和问题"></a>0.3.7 前缀和问题</h3><ul><li><p><a href="https://leetcode-cn.com/problems/matrix-block-sum/">1314. 矩阵区域和</a></p></li><li><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></p></li><li><p><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></p></li></ul><h3 id="0-3-8-复合问题"><a href="#0-3-8-复合问题" class="headerlink" title="0.3.8 复合问题"></a>0.3.8 复合问题</h3><h1 id="1-一维动态规划"><a href="#1-一维动态规划" class="headerlink" title="1. 一维动态规划"></a>1. 一维动态规划</h1><h2 id="1-1-斐波那契数列"><a href="#1-1-斐波那契数列" class="headerlink" title="1.1 斐波那契数列"></a>1.1 斐波那契数列</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">https://leetcode-cn.com/problems/fibonacci-number/</a></p><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。<br>该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。<br>也就是：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">F(0)</span> = <span class="hljs-number">0</span>，<span class="hljs-constructor">F(1)</span> = <span class="hljs-number">1</span><br><span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span> = <span class="hljs-constructor">F(<span class="hljs-params">n</span> - 1)</span> + <span class="hljs-constructor">F(<span class="hljs-params">n</span> - 2)</span>，其中 n &gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br>解释：F<span class="hljs-comment">(2)</span> = F<span class="hljs-comment">(1)</span> + F<span class="hljs-comment">(0)</span> = <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：F<span class="hljs-comment">(3)</span> = F<span class="hljs-comment">(2)</span> + F<span class="hljs-comment">(1)</span> = <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h2 id="1-2-泰波那契数列"><a href="#1-2-泰波那契数列" class="headerlink" title="1.2 泰波那契数列"></a>1.2 泰波那契数列</h2><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">https://leetcode-cn.com/problems/n-th-tribonacci-number/</a></p><p>泰波那契序列 Tn 定义如下： </p><p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4<br>输出：4<br>解释：<br>T_3 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 2<br>T_4 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>= 4<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">25</span><br>输出：<span class="hljs-number">1389537</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 37</code></li><li>答案保证是一个 32 位整数，即 <code>answer &lt;= 2^31 - 1</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tribonacci</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>] + dp[i-<span class="hljs-number">3</span>]<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h2 id="1-3-爬楼梯-I"><a href="#1-3-爬楼梯-I" class="headerlink" title="1.3 爬楼梯 I"></a>1.3 爬楼梯 I</h2><p><strong>描述：</strong><br>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><blockquote><p><strong>注意：</strong><br>给定 <em>n</em> 是一个正整数。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h2 id="1-4-爬楼梯-II"><a href="#1-4-爬楼梯-II" class="headerlink" title="1.4 爬楼梯 II"></a>1.4 爬楼梯 II</h2><p><strong>描述：</strong></p><p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>（下标从 <code>0</code> 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[10, 15, 20]</span><br>输出：15<br>解释：最低花费是从 cost<span class="hljs-comment">[1]</span> 开始，然后走两步即可到阶梯顶，一共花费 15 。<br></code></pre></td></tr></table></figure><p> <strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br>输出：6<br>解释：最低花费方式是从 cost<span class="hljs-comment">[0]</span> 开始，逐个经过那些 1 ，跳过 cost<span class="hljs-comment">[3]</span> ，一共花费 6 。<br></code></pre></td></tr></table></figure><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">https://leetcode-cn.com/problems/min-cost-climbing-stairs/</a></p><p><strong>提示：</strong></p><ul><li><code>cost</code> 的长度范围是 <code>[2, 1000]</code>。</li><li><code>cost[i]</code> 将会是一个整型数据，范围为 <code>[0, 999]</code> 。</li></ul><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span>(<span class="hljs-params">self, cost</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cost) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> cost[-<span class="hljs-number">1</span>]<br>        cost.append(<span class="hljs-number">0</span>)<br>        dp = [<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(cost))<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(dp)):<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1-5-跳跃游戏-I"><a href="#1-5-跳跃游戏-I" class="headerlink" title="1.5 跳跃游戏 I"></a>1.5 跳跃游戏 I</h2><p><strong>描述：</strong></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：无论怎样，总会到达下标为 <span class="hljs-number">3</span> 的位置。但该下标的最大跳跃长度是 <span class="hljs-number">0</span> ， 所以永远不可能到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canJump</span>(<span class="hljs-params">self, nums</span>) -&gt; bool:</span><br>        dp = [<span class="hljs-literal">False</span>]*<span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> dp[i-<span class="hljs-number">1</span>] == <span class="hljs-literal">False</span>:<br>                dp[i] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">elif</span> nums[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> nums[j] &gt;= i - j:<br>                        dp[i] = <span class="hljs-literal">True</span><br>                        print(j,i)<br>                        <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                dp[i] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1-6-跳跃游戏-II"><a href="#1-6-跳跃游戏-II" class="headerlink" title="1.6 跳跃游戏 II"></a>1.6 跳跃游戏 II</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为<span class="hljs-number"> 0 </span>跳到下标为<span class="hljs-number"> 1 </span>的位置，跳<span class="hljs-number"> 1 </span>步，然后跳<span class="hljs-number"> 3 </span>步到达数组的最后一个位置。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,0,1,4]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">https://leetcode-cn.com/problems/jump-game-ii/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpByGreedy</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        p = <span class="hljs-number">0</span><br>        q = nums[p]<br>        <span class="hljs-keyword">if</span> p + q &gt;= <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        counter = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> p + q &lt; <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>:<br>            t = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p+<span class="hljs-number">1</span>,p+q+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums[i] + i &gt;= t:<br>                    t = nums[i] + i<br>                    p = i<br>            q = nums[p]<br>            counter += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>  p + q &gt; <span class="hljs-built_in">len</span>(nums):<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> counter+<span class="hljs-number">1</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpByDP</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)))<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            t = nums[i-<span class="hljs-number">1</span>] + i-<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>                dp[-<span class="hljs-number">1</span>] = dp[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,t+<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,dp[j])<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.jumpByDP([<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><h2 id="1-7-打家劫舍I"><a href="#1-7-打家劫舍I" class="headerlink" title="1.7 打家劫舍I"></a>1.7 打家劫舍I</h2><p><strong>描述:</strong><br>你是一个专业的小偷，计划偷窃沿街的房屋。<br>每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpByGreedy</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        p = <span class="hljs-number">0</span><br>        q = nums[p]<br>        <span class="hljs-keyword">if</span> p + q &gt;= <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        counter = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> p + q &lt; <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>:<br>            t = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p+<span class="hljs-number">1</span>,p+q+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums[i] + i &gt;= t:<br>                    t = nums[i] + i<br>                    p = i<br>            q = nums[p]<br>            counter += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>  p + q &gt; <span class="hljs-built_in">len</span>(nums):<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> counter+<span class="hljs-number">1</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpByDP</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)))<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            t = nums[i-<span class="hljs-number">1</span>] + i-<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>                dp[-<span class="hljs-number">1</span>] = dp[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,t+<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,dp[j])<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.jumpByDP([<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><h2 id="1-8-打家劫舍II"><a href="#1-8-打家劫舍II" class="headerlink" title="1.8  打家劫舍II"></a>1.8  打家劫舍II</h2><p><strong>描述：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。<br>这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。<br>同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 1），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 3）。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/house-robber-ii/">https://leetcode-cn.com/problems/house-robber-ii/</a></p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>])<br>        a1 = self.fdp(nums[<span class="hljs-number">1</span>:])<br>        a2 = self.fdp(nums[:<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a1, a2)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fdp</span>(<span class="hljs-params">self, nums</span>):</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>((dp[i-<span class="hljs-number">2</span>]+nums[i]), dp[i-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1-9-删除并获得点数"><a href="#1-9-删除并获得点数" class="headerlink" title="1.9 删除并获得点数"></a>1.9 删除并获得点数</h2><p><a href="https://leetcode-cn.com/problems/delete-and-earn/">https://leetcode-cn.com/problems/delete-and-earn/</a></p><p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有</strong> 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p><p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,4,2]<br>输出：6<br>解释：<br>删除<span class="hljs-number"> 4 </span>获得<span class="hljs-number"> 4 </span>个点数，因此<span class="hljs-number"> 3 </span>也被删除。<br>之后，删除<span class="hljs-number"> 2 </span>获得<span class="hljs-number"> 2 </span>个点数。总共获得<span class="hljs-number"> 6 </span>个点数。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,2,3,3,3,4]<br>输出：9<br>解释：<br>删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数，接着要删除两个<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>。<br>之后，再次删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数，再次删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数。<br>总共获得<span class="hljs-number"> 9 </span>个点数。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteAndEarn</span>(<span class="hljs-params">self, nums</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br><br>        maxNum = self.getMaxNum(nums)<br>        numsList = [<span class="hljs-number">0</span>]*(maxNum+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            numsList[i] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.fdp(numsList)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMaxNum</span>(<span class="hljs-params">self, arr</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>]<br>        t = arr[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>            <span class="hljs-keyword">if</span> i &gt; t:<br>                t = i<br>        <span class="hljs-keyword">return</span> t<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fdp</span>(<span class="hljs-params">self, arr</span>):</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(arr)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = arr[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(arr)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], (dp[i-<span class="hljs-number">2</span>]+i * arr[i]))<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1-10-最佳观光组合"><a href="#1-10-最佳观光组合" class="headerlink" title="1.10 最佳观光组合"></a>1.10 最佳观光组合</h2><p><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">https://leetcode-cn.com/problems/best-sightseeing-pair/</a></p><p>给你一个正整数数组 <code>values</code>，其中 <code>values[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>j - i</code>。</p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为 <code>values[i] + values[j] + i - j</code> ，也就是景点的评分之和 <strong>减去</strong> 它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：values = <span class="hljs-selector-attr">[8,1,5,2,6]</span><br>输出：<span class="hljs-number">11</span><br>解释：<span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>, j = <span class="hljs-number">2</span>, values<span class="hljs-selector-attr">[i]</span> + values<span class="hljs-selector-attr">[j]</span> + <span class="hljs-selector-tag">i</span> - j = <span class="hljs-number">8</span> + <span class="hljs-number">5</span> + <span class="hljs-number">0</span> - <span class="hljs-number">2</span> = <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：values </span>=<span class="hljs-string"> [1,2]</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= values.length &lt;= 5 * 104</code></li><li><code>1 &lt;= values[i] &lt;= 1000</code></li></ul><p>解:<br>动态规划和贪心算法都可解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># https://leetcode-cn.com/problems/best-sightseeing-pair/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxScoreSightseeingPairByDP</span>(<span class="hljs-params">self, values</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(values) == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> values[<span class="hljs-number">0</span>] + values[<span class="hljs-number">1</span>] -<span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>] *<span class="hljs-built_in">len</span>(values)<br>        dp[<span class="hljs-number">0</span>] = values[<span class="hljs-number">0</span>]<br>        maxValue = dp[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(values)):<br>            maxValue = <span class="hljs-built_in">max</span>(maxValue, dp[i-<span class="hljs-number">1</span>]+values[i]-i)<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>],values[i]+i)<br>        <span class="hljs-keyword">return</span> maxValue<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxScoreSightseeingPairByGreedy</span>(<span class="hljs-params">self, values</span>):</span><br>        maxValue = <span class="hljs-number">0</span><br>        lastMVPIndex = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(values)):<br>            maxValue = <span class="hljs-built_in">max</span>(maxValue, values[lastMVPIndex]+lastMVPIndex+values[i]-i)<br>            <span class="hljs-keyword">if</span> values[i] &gt;= values[lastMVPIndex]+lastMVPIndex-i:<br>                lastMVPIndex = i<br>        <span class="hljs-keyword">return</span> maxValue<br></code></pre></td></tr></table></figure><h2 id="1-11-丑数-II"><a href="#1-11-丑数-II" class="headerlink" title="1.11 丑数-II"></a>1.11 丑数-II</h2><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">12</span><br>解释：<span class="hljs-string">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]</span> 是由前 <span class="hljs-number">10</span> 个丑数组成的序列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">1</span> 通常被视为丑数。<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1690</code></li></ul><p><strong>解：</strong><br>同剑指-49</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthUglyNumber</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*n<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        a,b,c = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>            n2,n3,n5 = dp[a]*<span class="hljs-number">2</span>,dp[b]*<span class="hljs-number">3</span>,dp[c]*<span class="hljs-number">5</span><br>            dp[i] = <span class="hljs-built_in">min</span>(n2,n3,n5)<br>            <span class="hljs-keyword">if</span> dp[i] == n2:<br>                a += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dp[i] == n3:<br>                b += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dp[i] == n5:<br>                c += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="2-二维动态规划"><a href="#2-二维动态规划" class="headerlink" title="2. 二维动态规划"></a>2. 二维动态规划</h1><h2 id="2-1-最小路径和"><a href="#2-1-最小路径和" class="headerlink" title="2.1 最小路径和"></a>2.1 最小路径和</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/minpath.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><p>解:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minPathSum</span>(<span class="hljs-params">self, grid: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; int:</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(grid)):<br>            grid[i][<span class="hljs-number">0</span>] += grid[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>            grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>                grid[i][j] += <span class="hljs-built_in">min</span>(grid[i-<span class="hljs-number">1</span>][j],grid[i][j-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> grid[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="2-2-下降路径最小和"><a href="#2-2-下降路径最小和" class="headerlink" title="2.2 下降路径最小和"></a>2.2 下降路径最小和</h2><p>给你一个 <code>n x n</code> 的 <strong>方形</strong> 整数数组 <code>matrix</code> ，请你找出并返回通过 <code>matrix</code> 的<strong>下降路径</strong> 的 <strong>最小和</strong> 。</p><p><strong>下降路径</strong> 可以从第一行中的任何元素开始，并从每一行中选择一个元素。<br>在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。</p><p>具体来说，位置 <code>(row, col)</code> 的下一个元素应当是 <code>(row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者 <code>(row + 1, col + 1)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[6,5,4]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：13<br>解释：下面是两条和最小的下降路径，用加粗+斜体标注：<br><span class="hljs-comment">[<span class="hljs-comment">[2,1,3]</span>,      <span class="hljs-comment">[<span class="hljs-comment">[2,1,3]</span>,</span></span><br><span class="hljs-comment"><span class="hljs-comment"> <span class="hljs-comment">[6,5,4]</span>,       <span class="hljs-comment">[6,5,4]</span>,</span></span><br><span class="hljs-comment"><span class="hljs-comment"> <span class="hljs-comment">[7,8,9]</span>]</span>       <span class="hljs-comment">[7,8,9]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[-19,57],[-40,-5]]</span><br>输出：<span class="hljs-number">-59</span><br>解释：下面是一条和最小的下降路径，用加粗+斜体标注：<br><span class="hljs-string">[[-19,57],</span><br><span class="hljs-string"> [-40,-5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[-48]]</span><br>输出：<span class="hljs-number">-48</span><br></code></pre></td></tr></table></figure><p> **链接:</p><p>**<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">https://leetcode-cn.com/problems/minimum-falling-path-sum/</a></p><p><strong>提示：</strong></p><ul><li><code>n == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minFallingPathSum</span>(<span class="hljs-params">self, matrix</span>):</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                    matrix[i][<span class="hljs-number">0</span>] += <span class="hljs-built_in">min</span>(matrix[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],matrix[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">elif</span> j == <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>:<br>                    matrix[i][-<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(matrix[i-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>],matrix[i-<span class="hljs-number">1</span>][-<span class="hljs-number">2</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    matrix[i][j] += <span class="hljs-built_in">min</span>(matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],matrix[i-<span class="hljs-number">1</span>][j],matrix[i-<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(matrix[-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="2-3-不同路径-I"><a href="#2-3-不同路径-I" class="headerlink" title="2.3 不同路径 I"></a>2.3 不同路径 I</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。<br>机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/robot_maze.png" srcset="/img/loading.gif" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">7</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="2-4-不同路径-II"><a href="#2-4-不同路径-II" class="headerlink" title="2.4 不同路径 II"></a>2.4 不同路径 II</h2><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/unique-paths-ii/">https://leetcode-cn.com/problems/unique-paths-ii/</a></p><p><strong>描述:</strong><br>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/robot_maze-16333302399772.png" srcset="/img/loading.gif" alt="img"></p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/robot1.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：obstacleGrid = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">3</span>x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 <span class="hljs-number">2</span> 条不同的路径：<br><span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/robot2.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniquePathsWithObstacles</span>(<span class="hljs-params">self, obstacleGrid</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(obstacleGrid) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(obstacleGrid)):<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>                obstacleGrid[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                obstacleGrid[i][<span class="hljs-number">0</span>] = obstacleGrid[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>:<br>                obstacleGrid[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                obstacleGrid[<span class="hljs-number">0</span>][j] = obstacleGrid[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(obstacleGrid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span>:<br>                    obstacleGrid[i][j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    obstacleGrid[i][j] = obstacleGrid[i-<span class="hljs-number">1</span>][j] + obstacleGrid[i][j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> obstacleGrid[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="2-5-杨辉三角"><a href="#2-5-杨辉三角" class="headerlink" title="2.5 杨辉三角"></a>2.5 杨辉三角</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle/">https://leetcode-cn.com/problems/pascals-triangle/</a></p><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1626927345-DZmfxB-PascalTriangleAnimated2.gif" srcset="/img/loading.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: numRows = 5<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[1,3,3,1]</span>,<span class="hljs-comment">[1,4,6,4,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: numRows = <span class="hljs-number">1</span><br>输出: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate</span>(<span class="hljs-params">self, numRows</span>):</span><br>        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> [[<span class="hljs-number">1</span>]]<br>        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> [[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>        dp = [<span class="hljs-literal">None</span>]*numRows<br>        dp[<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>]<br>        dp[<span class="hljs-number">1</span>] = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,numRows):<br>            dp[i] = [<span class="hljs-number">0</span>]*(i+<span class="hljs-number">1</span>)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            dp[i][-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i):<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">return</span> dp<br></code></pre></td></tr></table></figure><h2 id="2-6-三角形最小路径和"><a href="#2-6-三角形最小路径和" class="headerlink" title="2.6 三角形最小路径和"></a>2.6 三角形最小路径和</h2><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<br><strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。<br>也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br> <span class="hljs-number"> 3 </span>4<br><span class="hljs-number"> 6 </span>5 7<br>4<span class="hljs-number"> 1 </span>8 3<br>自顶向下的最小路径和为 11（即，2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>= 11）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：triangle = <span class="hljs-string">[[-10]]</span><br>输出：<span class="hljs-number">-10</span><br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/triangle/">https://leetcode-cn.com/problems/triangle/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= triangle.length &lt;= 200</code></li><li><code>triangle[0].length == 1</code></li><li><code>triangle[i].length == triangle[i - 1].length + 1</code></li><li><code>-104 &lt;= triangle[i][j] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimumTotal</span>(<span class="hljs-params">self, triangle</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(triangle) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(triangle)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(triangle[i])):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                    triangle[i][<span class="hljs-number">0</span>] += triangle[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">elif</span> j == <span class="hljs-built_in">len</span>(triangle[i])-<span class="hljs-number">1</span>:<br>                    triangle[i][-<span class="hljs-number">1</span>] += triangle[i-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    triangle[i][j] += <span class="hljs-built_in">min</span>(triangle[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],triangle[i-<span class="hljs-number">1</span>][j])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(triangle[-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="2-7-摆动序列"><a href="#2-7-摆动序列" class="headerlink" title="2.7 摆动序列"></a>2.7 摆动序列</h2><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong><br>第一个差（如果存在的话）可能是正数或负数。<br>仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度完成此题?</p><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wiggleMaxLengthByDP</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            sub = nums[i] - nums[i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> sub &gt; <span class="hljs-number">0</span>:<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">elif</span> sub &lt; <span class="hljs-number">0</span>:<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    nums = [<span class="hljs-number">1</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>]<br>    s = Solution()<br>    print(s.wiggleMaxLengthByDP(nums))<br></code></pre></td></tr></table></figure><h2 id="2-8-单词拆分"><a href="#2-8-单词拆分" class="headerlink" title="2.8 单词拆分"></a>2.8 单词拆分</h2><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p><strong>说明：</strong></p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;applepenapple&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;applepenapple&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;apple pen apple&quot;</span>。<br>     注意你可以重复使用字典中的单词。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;catsandog&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordBreak</span>(<span class="hljs-params">self, s, wordDict</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        strList = <span class="hljs-built_in">list</span>(s)<br>        dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">len</span>(s))<br>        <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> wordDict:<br>            dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;&#x27;</span>.join(strList[:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">in</span> wordDict:<br>                dp[i] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> dp[j] == <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;&#x27;</span>.join(strList[j+<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">in</span> wordDict:<br>                    dp[i] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.wordBreak(<span class="hljs-string">&quot;applepenapple&quot;</span>,[<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;pen&quot;</span>]))<br></code></pre></td></tr></table></figure><h1 id="3-子数组问题"><a href="#3-子数组问题" class="headerlink" title="3. 子数组问题"></a>3. 子数组问题</h1><h2 id="3-1-子数组最大和"><a href="#3-1-子数组最大和" class="headerlink" title="3.1 子数组最大和"></a>3.1 子数组最大和</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-100000</span>]<br>输出：<span class="hljs-string">-100000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        maxSum = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            nums[i] = <span class="hljs-built_in">max</span>(nums[i],nums[i-<span class="hljs-number">1</span>]+nums[i])<br>            <span class="hljs-keyword">if</span> nums[i] &gt; maxSum:<br>                maxSum = nums[i]<br>        <span class="hljs-keyword">return</span> maxSum<br></code></pre></td></tr></table></figure><h2 id="3-2-环形子数组最大和"><a href="#3-2-环形子数组最大和" class="headerlink" title="3.2 环形子数组最大和"></a>3.2 环形子数组最大和</h2><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">https://leetcode-cn.com/problems/maximum-sum-circular-subarray/</a></p><p>给定一个由整数数组 <code>A</code> 表示的**环形数组 <code>C</code>**，求 <code>**C**</code> 的非空子数组的最大可能和。</p><p>在此处，<em>环形数组</em>意味着数组的末端将会与开头相连呈环状。（形式上，当<code>0 &lt;= i &lt; A.length</code> 时 <code>C[i] = A[i]</code>，且当 <code>i &gt;= 0</code> 时 <code>C[i+A.length] = C[i]</code>）</p><p>此外，子数组最多只能包含固定缓冲区 <code>A</code> 中的每个元素一次。（形式上，对于子数组 <code>C[i], C[i+1], ..., C[j]</code>，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % A.length = k2 % A.length</code>）</p><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,-2,3,-2]</span><br>输出：<span class="hljs-number">3</span><br>解释：从子数组 <span class="hljs-selector-attr">[3]</span> 得到最大和 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<span class="hljs-comment">[5,-3,5]</span><br>输出：10<br>解释：从子数组 <span class="hljs-comment">[5,5]</span> 得到最大和 5 + 5 = 10<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：[3,<span class="hljs-string">-1</span>,2,<span class="hljs-string">-1</span>]<br>输出：4<br>解释：从子数组 [2,<span class="hljs-string">-1</span>,3] 得到最大和 2 + (<span class="hljs-string">-1</span>) + 3 = 4<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,-2,2,-3]</span><br>输出：<span class="hljs-number">3</span><br>解释：从子数组 <span class="hljs-selector-attr">[3]</span> 和 <span class="hljs-selector-attr">[3,-2,2]</span> 都可以得到最大和 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：[<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br>解释：从子数组 [<span class="hljs-string">-1</span>] 得到最大和 <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>-30000 &lt;= A[i] &lt;= 30000</code></li><li><code>1 &lt;= A.length &lt;= 30000</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubarraySumCircular</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        dp1 = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        dp2 = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        maxSum1 = minSum = <span class="hljs-built_in">sum</span> = dp1[<span class="hljs-number">0</span>] = dp2[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            dp1[i] = <span class="hljs-built_in">max</span>(dp1[i-<span class="hljs-number">1</span>]+nums[i],nums[i])<br>            maxSum1 = <span class="hljs-built_in">max</span>(dp1[i], maxSum1)<br><br>            <span class="hljs-built_in">sum</span> += nums[i]<br>            dp2[i] = <span class="hljs-built_in">min</span>(dp2[i-<span class="hljs-number">1</span>]+nums[i],nums[i])<br>            minSum = <span class="hljs-built_in">min</span>(dp2[i], minSum)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> == minSum:<br>            <span class="hljs-keyword">return</span> maxSum1<br>        maxSum2 = <span class="hljs-built_in">sum</span> - minSum<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxSum1,maxSum2)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.maxSubarraySumCircular([-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><h2 id="3-3-乘积最大子数组"><a href="#3-3-乘积最大子数组" class="headerlink" title="3.3 乘积最大子数组"></a>3.3 乘积最大子数组</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,3,-2,4]</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: [<span class="hljs-string">-2</span>,0,<span class="hljs-string">-1</span>]<br>输出: 0<br>解释: 结果不能为 2, 因为 [<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>] 不是子数组。<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProduct</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        dpMax = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        dpMin = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        dpMax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        dpMin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        maxMulti = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            dpMin[i] = <span class="hljs-built_in">min</span>(nums[i] * dpMin[i-<span class="hljs-number">1</span>], nums[i] * dpMax[i-<span class="hljs-number">1</span>], nums[i])<br>            dpMax[i] = <span class="hljs-built_in">max</span>(nums[i] * dpMax[i-<span class="hljs-number">1</span>], nums[i] * dpMin[i-<span class="hljs-number">1</span>], nums[i])<br>            maxMulti = <span class="hljs-built_in">max</span>(dpMax[i], maxMulti)<br>        print(dpMin,dpMax)<br>        <span class="hljs-keyword">return</span> maxMulti<br></code></pre></td></tr></table></figure><h2 id="3-4-乘积为正的最长子串长度"><a href="#3-4-乘积为正的最长子串长度" class="headerlink" title="3.4 乘积为正的最长子串长度"></a>3.4 乘积为正的最长子串长度</h2><p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/</a></p><p>给你一个整数数组 <code>nums</code> ，请你求出乘积为正数的最长子数组的长度。</p><p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p><p>请你返回乘积为正数的最长子数组长度。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,4]<br>输出：4<br>解释：数组本身乘积就是正数，值为 24 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [0,1,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-4</span>]<br>输出：3<br>解释：最长乘积为正数的子数组为 [1,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>] ，乘积为 6 。<br>注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,0,1]<br>输出：2<br>解释：乘积为正数的最长子数组是 [<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>] 或者 [<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [-1,2]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,5</span>,-<span class="hljs-number">6,4,0,10</span>]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMaxLen</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &gt;=<span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        positiveDP = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        negativeDP = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>            positiveDP[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            negativeDP[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>:<br>            positiveDP[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            negativeDP[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            positiveDP[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            negativeDP[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        longestLne = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">0</span>:<br>                positiveDP[i] = <span class="hljs-number">0</span><br>                negativeDP[i] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">elif</span> nums[i] &gt; <span class="hljs-number">0</span>:<br>                positiveDP[i] = positiveDP[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> negativeDP[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                    negativeDP[i] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    negativeDP[i] = negativeDP[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                negativeDP[i] = positiveDP[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> negativeDP[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                    positiveDP[i] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    positiveDP[i] = negativeDP[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>            longestLne = <span class="hljs-built_in">max</span>(longestLne,positiveDP[i])<br>        <span class="hljs-keyword">return</span> longestLne<br><br></code></pre></td></tr></table></figure><h2 id="3-5-最长递增子序列"><a href="#3-5-最长递增子序列" class="headerlink" title="3.5 最长递增子序列"></a>3.5 最长递增子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。<br>例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p> <strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLIS</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>        dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><h2 id="3-6-摆动序列"><a href="#3-6-摆动序列" class="headerlink" title="3.6 摆动序列"></a>3.6 摆动序列</h2><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong><br>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>解:</strong></p><p>可贪心可动态规划</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wiggleMaxLength</span>(<span class="hljs-params">self, nums</span>):</span><br>        dp = [[<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i-<span class="hljs-number">1</span>]:<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">elif</span> nums[i] &lt; nums[i-<span class="hljs-number">1</span>]:<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="3-7-等差数列划分"><a href="#3-7-等差数列划分" class="headerlink" title="3.7 等差数列划分"></a>3.7 等差数列划分</h2><p><strong>描述:</strong><br>如果一个数列 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><ul><li>例如，<code>[1,3,5,7,9]</code>、<code>[7,7,7,7]</code> 和 <code>[3,-1,-5,-9]</code> 都是等差数列。</li></ul><p>给你一个整数数组 <code>nums</code> ，返回数组 <code>nums</code> 中所有为等差数组的 <strong>子数组</strong> 个数。</p><p><strong>子数组</strong> 是数组中的一个连续序列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3,4]</span><br>输出：3<br>解释：nums 中有三个子等差数组：<span class="hljs-comment">[1, 2, 3]</span>、<span class="hljs-comment">[2, 3, 4]</span> 和 <span class="hljs-comment">[1,2,3,4]</span> 自身。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/arithmetic-slices/">https://leetcode-cn.com/problems/arithmetic-slices/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numberOfArithmeticSlices</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        output = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] - nums[i-<span class="hljs-number">1</span>] == nums[i+<span class="hljs-number">1</span>] - nums[i]:<br>                dp[i] = dp[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                output += dp[i]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="4-回文串与编辑问题"><a href="#4-回文串与编辑问题" class="headerlink" title="4. 回文串与编辑问题"></a>4. 回文串与编辑问题</h1><h2 id="4-1-最长回文子串"><a href="#4-1-最长回文子串" class="headerlink" title="4.1 最长回文子串"></a>4.1 最长回文子串</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>与<a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a>类似</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;a&quot;</span><br>输出：<span class="hljs-comment">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aa&quot;</span><br>输出：<span class="hljs-string">&quot;aa&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-comment"># 双指针中心扩散法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindromeByCD</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> s<br>        self.longestStr = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> center <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>):<br>            self.centralDiffusion(s,center,center)<br>            self.centralDiffusion(s,center,center + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> self.longestStr<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">centralDiffusion</span>(<span class="hljs-params">self,s,leftP,rightP</span>):</span><br>        <span class="hljs-keyword">while</span> leftP &gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> rightP &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[leftP] != s[rightP]:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> rightP - leftP +<span class="hljs-number">1</span> &gt; <span class="hljs-built_in">len</span>(self.longestStr):<br>                self.longestStr = s[leftP:rightP+<span class="hljs-number">1</span>]<br>            leftP  -= <span class="hljs-number">1</span><br>            rightP += <span class="hljs-number">1</span><br>            <br>    <span class="hljs-comment"># 动态规划</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindromeByDP</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> s<br>        longestLen = <span class="hljs-number">1</span><br>        leftP = <span class="hljs-number">0</span><br>        rightP = <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> col &lt; row:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> col == row:<br>                    dp[row][col] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">elif</span> s[col] == s[row] <span class="hljs-keyword">and</span> (col - row == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> dp[row+<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>]):<br>                    dp[row][col] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[row][col] = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">if</span> dp[row][col] == <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> col - row + <span class="hljs-number">1</span> &gt; longestLen:<br>                    longestLen = col - row + <span class="hljs-number">1</span><br>                    leftP = row<br>                    rightP = col<br>        <span class="hljs-keyword">return</span> s[leftP:rightP+<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    s.longestPalindromeByDP(<span class="hljs-string">&quot;aa&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="4-2-最长回文子序列"><a href="#4-2-最长回文子序列" class="headerlink" title="4.2 最长回文子序列"></a>4.2 最长回文子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">https://leetcode-cn.com/problems/longest-palindromic-subsequence/</a></p><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;bbbab&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：一个可能的最长回文子序列为 <span class="hljs-string">&quot;bbbb&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：一个可能的最长回文子序列为 <span class="hljs-string">&quot;bb&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li><li>与16题不同点在于，16题的子串必须连续，本题则不需要</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindromeSubseq</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            dp[i][i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> s[col] == s[row]:<br>                    dp[row][col] = dp[row+<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>] + <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[row][col] = <span class="hljs-built_in">max</span>(dp[row+<span class="hljs-number">1</span>][col], dp[row][col-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="4-3-最长公共子序列"><a href="#4-3-最长公共子序列" class="headerlink" title="4.3 最长公共子序列"></a>4.3 最长公共子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：最长公共子序列是 <span class="hljs-string">&quot;abc&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;def&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：两个字符串没有公共子序列，返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span>(<span class="hljs-params">self, text1: <span class="hljs-built_in">str</span>, text2: <span class="hljs-built_in">str</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(text1) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> text2 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i-<span class="hljs-number">1</span>] == text2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="4-4-编辑距离"><a href="#4-4-编辑距离" class="headerlink" title="4.4 编辑距离"></a>4.4 编辑距离</h2><p><a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">&#x27;t&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">&#x27;i&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">&#x27;u&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> word1 == word2:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> word1 == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> word2 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(word1) + <span class="hljs-built_in">len</span>(word2)<br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>):<br>            dp[i][<span class="hljs-number">0</span>] = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">0</span>][j] = j<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> word1[i-<span class="hljs-number">1</span>] == word2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) +<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="5-股票问题"><a href="#5-股票问题" class="headerlink" title="5. 股票问题"></a>5. 股票问题</h1><h2 id="5-1-买卖股票的最佳时机I"><a href="#5-1-买卖股票的最佳时机I" class="headerlink" title="5.1 买卖股票的最佳时机I"></a>5.1 买卖股票的最佳时机I</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(prices)<br>        dp[<span class="hljs-number">0</span>] = prices[<span class="hljs-number">0</span>]<br>        maxValue = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>], prices[i])<br>            maxValue = <span class="hljs-built_in">max</span>(maxValue, prices[i] - dp[i])<br>        <span class="hljs-keyword">return</span> maxValue<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfitByGreedy</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        maxProfit = <span class="hljs-number">0</span><br>        minValue = prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prices)):<br>            minValue = <span class="hljs-built_in">min</span>(minValue, prices[i])<br>            maxProfit = <span class="hljs-built_in">max</span>(maxProfit, prices[i]-minValue)<br>        <span class="hljs-keyword">return</span> maxProfit<br></code></pre></td></tr></table></figure><h2 id="5-2-买卖股票的最佳时机II"><a href="#5-2-买卖股票的最佳时机II" class="headerlink" title="5.2 买卖股票的最佳时机II"></a>5.2 买卖股票的最佳时机II</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><blockquote><p><strong>注意：</strong><br>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [1,2,3,4,5]<br>输出: 4<br>解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: prices = [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfitByGreedy</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        maxProfit = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            profit = prices[i] - prices[i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> profit &gt; <span class="hljs-number">0</span>:<br>                maxProfit += profit<br>        <span class="hljs-keyword">return</span> maxProfit<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfitByDP</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(prices)<br>        dp[<span class="hljs-number">0</span>] = prices[<span class="hljs-number">0</span>]<br>        maxValue = <span class="hljs-number">0</span><br>        maxProfit = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>], prices[i])<br>            <span class="hljs-keyword">if</span> prices[i] - dp[i] &lt; maxValue:<br>                maxProfit += maxValue<br>                dp[i] = prices[i]<br>                maxValue = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                maxValue = prices[i] - dp[i]<br>        maxProfit += maxValue<br>        <span class="hljs-keyword">return</span> maxProfit<br></code></pre></td></tr></table></figure><h2 id="5-3-买卖股票的最佳时机III"><a href="#5-3-买卖股票的最佳时机III" class="headerlink" title="5.3 买卖股票的最佳时机III"></a>5.3 买卖股票的最佳时机III</h2><p><strong>描述:</strong><br>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,0,2]</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></code></pre></td></tr></table></figure><p><strong>链接:</strong></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prices))] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[<span class="hljs-number">1</span>])<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+prices[<span class="hljs-number">1</span>])<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">2</span>]-prices[i])<br>            dp[<span class="hljs-number">1</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]+prices[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="5-4-买卖股票的最佳时机IV"><a href="#5-4-买卖股票的最佳时机IV" class="headerlink" title="5.4 买卖股票的最佳时机IV"></a>5.4 买卖股票的最佳时机IV</h2><p><strong>描述:</strong><br>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。<br>如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><blockquote><p><strong>注意：</strong><br>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p></blockquote><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：prices = <span class="hljs-comment">[1, 3, 2, 8, 4, 9]</span>, fee = 2<br>输出：8<br>解释：能够达到的最大利润:  <br>在此处买入 prices<span class="hljs-comment">[0]</span> = 1<br>在此处卖出 prices<span class="hljs-comment">[3]</span> = 8<br>在此处买入 prices<span class="hljs-comment">[4]</span> = 4<br>在此处卖出 prices<span class="hljs-comment">[5]</span> = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">prices</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">fee</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5 * 104</code></li><li><code>1 &lt;= prices[i] &lt; 5 * 104</code></li><li><code>0 &lt;= fee &lt; 5 * 104</code></li></ul><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices, fee</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prices))]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]-prices[i])<br>            dp[<span class="hljs-number">1</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>],dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]+prices[i]-fee)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h1 id="6-背包问题"><a href="#6-背包问题" class="headerlink" title="6. 背包问题"></a>6. 背包问题</h1><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009155910693.png" srcset="/img/loading.gif" alt="背包问题分类"></p><h2 id="6-1-0-1背包问题"><a href="#6-1-0-1背包问题" class="headerlink" title="6.1 0/1背包问题"></a>6.1 0/1背包问题</h2><h3 id="6-1-0-原型"><a href="#6-1-0-原型" class="headerlink" title="6.1.0 原型"></a>6.1.0 原型</h3><h4 id="6-1-0-1-题目描述"><a href="#6-1-0-1-题目描述" class="headerlink" title="6.1.0.1 题目描述"></a>6.1.0.1 题目描述</h4><p>有N件物品和一个最多能被重量为W 的背包。<br>第i件物品的重量是weight[i]，得到的价值是value[i] 。<br><strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>**例如:**背包最大重量为4。<br>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><h4 id="6-1-0-2-题目分析"><a href="#6-1-0-2-题目分析" class="headerlink" title="6.1.0.2 题目分析"></a>6.1.0.2 题目分析</h4><ol><li><p><strong>确定dp数组以及下标的含义</strong><br>使用二维数组，即:<br><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。<br><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009160154930.png" srcset="/img/loading.gif" alt="image-20211009160154930"></p></li><li><p><strong>确定递推公式</strong><br>两种情况:</p></li></ol><ul><li><p><strong>不放物品i</strong>：<br>由 dp[i - 1][j] 推出，即背包容量为 j ，里面不放物品 i 的最大价值，此时 dp[i][j] 就是 dp[i - 1][j] 。<br>(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</p></li><li><p><strong>放物品i</strong>：<br>由 dp[i - 1][j - weight[i]] 推出， dp[i - 1][j - weight[i]] 为背包容量为 j - weight[i] 的时候不放物品i的最大价值，那么 dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</p><p>所以递归公式：<br>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</p></li></ul><ol start="3"><li><p><strong>dp数组如何初始化</strong></p><ul><li><p>首先从dp[i][j]的定义出发<br>如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。</p></li><li><p>状态转移方程 :dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])<br>可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p></li></ul><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009160811954.png" srcset="/img/loading.gif" alt="image-20211009160811954"></p></li><li><p><strong>确定遍历顺序</strong><br>递推方向如下</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009161003391.png" srcset="/img/loading.gif" alt="image-20211009161003391"><br>所以：<br>先遍历物品还是先遍历背包重量其实都可以<br>但是先遍历物品更好理解</p></li><li><p><strong>举例推导dp数组</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009161539532.png" srcset="/img/loading.gif" alt="image-20211009161539532"></p></li></ol><h4 id="6-1-0-3-代码实现"><a href="#6-1-0-3-代码实现" class="headerlink" title="6.1.0.3 代码实现"></a>6.1.0.3 代码实现</h4><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zero_oneBackpackProblem</span>(<span class="hljs-params">self, weight, value, volume</span>):</span><br>        dp = [<span class="hljs-number">0</span>] * (volume + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(dp)):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[<span class="hljs-number">0</span>]:<br>                dp[j] = value[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>            print(dp)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(volume,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> weight[i] &gt; j:<br>                    <span class="hljs-keyword">break</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-weight[i]]+value[i])<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    wight = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>    value = [<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]<br>    volume = <span class="hljs-number">4</span><br>    s = Solution()<br>    print(s.zero_oneBackpackProblem(wight,value,volume))<br></code></pre></td></tr></table></figure><h2 id="6-2-完全背包问题"><a href="#6-2-完全背包问题" class="headerlink" title="6.2 完全背包问题"></a>6.2 完全背包问题</h2><h3 id="6-2-0-原型"><a href="#6-2-0-原型" class="headerlink" title="6.2.0 原型"></a>6.2.0 原型</h3><h4 id="6-2-0-1-题目描述"><a href="#6-2-0-1-题目描述" class="headerlink" title="6.2.0.1 题目描述"></a>6.2.0.1 题目描述</h4><p>有N件物品和一个最多能背重量为W的背包。<br>第i件物品的重量是weight[i]，得到的价值是value[i] 。<br><strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><blockquote><p>完全背包和01背包问题唯一不同的地方就是: 每种物品有无限件</p></blockquote><p><strong>例如:</strong><br>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p><strong>每件商品都有无限个！</strong></p><p>问背包能背的物品最大价值是多少？</p><h4 id="6-2-0-2-题目分析"><a href="#6-2-0-2-题目分析" class="headerlink" title="6.2.0.2 题目分析"></a>6.2.0.2 题目分析</h4><p>和01背包问题不同的地方就是: <strong>每种物品有无限件</strong><br>这导致了在实现上有两点不同:</p><ul><li><p>dp初始化不同</p><ul><li>0-1背包的物体只能使用一次，所以初始化第一排(物体0)时：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dp = [<span class="hljs-number">0</span>] * (volume + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(weight[<span class="hljs-number">0</span>],<span class="hljs-built_in">len</span>(dp)):<br>dp[j] = value[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>​    只需要装入一次，然后价值就不变了，都是value[0]</p><ul><li><p>完全背包的物体可以多次使用，因此初始化第一排(物体0)时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dp = [<span class="hljs-number">0</span>] * (volume + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(weight[<span class="hljs-number">0</span>],<span class="hljs-built_in">len</span>(dp)):<br>dp[j] = dp[j-weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>要考虑多次装入，更新价值</p></li></ul></li><li><p>dp迭代顺序不同</p><ul><li><p>01背包物体只能使用一次，迭代时为了保证不重复装入，需要逆序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(volume,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> weight[i] &gt; j:<br>            <span class="hljs-keyword">break</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-weight[i]]+value[i])<br></code></pre></td></tr></table></figure></li><li><p>完全背包的物体可以多次使，正序遍历即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(wight[i],volume+<span class="hljs-number">1</span>):<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-weight[i]]+value[i])<br></code></pre></td></tr></table></figure><p>剩下的就完全一样了。</p></li></ul></li></ul><h4 id="6-2-0-3-代码实现"><a href="#6-2-0-3-代码实现" class="headerlink" title="6.2.0.3 代码实现"></a>6.2.0.3 代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">completeBackpack</span>(<span class="hljs-params">self, weight, value, volume</span>):</span><br>        dp = [<span class="hljs-number">0</span>] * (volume + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(weight[<span class="hljs-number">0</span>],<span class="hljs-built_in">len</span>(dp)):<br>            dp[j] = dp[j-weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>            print(dp)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(wight[i],volume+<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-weight[i]]+value[i])<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    wight = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>    value = [<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]<br>    volume = <span class="hljs-number">4</span><br>    s = Solution()<br>    print(s.completeBackpack(wight,value,volume))<br></code></pre></td></tr></table></figure><h3 id="6-2-1-零钱兑换-I"><a href="#6-2-1-零钱兑换-I" class="headerlink" title="6.2.1 零钱兑换 I"></a>6.2.1 零钱兑换 I</h3><p><a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。<br>如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">11</span><br>输出：<span class="hljs-number">3</span> <br>解释：<span class="hljs-number">11</span> = <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">2</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coinChange</span>(<span class="hljs-params">self, coins, amount</span>):</span><br>        <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(coins) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        dp = [amount+<span class="hljs-number">1</span>] * (amount+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(coins)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(coins[i],amount+<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> dp[-<span class="hljs-number">1</span>] == amount+<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="6-2-2-零钱兑换-II"><a href="#6-2-2-零钱兑换-II" class="headerlink" title="6.2.2 零钱兑换 II"></a>6.2.2 零钱兑换 II</h3><p><a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币<strong>组合数</strong>。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2<span class="hljs-string">+2</span><span class="hljs-string">+1</span><br>5=2<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br>5=1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">amount</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">coins</span> = [<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">0</span><br>解释：只用面额 <span class="hljs-number">2</span> 的硬币不能凑成总金额 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">amount</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">coins</span> = [<span class="hljs-number">10</span>] <br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span>(<span class="hljs-params">self, amount, coins</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(coins) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> amount == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>] * (amount+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(coin,amount+<span class="hljs-number">1</span>):<br>                dp[j] += dp[j-coin]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="6-2-3-组合总和-Ⅳ"><a href="#6-2-3-组合总和-Ⅳ" class="headerlink" title="6.2.3 组合总和 Ⅳ"></a>6.2.3 组合总和 Ⅳ</h3><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">https://leetcode-cn.com/problems/combination-sum-iv/</a></p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。<br>请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">9</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><p><strong>进阶：</strong><br>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><p><strong>解:</strong></p><p>与 <strong>6.2.2 零钱兑换</strong> 同类型，完全背包下：</p><ul><li>求组和：背包在内，物品在外</li><li>求排列：背包在外，物品在内</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combinationSum4</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        dp = [<span class="hljs-number">0</span>] * (target+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,target+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> num &lt;= i:<br>                    dp[i] += dp[i - num]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="6-2-4-整数拆分"><a href="#6-2-4-整数拆分" class="headerlink" title="6.2.4 整数拆分"></a>6.2.4 整数拆分</h3><p><a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p><p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。<br>返回你可以获得的最大乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: 10<br>输出: 36<br>解释:<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+ 4,<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 4 </span>= 36。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong> 你可以假设 <em>n</em> 不小于 2 且不大于 58。</p><p><strong>解:</strong></p><p><strong>状态定义：</strong><br>dp[i]： n=i 时的最大乘积</p><p><strong>状态转移：</strong><br>遍历1~i之间所有的因子j,则i可以被拆为 j 与 i-j两数的和, 其中i-j假设也可以被拆分，则取dp[i-j]，遍历j，取最大的dp[i]<br>dp[i] = max(dp[i],j*(i-j), dp[j]*(i-j))</p><p><strong>边界条件：</strong><br>dp[0]=dp[1]=0<br><strong>时间：</strong>O(n)<br><strong>空间：</strong>O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">integerBreak</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i],j*(i-j), dp[j]*(i-j))<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="6-2-5-完全平方数"><a href="#6-2-5-完全平方数" class="headerlink" title="6.2.5 完全平方数"></a>6.2.5 完全平方数</h1><p><a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 12<br>输出：3 <br>解释：12 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+ 4<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">13</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">13</span> = <span class="hljs-number">4</span> + <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numSquares</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        dp = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-comment"># dp[0] = 0 无意义，只是为了方便记录特殊情况:</span><br>        <span class="hljs-comment"># n本身就是完全平方数，dp[n] = min(dp[n], dp[n - n] + 1) = 1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n): <span class="hljs-comment"># 遍历物品</span><br>            <span class="hljs-keyword">if</span> i * i &gt; n:<br>                <span class="hljs-keyword">break</span><br>            num = i * i<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num, n + <span class="hljs-number">1</span>): <span class="hljs-comment"># 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - num] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h1 id="7-复合问题"><a href="#7-复合问题" class="headerlink" title="7. 复合问题"></a>7. 复合问题</h1><h2 id="7-1-接雨水"><a href="#7-1-接雨水" class="headerlink" title="7.1 接雨水"></a>7.1 接雨水</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/rainwatertrap.png" srcset="/img/loading.gif" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/trapping-rain-water/">https://leetcode-cn.com/problems/trapping-rain-water/</a></p><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trap</span>(<span class="hljs-params">self, height</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(height) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(height))] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        lenth = <span class="hljs-built_in">len</span>(height)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,lenth):<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>],height[i-<span class="hljs-number">1</span>])<br>            dp[<span class="hljs-number">1</span>][lenth-<span class="hljs-number">1</span>-i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][lenth-i],height[lenth-i])<br>        output = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,lenth-<span class="hljs-number">1</span>):<br>            rain = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][i],dp[<span class="hljs-number">1</span>][i]) - height[i]<br>            <span class="hljs-keyword">if</span> rain &gt; <span class="hljs-number">0</span>:<br>                output += rain<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h2 id="7-2-不同的二叉搜索树"><a href="#7-2-不同的二叉搜索树" class="headerlink" title="7.2 不同的二叉搜索树"></a>7.2 不同的二叉搜索树</h2><p><strong>描述:</strong><br>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？<br>返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/uniquebstn3.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> <strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><p><strong>解：</strong><br>卡特兰公式<br>明确：<br>二叉搜索树序列的个数与其值无关，只与区间长度有关</p><p>例如：我们在计算序列长度为 4 的二叉搜索树[1 , 2 , 3 , 4 ]。<br>假设以 1 作为根结点，则左子树序列长度为 0 ，右子树序列长度为 3 ，而我们之前就已经计算过序列长度为 3 的总个数了，没有必要再算一次，且当前状态受上一个状态的影响，因此我们就可以从这里入手，进行下一步优化——动态规划。</p><p>定义两个函数：</p><ul><li><p>G(n)：<br>长度为 n 的序列能构成的不同二叉搜索树的个数</p></li><li><p>F(i,n)：<br>以 i 为根、序列长度为 n 的不同二叉搜索树的个数(1≤i≤n)。</p></li></ul><p>首先，根据方法一的思路可以知道，对于不同的二叉搜索树的总数G(n) ，是所有F(i,n) 之和：</p><p>$G(n)=\displaystyle\sum^n_{i=0} F(i,n)$</p><p>对于边界情况，当序列长度为$ 1 $( 只有根 ) 或为 0 ( 空树 ) 时，只有一种情况，即：</p><p>G(0) = 1，G(1) = 1</p><p>举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 [1, 2, 3, 4, 5, 6, 7]，我们需要从左子序列 [1, 2][1,2] 构建左子树，从右子序列 [4, 5, 6, 7]构建右子树，然后将它们组合（即笛卡尔积）。</p><p>对于这个例子，不同二叉搜索树的个数为 F(3, 7)。<br>我们将 [1,2] 构建不同左子树的数量表示为 G(2), 从 [4, 5, 6, 7]构建不同右子树的数量表示为 G(4)，注意到G(n) 和序列的内容无关，只和序列的长度有关。<br>于是，$F(3,7) = G(2) \cdot G(4)$。<br>因此，我们可以得到以下公式：</p><p>$F(i,n) = G(i-1) \cdot G(n-i)$</p><p>因此，结合上述公式可以得出递归表达式：</p><p>$G(n) = \displaystyle \sum^{n}_{i=1}{G(i-1) \cdot G(n-i)}$</p><p>于是，我们可以从小到大计算GG函数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numTrees</span>(<span class="hljs-params">self, n</span>):</span><br>        dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>):<br>                dp[i] += dp[j-<span class="hljs-number">1</span>] * dp[i-j]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="22-解码方法"><a href="#22-解码方法" class="headerlink" title="22. 解码方法"></a>22. 解码方法</h1><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">2</span><br>...<br><span class="hljs-string">&#x27;Z&#x27;</span> -&gt; <span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：它可以解码为 <span class="hljs-string">&quot;AB&quot;</span>（<span class="hljs-number">1</span> <span class="hljs-number">2</span>）或者 <span class="hljs-string">&quot;L&quot;</span>（<span class="hljs-number">12</span>）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;226&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：它可以解码为 <span class="hljs-string">&quot;BZ&quot;</span> <span class="hljs-comment">(2 26)</span>, <span class="hljs-string">&quot;VF&quot;</span> <span class="hljs-comment">(22 6)</span>, 或者 <span class="hljs-string">&quot;BBF&quot;</span> <span class="hljs-comment">(2 2 6)</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：没有字符映射到以 <span class="hljs-number">0</span> 开头的数字。<br>含有 <span class="hljs-number">0</span> 的有效映射是 <span class="hljs-string">&#x27;J&#x27;</span> -&gt; <span class="hljs-string">&quot;10&quot;</span> 和 <span class="hljs-string">&#x27;T&#x27;</span>-&gt; <span class="hljs-string">&quot;20&quot;</span> 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;06&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-string">&quot;06&quot;</span> 不能映射到 <span class="hljs-string">&quot;F&quot;</span> ，因为字符串含有前导 <span class="hljs-number">0</span>（<span class="hljs-string">&quot;6&quot;</span> 和 <span class="hljs-string">&quot;06&quot;</span> 在映射中并不等价）。<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/decode-ways/">https://leetcode-cn.com/problems/decode-ways/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DinoParkour开发文档</title>
    <link href="/2021/09/11/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"/>
    <url>/2021/09/11/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DinoParkour开发文档"><a href="#DinoParkour开发文档" class="headerlink" title="DinoParkour开发文档"></a>DinoParkour开发文档</h1><p><strong>项目信息：</strong><br>项目负责人：买烤麸烤饼<br>程序：买烤麸烤饼<br>美工：买烤麸烤饼，一周<br>音效：洛一<br>项目开发周期：2021.9.1- 2021.9.10</p><p><strong>版本信息：</strong></p><ul><li><p>v1.0  完成小恐龙跑酷的基本玩法</p></li><li><p>v1.5</p><ul><li>将操作按钮放到了屏幕两侧</li><li>解决了摄像头无法归位的BUG</li><li>重置了所有碰撞器，精细化了碰撞检测</li><li>增加了全新的翼龙模式与全新的BUG</li></ul></li><li><p>v2.0</p><ul><li>降低了翼龙的敏感度</li><li>修复了翼龙模式天空块之间会有缝隙的bug</li></ul></li></ul><h1 id="1-玩法分析"><a href="#1-玩法分析" class="headerlink" title="1. 玩法分析"></a>1. 玩法分析</h1><p><strong>游戏原型：</strong><br>chrome://dino/</p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909224440720.png" srcset="/img/loading.gif" alt="游戏原型"></p><p>该游戏是谷歌浏览器自带的一款恐龙跑酷小游戏。<br>当在无网络的情况下使用谷歌浏览器访问网站时会出现一个小恐龙，再按下空格就可以触发这个小游戏了。</p><p>在该游戏中，玩家通过键盘操控小恐龙进行跑酷，躲避各种沙漠上的障碍物来取得高分。</p><p><strong>游戏目标：</strong><br>躲过更多障碍，跑的更远以取得更高的分数</p><p><strong>得分计算：</strong><br>小恐龙存活时间就是得分</p><p><strong>玩家操作：</strong><br>玩家可以通过按钮(移动端)键盘(pc)端等方式来操控小恐龙进行跑酷。<br>可以操作的动作：</p><ul><li>下箭头：低头</li><li>上箭头：跳跃</li></ul><p><strong>失败判定：</strong><br>小恐龙碰到任何障碍物就触发游戏失败</p><h1 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h1><h2 id="2-1-游戏实体分析"><a href="#2-1-游戏实体分析" class="headerlink" title="2.1 游戏实体分析"></a>2.1 游戏实体分析</h2><h3 id="2-1-1-总分析"><a href="#2-1-1-总分析" class="headerlink" title="2.1.1 总分析"></a>2.1.1 总分析</h3><p><strong>主要实体：</strong></p><ul><li>小恐龙Dino 1个</li><li>陆地Land 动态生成</li><li>背景墙TimeRing 1个</li></ul><p>其中动态生成的陆地中应该动态生成多个障碍实体</p><p><strong>障碍实体：</strong></p><ul><li>仙人掌Cactu 共10种<ul><li>单体仙人掌 5种</li><li>双体仙人掌 3种</li><li>三体仙人掌 1种</li><li>四体仙人掌 1种</li></ul></li><li>翼龙Pterosaur 1种</li></ul><p>每种障碍实体的碰撞体积均不相同</p><p><strong>其它实体：</strong></p><ul><li>灯光Light</li><li>摄影机MainCamera</li></ul><h3 id="2-1-2-实体动画分析"><a href="#2-1-2-实体动画分析" class="headerlink" title="2.1.2 实体动画分析"></a>2.1.2 实体动画分析</h3><p>应当设计动画的实体主要是小恐龙与翼龙：</p><h4 id="2-1-2-1-小恐龙动画分析"><a href="#2-1-2-1-小恐龙动画分析" class="headerlink" title="2.1.2.1 小恐龙动画分析"></a>2.1.2.1 小恐龙动画分析</h4><p><strong>状态分析：</strong></p><ul><li>开始状态Start:0 (1帧)</li><li>奔跑状态Run:1 (2帧)</li><li>跳跃状态Jump:2 (1帧)</li><li>低头状态DownRun:3 (2帧)</li><li>死亡状态Dead:4 (1帧)</li></ul><p><strong>状态机</strong>如下图所示：<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909223752586.png" srcset="/img/loading.gif" alt="Dino状态机"></p><blockquote><p>其中:</p><ul><li>实线为可打断当前状态进行状态转换</li><li>虚线为当前状态执行完毕前不可打断</li></ul></blockquote><p><strong>需求：</strong>6张美术素材<br>小恐龙共需要6张美术素材用于制作帧动画，其中跳跃帧和开始帧可共用一张</p><h4 id="2-1-2-2-翼龙动画分析"><a href="#2-1-2-2-翼龙动画分析" class="headerlink" title="2.1.2.2 翼龙动画分析"></a>2.1.2.2 翼龙动画分析</h4><p><strong>状态分析：</strong><br>仅需要一种状态</p><ul><li>奔跑状态 2帧</li></ul><p><strong>需求：</strong>2张美术素材<br>翼龙共需要2张美术素材</p><h3 id="2-1-3-障碍实体动态生成分析"><a href="#2-1-3-障碍实体动态生成分析" class="headerlink" title="2.1.3 障碍实体动态生成分析"></a>2.1.3 障碍实体动态生成分析</h3><p>障碍实体应当动态生成在陆地实体上，而陆地实体也是动态生成的，所以这两者用预制体实现比较合适。</p><p><strong>障碍实体动态生成需求：</strong></p><ul><li>随机生成种类</li><li>随机生成个数</li><li>随机生成的障碍实体的碰撞体积要与种类相关有所变化</li></ul><p><strong>陆地实体动态生成需求：</strong></p><ul><li>同一时间游戏内应当有三个陆地实体<ul><li>正在运行的陆地实体 (1个)</li><li>准备运行的陆地实体 (2个)</li></ul></li><li>运行到指定位置自动销毁</li><li>运行到指定位置自动启动下一个陆地实体</li><li>陆地上动态生成的障碍实体数量应该在0-2之间随机</li><li>陆地上动态生成的障碍实体的位置应该是固定的<br>如果随机位置，容易挨在一起造成死局</li><li>陆地的运动速度应该随着分数的提高而提高</li></ul><h3 id="2-1-4-背景墙分析"><a href="#2-1-4-背景墙分析" class="headerlink" title="2.1.4 背景墙分析"></a>2.1.4 背景墙分析</h3><p><strong>背景墙需求：</strong></p><ul><li>是个时间环，通过转动来展示昼夜变化</li><li>时间环的转动要与灯光配合，展示昼夜光线变化</li></ul><h2 id="2-2-美术需求分析"><a href="#2-2-美术需求分析" class="headerlink" title="2.2 美术需求分析"></a>2.2 美术需求分析</h2><p><strong>美术风格：</strong><br>彩色像素风格</p><p><strong>美术需求清单：</strong>(按优先级排序)</p><ol><li>小恐龙的六张帧序列用于制作各种状态的动画</li><li>多种障碍实体(详见实体分析)<ul><li>仙人掌 十张</li><li>翼龙 两张</li></ul></li><li>陆地</li><li>背景时间环</li><li>各种UI制作</li><li>游戏LOGO</li></ol><h2 id="2-3-UI需求分析"><a href="#2-3-UI需求分析" class="headerlink" title="2.3 UI需求分析"></a>2.3 UI需求分析</h2><h3 id="2-3-1-UI需求树"><a href="#2-3-1-UI需求树" class="headerlink" title="2.3.1 UI需求树"></a>2.3.1 UI需求树</h3><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909231310761.png" srcset="/img/loading.gif" alt="UI需求树"></p><h3 id="2-3-2-细节需求"><a href="#2-3-2-细节需求" class="headerlink" title="2.3.2 细节需求"></a>2.3.2 细节需求</h3><ul><li><p>开始界面</p><ul><li>三个主要按钮需要支持键盘选择</li><li>三个主要按钮需要支持选中提示(键盘与鼠标)</li></ul></li><li><p>游戏界面</p><ul><li>当前分数需要实时刷新</li><li>最佳分数在每次开始游戏时需要读取</li></ul></li><li><p>游戏失败界面</p><ul><li>当玩家取得更高的分数时，需要弹出提示并保存新最佳分数</li></ul></li></ul><h2 id="2-4-音效分析"><a href="#2-4-音效分析" class="headerlink" title="2.4 音效分析"></a>2.4 音效分析</h2><ul><li>游戏BGM<br>8bit音乐</li><li>小恐龙音效<ul><li>跳跃音效</li><li>死亡音效</li></ul></li><li>游戏音效<ul><li>开始游戏音效</li><li>每百分音效</li><li>新分数音效</li></ul></li></ul><p>共需要8bit风格音效6段。</p><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><h2 id="3-1-工程类图"><a href="#3-1-工程类图" class="headerlink" title="3.1 工程类图"></a>3.1 工程类图</h2><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/Dino%E5%B7%A5%E7%A8%8B%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt="Dino工程类图"></p><h2 id="3-2-UI实现"><a href="#3-2-UI实现" class="headerlink" title="3.2 UI实现"></a>3.2 UI实现</h2><p><strong>开始界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160306730.png" srcset="/img/loading.gif" alt="image-20210910160306730"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910153817356.png" srcset="/img/loading.gif" alt="开始界面"></p><p><strong>关于界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160422573.png" srcset="/img/loading.gif" alt="image-20210910160422573"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910154143211.png" srcset="/img/loading.gif" alt="关于界面"></p><p><strong>游戏界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160454308.png" srcset="/img/loading.gif" alt="image-20210910160454308"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910153929870.png" srcset="/img/loading.gif" alt="游戏界面"></p><p><strong>暂停界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160519755.png" srcset="/img/loading.gif" alt="image-20210910160519755"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910154116353.png" srcset="/img/loading.gif" alt="暂停界面"></p><p><strong>失败界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160553087.png" srcset="/img/loading.gif" alt="image-20210910160553087"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910154015705.png" srcset="/img/loading.gif" alt="失败界面"></p><h2 id="3-3-技术实现亮点与难点"><a href="#3-3-技术实现亮点与难点" class="headerlink" title="3.3 技术实现亮点与难点"></a>3.3 技术实现亮点与难点</h2><h3 id="3-3-1-开始界面UI的多种响应方式"><a href="#3-3-1-开始界面UI的多种响应方式" class="headerlink" title="3.3.1 开始界面UI的多种响应方式"></a>3.3.1 开始界面UI的多种响应方式</h3><h4 id="3-3-1-1-效果描述"><a href="#3-3-1-1-效果描述" class="headerlink" title="3.3.1.1 效果描述"></a>3.3.1.1 效果描述</h4><p>根据UI需求分析中的细节部分对于开始界面UI的描述，我们可以知道，该UI需要支持三种操作方式：</p><ul><li>鼠标操作</li><li>键盘方向键操作</li><li>移动端触摸操作</li></ul><p>其中鼠标操作与键盘方向键操作时，会有一个选中的按钮变色的效果。</p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910163606363.png" srcset="/img/loading.gif" alt="image-20210910163606363"><br>当使用键盘选中about按钮或者光标落在上面时，颜色变浅。</p><p>该效果实现的难点主要在鼠标与键盘两种操作方式上，移动端的触摸输入使用普通的按钮响应函数即可</p><h4 id="3-3-1-2-键盘方向键操作"><a href="#3-3-1-2-键盘方向键操作" class="headerlink" title="3.3.1.2 键盘方向键操作"></a>3.3.1.2 键盘方向键操作</h4><p>在该操作模式下，会默认选中第一个Start Game按钮并使其变色，按上下键可以变更选中的按钮。</p><p>想要实现这种效果，我想到了使用双向循环链表，将三个按钮按顺序放入循环链表中，每次按下方向就到下一个节点的按钮，以此类推。</p><p>在C#中，可以使用LinkedList(双向链表)加一点小改动，就能成满足我们需求的双向循环链表，代码如下：</p><p><strong>初始化双向循环链表：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//循环链表，里面装的是每个按钮的背景图片组件</span><br><span class="hljs-keyword">private</span> LinkedList&lt;Image&gt; startPageBtnImg;<br><span class="hljs-comment">//当前选中的链表节点</span><br><span class="hljs-keyword">private</span> LinkedListNode&lt;Image&gt; onBtnImg;<br><span class="hljs-comment">//普通按钮背景图片精灵</span><br><span class="hljs-keyword">private</span> Sprite btnBGSprite;<br><span class="hljs-comment">//被选中的按钮背景图片精灵</span><br><span class="hljs-keyword">private</span> Sprite onBtnBGSprite;<br><br><span class="hljs-comment">// 初始化循环链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initBtnLinkedList</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    startPageBtnImg = <span class="hljs-keyword">new</span> LinkedList&lt;Image&gt;();<br>startPageBtnImg.AddLast(GameObject.Find(<span class="hljs-string">&quot;StartBtn&quot;</span>).GetComponent&lt;Image&gt;());<br>startPageBtnImg.AddLast(GameObject.Find(<span class="hljs-string">&quot;AboutBtn&quot;</span>).GetComponent&lt;Image&gt;());<br>startPageBtnImg.AddLast(GameObject.Find(<span class="hljs-string">&quot;ExitBtn&quot;</span>).GetComponent&lt;Image&gt;());<br><span class="hljs-comment">//设置当前选中的按钮为 StartBtn</span><br>onBtnImg = startPageBtnImg.First;<br>&#125;<br><br><span class="hljs-comment">// 玩家键盘输入监听函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return))<br>        OnTheBtn();<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.UpArrow))<br>        lastBtn();<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.DownArrow))<br>        nextBtn();<br>&#125;<br><br><span class="hljs-comment">// 按钮的切换函数</span><br><span class="hljs-comment">// 按下下方向箭头时选中下一个按钮并更改按钮背景</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextBtn</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    onBtnImg.Value.sprite = btnBGSprite;<span class="hljs-comment">//将当前按钮背景图改为普通背景图</span><br>    onBtnImg = onBtnImg.Next;<span class="hljs-comment">//将当前被选中按钮改为下一个按钮</span><br>    <span class="hljs-keyword">if</span> (onBtnImg == <span class="hljs-literal">null</span>)<span class="hljs-comment">//如果倒了链表尾</span><br>        onBtnImg = startPageBtnImg.First;<span class="hljs-comment">//手动循环链表</span><br>    onBtnImg.Value.sprite = onBtnBGSprite;<span class="hljs-comment">//将更改后的选中按钮的背景图改为选中背景图</span><br>&#125;<br><span class="hljs-comment">// 按下上方向箭头时选中上一个按钮并更改按钮背景</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastBtn</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    onBtnImg.Value.sprite = btnBGSprite;<br>    onBtnImg = onBtnImg.Previous;<br>    <span class="hljs-keyword">if</span> (onBtnImg == <span class="hljs-literal">null</span>)<span class="hljs-comment">//手动循环链表</span><br>        onBtnImg = startPageBtnImg.Last;<br>    onBtnImg.Value.sprite = onBtnBGSprite;<br>&#125;<br><br><span class="hljs-comment">// 按钮执行的函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTheBtn</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">string</span> btnName = onBtnImg.Value.gameObject.name;<br><span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">&quot;StartBtn&quot;</span>)<br>        OnStartGame();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">&quot;AboutBtn&quot;</span>)<br>        OnAboutGame();<br>    <span class="hljs-keyword">else</span><br>        OnExitGame();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-3-鼠标操作模式"><a href="#3-3-1-3-鼠标操作模式" class="headerlink" title="3.3.1.3 鼠标操作模式"></a>3.3.1.3 鼠标操作模式</h4><p>在鼠标操作模式下，则需要使鼠标放在哪个按钮上，哪个按钮就成为选中按钮。<br>所以实现的关键就在于检测鼠标是否在按钮上，鼠标在哪个按钮上。</p><p>这就需要用到Unity封装好的一些UI事件接口了。<br>详细内容可以看：<a href="https://mycroftcooper.github.io/2021/09/07/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/">UI事件接口</a></p><p>在这里需要用到的只有两个接口：</p><ul><li><strong>IPointerEnterHandler</strong><br>鼠标移入对象时触发响应函数</li><li><strong>IPointerExitHandler</strong><br>鼠标移出对象时触发响应函数</li></ul><p>因为这两个接口是面对对象的，使用应该写一个脚本挂到对应的按钮上去。<br>脚本代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StartPageBtnController</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerEnterHandler</span>, <span class="hljs-title">IPointerExitHandler</span><br>&#123;<br>    <span class="hljs-comment">//UI控制器，管理所有按钮响应函数</span><br>    UIManager UIM;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; UIM = GameObject.Find(<span class="hljs-string">&quot;UI&quot;</span>).GetComponent&lt;UIManager&gt;();<br>    <span class="hljs-comment">// 鼠标移入按钮时触发该响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerEnter</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"><span class="hljs-comment">// 将该按钮的背景图片组件发送至UI控制器</span></span><br><span class="hljs-function"></span>        =&gt; UIM.setSelectBtn(gameObject.GetComponent&lt;Image&gt;());<br><span class="hljs-comment">// 鼠标移出按钮时触发该响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerExit</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"></span>        =&gt; UIM.setSelectBtn(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将这个写好的StartPageBtnController挂在到需要该功能的那三个按钮上后，再去UI控制器里编写响应函数setSelectBtn。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSelectBtn</span>(<span class="hljs-params">Image btnImg</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (btnImg == onBtnImg.Value)<span class="hljs-comment">//如果选中按钮没变，就啥也不干</span><br>        <span class="hljs-keyword">return</span>;<br>    onBtnImg.Value.sprite = btnBGSprite;<span class="hljs-comment">//先将当前的选中按钮背景图复原</span><br>    <span class="hljs-keyword">if</span> (btnImg != <span class="hljs-literal">null</span>)<span class="hljs-comment">//如果没有按钮被选中，就选中默认按钮</span><br>    &#123;<br>        onBtnImg = startPageBtnImg.Find(btnImg);<br>        onBtnImg.Value.sprite = onBtnBGSprite;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//有选中按钮，就把选中的按钮赋值给当前选中按钮节点</span><br>    &#123;<br>        onBtnImg = startPageBtnImg.First;<br>        onBtnImg.Value.sprite = onBtnBGSprite;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个功能就这样实现了。</p><h3 id="3-3-2-动画器与状态机的使用"><a href="#3-3-2-动画器与状态机的使用" class="headerlink" title="3.3.2 动画器与状态机的使用"></a>3.3.2 动画器与状态机的使用</h3><h4 id="3-3-2-1-状态机的设置"><a href="#3-3-2-1-状态机的设置" class="headerlink" title="3.3.2.1 状态机的设置"></a>3.3.2.1 状态机的设置</h4><p>根据实体分析中对小恐龙Dino的状态机分析图(下图)<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909223752586.png" srcset="/img/loading.gif" alt="Dino状态机"></p><p>可以在Unity中制作动画器，并设置好状态机<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910201330605.png" srcset="/img/loading.gif" alt="动画器"></p><p>动画转变的判断参数是 int DinoState</p><h4 id="3-3-2-2-代码实现"><a href="#3-3-2-2-代码实现" class="headerlink" title="3.3.2.2 代码实现"></a>3.3.2.2 代码实现</h4><p>将动画器结合使用简单状态模式的脚本DinoController一起使用，就完成了对小恐龙的状态控制与动画播放。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DinoController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> DinoState &#123; Start, Run, Jump, Down, Dead &#125;<br>    <span class="hljs-comment">//小恐龙状态：0:开始 1:跑 2:跳 3:低头 4:死亡</span><br>    <span class="hljs-keyword">public</span> DinoState state;<br>    <span class="hljs-comment">// 利用属性来完成简单的状态改变响应函数</span><br>    <span class="hljs-keyword">public</span> DinoState State<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            state = (DinoState)animator.GetInteger(<span class="hljs-string">&quot;DinoState&quot;</span>);<br>            <span class="hljs-keyword">return</span> state; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            state = <span class="hljs-keyword">value</span>;<br>            animator.SetInteger(<span class="hljs-string">&quot;DinoState&quot;</span>, (<span class="hljs-built_in">int</span>)<span class="hljs-keyword">value</span>);<br>            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">value</span>)<br>            &#123;<br>                <span class="hljs-keyword">case</span> DinoState.Run:<br>                    run();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DinoState.Jump:<br>                    jump();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DinoState.Down:<br>                    down();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DinoState.Dead:<br>                    dead();<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> GameController GC;<br>    <span class="hljs-keyword">public</span> Animator animator;<br>    <span class="hljs-keyword">private</span> List&lt;Vector3&gt; dinoBoxColliderSize<br>        = <span class="hljs-keyword">new</span> List&lt;Vector3&gt; &#123; <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">2.5f</span>, <span class="hljs-number">3f</span>, <span class="hljs-number">1f</span>), <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">4f</span>, <span class="hljs-number">2f</span>, <span class="hljs-number">1f</span>) &#125;;<br>    <span class="hljs-keyword">public</span> Rigidbody dinoRigidbody;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        GC = GameObject.Find(<span class="hljs-string">&quot;GameController&quot;</span>).GetComponent&lt;GameController&gt;();<br>        animator = gameObject.GetComponent&lt;Animator&gt;();<br>        dinoRigidbody = gameObject.GetComponent&lt;Rigidbody&gt;();<br>    &#125;<br>    <span class="hljs-comment">// 监听用户输入来改变小恐龙状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (GC.gameState != <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.UpArrow))<br>            State = DinoState.Jump;<br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.DownArrow))<br>            State = DinoState.Down;<br>        <span class="hljs-keyword">if</span> (Input.GetKeyUp(KeyCode.DownArrow))<br>            State = DinoState.Run;<br>    &#125;<br><br>    <span class="hljs-comment">// 当状态改变后更改小恐龙碰撞体积</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBoxCollider</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isDown</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        BoxCollider bc = gameObject.GetComponent&lt;BoxCollider&gt;();<br>        <span class="hljs-keyword">if</span> (isDown)<br>            bc.size = dinoBoxColliderSize[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span><br>            bc.size = dinoBoxColliderSize[<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">//状态改变响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; setBoxCollider(<span class="hljs-literal">false</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jump</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (transform.position.y &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        setBoxCollider(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; setBoxCollider(<span class="hljs-literal">true</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dead</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; dinoRigidbody.isKinematic = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 碰撞检测响应函数，发送碰撞后将小恐龙状态设置为死亡</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collisionInfo</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (collisionInfo.gameObject.name == <span class="hljs-string">&quot;LandPrefab&quot;</span> || collisionInfo.gameObject.name == <span class="hljs-string">&quot;LandPrefab(Clone)&quot;</span>)<br>            <span class="hljs-keyword">return</span>;<br>        State = DinoState.Dead;<br>        GameObject.Find(<span class="hljs-string">&quot;GameController&quot;</span>).GetComponent&lt;GameController&gt;().GameOver(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-3-需要注意的点"><a href="#3-3-2-3-需要注意的点" class="headerlink" title="3.3.2.3 需要注意的点"></a>3.3.2.3 需要注意的点</h4><h5 id="状态的可打断性："><a href="#状态的可打断性：" class="headerlink" title="状态的可打断性："></a>状态的可打断性：</h5><p>在状态机分析图中分两种箭头：</p><ul><li>实线箭头<br>该状态的转换过程可以打断当前状态</li><li>虚线箭头<br>该状态的转换过程不可以打断当前状态，只能等当前状态的动画播放完毕才能进行状态转换</li></ul><p>想在Unity的状态机中实现这种设定，需要更改<strong>有退出时间</strong>属性：<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910203147899.png" srcset="/img/loading.gif" alt="image-20210910203147899"></p><ul><li>可打断则不勾选</li><li>不可打断则勾选</li></ul><blockquote><p>如果不做此调整会导致用户输入被延迟到状态动画播放完后执行，导致输入延迟验证，影响玩家体验</p></blockquote><h5 id="状态的自动转换："><a href="#状态的自动转换：" class="headerlink" title="状态的自动转换："></a>状态的自动转换：</h5><p>当跳远状态的动画播放完毕后，应当自动切换至奔跑状态。</p><p>为了实现这个功能，就需要使用动画的回调函数接口了。<br>详细可以阅读我的个人博客：[Unity-动画-回调函数接口](<a href="https://mycroftcooper.github.io/2021/09/07/Unity-%E5%8A%A8%E7%94%BB-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"> - Mycroft’s Blog (mycroftcooper.github.io)</a>****)</p><p>而在这里只需要使用两个个接口：</p><ul><li><p><strong>OnStateEnter</strong><br>进入该状态时调用</p></li><li><p><strong>OnStateExit</strong><br>在该状态结束退出时调用</p></li></ul><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JumpCallBack</span> : <span class="hljs-title">StateMachineBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// 进入该状态时播放跳跃音效</span><br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateEnter</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        GameObject.Find(<span class="hljs-string">&quot;GameController&quot;</span>).GetComponent&lt;SoundsController&gt;().PlayVoice(<span class="hljs-string">&quot;Sounds/Jump&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 退出该状态时自动转换到奔跑状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateUpdate</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">int</span> stateIndex = animator.GetInteger(<span class="hljs-string">&quot;DinoState&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateIndex != <span class="hljs-number">1</span> &amp;&amp; stateIndex != <span class="hljs-number">4</span>)<br>            GameObject.Find(<span class="hljs-string">&quot;DinoPrefab&quot;</span>).GetComponent&lt;DinoController&gt;().State = DinoController.DinoState.Run;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将该脚本挂到状态机中对应的状态(Run)上，就实现了目标</p><h5 id="按键连续按下时状态的连贯性："><a href="#按键连续按下时状态的连贯性：" class="headerlink" title="按键连续按下时状态的连贯性："></a>按键连续按下时状态的连贯性：</h5><p>当玩家连续按下跳跃键时，小恐龙应该持续保持在跳跃状态<br>当玩家持续按下低头键时，小恐龙应该持续保持在低头状态</p><p>要想实现这两个功能，这就需要用到Unity封装好的一些UI事件接口了。<br>详细内容可以看：<a href="https://mycroftcooper.github.io/2021/09/07/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/">UI事件接口</a></p><p>在这里需要用到的只有两个接口：</p><ul><li><strong>IPointerDownHandler</strong><br>鼠标在对象范围内按下时触发响应函数</li><li><strong>IPointerUpHandler</strong><br>鼠标在对象范围内抬起时触发响应函数</li></ul><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GamePageBtnController</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span><br>&#123;<br>    <span class="hljs-keyword">private</span> DinoController DC;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isDown = <span class="hljs-literal">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    =&gt; DC = GameObject.Find(<span class="hljs-string">&quot;DinoPrefab&quot;</span>).GetComponent&lt;DinoController&gt;();<br><br>    <span class="hljs-comment">// 按钮按下回调函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"></span>        =&gt; isDown = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 按钮松开回调函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        isDown = <span class="hljs-literal">false</span>;<br>        DC.State = DinoController.DinoState.Run;<br>    &#125;<br><br>    <span class="hljs-comment">//每帧检测是否按钮按下</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span>(isDown)<br>        &#123;<br>            <span class="hljs-comment">//判断按钮种类，根据种类改变小恐龙状态</span><br>            <span class="hljs-keyword">if</span> (gameObject.name == <span class="hljs-string">&quot;UpBtn&quot;</span>)<br>                DC.State = DinoController.DinoState.Jump;<br>            <span class="hljs-keyword">if</span> (gameObject.name == <span class="hljs-string">&quot;DownBtn&quot;</span>)<br>                DC.State = DinoController.DinoState.Down;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了以上代码，就可以正常实现功能了</p><h3 id="3-3-3-背景时间环与灯光的配合"><a href="#3-3-3-背景时间环与灯光的配合" class="headerlink" title="3.3.3 背景时间环与灯光的配合"></a>3.3.3 背景时间环与灯光的配合</h3><h4 id="3-3-3-1-效果描述"><a href="#3-3-3-1-效果描述" class="headerlink" title="3.3.3.1 效果描述"></a>3.3.3.1 效果描述</h4><p>根据实体分析中对背景时间环的分析可以知道，时间环以一定的速度转动来表达昼夜变化。而想用灯光来配合时间环的转动，来将昼夜变化更加自然的体现出来。</p><p>灯光主要可以通过以下两个方面来体现时间的变化：</p><ul><li>光照强度<ul><li>正午时光照强度最强</li><li>午夜时光照强度最弱</li></ul></li><li>光照颜色<ul><li>正午时光照颜色为橘黄色</li><li>午夜时光照颜色为暗蓝色</li></ul></li></ul><p>光照的变化应当是随着背景时间环而渐变的。</p><p>表现如下图所示：<br><strong>正午时：</strong><br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910183325819.png" srcset="/img/loading.gif" alt="image-20210910183325819"></p><p><strong>午夜时：</strong><br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910183450256.png" srcset="/img/loading.gif" alt="image-20210910183450256"></p><h4 id="3-3-3-2-解决思路"><a href="#3-3-3-2-解决思路" class="headerlink" title="3.3.3.2 解决思路"></a>3.3.3.2 解决思路</h4><p>背景时间环是一直在转动的，可以根据当前的转动角度来决定灯光的强度与颜色属性。<br>分析可得以下映射表：</p><table><thead><tr><th>时间</th><th>角度a</th><th>灯光强度s</th><th>灯光颜色c</th></tr></thead><tbody><tr><td>正午</td><td>0°</td><td>1.5</td><td>255，244，214</td></tr><tr><td>午夜</td><td>-180°</td><td>0.25</td><td>144，259，204</td></tr></tbody></table><p>可以看出输入值是角度，输出值是灯光强度与灯光颜色，而这两个输出值都是在一定范围内周期性变化。<br>由此可想到使用三角函数公式。</p><p><strong>灯光强度公式如下：</strong><br>$s=0.625cos(a)+0.65$</p><p>因为开始旋转角度为0时是正午，灯光强度为最大值1.5，所以使用cos函数<br>其中振幅A = 0.625 是根据(1.5-0.25)/2得到的。</p><h4 id="3-3-3-3-代码实现"><a href="#3-3-3-3-代码实现" class="headerlink" title="3.3.3.3 代码实现"></a>3.3.3.3 代码实现</h4><p>时间环控制代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TimeRingController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> LightController LC;<br>    <span class="hljs-keyword">public</span> Vector3 playSpeed;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isDayTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isPlaying;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsDayTime &#123; <span class="hljs-keyword">get</span> =&gt; isDayTime; <span class="hljs-keyword">set</span> =&gt; setTime(<span class="hljs-keyword">value</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsPlaying &#123; <span class="hljs-keyword">get</span> =&gt; isPlaying; <span class="hljs-keyword">set</span> =&gt; isPlaying = <span class="hljs-keyword">value</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        LC = GameObject.Find(<span class="hljs-string">&quot;Light&quot;</span>).GetComponent&lt;LightController&gt;();<br>        isDayTime = <span class="hljs-literal">true</span>;<br>        isPlaying = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//转动时间环函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (isPlaying)<br>        &#123;<br>            transform.Rotate(playSpeed, Space.Self);<br>            <span class="hljs-comment">//根据当前角度设置灯光属性</span><br>            LC.setTimeByAngle(transform.rotation.eulerAngles.z);<br>        &#125;<br>            <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isDayTime</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.isDayTime = isDayTime;<br>        <span class="hljs-keyword">if</span> (isDayTime)<br>        &#123;<br>            transform.rotation = Quaternion.Euler(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>            LC.setTime(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            transform.rotation = Quaternion.Euler(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">180</span>, <span class="hljs-number">0</span>));<br>            LC.setTime(<span class="hljs-literal">false</span>);<br>        &#125;<br>            <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>灯光控制代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LightController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Light theLight;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> maxInstensity;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> minInstensity;<br>    <span class="hljs-keyword">public</span> Color dayTimeColor;<br>    <span class="hljs-keyword">public</span> Color nightTimeColor;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        theLight = gameObject.GetComponent&lt;Light&gt;();<br>    &#125;<br>    <span class="hljs-comment">//三角函数的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> <span class="hljs-title">trigonometric</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> min, <span class="hljs-built_in">float</span> max,<span class="hljs-built_in">float</span> angle</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">float</span> rad = angle * Mathf.Deg2Rad;<br>        <span class="hljs-built_in">float</span> A = (max - min) / <span class="hljs-number">2.0f</span>;<br>        <span class="hljs-built_in">float</span> fai = min + A;<br>        <span class="hljs-keyword">return</span> A * Mathf.Cos(rad) + fai;<br>    &#125;<br>    <span class="hljs-comment">//根据角度转换灯光属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTimeByAngle</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> angle</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        theLight.intensity = trigonometric(minInstensity,maxInstensity,angle);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">100</span>&lt;angle &amp;&amp; angle&lt;<span class="hljs-number">200</span>)<br>            theLight.color = nightTimeColor;<br>        <span class="hljs-keyword">else</span><br>            theLight.color = dayTimeColor;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isDayTime</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (isDayTime)<br>        &#123;<br>            theLight.intensity = maxInstensity;<br>            theLight.color = dayTimeColor;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            theLight.intensity = minInstensity;<br>            theLight.color = nightTimeColor;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-3-4-需要注意的点"><a href="#3-3-3-4-需要注意的点" class="headerlink" title="3.3.3.4 需要注意的点"></a>3.3.3.4 需要注意的点</h4><ul><li>GameObject的transform.rotation属性是四元数，得转换为欧拉角然后再转换为弧度制才能使用</li><li>2D精灵是无法对3D的灯光有反应的<br>因为2D精灵使用的是默认的2D图片材质<br>想要让3D灯光在2D精灵图片上有效果，需要自定义材质<br>如下图所示：<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910200427517.png" srcset="/img/loading.gif" alt="image-20210910200427517"><br>其中渲染模式(RenderingMode)要设置为：Cutout，其它设置根据需求进行更改。</li></ul><h3 id="3-3-4-不同画面比的自适应匹配"><a href="#3-3-4-不同画面比的自适应匹配" class="headerlink" title="3.3.4 不同画面比的自适应匹配"></a>3.3.4 不同画面比的自适应匹配</h3><h4 id="3-3-4-1-效果描述"><a href="#3-3-4-1-效果描述" class="headerlink" title="3.3.4.1 效果描述"></a>3.3.4.1 效果描述</h4><p>当游戏打包发布到安卓端时，需要解决目前市场上各式各样屏幕比例的自适应问题。<br>UI方面只要在编辑器中设置好就问题不大，主要是游戏实体的缩放与生成和销毁位置的问题。</p><p>需求如下：</p><ul><li>陆地块的生成位置必须在屏幕外</li><li>陆地块的开始运动位置必须在屏幕右侧边缘</li><li>陆地块运动至屏幕外需要销毁</li><li>陆地块右侧边缘位于屏幕右侧边缘时，需要启动下一个陆地块</li><li>时间环无论在什么屏幕下都应该充满背景</li></ul><h4 id="3-3-4-2-代码实现"><a href="#3-3-4-2-代码实现" class="headerlink" title="3.3.4.2 代码实现"></a>3.3.4.2 代码实现</h4><p>想要实现如上需求，就必须要知道屏幕的边缘在哪里，也就是将屏幕的边缘坐标从屏幕坐标转化为世界坐标。可以通过如下代码实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> leftBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> rightBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> topBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> downBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> height;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> width;<br><span class="hljs-keyword">public</span> Vector3 scale;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBorder</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//世界坐标的右上角  因为视口坐标右上角是1,1,点</span><br>    Vector3 cornerPos = Camera.main.ViewportToWorldPoint(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1f</span>, <span class="hljs-number">1f</span>,Mathf.Abs(-Camera.main.transform.position.z)));<br>    <span class="hljs-comment">//世界坐标左边界</span><br>    leftBorder = Camera.main.transform.position.x - (cornerPos.x - Camera.main.transform.position.x);<br>    <span class="hljs-comment">//世界坐标右边界</span><br>    rightBorder = cornerPos.x;<br>    <span class="hljs-comment">//世界坐标上边界</span><br>    topBorder = cornerPos.y;<br>    <span class="hljs-comment">//世界坐标下边界</span><br>    downBorder = Camera.main.transform.position.y - (cornerPos.y - Camera.main.transform.position.y);<br>    width = rightBorder - leftBorder;<br>    height = topBorder - downBorder;<br>    <span class="hljs-comment">//在默认比例:16:9下的宽高</span><br>    <span class="hljs-built_in">float</span> deffultH = <span class="hljs-number">13.85643f</span>;<br>    <span class="hljs-built_in">float</span> deffultW = <span class="hljs-number">24.60183f</span>;<br>    <span class="hljs-comment">//缩放求出比例</span><br>    scale = <span class="hljs-keyword">new</span> Vector3(width/deffultW, height/deffultH, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>把上述代码挂在到摄像机上，当摄像机就位后运行，就能得到：</p><ul><li>画面四个边界的世界坐标</li><li>当前画面比例下与默认画面比例的缩放比</li></ul><p>其中物体运行到视野外销毁还可以使用另一种方法：<br>使用 <strong>OnBecameInvisible()</strong> 函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//物体进入视野内触发响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBecameVisible</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-comment">//物体离开视野内触发响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBecameInvisible</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="4-附录"><a href="#4-附录" class="headerlink" title="4. 附录"></a>4. 附录</h1><p>GitHub链接：<a href="https://github.com/MycroftCooper/DinoParkour">https://github.com/MycroftCooper/DinoParkour</a></p>]]></content>
    
    
    <categories>
      
      <category>项目开发文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGUI详解-事件接口</title>
    <link href="/2021/09/10/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/09/10/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>UGUI 系统虽然提供了很多封装好的组件，但是要实现一些特定的功能还是显得非常有限，这时候就需要使用事件接口来完成UI功能的实现。</p><p>比如我们想实现鼠标移动到图片上时自动显示图片的文字介绍，一般思路会想到写个射线来检测。<br>但其实这样的检测UGUI已经替我们完成了，我们只需要实现检测到目标对象后所要执行的代码即可！</p><p><strong>事件系统：UnityEngine.EventSystems;</strong></p><p>UI 组件都是基于 UGUI 封装好的类和接口以及一些 Editor 文件来进行封装制作供开发者使用的，开发者利用这些封装好的工具，只需更专注于功能开发即可。</p><h1 id="2-事件系统的前置条件"><a href="#2-事件系统的前置条件" class="headerlink" title="2. 事件系统的前置条件"></a>2. 事件系统的前置条件</h1><h2 id="2-1-使用该事件系统的条件"><a href="#2-1-使用该事件系统的条件" class="headerlink" title="2.1 使用该事件系统的条件"></a>2.1 使用该事件系统的条件</h2><ul><li>对象必须是 Canvas 的子对象；</li><li>对象必须有 Rect 范围；</li><li>鼠标的操作不分左键 中键 右键；</li></ul><h2 id="2-2-事件触发条件"><a href="#2-2-事件触发条件" class="headerlink" title="2.2 事件触发条件"></a>2.2 事件触发条件</h2><ul><li><p>对象或其子对象所附加的 UI 组件含有 Raycast Target 属性（为 true）</p></li><li><p>鼠标光标进入该对象的 Rect 范围时</p></li></ul><h2 id="2-3-事件系统的特殊情况"><a href="#2-3-事件系统的特殊情况" class="headerlink" title="2.3 事件系统的特殊情况"></a>2.3 事件系统的特殊情况</h2><ul><li><p><strong>若：</strong>该对象实现事件接口，而其子对象所附加的 UI 组件含有 Raycast Target         属性且没有实现事件接口<br><strong>则：</strong>只有该对象会触发事件，而其子对象不会触发事件</p></li><li><p><strong>当：</strong>该对象和其子对象同时具有触发事件接口的条件时：<br><strong>若：</strong>该对象的 Rect 范围被其子对象的 Rect 范围完全覆盖掉<br><strong>则：</strong>该对象不会触发事件，只有其子对象会触发事件。</p></li></ul><h1 id="3-事件接口一览"><a href="#3-事件接口一览" class="headerlink" title="3. 事件接口一览"></a>3. 事件接口一览</h1><ul><li><p><strong>IPointerEnterHandler</strong></p><p><strong>功能：</strong><br>鼠标移入对象时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerEnter</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IPointerExitHandler</strong><br><strong>功能：</strong><br>鼠标移出对象时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerExit</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IPointerDownHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IPointerUpHandler</strong><br><strong>功能</strong>：<br>鼠标在对象范围内抬起时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>无论鼠标在何处抬起（即不在A对象中）都会在A对象中响应此事件</li><li>响应此事件的前提是A对象必须响应过OnPointerDown事件</li></ul></blockquote></li><li><p><strong>IPointerClickHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下并抬起后触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerClick</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>按下和抬起时鼠标要处于同一对象上</p></blockquote></li><li><p><strong>IDragHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下并拖拽时，对象每帧响应一次此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>如果不实现此接口，则后面的四个接口方法都不会触发</p></blockquote></li><li><p><strong>IInitializePotentialDragHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下还没开始拖拽时，对象响应此事件</p><blockquote><p>与IPointerDownHandler接口事件类似</p></blockquote><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInitializePotentialDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IBeginDragHandler</strong><br><strong>功能：</strong><br>当鼠标在对象范围内按下并开始拖拽时，对象响应此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBeginDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：<br>此事件在OnInitializePotentialDrag之后响应 OnDrag之前响应</p></blockquote></li><li><p><strong>IEndDragHandler</strong><br><strong>功能：</strong><br>当鼠标完成拖拽抬起时，对象响应此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEndDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IDropHandler</strong><br><strong>功能：</strong><br>当鼠标从A对象上开始拖拽，在B对象上抬起时，B对象响应此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrop</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><pre><code>A、B对象必须均实现IDropHandler接口，且A至少实现IDragHandler接口</code></pre></li><li><pre><code>此时eventData.pointerDrag.name获取到的是B对象的name属性</code></pre></li><li><pre><code>eventData.pointerDrag表示发起拖拽的对象（GameObject）</code></pre></li></ul></blockquote></li></ul><h1 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h1><p>总结整理自：<br><a href="https://blog.csdn.net/eazey_wj/article/details/65632664">https://blog.csdn.net/eazey_wj/article/details/65632664</a></p><p>他这还有很多案例和代码，建议去看看</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>UGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>UGUI</tag>
      
      <tag>事件接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-动画-回调函数接口</title>
    <link href="/2021/09/07/Unity-%E5%8A%A8%E7%94%BB-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/09/07/Unity-%E5%8A%A8%E7%94%BB-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>当你想在状态机的某个状态执行中干些什么的时候(增加状态机行为)<br>比如：播放音效，添加粒子特效，增加逻辑代码等等操作。<br>那么就可以试一试Unity封装好的回调函数接口：<strong>StateMachineBehaviour</strong></p><p>想要添加（State machine behaviours）状态机行为到状态或子状态机，可以选中某个状态后在inspector中的Add Behaviour按钮。</p><h1 id="2-使用该动画回调接口的前置条件"><a href="#2-使用该动画回调接口的前置条件" class="headerlink" title="2. 使用该动画回调接口的前置条件"></a>2. 使用该动画回调接口的前置条件</h1><ul><li>必须继承StateMachineBehaviour</li><li>脚本必须挂在到状态上</li></ul><h1 id="3-回调函数接口一览"><a href="#3-回调函数接口一览" class="headerlink" title="3. 回调函数接口一览"></a>3. 回调函数接口一览</h1><ul><li><p><strong>OnStateEnter</strong><br>进入该状态时调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateEnter</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnStateUpdate</strong><br>在该状态下每帧调用<br>(MonoBehaviour Updates 更新后)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateUpdate</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnStateExit</strong><br>在该状态结束退出时调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateExit</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnStateMove</strong><br>在Animator.OnAnimatorMove()执行后调用(普通动画开始播放后)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateMove</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>用于实现处理和影响根运动的代码</p></blockquote></li><li><p><strong>OnStateIK</strong><br>在Animator.OnAnimatorIK()执行后调用(骨骼动画开始播放后)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateIK</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="4-参数解释"><a href="#4-参数解释" class="headerlink" title="4. 参数解释"></a>4. 参数解释</h1></li><li><p><strong>Animator animator</strong><br>当前动画器，是这个状态机行为的引用。</p></li><li><p><strong>AnimatorStateInfo stateInfo</strong><br>当前状态的详细信息</p><ul><li>int fullPathHash<br>当前状态的全路径哈希值</li><li>int nameHash<br>当前状态名称的哈希值</li><li>int shortNameHash<br>不包括父层名称的短名称哈希值</li><li>float normalizedTime<br>状态的标准化时间</li><li>float length<br>状态当前已经持续的时间</li><li>float speed<br>动画播放速度(1为正常速度)</li><li>float speedMultiplier<br>动画播放倍速</li><li>int tagHash<br>标签的哈希值</li><li>bool loop<br>当前状态是否循环</li><li>bool IsName(string name)</li><li>bool IsTag(string tag)</li></ul></li><li><p><strong>int layerIndex</strong><br>是状态机行为状态的layer 层</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>动画</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>动画</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-射线检测</title>
    <link href="/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/"/>
    <url>/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>射线是3D世界中一个点向一个方向发射的一条无终点的线。在发射的轨迹中，一旦与其他物体发生碰撞，它就会停止。</p><p>在游戏中，射线检测可以有如下用途：</p><ul><li>检测光标位置的三维物体</li><li>检测角色前面的物体（自动开门）</li><li>从空中向下检测（凹凸不平的地形的瞬移）</li><li>测量距离（激光测距）</li></ul><p>等等，可以说是相当重要了。</p><h1 id="2-Ray射线"><a href="#2-Ray射线" class="headerlink" title="2. Ray射线"></a>2. Ray射线</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>要想使用射线检测，就要先定义一条射线。而Ray就是Unity提供的一个封装好的射线结构体。</p><p>一条无穷的线，开始于origin点，朝向direction方向</p><blockquote><p>根据项目验证来看:其默认长度为单位向量，只有对direction进行乘以倍率，才可实现延长射线，而非无穷</p></blockquote><h2 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2 结构"></a>2.2 结构</h2><p>Ray是一个结构体：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Ray</span> (<span class="hljs-params">Vector3 origin,Vector3 direction</span>)</span><br></code></pre></td></tr></table></figure><p>其中参数为：</p><ul><li>Origin： 射线的起点    </li><li>direction：射线的方向</li></ul><p>初始化方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Ray ray = <span class="hljs-keyword">new</span> Ray(Vector3 origin,Vector3 direction)<br></code></pre></td></tr></table></figure><h2 id="2-3-常见用法"><a href="#2-3-常见用法" class="headerlink" title="2.3 常见用法"></a>2.3 常见用法</h2><ul><li><p>从物体中心创建一条指向前方的射线:<br><code>Ray ray = new Ray(transform.position,transform.forward)</code></p></li><li><p>从摄像机产生、指向屏幕上光标的射线<br><code>Ray camerRay = Camera.main.ScreenPointToRay(Input.mousePosition)</code>：。</p><blockquote><p>相机为perspective模式:<br>射线在相机梯形视野内发散；<br>相机为orthoGraphic模式:<br>则为垂直与相机面的直线段;</p></blockquote></li></ul><h1 id="3-RaycastHit-光线投射碰撞信息"><a href="#3-RaycastHit-光线投射碰撞信息" class="headerlink" title="3. RaycastHit 光线投射碰撞信息"></a>3. RaycastHit 光线投射碰撞信息</h1><p><strong>定义：</strong><br>通过射线检测得到的碰撞信息。</p><p>常用信息如下：</p><p><strong>常用参数：</strong></p><ul><li>collider<br>射线检测到的collider，这个非常常用，因为能根据collider.gameObject获取到对应GameObject</li><li>distance<br>射线发射源与检测到的位置的距离</li><li>normal<br>射线碰撞位置的法线</li><li>point<br>射线碰撞位置的世界坐标</li><li>transform<br>射线碰撞物体的transform组件</li></ul><h1 id="4-LayerMask-层级蒙版"><a href="#4-LayerMask-层级蒙版" class="headerlink" title="4. LayerMask 层级蒙版"></a>4. LayerMask 层级蒙版</h1><p><strong>Layer与LayerMask的关系:</strong></p><ul><li>Layer是0-31的数字</li><li>LayerMask是按位对应0-31</li></ul><blockquote><p>如&gt;<br>Layer9：Enemy<br>LayerMask用二进制表示：<br>00000000 00000000 000000<strong>1</strong>0 00000000<br>从右往左第10位，等于表达式：1&lt;&lt;9</p></blockquote><p>这是一种二进制思想，使用mask(掩码)表示时，可以同时表示多个状态的有无。</p><p><strong>根据Layer获取LayerMask:</strong></p><ul><li><p>如果你知道Layer的名字:<br>可以通过LayerMask.GetMask()方法获取<br><code>int mask = LayerMask.GetMask(&quot;Player&quot;, &quot;NPC&quot;);</code></p><blockquote><p>注意这个方法可以传入一个或多个string类型参数。</p></blockquote></li><li><p>如果你知道Layer的数字:<br>比如Layer9，可以通过移位操作1&lt;&lt;9来获取</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> playerMask = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">9</span>;<br><span class="hljs-built_in">int</span> npcMask = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> mask = playerMask | npcMask; <span class="hljs-comment">// 通过位操作“或(|)”同时检测player 和 npc层</span><br><span class="hljs-built_in">int</span> reverse = ~mask; <span class="hljs-comment">// 通过位操作&quot;求反(~)&quot;，检测除了player 和 npc的其他层</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="5-检测方法"><a href="#5-检测方法" class="headerlink" title="5. 检测方法"></a>5. 检测方法</h1><h2 id="5-1-线型检测"><a href="#5-1-线型检测" class="headerlink" title="5.1 线型检测"></a>5.1 线型检测</h2><p>在使用射线检测时，调用的是<code>public static bool Physics.Raycast()</code>函数</p><h3 id="5-1-1-Physics-Raycast-光线投射"><a href="#5-1-1-Physics-Raycast-光线投射" class="headerlink" title="5.1.1 Physics.Raycast 光线投射"></a>5.1.1 Physics.Raycast 光线投射</h3><h4 id="5-1-1-1-功能"><a href="#5-1-1-1-功能" class="headerlink" title="5.1.1.1 功能"></a>5.1.1.1 功能</h4><p>在已有一条射线（也可无）的基础上，使用射线（新建射线）进行一定距离内的定向检测。</p><ul><li>可修改射线长度</li><li>可限制其检测的Layer层</li><li>可得到射线检测到的碰撞信息</li></ul><blockquote><p>仅能检测到<strong>第一个被射线碰撞的物体</strong>，后面的物体无法被检测到</p></blockquote><p><strong>适用场合：</strong><br>配合相机坐标转换实现各类交互</p><h4 id="5-1-1-2-用法"><a href="#5-1-1-2-用法" class="headerlink" title="5.1.1.2 用法"></a>5.1.1.2 用法</h4><p><strong>用法一：</strong></p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br> transform.position, <br>     Vector.forward, <br>     distance, <br>     LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li><p><code>transform.position</code>：<br>从物体中心点起</p></li><li><p><code>Vector.forward</code>：<br>朝向该方向发射一条射线</p></li><li><p><code>distance</code>：<br>该射线长度为distance</p></li><li><p><code>LayerMask.GetMask(&quot;Enemy&quot;)</code>：<br>射线可检测到的层为Enemy层</p></li><li><p>返回bool类型</p></li></ul><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br>    transform.position, <br>    Vector.forward, <br>    distance, <br>    <span class="hljs-keyword">out</span> RaycastHitInformation ,<br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)；<br></code></pre></td></tr></table></figure><ul><li>相同参数同上</li><li><code>out RaycastHitInformation</code>：<br>将碰撞信息反馈到RaycastHitInformation上</li></ul><p><strong>用法三：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br>    MyRay, <br>    distance, <br>    LayerMash.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>相同参数同上</li><li><code>MyRay</code><br>从已有的射线MyRay出发</li><li><code>distance</code><br>长度延伸至distance</li></ul><p><strong>用法四：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br>MyRay, <br>    <span class="hljs-keyword">out</span> RaycastHitInformation, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>相同参数同上</li></ul><h3 id="5-1-2-Physics-RaycastAll-所有光线投射"><a href="#5-1-2-Physics-RaycastAll-所有光线投射" class="headerlink" title="5.1.2 Physics.RaycastAll 所有光线投射"></a>5.1.2 Physics.RaycastAll 所有光线投射</h3><h4 id="5-1-2-1-功能"><a href="#5-1-2-1-功能" class="headerlink" title="5.1.2.1 功能"></a>5.1.2.1 功能</h4><p>机理用法大致同Raycast，区别在于可检测射线路径上的<strong>所有物体</strong>，<strong>返回RaycastHit[]</strong> 。<br>其他带All后缀的方法也同理</p><p><strong>适用场合：</strong><br>穿透性检测</p><h4 id="5-1-2-2-用法"><a href="#5-1-2-2-用法" class="headerlink" title="5.1.2.2 用法"></a>5.1.2.2 用法</h4><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">RaycastHit[] hits = RaycastAll(<br>    Vector3.zero, <br>    Vector.forward, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">RaycastHit[] hits = RaycastAll(<br>    MyRay, <br>    distance, <br>    LayerMash.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-1-3-线段投射"><a href="#5-1-3-线段投射" class="headerlink" title="5.1.3 线段投射"></a>5.1.3 线段投射</h3><h4 id="5-1-3-1-功能"><a href="#5-1-3-1-功能" class="headerlink" title="5.1.3.1 功能"></a>5.1.3.1 功能</h4><p>建立<strong>某两点之间</strong>的射线进行检测，返回bool类型</p><p><strong>适用场合：</strong><br>特定地点局部距离射线检测</p><h4 id="5-1-3-2-用法"><a href="#5-1-3-2-用法" class="headerlink" title="5.1.3.2 用法"></a>5.1.3.2 用法</h4><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Linecast(<br>    startPos, <br>    endPos, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Linecast(<br>startPos, <br>    endPos, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h2 id="5-2-体型检测"><a href="#5-2-体型检测" class="headerlink" title="5.2 体型检测"></a>5.2 体型检测</h2><h3 id="5-2-1-Physics-XXXCast-体投射"><a href="#5-2-1-Physics-XXXCast-体投射" class="headerlink" title="5.2.1 Physics.XXXCast 体投射"></a>5.2.1 Physics.XXXCast 体投射</h3><h4 id="5-2-1-1-BoxCast-立方体投射"><a href="#5-2-1-1-BoxCast-立方体投射" class="headerlink" title="5.2.1.1 BoxCast 立方体投射"></a>5.2.1.1 BoxCast 立方体投射</h4><p><strong>功能：</strong><br>检测范围是正立方，返回bool。</p><p><strong>适用场合：</strong><br>检测目的地是否可抵达，从而判断可移动性</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">BoxCast(<br>    originPos, <br>    halfExtents, <br>    direction, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li>originPos, halfExtents：<br>在originPos点创建半径halfBoxLength的立方体<br>（Vector3型，代表为正立方体在三个方向上的大小，一般用localScale/2）</li><li>direction, distance:<br>以朝向direction方向的平面为起始面（另一面舍弃）<br>移动distance距离，期间经过的区域即为检测区域。</li></ul><h4 id="5-2-1-2-SphereCast-球体投射"><a href="#5-2-1-2-SphereCast-球体投射" class="headerlink" title="5.2.1.2 SphereCast 球体投射"></a>5.2.1.2 SphereCast 球体投射</h4><p><strong>功能：</strong><br>扩展检测范围为球形，返回bool类型。</p><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">SphereCast(<br>    originPos, <br>    originPos, <br>    direction, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li><p>originPos, originPos:<br>在originPos点创建半径为radius的球体</p></li><li><p>direction, distance:<br>以朝向direction方向的球面为起始面（另一面舍弃）<br>移动distance距离<br>期间半球面经过的区域即为检测区域。</p></li></ul><p>那么originPos到originPos+radius内的半球区域呢？<br>答案是舍弃，用官方的话来说，<strong>是边界而不是包围体</strong> 。</p><blockquote><p>立体结构：<br>以左右球球心为轴线，建立半径为radius、高为distance的圆柱体<br>左球挖去右半体积，右球添加右半体积</p></blockquote><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">SphereCast (<br>    Ray, <br>    radius, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-1-3-CapsuleCast-胶囊体投射"><a href="#5-2-1-3-CapsuleCast-胶囊体投射" class="headerlink" title="5.2.1.3 CapsuleCast 胶囊体投射"></a>5.2.1.3 CapsuleCast 胶囊体投射</h4><p><strong>功能：</strong><br>检测范围是胶囊体，返回bool</p><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">Physics.CapsuleCast(<br>    pos1, <br>    pos2, <br>    radius, <br>    direction, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    maxDistance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Anchor&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li><p>机理和SphereCast类似</p></li><li><p>pos1, pos2, radius:<br>在pos1、pos2两点创建半径为0.5f的球体，以此作为胶囊体模型两端；</p></li><li><p>direction, maxDistance:<br>以朝向direction方向的半胶囊体面为起始面，移动maxDistance距离<br>期间该面经过的区域即为检测区域。</p><blockquote><p>注：<br>maxDistance和上面的distance必须非0否则无用</p></blockquote></li></ul><h5 id="5-2-1-4-XXXCastAll-穿透投射"><a href="#5-2-1-4-XXXCastAll-穿透投射" class="headerlink" title="5.2.1.4 XXXCastAll 穿透投射"></a>5.2.1.4 XXXCastAll 穿透投射</h5><p><strong>功能：</strong><br>上述三种投射都只返回bool，只能检测单个物体，但是All方法的可检测射线上的所有物体，返回 <strong>RaycastHit[]</strong></p><blockquote><p>慎用，<strong>产生GC极多</strong></p></blockquote><h3 id="5-2-2-Physics-OverlapXXX-相交体"><a href="#5-2-2-Physics-OverlapXXX-相交体" class="headerlink" title="5.2.2 Physics.OverlapXXX 相交体"></a>5.2.2 Physics.OverlapXXX 相交体</h3><h4 id="5-2-2-1-OverlapBox-相交盒"><a href="#5-2-2-1-OverlapBox-相交盒" class="headerlink" title="5.2.2.1 OverlapBox 相交盒"></a>5.2.2.1 OverlapBox 相交盒</h4><p><strong>功能：</strong><br>检测与正立方体接触、重叠、或者处于其内的所有collider</p><p><strong>适用场合：</strong><br>检测挂载物体范围内是否存在碰撞，常用方法</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Collider[] hits = OverlapBox(<br>    Pos, <br>    halfExtents, <br>    Quaternion.identity, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>Pos, halfExtents:<br>以Pos点为中心创建三维半径halfExtents的正立方体</li><li>Quaternion.identity：<br>不对其进行旋转</li></ul><h4 id="5-2-2-2-OverlapSphere-相交球"><a href="#5-2-2-2-OverlapSphere-相交球" class="headerlink" title="5.2.2.2 OverlapSphere 相交球"></a>5.2.2.2 OverlapSphere 相交球</h4><p><strong>功能：</strong><br>检测与球体接触、重叠、或者处于其内的所有collider，即<strong>包围体</strong>。</p><blockquote><p>注意:<br><strong>自身collider也会被检测</strong>到（下列Overlap方法都是）</p></blockquote><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Collider[] hits = Physics.OverlapSphere(<br>    Pos, <br>    radius, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li><p>Pos, radius：<br>以Pos为原点，创建半径为radius的球形<br>检测区域为整个球形包围体（实心）<br>返回所有碰撞物体的collider而不是RaycastHit</p><blockquote><p>注意：<br>存在于球内部的物体也会被检测到</p></blockquote></li></ul><h4 id="5-2-2-3-OverlapCapsule-相交胶囊体"><a href="#5-2-2-3-OverlapCapsule-相交胶囊体" class="headerlink" title="5.2.2.3 OverlapCapsule 相交胶囊体"></a>5.2.2.3 OverlapCapsule 相交胶囊体</h4><p><strong>功能：</strong><br>检测与胶囊体接触、重叠、或者处于其内的所有collider</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Collider[] hits = OverlapCapsule(<br>    pos1, <br>    pos2, <br>    radius, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>在pos1、pos2两点创建半径为radius的球体，加上中间部分组成胶囊体</li></ul><h3 id="5-2-3-Physics-OverlapXXXNonAlloc-无GC相交体"><a href="#5-2-3-Physics-OverlapXXXNonAlloc-无GC相交体" class="headerlink" title="5.2.3 Physics.OverlapXXXNonAlloc 无GC相交体"></a>5.2.3 Physics.OverlapXXXNonAlloc 无GC相交体</h3><h4 id="5-2-3-1-OverlapBoxNonAlloc-无GC相交盒"><a href="#5-2-3-1-OverlapBoxNonAlloc-无GC相交盒" class="headerlink" title="5.2.3.1 OverlapBoxNonAlloc 无GC相交盒"></a>5.2.3.1 OverlapBoxNonAlloc 无GC相交盒</h4><p><strong>功能：</strong><br>实现OverlapBox的所有功能，但是另<strong>传递进colliders[]</strong> ，<strong>返回相交物体数量</strong>，从而<strong>杜绝GC的产生</strong></p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">CollAmount = Physics.OverlapBoxNonAlloc(<br>    Pos, <br>    halfExtents, <br>    colliders, <br>    Quaternion.identity, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-3-2-OverlapSphereNonAlloc-无GC相交球"><a href="#5-2-3-2-OverlapSphereNonAlloc-无GC相交球" class="headerlink" title="5.2.3.2 OverlapSphereNonAlloc 无GC相交球"></a>5.2.3.2 OverlapSphereNonAlloc 无GC相交球</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">CollAmount = OverlapSphereNonAlloc(<br>    Pos, <br>    radius, <br>    colliders, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-3-3-OverlapCapsuleNonAlloc-无GC相交胶囊体"><a href="#5-2-3-3-OverlapCapsuleNonAlloc-无GC相交胶囊体" class="headerlink" title="5.2.3.3 OverlapCapsuleNonAlloc 无GC相交胶囊体"></a>5.2.3.3 OverlapCapsuleNonAlloc 无GC相交胶囊体</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">CollAmount = OverlapCapsuleNonAlloc(<br>    pos1, <br>    pos2, <br>    radius, <br>    colliders, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-2-4-Physics-CheckXXX-检验体"><a href="#5-2-4-Physics-CheckXXX-检验体" class="headerlink" title="5.2.4 Physics.CheckXXX 检验体"></a>5.2.4 Physics.CheckXXX 检验体</h3><h4 id="5-2-4-1-CheckBox-检验盒"><a href="#5-2-4-1-CheckBox-检验盒" class="headerlink" title="5.2.4.1 CheckBox 检验盒"></a>5.2.4.1 CheckBox 检验盒</h4><p><strong>功能：</strong><br>创建检测盒，检测是否被碰撞。<br>较比与上面的检测方法，该类方法特点在于:<br>    <strong>检验是否发生了碰撞</strong>，而<strong>不是取得碰撞体信息</strong>，效率最高。</p><blockquote><p>注:<br>此方法同样也会检验自身collider</p></blockquote><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">IsOverlapAnyCollider = Physics.CheckBox(<br>    transform.position, <br>    transform.localScale / <span class="hljs-number">2</span>, <br>    Quaternion.identity, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>在物体中心创建检验盒，一定大小，不旋转，检测Enemy层，若有检测到碰撞则返回True</li></ul><h4 id="5-2-4-2-CheckSphere-检验球"><a href="#5-2-4-2-CheckSphere-检验球" class="headerlink" title="5.2.4.2 CheckSphere 检验球"></a>5.2.4.2 CheckSphere 检验球</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">IsOverlapAnyCollider = Physics.CheckSphere(<br>transform.position, <br>    radius, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-4-3-CheckCapsule-检验胶囊体"><a href="#5-2-4-3-CheckCapsule-检验胶囊体" class="headerlink" title="5.2.4.3 CheckCapsule 检验胶囊体"></a>5.2.4.3 CheckCapsule 检验胶囊体</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">IsOverlapAnyCollider = Physics.CheckCapsule(<br>pos1, <br>pos2，<br>    radius, <br>    LayerMask.<br>    GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-2-5-Physics-IgnoreCollision-忽略碰撞"><a href="#5-2-5-Physics-IgnoreCollision-忽略碰撞" class="headerlink" title="5.2.5 Physics.IgnoreCollision 忽略碰撞"></a>5.2.5 Physics.IgnoreCollision 忽略碰撞</h3><p><strong>功能：</strong><br>屏蔽两个collider的碰撞，第三个参数为bool</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">IgnoreCollision (collider1, collider2, ignore)<br></code></pre></td></tr></table></figure><h1 id="6-调试小技巧"><a href="#6-调试小技巧" class="headerlink" title="6. 调试小技巧"></a>6. 调试小技巧</h1><h2 id="6-1-绘制线段"><a href="#6-1-绘制线段" class="headerlink" title="6.1 绘制线段"></a>6.1 绘制线段</h2><ul><li><code>DrawLine(startPos, endPos, color)</code>：<br>绘制一条从startPos到endPos点、颜色为color的线段</li></ul><h2 id="6-2-绘制射线"><a href="#6-2-绘制射线" class="headerlink" title="6.2 绘制射线"></a>6.2 绘制射线</h2><p>使用Debug.DrawRay()方法可以在Scene中画出射线或者检测到的位置，更好的方便调试。</p><ul><li><p><code>DrawRay(startPos, direction, color)</code>：<br>绘制一条从startPos出发，指向direction的、颜色color的射线</p><blockquote><p>默认长度为单位向量，再乘以倍率即可边长<br>在下一次绘制才会覆盖上一次的射线</p></blockquote></li><li><p><code>Debug.DrawRay(startPos , direction, color, duration)</code> ：<br>同理绘制一定方向射线，但射线持续时间为duration </p></li></ul><h2 id="6-3-Gimos-DrawXXX方法"><a href="#6-3-Gimos-DrawXXX方法" class="headerlink" title="6.3 Gimos.DrawXXX方法"></a>6.3 Gimos.DrawXXX方法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123; <br>    Gizmos.DrawCube(transform.position, transform.localScale);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-GC开销问题"><a href="#7-GC开销问题" class="headerlink" title="7. GC开销问题"></a>7. GC开销问题</h1><p>从上面对几种检测方法的分析及对比其<strong>返回值</strong>不难发现：<br><strong>不同方法产生GC情况相差甚远</strong></p><p>因此在工程项目上应该慎重使用。</p><p>此处引用网友 <a href="https://www.cnblogs.com/hont/p/6180822.html">HONT</a>的测试作为GC情况参考：</p><ul><li>同方法下不同模型GC开销：<strong>Box &lt; Sphere &lt; Capsule</strong></li><li>同模型下不同方法GC开销：<strong>CheckXXX &lt; OverlapXXX &lt; XXXCast</strong></li></ul><h1 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h1><ul><li><a href="https://www.cnblogs.com/SouthBegonia/p/11732340.html">https://www.cnblogs.com/SouthBegonia/p/11732340.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>射线检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>当对象可能会根据不同的情况做出不同的行为，我们就把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。</p><p>当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变。</p><p>对这种有状态的对象编程有两种解决方法：</p><p><strong>传统的解决方案</strong>：<br>使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理。<br>但是显然这种做法存在弊端：<br>条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。</p><p><strong>状态模式的解决方案：</strong><br>当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理。<br>这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。</p><blockquote><p>状态模式<br>允许对象在内部状态改变时改变它的行为，对象看起来好像被修改了它的类</p></blockquote><h1 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h1><p>通常在以下情况下可以考虑使用状态模式。</p><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><blockquote><p>Unity中的动画控制器本质上来讲就是个使用状态模式的有限状态机</p></blockquote><h1 id="4-模式结构"><a href="#4-模式结构" class="headerlink" title="4. 模式结构"></a>4. 模式结构</h1><p>状态模式包含以下主要角色。</p><ul><li>环境类（Context）角色：<br>也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</li><li>抽象状态（State）角色：<br>定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</li><li>具体状态（Concrete State）角色：<br>实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li></ul><p>类图如下图所示：<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20210831211640607.png" srcset="/img/loading.gif" alt="image-20210831211640607"></p><h1 id="5-状态机"><a href="#5-状态机" class="headerlink" title="5. 状态机"></a>5. 状态机</h1><p>为了能够更好的描述状态模式中各种状态之间的转换关系，我们一般会使用有限状态机来更加具体的描述它。</p><h2 id="5-1-什么是状态机"><a href="#5-1-什么是状态机" class="headerlink" title="5.1 什么是状态机"></a>5.1 什么是状态机</h2><p><strong>定义:</strong><br>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。</p><p><strong>要素：</strong></p><ul><li>现态：<br>是指当前所处的状态。</li><li>条件：<br>又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</li><li>动作：<br>条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。</li><li>次态：<br>条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li></ul><h2 id="5-2-如何实现状态机"><a href="#5-2-如何实现状态机" class="headerlink" title="5.2 如何实现状态机"></a>5.2 如何实现状态机</h2><p>实现状态机主要体现在两部:<br>画出状态转换图和将有限状态机用代码实现。<br>其中代码实现部分其实就是状态模式的实现。</p><ol><li><p>画出状态转换图</p><ol><li>找出所有状态(圆圈表示)</li><li>找出所有状态间的转换条件(圆圈间的线段表示)</li><li>分析每个状态需要执行的策略(圆圈边的大括号表示)</li></ol></li><li><p>将有限状态机用代码实现</p><ol><li>定义一个状态机类</li><li>根据状态转换图的<strong>状态节点(圆圈)**，定义</strong>状态**(可使用类(推荐)，枚举或无符号整数)</li><li>根据状态转换图的<strong>转换条件(边)**，实现</strong>转换动作**方法</li></ol></li></ol><h1 id="6-模式案例"><a href="#6-模式案例" class="headerlink" title="6. 模式案例"></a>6. 模式案例</h1><h2 id="6-1-案例分析"><a href="#6-1-案例分析" class="headerlink" title="6.1 案例分析"></a>6.1 案例分析</h2><p><strong>案例描述：</strong><br>用状态模式设计一个多线程的状态转换程序</p><p><strong>状态分析：</strong><br>多线程存在 5 种状态，分别为：</p><ul><li>新建状态（New）</li><li>就绪状态（Runnable ）</li><li>运行状态（Running）</li><li>阻塞状态（Blocked）</li><li>死亡状态（Dead）</li></ul><p>各个状态当遇到相关方法调用或事件触发时会转换到其他状态。</p><p><strong>状态转换图：</strong><br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20210831223512143.png" srcset="/img/loading.gif" alt="image-20210831223512143"></p><h2 id="6-2-类定义"><a href="#6-2-类定义" class="headerlink" title="6.2 类定义"></a>6.2 类定义</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20210831223846969.png" srcset="/img/loading.gif" alt="image-20210831223846969"></p><h2 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScoreStateTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadContext context = <span class="hljs-keyword">new</span> ThreadContext();<br>        context.start();<br>        context.getCPU();<br>        context.suspend();<br>        context.resume();<br>        context.getCPU();<br>        context.stop();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//环境类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadContext</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ThreadState state;<br>    ThreadContext() &#123;<br>        state = <span class="hljs-keyword">new</span> New();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(ThreadState state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadState <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        ((New) state).start(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCPU</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Runnable) state).getCPU(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Running) state).suspend(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Running) state).stop(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Blocked) state).resume(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象状态类：线程状态</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String stateName; <span class="hljs-comment">//状态名</span><br>&#125;<br><span class="hljs-comment">//具体状态类：新建状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">New</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;新建状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：新建状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用start()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;新建状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Runnable());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是新建状态，不能调用start()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：就绪状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Runnable</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;就绪状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：就绪状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCPU</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;获得CPU时间--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;就绪状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Running());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是就绪状态，不能获取CPU.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：运行状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Running</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Running</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;运行状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：运行状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用suspend()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;运行状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Blocked());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是运行状态，不能调用suspend()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用stop()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;运行状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Dead());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是运行状态，不能调用stop()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：阻塞状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blocked</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Blocked</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;阻塞状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：阻塞状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用resume()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;阻塞状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Runnable());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是阻塞状态，不能调用resume()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：死亡状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dead</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dead</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;死亡状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：死亡状态.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">当前线程处于：新建状态.<br>调用<span class="hljs-built_in">start</span>()方法<span class="hljs-comment">--&gt;当前线程处于：就绪状态.</span><br>获得CPU时间<span class="hljs-comment">--&gt;当前线程处于：运行状态.</span><br>调用suspend()方法<span class="hljs-comment">--&gt;当前线程处于：阻塞状态.</span><br>调用resume()方法<span class="hljs-comment">--&gt;当前线程处于：就绪状态.</span><br>获得CPU时间<span class="hljs-comment">--&gt;当前线程处于：运行状态.</span><br>调用<span class="hljs-built_in">stop</span>()方法<span class="hljs-comment">--&gt;当前线程处于：死亡状态.</span><br></code></pre></td></tr></table></figure><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><h2 id="7-2-优缺点"><a href="#7-2-优缺点" class="headerlink" title="7.2 优缺点"></a>7.2 优缺点</h2><p><strong>优点：</strong></p><ul><li>结构清晰：<br>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将状态转换显示化，减少对象间的相互依赖：<br>将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，有利于程序的扩展：<br>通过定义新的子类很容易地增加新的状态和转换。</li></ul><p><strong>缺点：</strong></p><ul><li>状态模式的使用必然会增加系统的类与对象的个数。 </li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。 </li><li>状态模式对开闭原则的支持并不太好:<br>对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li></ul><h2 id="7-3-与其他模式的区别"><a href="#7-3-与其他模式的区别" class="headerlink" title="7.3 与其他模式的区别"></a>7.3 与其他模式的区别</h2><p>状态模式与策略模式看起来像双胞胎，但他们还是不相同的。</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>策略模式</td><td>将可以互换的行为封装，使用委托的方法决定使用哪个行为</td></tr><tr><td>状态莫斯</td><td>封装基于状态的行为，将行为委托至当前状态</td></tr><tr><td>模板方法</td><td>由子类决定如何实现算法中的某些步骤</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>状态模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2021/07/15/%E5%89%91%E6%8C%87offer/"/>
    <url>/2021/07/15/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h1 id="03-找出数组中重复的数字"><a href="#03-找出数组中重复的数字" class="headerlink" title="03. 找出数组中重复的数字"></a>03. 找出数组中重复的数字</h1><p>21-7-15</p><p><strong>描述：</strong><br>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。<br>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。<br>请找出数组中任意一个重复的数字。</p><p><strong>示例：</strong><br>输入：<br>    [2, 3, 1, 0, 2, 5, 3]<br>输出：<br>    2 或 3<br>限制：<br>    2 &lt;= n &lt;= 100000</p><p><strong>解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber1</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//哈希表法 时间复杂度o(n) 空间复杂度o(n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; numMap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (numMap.find(nums[i]) == numMap.end())<br>                numMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(nums[i], <span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//原地置换法 </span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] != nums[nums[i]])<br>                swap(nums[i], nums[nums[i]]);<br>            <span class="hljs-keyword">if</span> (nums[i] != i) <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-keyword">int</span> output;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(&#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span> &#125;)</span></span>;<br>    output =s.findRepeatNumber1(v);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    output = s.findRepeatNumber2(v);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>要求空间复杂度低<ul><li>先排序，然后看相邻元素是否有相同的，有直接return。<br>时间复杂度O(nlogn)，空间复杂度O(1)</li><li>原地置换<br>题目说明尚未被充分使用<br>即：在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内<br>此说明含义：数组元素的 索引 和 值 是 一对多 的关系。<br>因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = inums[i]=i ）。<br>因而，就能通过索引映射对应的值，起到与字典等价的作用。</li></ul></li><li>均衡的方法<br>使用哈希表(map)<br>时间复杂度O(n)，空间复杂度O（n）</li></ul><h1 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. 二维数组中的查找</h1><p>21-7-15</p><p><strong>描述：</strong><br>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p><p><strong>示例：</strong><br>现有矩阵 matrix 如下：<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p><p><strong>限制：</strong><br>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p><p><strong>解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (col &gt; <span class="hljs-number">-1</span> &amp;&amp; row&lt;matrix.size())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (target == matrix[row][col])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (target &gt; matrix[row][col])<br>                row++;<br>            <span class="hljs-keyword">else</span><br>                col--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a1(&#123; <span class="hljs-number">1</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a2(&#123; <span class="hljs-number">2</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a3(&#123; <span class="hljs-number">3</span>,   <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a4(&#123; <span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">24</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a5(&#123; <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">26</span>, <span class="hljs-number">30</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; inputMatrix(&#123;a1,a2,a3,a4,a5&#125;);<br>    <span class="hljs-keyword">int</span> target;<br>    <span class="hljs-keyword">bool</span> output;<br><br>    target = <span class="hljs-number">5</span>;<br>    output =s.findNumberIn2DArray(inputMatrix,target);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    target = <span class="hljs-number">20</span>;<br>    output = s.findNumberIn2DArray(inputMatrix, target);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>线性查找</p><p>从二维数组的右上角开始查找。</p><ul><li>如果当前元素等于目标值，则返回 true。</li><li>如果当前元素大于目标值，则移到左边一列。</li><li>如果当前元素小于目标值，则移到下边一行。</li><li>若数组为空，返回 false</li><li>循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false</li></ul><p>可以证明这种方法不会错过目标值。</p><ul><li>如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值<br>因此往下查找不可能找到目标值，往左查找可能找到目标值。</li><li>如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值<br>因此往左查找不可能找到目标值，往下查找可能找到目标值。</li></ul><h1 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a>05. 替换空格</h1><p>21-7-15</p><p><strong>描述：</strong><br>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。<br>链接：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof</a></p><p><strong>示例：</strong></p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p><strong>限制：</strong><br>0 &lt;= s 的长度 &lt;= 10000</p><p><strong>解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">string</span> output=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>)<br>                output += <span class="hljs-string">&quot;%20&quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                output += s[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">string</span> target = <span class="hljs-string">&quot;We are happy.&quot;</span>;<br>    <span class="hljs-built_in">string</span> output = s.replaceSpace(target);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串拼接或转为字符数组操作</p><h1 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a>06. 从尾到头打印链表</h1><p>21-7-15</p><p><strong>描述：</strong></p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>链接：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</a></p><p><strong>示例：</strong><br>输入：head = [1,3,2]<br>输出：[2,3,1]</p><p><strong>限制：</strong><br>0 &lt;= 链表长度 &lt;= 10000</p><p><strong>解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* next;<br>    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint1</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-comment">//利用vector的insert特性</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output;<br>        ListNode* p = head;<br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            output.insert(output.begin(),p-&gt;val);<br>            p = p-&gt;next;<br>        &#125; <br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint2</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-comment">//回溯法</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output;<br>        ListNode* p = head;<br>        flashBack(p, output);<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flashBack</span><span class="hljs-params">(ListNode* p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;output)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;next!= <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ListNode* q = p-&gt;next;<br>            flashBack(q, output);<br>        &#125;<br>        output.push_back(p-&gt;val);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    ListNode *target=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    target-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>    target-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output = s.reversePrint2(target);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; output.size(); i++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; output[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>法一：回溯法<br>法二：用栈<br>法三：利用vector的insert特性</p><h1 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07. 重建二叉树"></a>07. 重建二叉树</h1><p>21-7-16</p><p><strong>描述：</strong><br>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>相关知识点：</p><ul><li><a href="https://www.cnblogs.com/jpfss/p/11141956.html">树的三种遍历与推导</a></li></ul><p>链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof</a></p><p><strong>示例1：</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210716143123077.png" srcset="/img/loading.gif" alt="image-20210716143123077"></p><p><strong>Input:</strong><br>preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</p><p><strong>Output:</strong><br> [3,9,20,null,null,15,7]</p><p><strong>示例2：</strong><br><strong>Input:</strong><br>preorder = [-1], inorder = [-1]</p><p><strong>Output:</strong><br>[-1]</p><p><strong>限制：</strong><br>0 &lt;= 节点个数 &lt;= 5000</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">NULL</span>), right(<span class="hljs-literal">NULL</span>) &#123;&#125;   <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;preMap;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;inoMap;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; preorder;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorder.size() == <span class="hljs-number">0</span> || inorder.size() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; preorder.size(); i++)<br>        &#123;<br>            preMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; (preorder[i],i));<br>            inoMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; (inorder[i], i));<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;preorder = preorder;<br>        <span class="hljs-keyword">this</span>-&gt;inorder = inorder;<br>        treeBuilder(<span class="hljs-number">0</span>,inorder.size()<span class="hljs-number">-1</span>, root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">treeBuilder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inorderBegin, <span class="hljs-keyword">int</span> inorderEnd, TreeNode* nowRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> boundary;<br>        boundary = inoMap[nowRoot-&gt;val];<br><br>        <span class="hljs-keyword">int</span> leftBegin = inorderBegin;<br>        <span class="hljs-keyword">int</span> leftEnd = boundary - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (leftEnd &lt; inorderBegin)leftEnd = inorderBegin;<br>        <span class="hljs-keyword">int</span> rightBegin = boundary + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (rightBegin &gt; inorderEnd)rightBegin = inorderEnd;<br>        <span class="hljs-keyword">int</span> rightEnd = inorderEnd;<br>        <span class="hljs-keyword">if</span> (leftBegin == rightEnd)<span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (inorder[leftBegin] != nowRoot-&gt;val)<br>        &#123;<br>            nowRoot-&gt;left=findRootNode(leftBegin, leftEnd);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (inorder[rightBegin] != nowRoot-&gt;val)<br>        &#123;<br>            nowRoot-&gt;right = findRootNode(rightBegin,rightEnd);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nowRoot-&gt;left !=<span class="hljs-literal">NULL</span>)<br>            treeBuilder(leftBegin, leftEnd, nowRoot-&gt;left);<br>        <span class="hljs-keyword">if</span> (nowRoot-&gt;right !=<span class="hljs-literal">NULL</span>)<br>            treeBuilder(rightBegin, rightEnd, nowRoot-&gt;right);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">findRootNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> root_p = preMap[inorder[begin]];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = begin; j &lt;= end; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (preMap[inorder[j]] &lt; root_p)<br>            &#123;<br>                root_p = preMap[inorder[j]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(preorder[root_p]);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(&#123; <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span> &#125;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorder</span><span class="hljs-params">(&#123; <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span> &#125;)</span></span>;<br>    TreeNode* output = s.buildTree(preorder,inorder);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路:</strong></p><p><strong>二叉树的遍历:</strong></p><p>二叉树前序遍历的顺序为：</p><ul><li>先遍历根节点；</li><li>随后递归地遍历左子树；</li><li>最后递归地遍历右子树。</li></ul><p>二叉树中序遍历的顺序为：</p><ul><li>先递归地遍历左子树；</li><li>随后遍历根节点；</li><li>最后递归地遍历右子树。</li></ul><p>在「递归」地遍历某个子树的过程中，我们也是将这颗子树看成一颗全新的树，按照上述的顺序进行遍历。<br>挖掘「前序遍历」和「中序遍历」的性质，我们就可以得出本题的做法。</p><p><strong>方法一：递归</strong></p><p>对于任意一颗树而言，前序遍历的形式总是</p><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p><p>而中序遍历的形式总是</p><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p><p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><blockquote><p>注意：<br>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。<br>我们可以考虑使用哈希表来帮助我们快速地定位根节点。<br>对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。<br>在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。<br>在此后构造二叉树的过程中，我们就只需要 O(1)O(1) 的时间对根节点进行定位了。</p></blockquote><p>复杂度分析：</p><ul><li>时间复杂度：O(n)O(n)<br>其中 nn 是树中的节点个数。</li><li>空间复杂度：O(n)O(n)<br>除去返回的答案需要的 O(n)O(n) 空间之外，我们还需要使用 O(n)O(n) 的空间存储哈希映射，以及 O(h)O(h)（其中 hh 是树的高度）的空间表示递归时栈空间。<br>这里 h &lt; nh&lt;n，所以总空间复杂度为 O(n)O(n)。</li></ul><p><strong>方法二：迭代</strong></p><p>略，详见：链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</a></p><h1 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09. 用两个栈实现队列"></a>09. 用两个栈实现队列</h1><p>21-7-16</p><p><strong>描述:</strong><br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。<br>(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a></p><p><strong>示例 1：</strong></p><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-literal">null</span>,<span class="hljs-number">-1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong><br>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p><p><strong>解:</strong><br><a href="https://blog.csdn.net/cherrydreamsover/article/details/80466781">队列与栈的互相实现</a></p><p>复杂度分析</p><ul><li>时间复杂度：<br>对于插入和删除操作，时间复杂度均为 O(1)O(1)。<br>插入不多说，对于删除操作，虽然看起来是 O(n)O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 stack2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)O(1)。</li><li>空间复杂度：<br>O(n)O(n)。<br>需要使用两个栈存储已有的元素。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;a;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;b;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;<br><span class="hljs-keyword">public</span>:<br>    CQueue() <br>    &#123;<br>        <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        a.push(value);<br>        <span class="hljs-built_in">size</span>++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (b.empty())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (!a.empty())<br>            &#123;<br>                b.push(a.top());<br>                a.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> value = b.top();<br>        b.pop();<br>        <span class="hljs-built_in">size</span>--;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10-1. 斐波那契数列"></a>10-1. 斐波那契数列</h1><p>21-7-17</p><p><strong>描述:</strong><br>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。</p><p>斐波那契数列的定义如下：<br>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1</p><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a></p><p><strong>示例 1：</strong><br>输入：n = 2<br>输出：1</p><p><strong>示例 2：</strong><br>输入：n = 5<br>输出：5</p><p><strong>提示：</strong><br>0 &lt;= n &lt;= 100</p><p><strong>解:</strong></p><p>斐波那契数列的定义是 f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ，生成第 nn 项的做法有以下几种：</p><ul><li><strong>递归法：</strong><br><strong>原理：</strong><br>把 f(n)f(n) 问题的计算拆分成 f(n-1)f(n−1) 和 f(n-2)f(n−2) 两个子问题的计算，并递归，以 f(0)f(0) 和 f(1)f(1) 为终止条件。<br><strong>缺点：</strong><br>大量重复的递归计算，例如 f(n)f(n) 和 f(n - 1)f(n−1) 两者向下递归需要 各自计算 f(n - 2)f(n−2) 的值。</li><li><strong>记忆化递归法：</strong><br><strong>原理：</strong><br>在递归法的基础上，新建一个长度为 nn 的数组，用于在递归时存储 f(0)f(0) 至 f(n)f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。<br><strong>缺点：</strong><br>记忆化存储需要使用 O(N)O(N) 的额外空间。</li><li><strong>动态规划：</strong><br><strong>原理：</strong><br>以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) 为转移方程。<br>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;fibMap;<br>    <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    Solution()<br>    &#123;<br>        fibMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        fibMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//纯递归</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">return</span> fib1(n<span class="hljs-number">-1</span>) + fib1(n<span class="hljs-number">-2</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//带记录的递归</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">if</span> (fibMap.find(n) == fibMap.end())<br>        &#123;<br>            fibMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(n, (fib2(n - <span class="hljs-number">1</span>) + fib2(n - <span class="hljs-number">2</span>)) % mod));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (fibMap[n - <span class="hljs-number">1</span>] + fibMap[n - <span class="hljs-number">2</span>]) % mod;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//动态规划</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        *p = <span class="hljs-number">0</span>;<br>        *(p + <span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        &#123;<br>            *(p + i) = (*(p + i - <span class="hljs-number">1</span>) + *(p + i - <span class="hljs-number">2</span>))%mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *(p + n);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.fib3(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="10-2-青蛙跳台阶"><a href="#10-2-青蛙跳台阶" class="headerlink" title="10-2. 青蛙跳台阶"></a>10-2. 青蛙跳台阶</h1><p>21-7-17</p><p><strong>描述:</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a></p><p><strong>示例 1：</strong><br>输入：n = 2<br>输出：2</p><p><strong>示例 2：</strong><br>输入：n = 7<br>输出：21</p><p><strong>示例 3：</strong><br>输入：n = 0<br>输出：1</p><p><strong>提示：</strong><br>0 &lt;= n &lt;= 100</p><p><strong>解:</strong><br>同10-2动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        *p = <span class="hljs-number">1</span>;<br>        *(p + <span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br>        *(p + <span class="hljs-number">2</span>) = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>        &#123;<br>            *(p + i) = (*(p + i - <span class="hljs-number">1</span>) + *(p + i - <span class="hljs-number">2</span>)) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *(p + n);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.numWays(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h1><p>21-7-17</p><p><strong>描述:</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a></p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray1</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span><span class="hljs-comment">//线性查找</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers[<span class="hljs-number">0</span>]&lt;numbers[numbers.size() - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = numbers.size() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (numbers[i - <span class="hljs-number">1</span>] &gt; numbers[i])<br>                <span class="hljs-keyword">return</span> numbers[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span><span class="hljs-comment">//二分法</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> size = numbers.size();<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = size - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;<br>                <span class="hljs-comment">// [3, 4, 5, 1, 2]，mid 以及 mid 的左边一定不是最小数字</span><br>                <span class="hljs-comment">// 下一轮搜索区间是 [mid + 1, right]</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] == numbers[right]) &#123;<br>                <span class="hljs-comment">// 只能把 right 排除掉，下一轮搜索区间是 [left, right - 1]</span><br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 此时 numbers[mid] &lt; numbers[right]</span><br>                <span class="hljs-comment">// mid 的右边一定不是最小数字，mid 有可能是，下一轮搜索区间是 [left, mid]</span><br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[left];<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>&#125;<br></code></pre></td></tr></table></figure><p>二分查找（减治思想）<br>题目中给出的是半有序数组，虽然传统二分告诉我们二分只能用在有序数组中，但事实上，只要是可以减治的问题，仍然可以使用二分思想。</p><p><strong>思路：</strong><br>数组中最特殊的位置是左边位置 left 和右边位置 right，将它们与中间位置 mid 的值进行比较，进而判断最小数字出现在哪里。</p><p>用左边位置 left 和中间位置 mid 的值进行比较是否可以？<br>举例：[3, 4, 5, 1, 2] 与 [1, 2, 3, 4, 5] ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，因此这种做法不能有效地减治。</p><p>用右边位置 right 和中间位置 mid 的值进行比较是否可以？<br>举例：[1, 2, 3, 4, 5]、[3, 4, 5, 1, 2]、[2, 3, 4, 5 ,1]，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。</p><p>补充说明：遇到 nums[mid] == nums[right] 的时候，不能草率地下定结论最小数字在哪一边，但是可以确定的是，把 right 舍弃掉，并不影响结果。</p><h1 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a>12. 矩阵中的路径</h1><p>21-7-18</p><p><strong>描述:</strong><br>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。<br>如果 word 存在于网格中，返回 true ；<br>否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。<br>同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210717130732349.png" srcset="/img/loading.gif" alt="image-20210717130732349"><br>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p><p><strong>示例 1：</strong><br>输入：<br>board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：<br>true</p><p><strong>示例 2：</strong><br>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false</p><p><strong>提示：</strong><br>1 &lt;= board.length &lt;= 200<br>1 &lt;= board[i].length &lt;= 200<br>board 和 word 仅由大小写英文字母组成</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-built_in">string</span> word;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;board;<br>    <span class="hljs-keyword">int</span> rowNum,colNum;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span> word)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        rowNum = board.size();<br>        colNum = board[<span class="hljs-number">0</span>].size();<br>        <br>        <span class="hljs-keyword">this</span>-&gt;word = word;<br>        <span class="hljs-keyword">this</span>-&gt;board = board;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rowNum; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; colNum; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (dfs(i, j, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i&gt;=rowNum || j&gt;=colNum)<span class="hljs-comment">//越界判断</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (board[i][j]==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (board[i][j] != word[k])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (k == word.size() - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            board[i][j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dfs(i + <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || dfs(i - <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || dfs(i, j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>) || dfs(i, j - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                board[i][j] = word[k];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;  <br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(&#123; <span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span> &#125;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(&#123; <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span> &#125;)</span></span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board(&#123;a,b,c&#125;);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.exist(board,<span class="hljs-string">&quot;ABCCED&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路:</strong></p><p>本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。<br><img src="/images/%E5%89%91%E6%8C%87offer/image-20210718125453317.png" srcset="/img/loading.gif" alt="image-20210718125453317"></p><p><strong>深度优先搜索：</strong><br>可以理解为暴力法遍历矩阵中所有字符串可能性。<br>DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p><p><strong>剪枝：</strong><br>在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况<br>（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p><p><strong>DFS 解析：</strong></p><ul><li><p>递归参数：<br>当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</p></li><li><p>终止条件：</p><ul><li><p>返回 false：<br> (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过<br>（ (3) 可合并至 (2) ） </p></li><li><p>返回 true：<br>k = len(word) - 1 ，即字符串 word 已全部匹配。</p></li></ul></li><li><p>递推工作：</p><ul><li>标记当前矩阵元素：<br>将 board[i][j] 修改为 空字符 ‘’ ，代表此元素已访问过，防止之后搜索时重复访问。</li><li>搜索下一单元格：<br>朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。</li><li>还原当前矩阵元素：<br>将 board[i][j] 元素还原至初始值，即 word[k] 。</li><li>返回值：<br>返回布尔量 res ，代表是否搜索到目标字符串。</li></ul></li></ul><blockquote><p>使用空字符（Python: ‘’ , Java/C++: ‘\0’ ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。</p></blockquote><p><strong>复杂度分析：</strong><br>M, NM,N 分别为矩阵行列大小， KK 为字符串 word 长度。</p><ul><li><strong>时间复杂度</strong>$O(3^KMN)$：<br>最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为$O(3^K)$；<br>矩阵中共有 MN个起点，时间复杂度为 O(MN) 。</li><li><strong>方案数计算：</strong><br>设字符串长度为 KK ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 33 种选择，因此方案数的复杂度为 $O(3^K)$。</li><li><strong>空间复杂度</strong> O(K) ：<br>搜索过程中的递归深度不超过 KK ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。<br>最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN)的额外空间。</li></ul><h1 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a>13. 机器人的运动范围</h1><p>21-7-18</p><p><strong>描述:</strong><br>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。<br>一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。<br>例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。<br>但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p><p><strong>示例 1：</strong><br>输入：m = 2, n = 3, k = 1<br>输出：3</p><p><strong>示例 2：</strong><br>输入：m = 3, n = 1, k = 0<br>输出：1</p><p><strong>提示：</strong><br>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> rowNum,colNum;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> s1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> s2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i != <span class="hljs-number">0</span> || j!=<span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>            &#123;<br>                s1 += i % <span class="hljs-number">10</span>;<br>                i = i / <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>)<br>            &#123;<br>                s2 += j % <span class="hljs-number">10</span>;<br>                j = j / <span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s1+s2&lt;=k;<br>    &#125;<br>    <span class="hljs-keyword">int</span> m, n, k;<br>    <span class="hljs-keyword">int</span> counter;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;* visited;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        rowNum = m;<br>        colNum = n;<br>        <span class="hljs-keyword">this</span>-&gt;k=k;<br>        counter = <span class="hljs-number">0</span>;<br>        visited=<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-number">0</span>));<br>        bfs();<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>*&gt;q;<br>        q.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]&#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;);<br>        <span class="hljs-keyword">while</span> (!q.empty())<br>        &#123;<br>            <span class="hljs-keyword">int</span>* p = q.front();<br>            <span class="hljs-keyword">int</span> i = p[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> j = p[<span class="hljs-number">1</span>];<br>            q.pop();<br><br>            <span class="hljs-keyword">if</span> (i &gt;= rowNum || j &gt;= colNum || !sums(i, j) || visited-&gt;at(i).at(j))<br>                <span class="hljs-keyword">continue</span>;<br>            counter++;<br>            visited-&gt;at(i).at(j) = <span class="hljs-literal">true</span>;<br><br>            q.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]&#123; i + <span class="hljs-number">1</span>,j &#125;); <br>            q.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]&#123; i,j + <span class="hljs-number">1</span> &#125;);     <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= rowNum || j &gt;= colNum)<span class="hljs-comment">//越界判断</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (visited-&gt;at(i).at(j))<br>            <span class="hljs-keyword">return</span>;<br>        visited-&gt;at(i).at(j) = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!sums(i, j))<br>            <span class="hljs-keyword">return</span>;<br>        counter++;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        dfs(i + <span class="hljs-number">1</span>, j);<br>        dfs(i, j + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.movingCount(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">17</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似与12题，深搜与广搜两种解法</p><h1 id="14-剪绳子1"><a href="#14-剪绳子1" class="headerlink" title="14. 剪绳子1"></a>14. 剪绳子1</h1><p>21-7-19</p><p><strong>描述:</strong><br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。<br>请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？</p><p>例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p><p><strong>示例 1：</strong><br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p><p><strong>示例 2:</strong><br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p><strong>提示：</strong><br>2 &lt;= n &lt;= 58</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dpf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//动态规划</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>* dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> max_val = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++)<br>            &#123;<br>                max_val = max(max_val, dp[i - j] * dp[j]);<br>            &#125;<br>            dp[i] = max_val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">greedy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//贪心算法</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-comment">//能全部拆成3</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>) <span class="hljs-comment">//余1，少拆个3，换成3+1=4</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;<span class="hljs-comment">//余2，直接乘2</span><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.dpf(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.greedy(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路:</strong><br><strong>动态规划</strong><br><strong>算法流程：</strong></p><ul><li>我们想要求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来</li><li>用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1</li><li>我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪</li><li>剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话长度乘积即为j * (i - j)；如果剪的话长度乘积即为j * dp[i - j]。取两者最大值max(j * (i - j), j * dp[i - j])</li><li>第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为<br>dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</li><li>最后返回dp[n]即可</li></ul><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n ^ 2)<em>O</em>(<em>n</em>2)</li><li>空间复杂度：O(n)<em>O</em>(<em>n</em>)</li></ul><p><strong>贪心算法:</strong></p><p>找规律或数学证明可知： <strong>尽可能将绳子以长度 3 等分为多段时，乘积最大。</strong></p><p><strong>算法流程：</strong><br>当 n≤3 时，按照规则应不切分，但由于题目要求必须剪成 m&gt;1 段，因此必须剪出一段长度为 1 的绳子，即返回 n - 1。<br>当 n&gt;3时，求 n除以 3 的 整数部分 a 和 余数部分 b（即 n = 3a + b），并分为以下三种情况：</p><ul><li>当 b = 0时，直接返回 pow(3,a)；</li><li>当 b = 1时，要将一个 1 + 3 转换为 2+2，因此返回pow(3,a-1)*4；</li><li>当 b = 2b=2 时，返回 pow(3,a)*2 ;</li></ul><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1)：<br>仅有求整、求余、次方运算。<ul><li>求整和求余运算：<br>资料提到不超过机器数的整数可以看作是 O(1)O(1) ；</li><li>幂运算：<br>查阅资料，提到浮点取幂为 O(1)O(1) 。</li></ul></li><li>空间复杂度 O(1)： 变量 a 和 b 使用常数大小额外空间。</li></ul><h1 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a>15. 二进制中1的个数</h1><p>21-7-19</p><p><strong>描述:</strong><br>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p><blockquote><p>提示：<br>请注意，在某些语言（如 Java）中，没有无符号整数类型。<br>在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。<br>因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p></blockquote><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p><p><strong>示例 1：</strong><br>输入：n = 11<br>(控制台输入 00000000000000000000000000001011)<br>输出：3<br>解释：<br>输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p><p><strong>示例 2：</strong><br>输入：n = 128<br>(控制台输入 00000000000000000000000010000000)<br>输出：1<br>解释：<br>输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p><p><strong>示例 3：</strong><br>输入：n = 4294967293<br> (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）<br>输出：31<br>解释：<br>输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><p><strong>提示：</strong><br>输入必须是长度为 32 的 二进制串 。</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>)<br>                counter++;<br>            n = n &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.hammingWeight(<span class="hljs-number">4294967293</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单位运算，略</p><h1 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a>16. 数值的整数次方</h1><p>21-7-26</p><p><strong>描述:</strong><br>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。</p><p>不得使用库函数，同时不需要考虑大数问题。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p><p><strong>示例 1：</strong><br>输入：x = 2.00000, n = 10<br>输出：1024.00000</p><p><strong>示例 2：</strong><br>输入：x = 2.10000, n = 3<br>输出：9.26100</p><p><strong>示例 3：</strong><br>输入：x = 2.00000, n = -2<br>输出：0.25000<br>解释：2-2 = 1/22 = 1/4 = 0.25</p><p><strong>提示：</strong><br>-100.0 &lt; x &lt; 100.0<br>-231 &lt;= n &lt;= 231-1<br>-104 &lt;= xn &lt;= 104</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow1</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span> </span><br><span class="hljs-function">        <span class="hljs-comment">//递归快速幂+位运算(会爆栈)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>/myPow1(x, -n);<br><br>        <span class="hljs-keyword">if</span>((n&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> myPow1(x, n<span class="hljs-number">-1</span>)*x;<br>        n = n &gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">double</span> t = myPow1(x, n);<br>        <span class="hljs-keyword">return</span> t * t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow2</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//迭代快速幂</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / x;<br><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            n = -n;<br>            x = <span class="hljs-number">1.0</span> / x;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> output = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>                output *= x;<br>            x *= x;<br>            n = n &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow3</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//2分法</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / x;<br>        <span class="hljs-keyword">double</span> half = myPow3(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">double</span> mod = myPow3(x, n % <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> half * half * mod;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.myPow2(<span class="hljs-number">2.00000</span>, <span class="hljs-number">-2147483648</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>快速幂</li><li>二分法</li><li>位运算</li><li>int类型边界<br>-2147483648</li></ul><h1 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a>17. 打印从1到最大的n位数</h1><p>21-7-26</p><p><strong>描述:</strong><br>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。</p><p>比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>链接：<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</a></p><p><strong>示例 1:</strong><br>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p><p><strong>说明：</strong><br>用返回一个整数列表来代替打印<br>n 为正整数</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">char</span> numChar[<span class="hljs-number">10</span>] = &#123; <span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span> &#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; output;<br>    <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        dfs(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;intOutput;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; output.size(); i++)<br>        &#123;<br>            intOutput.push_back(atoi(output[i].c_str()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> intOutput;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> num,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == n)<br>        &#123;<br>            output.push_back(num);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">string</span> str = num+numChar[i];<br>            dfs(str, x + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;intOutput=s.printNumbers(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intOutput.size(); i++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; intOutput[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的主要考点是大数越界情况下的打印。</p><p>需要解决以下三个问题：</p><ul><li>表示大数的变量类型：<br>无论是 short / int / long … 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。</li><li>生成数字的字符串集：<br>使用 int 类型时，每轮可通过 +1+1 生成下个数字，而此方法无法应用至 String 类型。<br>并且， String 类型的数字的进位操作效率较低，例如 “9999” 至 “10000” 需要从个位到千位循环判断，进位 4 次。<br>观察可知，生成的列表实际上是 nn 位 00 - 99 的 全排列 ，因此可避开进位操作，通过递归生成数字的 String 列表。</li><li>递归生成全排列：<br>基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。<br>例如当 n = 2n=2 时（数字范围 1 - 991−99 ），固定十位为 00 - 99 ，按顺序依次开启递归，固定个位 00 - 99 ，终止递归并添加数字字符串。</li></ul><p><img src="../images/%E5%89%91%E6%8C%87offer/image-20210726150257820.png" srcset="/img/loading.gif" alt="image-20210726150257820"></p><p>即：使用深度优先搜索算法(dfs)。</p><h1 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h1><p>21-7-26</p><p><strong>描述:</strong><br>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a></p><p><strong>示例 1:</strong><br>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p><strong>示例 2:</strong><br>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p><strong>说明：</strong><br>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* next;<br>    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (head-&gt;val == val)<span class="hljs-keyword">return</span> head-&gt;next;<br>        ListNode* p, * q;<br>        p = head;<br>        q = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (q-&gt;next!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (q-&gt;val == val)<br>            &#123;<br>                p-&gt;next = q-&gt;next;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            p = p-&gt;next;<br>            q = p-&gt;next;<br>        &#125;<br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br>    <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    ListNode* head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    ListNode* p = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        p-&gt;next = <span class="hljs-keyword">new</span> ListNode(i);<br>        p = p-&gt;next;<br>    &#125;<br>    p = s.deleteNode(head, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; p-&gt;val &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        p = p-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的链表删除节点，双指针操作</p><h1 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19.正则表达式匹配"></a>19.正则表达式匹配</h1><p>21-7-26</p><p><strong>描述:</strong><br>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。</em></p><p><em>模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。</p><p>在本题中，匹配是指字符串的所有字符匹配整个模式。<br>例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p><p><strong>示例 1:</strong><br>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p><p><strong>示例 2:</strong><br>输入:<br>s = “aa”<br>p = “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p><strong>示例 3:</strong><br>输入:<br>s = “ab”<br>p = “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。</p><p><strong>示例 4:</strong><br>输入:<br>s = “aab”<br>p = “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p><p><strong>示例 5:</strong><br>输入:<br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br>输出: false</p><p><strong>注意：</strong></p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘\</em>’。</li></ul><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> m = s.size()+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> n = p.size()+<span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; dp(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 初始化首行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; n; j += <span class="hljs-number">2</span>)<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>] &amp;&amp; p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (dp[i][j - <span class="hljs-number">2</span>] ||<br>                        (dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">2</span>]) ||<br>                        (dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; p[j - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                    &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> ((dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>]) ||<br>                        dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span><br>                        )<br>                    &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;   <br>                &#125;<br>                dp[i][j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br>    <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.isMatch(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路:</strong></p><ul><li><p>状态数组：设二维数组</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dp</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>，m和n是s、p的长度</p><ul><li>特殊说明：<code>dp[i][j]</code>表示s下标为<code>s[i-1]</code>的字符，p下标为<code>p[j-1]</code>字符</li></ul></li><li><p>初始化：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span><br></code></pre></td></tr></table></figure><p>表示 s的前i个字符和p的前j个字符是否匹配</p><ul><li><code>dp[0][0]=true</code>，表示s和p的前0个字符均为空串肯定匹配</li><li>若s是空串且p 的偶数次下标为$*$,那也是匹配的</li></ul></li><li><p>状态转移：</p><ul><li><pre><code>p.charAt(j - 1) == &#39;*&#39;<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>  ,有三种情况匹配<br><br>  - `dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j - 2]</span>`，既是`<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-2]</span>`出现<span class="hljs-number">0</span>次<br>  - `(dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> &amp;&amp; s<span class="hljs-selector-class">.charAt</span>(<span class="hljs-selector-tag">i</span> - <span class="hljs-number">1</span>) == <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.charAt</span>(j - <span class="hljs-number">2</span>)`，`<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-2]</span>`出现<span class="hljs-number">1</span>次 且 当前i-<span class="hljs-number">1</span>和j-<span class="hljs-number">2</span>指向的字符相同<br>  - `dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> &amp;&amp; <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.charAt</span>(j - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>`，最特殊情况:`<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-2]</span>=. <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-1]</span>=*`时，根据条件知是万能匹配<br><br>- ```<br>  <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.charAt</span>(j - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure>,有两种情况匹配- `dp[i - 1][j - 1] &amp;&amp; s.charAt(i - 1) == p.charAt(j - 1)`，前面元素之前都匹配 且 当前元素也相容- `dp[i - 1][j - 1] &amp;&amp; p.charAt(j - 1) == &#39;.&#39;`，前面元素之前都匹配 且 p的当期元素是`.`</code></pre></li></ul></li><li><p>返回值：<code>dp[m-1][n-1]</code></p></li></ul><h1 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串#"></a>20. 表示数值的字符串#</h1><p>21-7-26</p><p><strong>描述:</strong><br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><p>数值（按顺序）可以分成以下几个部分：</p><ul><li><p>若干空格</p></li><li><p>一个 小数 或者 整数</p></li><li><p>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</p></li><li><p>若干空格</p></li></ul><p>小数（按顺序）可以分成以下几个部分：</p><ul><li>（可选）一个符号字符（’+’ 或 ‘-‘）</li><li>下述格式之一：<ul><li>至少一位数字，后面跟着一个点 ‘.’</li><li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li><li>一个点 ‘.’ ，后面跟着至少一位数字</li></ul></li></ul><p>整数（按顺序）可以分成以下几个部分：</p><ul><li><p>（可选）一个符号字符（’+’ 或 ‘-‘）</p></li><li><p>至少一位数字</p></li></ul><p>部分数值列举如下：</p><ul><li>[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]</li></ul><p>部分非数值列举如下：</p><ul><li>[“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”]</li></ul><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof</a></p><p><strong>示例 1：</strong><br>输入：s = “0”<br>输出：true</p><p><strong>示例 2：</strong><br>输入：s = “e”<br>输出：false</p><p><strong>示例 3：</strong><br>输入：s = “.”<br>输出：false</p><p><strong>示例 4：</strong><br>输入：s = “    .1  “<br>输出：true</p><p><strong>提示：</strong><br>1 &lt;= s.length &lt;= 20<br>s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，空格 ‘ ‘ 或者点 ‘.’ 。</p><h1 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h1><p><strong>描述:</strong><br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</a></p><p><strong>示例：</strong><br>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p><p><strong>提示：</strong><br>0 &lt;= nums.length &lt;= 50000<br>1 &lt;= nums[i] &lt;= 10000</p><p><strong>解:</strong></p><p>双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>]</span>) -&gt; List[int]:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> nums<br>        iStart = <span class="hljs-number">0</span><br>        iEnd = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> iStart != iEnd:<br>            <span class="hljs-keyword">if</span> nums[iStart] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                iStart += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> nums[iEnd] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                iEnd -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            t = nums[iStart]<br>            nums[iStart] = nums[iEnd]<br>            nums[iEnd] = t<br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure><h1 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22. 链表中倒数第k个节点"></a>22. 链表中倒数第k个节点</h1><p><strong>描述：</strong><br>输入一个链表，输出该链表中倒数第k个节点。<br>为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。<br>这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></p><p><strong>示例：</strong><br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2。<br>返回链表 4-&gt;5。</p><p><strong>解：</strong><br>快慢双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getKthFromEnd</span>(<span class="hljs-params">self, head: ListNode, k: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span><br>        <span class="hljs-keyword">if</span> head == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        first = head<br>        last = head<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k-<span class="hljs-number">1</span>):<br>            first = first.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> first == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> first.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            first = first.<span class="hljs-built_in">next</span><br>            last = last.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> last<br></code></pre></td></tr></table></figure><h1 id="24-反转列表"><a href="#24-反转列表" class="headerlink" title="24.  反转列表"></a>24.  反转列表</h1><p><strong>描述:</strong><br>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a></p><p><strong>示例:</strong><br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>限制：<br>0 &lt;= 节点个数 &lt;= 5000</p><p><strong>解:</strong><br>快慢三指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>         self.val = x<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head</span>):</span><br>        <span class="hljs-keyword">if</span> head == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> head.<span class="hljs-built_in">next</span> == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> head<br>        <br>        first = head<br>        last = <span class="hljs-literal">None</span><br>        t = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> t <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            first.<span class="hljs-built_in">next</span> = last<br>            last = first<br>            first = t<br>            t = t.<span class="hljs-built_in">next</span><br>        first.<span class="hljs-built_in">next</span> = last<br>        <span class="hljs-keyword">return</span> first<br>        <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    head = ListNode(<span class="hljs-number">1</span>)<br>    Node1 = ListNode(<span class="hljs-number">2</span>)<br>    head.<span class="hljs-built_in">next</span> = Node1<br>    Node2 = ListNode(<span class="hljs-number">3</span>)<br>    Node1.<span class="hljs-built_in">next</span> = Node2<br>    s = Solution()<br>    output = s.reverseList(head)<br>    <span class="hljs-keyword">while</span> output <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        print(output.val)<br>        output = output.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="25-合并两个排序的列表"><a href="#25-合并两个排序的列表" class="headerlink" title="25. 合并两个排序的列表"></a>25. 合并两个排序的列表</h1><p><strong>描述:</strong></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong><br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p><strong>限制：</strong><br>0 &lt;= 链表长度 &lt;= 1000</p><p><strong>解:</strong></p><p>归并排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>         self.val = x<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br>        <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> l2<br>        <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> l1<br>        p1 = l1<br>        p2 = l2<br>        head = ListNode(-<span class="hljs-number">1</span>)<br>        p3 = head<br>        <span class="hljs-keyword">while</span> p1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> p2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> p1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                p3.<span class="hljs-built_in">next</span> = p2<br>                p2 = p2.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> p2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                p3.<span class="hljs-built_in">next</span> = p1<br>                p1 = p1.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> p1.val &lt; p2.val:<br>                p3.<span class="hljs-built_in">next</span> = p1<br>                p1 = p1.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                p3.<span class="hljs-built_in">next</span> = p2<br>                p2 = p2.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br>        <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    head1 = ListNode(<span class="hljs-number">1</span>)<br>    Node1 = ListNode(<span class="hljs-number">3</span>)<br>    head1.<span class="hljs-built_in">next</span> = Node1<br>    Node2 = ListNode(<span class="hljs-number">5</span>)<br>    Node1.<span class="hljs-built_in">next</span> = Node2<br><br>    head2 = ListNode(<span class="hljs-number">2</span>)<br>    Node1 = ListNode(<span class="hljs-number">4</span>)<br>    head2.<span class="hljs-built_in">next</span> = Node1<br>    Node2 = ListNode(<span class="hljs-number">6</span>)<br>    Node1.<span class="hljs-built_in">next</span> = Node2<br><br>    s = Solution()<br>    output = s.mergeTwoLists(head1, head2)<br>    <span class="hljs-keyword">while</span> output <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        print(output.val)<br>        output = output.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h1><p><strong>描述:</strong><br>输入两棵二叉树A和B，判断B是不是A的子结构。<br>(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p><strong>例如:</strong><br>给定的树 A:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">   <span class="hljs-number"> 3 </span> <br>   / \  <br> <span class="hljs-number"> 4 </span> <span class="hljs-number"> 5 </span><br> / \ <br>1  2<br></code></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-number">4</span>  <br> / <br><span class="hljs-number">1</span><br>返回 true，因为 <span class="hljs-selector-tag">B</span> 与 <span class="hljs-selector-tag">A</span> 的一个子树拥有相同的结构和节点值。<br></code></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 节点个数 &lt;= <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p><strong>解:</strong><br>简单的树的搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSubStructure</span>(<span class="hljs-params">self, A, B</span>):</span><br>        <span class="hljs-keyword">if</span> A <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> B <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        self.targetNodeList = <span class="hljs-built_in">list</span>()<br>        self.dfs(A,B)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.targetNodeList) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        output = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> targetNode <span class="hljs-keyword">in</span> self.targetNodeList:<br>            <span class="hljs-keyword">if</span> self.isSubTree(targetNode,B):<br>                output = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> output<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self,root,target</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> root.val == target.val:<br>            self.targetNodeList.append(root)<br>        <span class="hljs-keyword">return</span> self.dfs(root.left,target) <span class="hljs-keyword">or</span> self.dfs(root.right,target)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSubTree</span>(<span class="hljs-params">self,a,b</span>):</span><br>        <span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> a.val != b.val:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> self.isSubTree(a.left,b.left) <span class="hljs-keyword">and</span> self.isSubTree(a.right,b.right)<br></code></pre></td></tr></table></figure><h1 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h1><p><strong>描述:</strong><br>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a></p><p><strong>示例:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livescript">例如输入：<br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span><br><br>镜像输出：<br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">7</span>     <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p><strong>限制：</strong></p><p>0 &lt;= 节点个数 &lt;= 1000</p><p><strong>解:</strong></p><p>递归与深度优先搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mirrorTree</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        self.dfs(root)<br>        <span class="hljs-keyword">return</span> root<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self,root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <br>        t = root.left<br>        root.left = root.right<br>        root.right = t<br>        self.dfs(root.left)<br>        self.dfs(root.right)<br></code></pre></td></tr></table></figure><h1 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a>28. 对称的二叉树</h1><p><strong>描述：</strong><br>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>    1<br>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br>    1<br>   / <br>  2   2<br>   \   <br>   3    3</p><p>链接：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof</a></p><p><strong>示例 1：</strong><br>输入：root = [1,2,2,3,4,4,3]<br>输出：true</p><p><strong>示例 2：</strong><br>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><p><strong>限制：</strong><br>0 &lt;= 节点个数 &lt;= 1000</p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSymmetric</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> self.dfs(root.left,root.right)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self,L,R</span>):</span><br>        <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> R <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> R <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> L.val != R.val:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> self.dfs(L.left,R.right) <span class="hljs-keyword">and</span> self.dfs(L.right,R.left)<br></code></pre></td></tr></table></figure><h1 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><p><strong>解：</strong><br>模拟法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spiralOrder</span>(<span class="hljs-params">self, matrix</span>):</span><br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> output<br>        l = <span class="hljs-number">0</span> <br>        r = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span><br>        t = <span class="hljs-number">0</span><br>        b = <span class="hljs-built_in">len</span>(matrix) - <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> l &gt; r:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l, r + <span class="hljs-number">1</span>):<br>                output.append(matrix[t][i])<br>            t += <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> t &gt; b:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t ,b + <span class="hljs-number">1</span>):<br>                output.append(matrix[j][r])<br>            r -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> l &gt; r:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r, l - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                output.append(matrix[b][i])<br>            b -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span>  t &gt; b:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b, t - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                output.append(matrix[j][l])<br>            l += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>    print(s.spiralOrder(matrix))<br></code></pre></td></tr></table></figure><h1 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30. 包含min函数的栈"></a>30. 包含min函数的栈</h1><p><strong>描述：</strong><br>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">M<span class="hljs-keyword">in</span>Stack <span class="hljs-keyword">min</span>Stack = new M<span class="hljs-keyword">in</span>Stack();<br><span class="hljs-keyword">min</span>Stack.push(-<span class="hljs-number">2</span>);<br><span class="hljs-keyword">min</span>Stack.push(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">min</span>Stack.push(-<span class="hljs-number">3</span>);<br><span class="hljs-keyword">min</span>Stack.<span class="hljs-keyword">min</span>();   --&gt; 返回 -<span class="hljs-number">3</span>.<br><span class="hljs-keyword">min</span>Stack.pop();<br><span class="hljs-keyword">min</span>Stack.top();      --&gt; 返回 <span class="hljs-number">0</span>.<br><span class="hljs-keyword">min</span>Stack.<span class="hljs-keyword">min</span>();   --&gt; 返回 -<span class="hljs-number">2</span>.<br></code></pre></td></tr></table></figure><p> <a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/</a></p><p><strong>提示：</strong></p><ol><li>各函数的调用总次数不超过 20000 次</li></ol><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.stack = <span class="hljs-built_in">list</span>()<br>        self.minStack = <span class="hljs-built_in">list</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.stack.append(x)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.minStack) == <span class="hljs-number">0</span>:<br>            self.minStack.append(x)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> x &lt;= self.<span class="hljs-built_in">min</span>():<br>                self.minStack.append(x)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stack) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        x = self.stack.pop(<span class="hljs-built_in">len</span>(self.stack)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> x == self.<span class="hljs-built_in">min</span>():<br>            self.minStack.pop(<span class="hljs-built_in">len</span>(self.minStack)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> self.minStack[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = MinStack()<br>    s.push(-<span class="hljs-number">2</span>)<br>    s.push(<span class="hljs-number">0</span>)<br>    s.push(-<span class="hljs-number">3</span>)<br>    print(s.<span class="hljs-built_in">min</span>())<br>    print(s.pop())<br>    print(s.top())<br>    print(s.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>使用辅助栈</p><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210921114403708.png" srcset="/img/loading.gif" alt="image-20210921114403708"></p><h1 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a>31. 栈的压入、弹出序列</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。<br>例如：<br>序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，<br>但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], popped = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：我们可以按以下顺序执行：<br>push<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span>, <span class="hljs-title">pop</span><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">4</span>,<br>push<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, <span class="hljs-title">pop</span><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">5</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">3</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">2</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">pushed</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">popped</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-number">1</span> 不能在 <span class="hljs-number">2</span> 之前弹出。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li><li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li><li><code>pushed</code> 是 <code>popped</code> 的排列。</li></ol><p><strong>解：</strong></p><p>模拟法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validateStackSequences</span>(<span class="hljs-params">self, pushed, popped</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pushed) == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(popped) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <br>        queue = <span class="hljs-built_in">list</span>()<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> pushed:<br>            queue.append(num)<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> queue[-<span class="hljs-number">1</span>] == popped[i]:<br>                queue.pop()<br>                i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>    popped = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>    s = Solution()<br>    print(s.validateStackSequences(pushed,popped))<br></code></pre></td></tr></table></figure><h1 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32-I. 从上到下打印二叉树"></a>32-I. 从上到下打印二叉树</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</a></p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p><strong>例如:</strong><br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p><strong>解：</strong></p><p>简单的广度优先搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            r = queue.pop(<span class="hljs-number">0</span>)<br>            output.append(r.val)<br>            <span class="hljs-keyword">if</span> r.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                queue.append(r.left)<br>            <span class="hljs-keyword">if</span> r.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                queue.append(r.right)<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="32-II-从上到下打印二叉树"><a href="#32-II-从上到下打印二叉树" class="headerlink" title="32-II. 从上到下打印二叉树"></a>32-II. 从上到下打印二叉树</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a></p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><strong>例如:</strong><br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p><strong>解：</strong><br>同上题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            t = <span class="hljs-built_in">list</span>()<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                r = queue.pop(<span class="hljs-number">0</span>)<br>                t.append(r.val)<br>                <span class="hljs-keyword">if</span> r.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    queue.append(r.left)<br>                <span class="hljs-keyword">if</span> r.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    queue.append(r.right)            <br>            output.append(t)<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="32-III-从上到下打印二叉树"><a href="#32-III-从上到下打印二叉树" class="headerlink" title="32-III. 从上到下打印二叉树"></a>32-III. 从上到下打印二叉树</h1><p><strong>描述:</strong><br>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p> <strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</a>)</p><p><strong>例如:</strong><br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        output = <span class="hljs-built_in">list</span>()<br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        isBackWord = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            t = <span class="hljs-built_in">list</span>()<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                r = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isBackWord:<br>                    t.append(r.val)<br>                <span class="hljs-keyword">else</span>:<br>                    t.insert(<span class="hljs-number">0</span>,r.val)<br>                <span class="hljs-keyword">if</span> r.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    queue.append(r.left)<br>                <span class="hljs-keyword">if</span> r.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    queue.append(r.right)<br>            isBackWord = <span class="hljs-keyword">not</span> isBackWord<br>            output.append(t)<br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    head = TreeNode(<span class="hljs-number">1</span>)<br>    head.left = TreeNode(<span class="hljs-number">2</span>)<br>    head.right = TreeNode(<span class="hljs-number">3</span>)<br>    head.left.left = TreeNode(<span class="hljs-number">4</span>)<br>    head.right.right = TreeNode(<span class="hljs-number">5</span>)<br>    output = s.levelOrder(head)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> output:<br>        print(i)<br></code></pre></td></tr></table></figure><h1 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h1><p><strong>描述:</strong><br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">6</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,6,3,2,5]</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,2,6,5]</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p><p><strong>提示：</strong></p><ol><li><code>数组长度 &lt;= 1000</code></li></ol><p><strong>解：</strong></p><p>辅助单调栈:<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">verifyPostorder</span>(<span class="hljs-params">self, postorder</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(postorder) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        postorder = postorder[::-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(postorder) == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span> postorder[<span class="hljs-number">0</span>] &gt; postorder[<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span>  <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        incStack = <span class="hljs-built_in">list</span>()<br>        root = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(postorder)):<br>            <span class="hljs-keyword">if</span> postorder[i] &gt;= root:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(incStack) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> postorder[i] &lt; incStack[-<span class="hljs-number">1</span>]:<br>                root = incStack.pop()<br>            incStack.append(postorder[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.二叉树中和为某一值的路径</h1><p><strong>描述:</strong><br>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>target = 22</code>，</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">      5<br>     / \<br>   <span class="hljs-number"> 4 </span>  8<br>   /   / \<br> <span class="hljs-number"> 11 </span><span class="hljs-number"> 13 </span> 4<br> /  \    / \<br>7   <span class="hljs-number"> 2 </span><span class="hljs-number"> 5 </span>  1<br></code></pre></td></tr></table></figure><p>返回:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>   [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>],<br>   [<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>]<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</a></p><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><p><strong>解：</strong><br>深度优先搜索+回溯法<br>注意，是到叶节点，中间的不算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>        self.val = val<br>        self.left = left<br>        self.right = right<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pathSum</span>(<span class="hljs-params">self, root, target</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        self.pathList = <span class="hljs-built_in">list</span>()<br>        path = <span class="hljs-built_in">list</span>()<br>        self.dfs(root,target,path)<br>        <span class="hljs-keyword">return</span> self.pathList<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self, root, target, path</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        path.append(root.val)<br>        <span class="hljs-keyword">if</span> root.val == target <span class="hljs-keyword">and</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.pathList.append(<span class="hljs-built_in">list</span>(path))<br>        target -= root.val<br>        self.dfs(root.left, target, path)<br>        self.dfs(root.right, target, path)<br>        path.pop()<br></code></pre></td></tr></table></figure><h1 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a>35. 复杂链表的复制</h1><p><strong>描述:</strong><br>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/e1.png" srcset="/img/loading.gif" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/e2.png" srcset="/img/loading.gif" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[1,1],[2,1]]</span><br>输出：<span class="hljs-string">[[1,1],[2,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="/images/%E5%89%91%E6%8C%87offer/e3.png" srcset="/img/loading.gif" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br>输出：<span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：给定的链表为空（空指针），因此返回 null。<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</a></p><p><strong>提示：</strong></p><ul><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><p><strong>解：</strong><br>利用字典把新旧链表对应起来再复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, <span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>, random = <span class="hljs-literal">None</span></span>):</span><br>        self.val = <span class="hljs-built_in">int</span>(x)<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        self.random = random<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head: <span class="hljs-keyword">return</span><br>        dic = &#123;&#125;<br>        <span class="hljs-comment"># 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span><br>        cur = head<br>        <span class="hljs-keyword">while</span> cur:<br>            dic[cur] = Node(cur.val)<br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur = head<br>        <span class="hljs-comment"># 4. 构建新节点的 next 和 random 指向</span><br>        <span class="hljs-keyword">while</span> cur:<br>            dic[cur].<span class="hljs-built_in">next</span> = dic.get(cur.<span class="hljs-built_in">next</span>)<br>            dic[cur].random = dic.get(cur.random)<br>            cur = cur.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 5. 返回新链表的头节点</span><br>        <span class="hljs-keyword">return</span> dic[head]<br></code></pre></td></tr></table></figure><h1 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h1><p><strong>描述:</strong><br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p> 为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="/images/%E5%89%91%E6%8C%87offer/bstdlloriginalbst.png" srcset="/img/loading.gif" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="/images/%E5%89%91%E6%8C%87offer/bstdllreturndll.png" srcset="/img/loading.gif" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</a></p><p><strong>解:</strong><br>中序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>        self.val = val<br>        self.left = left<br>        self.right = right<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">treeToDoublyList</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        self.midOrderList = <span class="hljs-built_in">list</span>()<br>        self.dfs(root)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(self.midOrderList)):<br>            self.midOrderList[i].left = self.midOrderList[i-<span class="hljs-number">1</span>]<br>            self.midOrderList[i-<span class="hljs-number">1</span>].right = self.midOrderList[i] <br>        self.midOrderList[<span class="hljs-number">0</span>].left = self.midOrderList[-<span class="hljs-number">1</span>]<br>        self.midOrderList[-<span class="hljs-number">1</span>].right = self.midOrderList[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> self.midOrderList[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        self.dfs(root.left)<br>        self.midOrderList.append(root)<br>        self.dfs(root.right)<br></code></pre></td></tr></table></figure><h1 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= 数组长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-comment"># 摩尔投票法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElementByMooreVote</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        t = nums[<span class="hljs-number">0</span>]<br>        v = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> i == t:<br>                v += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                v -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> v &lt; <span class="hljs-number">0</span>:<br>                t = i<br>                v = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> t<br><br>    <span class="hljs-comment">#快排中位数法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElementByQuickSort</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        self.quickSort(nums,left,right)<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">self, arr,left,right</span>):</span><br>        <span class="hljs-keyword">if</span> arr <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span><br>        l = left<br>        r = right<br>        p = arr[l]<br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            <span class="hljs-keyword">while</span> arr[r] &gt;= p <span class="hljs-keyword">and</span> l &lt; r:<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[l] = arr[r]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> arr[l] &lt;= p <span class="hljs-keyword">and</span> l &lt; r:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[r] = arr[l]<br>                r -= <span class="hljs-number">1</span><br>        arr[l] = p<br>        self.quickSort(arr,left,l-<span class="hljs-number">1</span>)<br>        self.quickSort(arr,l+<span class="hljs-number">1</span>,right)<br><br>    <span class="hljs-comment"># 哈希地图法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElementByHashMap</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        hashMap = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> hashMap.get(i) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                hashMap[i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                hashMap[i] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> hashMap[i] &gt;= <span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>:<br>                    <span class="hljs-keyword">return</span> i<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.majorityElementByMooreVote([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]))<br></code></pre></td></tr></table></figure><h1 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37. 序列化二叉树"></a>37. 序列化二叉树</h1><p><strong>描述:</strong><br>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示：</strong><br>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode-cn.com/hc/kb/article/1194353/">LeetCode 序列化二叉树的格式</a>。<br>你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例：</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/serdeser.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/</a></p><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[]&#x27;</span><br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        strList = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            r = queue.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                strList.append(<span class="hljs-string">&quot;null&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                strList.append(<span class="hljs-built_in">str</span>(r.val))<br>                queue.append(r.left)<br>                queue.append(r.right)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span> + <span class="hljs-string">&#x27;,&#x27;</span>.join(strList) + <span class="hljs-string">&#x27;]&#x27;</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-keyword">if</span> data == <span class="hljs-string">&#x27;[]&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        strList = data[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        root = TreeNode(<span class="hljs-built_in">int</span>(strList[<span class="hljs-number">0</span>]))<br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        p = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            r = queue.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> strList[p] != <span class="hljs-string">&#x27;null&#x27;</span>:<br>                r.left = TreeNode(<span class="hljs-built_in">int</span>(strList[p]))<br>                queue.append(r.left)<br>            <span class="hljs-keyword">if</span> strList[p+<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;null&#x27;</span>:<br>                r.right = TreeNode(<span class="hljs-built_in">int</span>(strList[p+<span class="hljs-number">1</span>]))<br>                queue.append(r.right)<br>            p += <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> root<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Codec()<br>    head = TreeNode(<span class="hljs-number">1</span>)<br>    head.left = TreeNode(<span class="hljs-number">2</span>)<br>    head.right = TreeNode(<span class="hljs-number">3</span>)<br>    head.right.left = TreeNode(<span class="hljs-number">4</span>)<br>    head.right.right = TreeNode(<span class="hljs-number">5</span>)<br>    data = s.serialize(head)<br>    root = s.deserialize(data)<br>    print(s.serialize(root))<br></code></pre></td></tr></table></figure><h1 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a>38. 字符串的排列</h1><p><strong>描述:</strong><br>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p><p><strong>示例:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= s 的长度 &lt;= <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permutation</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> [s]<br>        self.lenth = <span class="hljs-built_in">len</span>(s)<br>        self.resultSet = <span class="hljs-built_in">list</span>()<br>        self.backtracking(<span class="hljs-built_in">list</span>(),<span class="hljs-built_in">list</span>(s))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(self.resultSet)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtracking</span>(<span class="hljs-params">self,accStr,unaccStr</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(accStr) == self.lenth:<br>            self.resultSet.append(<span class="hljs-string">&#x27;&#x27;</span>.join(accStr))<br>            <span class="hljs-keyword">return</span><br>        cutUnaccSet = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(unaccStr)):<br>            <span class="hljs-keyword">if</span> unaccStr[i] <span class="hljs-keyword">in</span> cutUnaccSet:<br>                <span class="hljs-keyword">continue</span><br>            cutUnaccSet.add(unaccStr[i])<br>            newAccStr = <span class="hljs-built_in">list</span>(accStr)<br>            newUnaccStr = <span class="hljs-built_in">list</span>(unaccStr)<br>            newAccStr.append(unaccStr[i])<br>            newUnaccStr.pop(i)<br>            self.backtracking(newAccStr,newUnaccStr)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.permutation(<span class="hljs-string">&quot;abc&quot;</span>))<br></code></pre></td></tr></table></figure><h1 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40. 最小的k个数"></a>40. 最小的k个数</h1><p><strong>描述：</strong><br>输入整数数组 arr ，找出其中最小的 k 个数。</p><p>例如：<br>输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong><br>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]</p><p><strong>示例 2：</strong><br>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p><p><strong>限制：</strong><br>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">链接</a></p><p><strong>解：</strong></p><p>普通解法：<br>使用双数组，第二个新数组从大到小排列，将旧数组中的数遍历插入到新数组中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNumArr</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):</span><br>        inputNumStrList = <span class="hljs-built_in">str</span>.split(<span class="hljs-built_in">input</span>,<span class="hljs-string">&#x27;,&#x27;</span>)<br>        numList = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(inputNumStrList)):<br>            numList.append(<span class="hljs-built_in">int</span>(inputNumStrList[i]))<br>        <span class="hljs-keyword">return</span> numList<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getLeastNumbers</span>(<span class="hljs-params">self, arr, k</span>):</span><br>        self.outputList = <span class="hljs-built_in">list</span>()<br>        self.k = k<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> self.outputList<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br>            self.pushNum(arr[i])<br>        <span class="hljs-keyword">return</span> self.outputList<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pushNum</span>(<span class="hljs-params">self, num</span>):</span><br>        print(<span class="hljs-string">&quot;+++&quot;</span>+<span class="hljs-built_in">str</span>(num))<br>        print(self.outputList)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.outputList) == <span class="hljs-number">0</span>:<br>            self.outputList.append(num)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>(self.outputList) &lt; self.k):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.outputList)):<br>                <span class="hljs-keyword">if</span> num &gt; self.outputList[j]:<br>                    self.outputList.insert(j,num)<br>                    <span class="hljs-keyword">return</span><br>            self.outputList.append(num)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span> num &gt;= self.outputList[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(self.outputList)):<br>            <span class="hljs-keyword">if</span> num &lt; self.outputList[j-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> num &gt;= self.outputList[j]:<br>                self.outputList.insert(j, num)<br>                self.outputList = self.outputList[<span class="hljs-number">1</span>:]<br>                <span class="hljs-keyword">return</span><br>        self.outputList.append(num)<br>        self.outputList = self.outputList[<span class="hljs-number">1</span>:]<br>            <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    inputNumList = s.getNumArr(<span class="hljs-string">&quot;0,1,1,2,4,4,2,3,3,2&quot;</span>)<br>    outputNumList = s.getLeastNumbers(inputNumList,<span class="hljs-number">6</span>)<br>    print(outputNumList)<br></code></pre></td></tr></table></figure><p>快速排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getLeastNumbers</span>(<span class="hljs-params">self, arr, k</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> arr<br>        self.k = k<br>        self.halfQuickSort(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> arr[:k]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">halfQuickSort</span>(<span class="hljs-params">self,arr,left,right</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span><br>        l = left<br>        r = right<br>        p = arr[l]<br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> arr[r] &gt;= p:<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[l] = arr[r]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> arr[l] &lt;= p:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[r] = arr[l]<br>                r -= <span class="hljs-number">1</span><br>        arr[l] = p<br>        <span class="hljs-keyword">if</span> l == self.k:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> l &lt; self.k:<br>            self.halfQuickSort(arr,l+<span class="hljs-number">1</span>,right)<br>        <span class="hljs-keyword">else</span>:<br>            self.halfQuickSort(arr,left,l-<span class="hljs-number">1</span>)<br>            <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    NumList = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>    s = Solution()<br>    outputNumList = s.getLeastNumbers(NumList,<span class="hljs-number">8</span>)<br>    print(NumList)<br>    print(outputNumList)<br></code></pre></td></tr></table></figure><h1 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41. 数据流中的中位数"></a>41. 数据流中的中位数</h1><p><strong>描述:</strong><br>如何得到一个数据流中的中位数？<br>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。<br>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p><strong>例如:</strong><br>[2,3,4] 的中位数是 3<br>[2,3] 的中位数是 (2 + 3) / 2 = 2.5<br>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]<br>输出：[null,null,null,<span class="hljs-number">1.50000</span>,null,<span class="hljs-number">2.00000</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]<br>输出：[null,null,<span class="hljs-number">2.00000</span>,null,<span class="hljs-number">2.50000</span>]<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</a></p><p><strong>限制：</strong></p><ul><li>最多会对 <code>addNum、findMedian</code> 进行 <code>50000</code> 次调用。</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">```<br><br><br><br><span class="hljs-comment"># 42连续子数组的最大和</span><br><br>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。<br>求所有子数组的和的最大值。<br><br>要求时间复杂度为O(n)。<br><br>**示例<span class="hljs-number">1</span>:**<br><br></code></pre></td></tr></table></figure><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs vim"><br>**提示：**<br><br>- `<span class="hljs-number">1</span> &lt;= arr.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span>`<br>- `-<span class="hljs-number">100</span> &lt;= arr[i] &lt;= <span class="hljs-number">100</span>`<br><br>(http<span class="hljs-variable">s:</span>//leetcode-<span class="hljs-keyword">cn</span>.<span class="hljs-keyword">com</span>/problems/lian-<span class="hljs-keyword">xu</span>-zi-shu-zu-de-zui-da-he-lcof/)<br><br>**解：**<br><br>简单的动态规划<br>**状态定义：** <br>设动态规划列表 <span class="hljs-keyword">dp</span> ，<span class="hljs-keyword">dp</span>[i]代表以元素 nums[i]为结尾的连续子数组最大和。<br><br>**转移方程：**<br><br>- 若nums[i] &gt; <span class="hljs-keyword">dp</span>[i-<span class="hljs-number">1</span>]+nums[i]<br>  则取nums[i]<br>- 若nums[i] &lt; <span class="hljs-keyword">dp</span>[i-<span class="hljs-number">1</span>]+nums[i]<br>  则取<span class="hljs-keyword">dp</span>[i-<span class="hljs-number">1</span>]+nums[i]<br><br>**初始状态：** <br><span class="hljs-keyword">dp</span>[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]，即以 nums[<span class="hljs-number">0</span>]结尾的连续子数组最大和为nums[<span class="hljs-number">0</span>] 。<br><br>**返回值：** <br>返回 <span class="hljs-keyword">dp</span>列表中的最大值，代表全局最大值。<br><br>```<span class="hljs-keyword">python</span><br>class Solution:<br>    def maxSubArray(self, nums):<br>        <span class="hljs-keyword">if</span> nums <span class="hljs-keyword">is</span> None:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br><br>        output = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">dp</span> = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">dp</span>[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span>  i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">dp</span>[i] = <span class="hljs-built_in">max</span>(nums[i],<span class="hljs-keyword">dp</span>[i-<span class="hljs-number">1</span>]+nums[i])<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] &gt; outpu<span class="hljs-variable">t:</span><br>                output = <span class="hljs-keyword">dp</span>[i]<br>        <span class="hljs-keyword">return</span> output<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-keyword">c</span> = Solution()<br>    <span class="hljs-keyword">print</span>(str(<span class="hljs-keyword">c</span>.maxSubArray([-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">5</span>,<span class="hljs-number">4</span>])))<br></code></pre></td></tr></table></figure><h1 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46.把数字翻译成字符串"></a>46.把数字翻译成字符串</h1><p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</a></p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。<br>一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-number">12258</span><br>输出: <span class="hljs-number">5</span><br>解释: <span class="hljs-number">12258</span>有<span class="hljs-number">5</span>种不同的翻译，分别是<span class="hljs-string">&quot;bccfi&quot;</span>, <span class="hljs-string">&quot;bwfi&quot;</span>, <span class="hljs-string">&quot;bczi&quot;</span>, <span class="hljs-string">&quot;mcfi&quot;</span>和<span class="hljs-string">&quot;mzi&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= num &lt; 231</code></li></ul><p><strong>解：</strong></p><p>一维动态规划稍稍变形题</p><p>动态规划解析：</p><p><strong>转移方程：</strong><br><img src="/images/%E5%89%91%E6%8C%87offer/image-20210922201844462.png" srcset="/img/loading.gif" alt="image-20210922201844462"></p><p><strong>初始状态：</strong><br>dp[0] = 1<br>dp[1] 也需要求出来</p><p><strong>返回值：</strong><br>dp[n]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">translateNum</span>(<span class="hljs-params">self, num</span>):</span><br>        <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">10</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        numList = self.numToNumList(num)<br>        <span class="hljs-keyword">return</span> self.dpf(numList)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dpf</span>(<span class="hljs-params">self, arr</span>):</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(arr)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> self.possibilityAnalysis(arr,<span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(arr)):<br>            <span class="hljs-keyword">if</span> self.possibilityAnalysis(arr,i):<br>                dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i] = dp[i-<span class="hljs-number">1</span>]<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">possibilityAnalysis</span>(<span class="hljs-params">self, arr, index</span>):</span><br>        <span class="hljs-keyword">if</span> arr[index-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            n = <span class="hljs-built_in">int</span>(arr[index-<span class="hljs-number">1</span>]) * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(arr[index])<br>            <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n &lt; <span class="hljs-number">26</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>: <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numToNumList</span>(<span class="hljs-params">self, num</span>):</span><br>        numList = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:<br>            numList.insert(<span class="hljs-number">0</span>,num%<span class="hljs-number">10</span>)<br>            num = num // <span class="hljs-number">10</span><br>        <span class="hljs-keyword">return</span> numList<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>     s = Solution()<br>     print(s.translateNum(<span class="hljs-number">18822</span>))<br></code></pre></td></tr></table></figure><h1 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45. 把数组排成最小的数"></a>45. 把数组排成最小的数</h1><p><strong>描述:</strong><br>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [10,2]</span><br><span class="hljs-section">输出: &quot;102&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,30,34,5</span>,<span class="hljs-number">9</span>]<br>输出: &quot;<span class="hljs-number">3033459</span>&quot;<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</a></p><p><strong>提示:</strong></p><ul><li><code>0 &lt; nums.length &lt;= 100</code></li></ul><p><strong>说明:</strong></p><ul><li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li><li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li></ul><p><strong>解:</strong><br>自定义排序类型的问题。该种类型解题模板：</p><ol><li>定义元素比较规则，确定比较函数</li><li>将比较函数套入现有排序算法中(快速排序)</li><li>将排序后的元素按要求整理后输出</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumber</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(nums[<span class="hljs-number">0</span>])<br>        self.quickSort(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)<br>        output = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            output += <span class="hljs-built_in">str</span>(i)<br>        <span class="hljs-keyword">return</span> output<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">self, arr, left, right</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span><br>        l = left<br>        r = right<br>        t = arr[l]<br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> self.compare(arr[r], t) == <span class="hljs-number">1</span>:<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[l] = arr[r]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> self.compare(arr[l], t) == -<span class="hljs-number">1</span>:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[r] = arr[l]<br>                r -= <span class="hljs-number">1</span><br>            arr[l] = t<br>        self.quickSort(arr,left,l-<span class="hljs-number">1</span>)<br>        self.quickSort(arr,l+<span class="hljs-number">1</span>,right)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare</span>(<span class="hljs-params">self, strA ,strB</span>):</span><br>        a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(strA)+<span class="hljs-built_in">str</span>(strB))<br>        b = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(strB)+<span class="hljs-built_in">str</span>(strA))<br>        <span class="hljs-keyword">if</span> a == b:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> a &gt; b:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44. 数字序列中某一位的数字"></a>44. 数字序列中某一位的数字</h1><p><strong>描述:</strong><br>数字以0123456789101112131415…的格式序列化到一个字符序列中。<br>在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">11</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</a></p><p><strong>限制：</strong></p><ul><li><code>0 &lt;= n &lt; 2^31</code></li></ul><p><strong>解:</strong><br>这是个纯粹的找规律数学问题<br><img src="/images/%E5%89%91%E6%8C%87offer/image-20210925212710412.png" srcset="/img/loading.gif" alt="image-20210925212710412"></p><p>根据以上分析，可将求解分为三步：</p><ol><li>确定 n 所在 数字 的 位数 ，记为 digit ；</li><li>确定 n 所在的 数字 ，记为 num ；</li><li>确定 n 是num 中的哪一数位，并返回结果。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findNthDigit</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        digit = <span class="hljs-number">1</span><br>        start = <span class="hljs-number">1</span><br>        count = <span class="hljs-number">9</span><br>        <span class="hljs-keyword">while</span> n &gt; count:<br>            n -= count<br>            digit += <span class="hljs-number">1</span><br>            start *= <span class="hljs-number">10</span><br>            count = digit * start * <span class="hljs-number">9</span><br>        <br>        num = start + (n-<span class="hljs-number">1</span>) // digit<br>        index = (n-<span class="hljs-number">1</span>) % digit<br>        output = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(num)[index])<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a>47. 礼物的最大价值</h1><p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/</a></p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。<br>你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。<br>给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,5,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[4,2,1]</span></span><br><span class="hljs-comment">]</span><br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><p><strong>解：</strong></p><p>简单的二维动态规划，注意python中二维数组的初始化问题<br><a href="https://blog.csdn.net/weixin_30023527/article/details/113507419">https://blog.csdn.net/weixin_30023527/article/details/113507419</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxValue</span>(<span class="hljs-params">self, grid</span>):</span><br>        xLen = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        yLen = <span class="hljs-built_in">len</span>(grid)<br>        <span class="hljs-keyword">if</span> xLen == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> yLen == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        dp = [[<span class="hljs-number">0</span>]* xLen <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(yLen)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,xLen):<br>            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][i]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,yLen):<br>            dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,yLen):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,xLen):<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    grid = [ [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]<br>    print(s.maxValue(grid))<br></code></pre></td></tr></table></figure><h1 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48. 最长不含重复字符的子字符串"></a>48. 最长不含重复字符的子字符串</h1><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>s.length &lt;= 40000</code></li></ul><p><strong>解：</strong></p><p>方法一：<br>使用双指针与字典(快些)或集合(慢些)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        longestLen = <span class="hljs-number">1</span><br>        p = <span class="hljs-number">0</span><br>        q = <span class="hljs-number">0</span><br>        charDict = <span class="hljs-built_in">dict</span>()<br>        long = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[q] <span class="hljs-keyword">in</span> charDict:<br>                longestLen = <span class="hljs-built_in">max</span>(q-p, longestLen) <br>                p = charDict[s[q]] + <span class="hljs-number">1</span><br>                charDict[s[q]] = q<br>                q += <span class="hljs-number">1</span><br>                long = q - p<br>                <span class="hljs-keyword">for</span> key,values <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(charDict.items()):<br>                    <span class="hljs-keyword">if</span> values &lt; p:<br>                        charDict.pop(key)   <br>            <span class="hljs-keyword">else</span>:<br>                charDict[s[q]] = q<br>                q += <span class="hljs-number">1</span><br>                long += <span class="hljs-number">1</span><br>        longestLen = <span class="hljs-built_in">max</span>(long, longestLen)<br>        <span class="hljs-keyword">return</span> longestLen<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.lengthOfLongestSubstring(<span class="hljs-string">&quot;aab&quot;</span>))<br></code></pre></td></tr></table></figure><h1 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a>49. 丑数</h1><p><strong>描述:</strong><br>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。<br>求按从小到大的顺序的第 n 个丑数。</p><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">https://leetcode-cn.com/problems/chou-shu-lcof/</a></p><p><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 10</span><br><span class="hljs-section">输出: 12</span><br><span class="hljs-section">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong> </p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthUglyNumber</span>(<span class="hljs-params">self, n</span>):</span><br>        a=b=c=<span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>]*n<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>            n2,n3,n5 = dp[a]*<span class="hljs-number">2</span>,dp[b]*<span class="hljs-number">3</span>,dp[c]*<span class="hljs-number">5</span><br>            dp[i] = <span class="hljs-built_in">min</span>(n2,n3,n5)<br>            <span class="hljs-keyword">if</span> dp[i] == n2:<br>                a += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dp[i] == n3:<br>                b += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dp[i] == n5:<br>                c += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50.第一个只出现一次的字符"></a>50.第一个只出现一次的字符</h1><p>在字符串 s 中找出第一个只出现一次的字符。<br>如果没有，返回一个单空格。<br> s 只包含小写字母。</p><p><strong>示例 1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;abaccdeff&quot;</span><br>输出：&#x27;b&#x27;<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;&quot;</span> <br>输出：&#x27; &#x27;<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= s 的长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</a></p><p><strong>解：</strong></p><p>使用字典(HashMap)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstUniqChar</span>(<span class="hljs-params">self, s</span>):</span><br>        charDict = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> charDict:<br>                charDict[c] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                charDict[c] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> charDict.items():<br>            <span class="hljs-keyword">if</span> v: <span class="hljs-keyword">return</span> k<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span><br></code></pre></td></tr></table></figure><h1 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a>51. 数组中的逆序对</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,5,6,4]</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 数组长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p><p><strong>解:</strong><br>归并排序变形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reversePairs</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        self.arr = nums<br>        self.output = <span class="hljs-number">0</span><br>        print(self.mergeSort(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">return</span> self.output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">self,left,right</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span> [self.arr[left]]<br>        mid = (left+right) // <span class="hljs-number">2</span><br>        leftArr = self.mergeSort(left,mid)<br>        rightArr = self.mergeSort(mid+<span class="hljs-number">1</span>,right)<br>        mergeArr = <span class="hljs-built_in">list</span>()<br>        p = <span class="hljs-number">0</span><br>        q = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> p &lt; <span class="hljs-built_in">len</span>(leftArr) <span class="hljs-keyword">and</span> q &lt; <span class="hljs-built_in">len</span>(rightArr):<br>            <span class="hljs-keyword">if</span> rightArr[q] &lt; leftArr[p]:<br>                self.output += <span class="hljs-built_in">len</span>(leftArr) - p<br>                mergeArr.append(rightArr[q])<br>                q += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                mergeArr.append(leftArr[p])<br>                p += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> q &lt; <span class="hljs-built_in">len</span>(rightArr):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(q,<span class="hljs-built_in">len</span>(rightArr)):<br>                mergeArr.append(rightArr[i])<br>        <span class="hljs-keyword">if</span> p &lt; <span class="hljs-built_in">len</span>(leftArr):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p,<span class="hljs-built_in">len</span>(leftArr)):<br>                mergeArr.append(leftArr[i])<br>        <span class="hljs-keyword">return</span> mergeArr<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.reversePairs([<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]))<br></code></pre></td></tr></table></figure><h1 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a>52. 两个链表的第一个公共节点</h1><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="/images/%E5%89%91%E6%8C%87offer/160_statement.png" srcset="/img/loading.gif" alt="img"></a></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="/images/%E5%89%91%E6%8C%87offer/160_example_1.png" srcset="/img/loading.gif" alt="img"></a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<br><span class="hljs-attr">intersectVal</span> = <span class="hljs-number">8</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">3</span><br>输出：<br>Reference of the node <span class="hljs-keyword">with</span> <span class="hljs-attr">value</span> = <span class="hljs-number">8</span><br>输入解释：<br>相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 A 为 [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 A 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="/images/%E5%89%91%E6%8C%87offer/160_example_3.png" srcset="/img/loading.gif" alt="img"></a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<br><span class="hljs-attr">intersectVal</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">2</span><br>输出：<br><span class="hljs-literal">null</span><br>输入解释：<br>从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 intersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>解释：<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span>。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li></ul><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p><p><strong>解：</strong></p><p>双指针交叉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getIntersectionNode</span>(<span class="hljs-params">self, headA, headB</span>):</span><br>        <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> headB == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        p = headA<br>        q = headB<br>        <span class="hljs-keyword">while</span> p != q:<br>            p = p.<span class="hljs-built_in">next</span><br>            q = q.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> p == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> q == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> p == <span class="hljs-literal">None</span>:<br>                p = headB<br>            <br>            <span class="hljs-keyword">if</span> q == <span class="hljs-literal">None</span>:<br>                q = headA<br>        <span class="hljs-keyword">return</span> p<br></code></pre></td></tr></table></figure><h1 id="53-在排序数组中查找数字-I"><a href="#53-在排序数组中查找数字-I" class="headerlink" title="53. 在排序数组中查找数字 I"></a>53. 在排序数组中查找数字 I</h1><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</a></p><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><p><strong>解：</strong></p><p>二分法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">self, nums, target</span>):</span><br>        <span class="hljs-keyword">if</span> nums == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> self.dichotomous(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>,target)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dichotomous</span>(<span class="hljs-params">self, arr, left, right, target</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">if</span> arr[left] == target:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        mid = left + (right - left) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> self.dichotomous(arr,left,mid,target) + self.dichotomous(arr,mid+<span class="hljs-number">1</span>,right,target)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.search([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h1 id="53-在排序数组中查找数字-II"><a href="#53-在排序数组中查找数字-II" class="headerlink" title="53. 在排序数组中查找数字 II"></a>53. 在排序数组中查找数字 II</h1><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。<br>在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong><br>输入: [0,1,3]<br>输出: 2</p><p><strong>示例 2:</strong><br>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p><p><strong>限制：</strong><br>1 &lt;= 数组长度 &lt;= 10000</p><p>链接：<br><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a></p><p><strong>解：</strong></p><p>二分法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">missingNumber</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> nums[l - <span class="hljs-number">1</span>] == l-<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> l<br><br>        left = <span class="hljs-number">0</span><br>        right = l-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> mid == nums[mid]:<br>                left = mid + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                right = mid - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">return</span> left<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.missingNumber([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]))<br></code></pre></td></tr></table></figure><h1 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54. 二叉搜索树的第k大节点"></a>54. 二叉搜索树的第k大节点</h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>   <span class="hljs-number">3</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>       <span class="hljs-number">5</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span><br>  /<br> <span class="hljs-number">1</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><p>1 ≤ k ≤ 二叉搜索树元素个数</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a></p><p><strong>解：</strong><br>二叉树反向的中序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kthLargest</span>(<span class="hljs-params">self, root, k</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        self.rMidOrderList = <span class="hljs-built_in">list</span>()<br>        self.k = k<br>        self.reverseMidTraversal(root)<br>        <span class="hljs-keyword">return</span> self.rMidOrderList[k-<span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseMidTraversal</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(self.rMidOrderList) == self.k:<br>            <span class="hljs-keyword">return</span><br>        self.reverseMidTraversal(root.right)<br>        self.rMidOrderList.append(root.val)<br>        self.reverseMidTraversal(root.left)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    head = TreeNode(<span class="hljs-number">3</span>)<br>    head.left = TreeNode(<span class="hljs-number">1</span>)<br>    head.right = TreeNode(<span class="hljs-number">4</span>)<br>    head.left.right = TreeNode(<span class="hljs-number">2</span>)<br>    s.kthLargest(head,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h1 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55. 二叉树的深度"></a>55. 二叉树的深度</h1><p>输入一棵二叉树的根节点，求该树的深度。<br>从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>例如：</strong><br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回它的最大深度 3 。</p><p><strong>提示：</strong><br>节点总数 &lt;= 10000</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof</a></p><p><strong>解：</strong></p><p>二叉树的深度优先搜索或广度优先搜索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        self.deep = <span class="hljs-number">0</span><br>        self.dfs(root,<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> self.deep<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self, root, d</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        d += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> d &gt; self.deep:<br>            self.deep = d<br>        self.dfs(root.left, d)<br>        self.dfs(root.right, d)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">self, root</span>):</span><br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        deep = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            tq = <span class="hljs-built_in">list</span>()<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    tq.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    tq.append(node.right)<br>            queue = tq<br>            deep += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> deep<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    head = TreeNode(<span class="hljs-number">3</span>)<br>    head.left = TreeNode(<span class="hljs-number">1</span>)<br>    head.right = TreeNode(<span class="hljs-number">4</span>)<br>    head.left.right = TreeNode(<span class="hljs-number">2</span>)<br>    print(s.maxDepth(head))<br></code></pre></td></tr></table></figure><h1 id="55-II-平衡二叉树"><a href="#55-II-平衡二叉树" class="headerlink" title="55. II 平衡二叉树"></a>55. II 平衡二叉树</h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。<br>如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><strong>示例 1:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong><br>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">      <span class="hljs-number">1</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><p><strong>限制：</strong></p><ul><li><code>0 &lt;= 树的结点个数 &lt;= 10000</code></li></ul><p><strong>解：</strong><br>先后序遍历再嵌套第55题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBalanced</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">return</span> self.postOrderTraversal(root)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postOrderTraversal</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        ld = self.getDeepByBFS(root.left)<br>        rd = self.getDeepByBFS(root.right)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(ld - rd) &gt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> self.postOrderTraversal(root.left) <span class="hljs-keyword">and</span> self.postOrderTraversal(root.right)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getDeepByBFS</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        deep = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            t = <span class="hljs-built_in">list</span>()<br>            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> p.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    t.append(p.left)<br>                <span class="hljs-keyword">if</span> p.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    t.append(p.right)<br>            deep += <span class="hljs-number">1</span><br>            queue = t<br>        <span class="hljs-keyword">return</span> deep<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    head = TreeNode(<span class="hljs-number">3</span>)<br>    head.left = TreeNode(<span class="hljs-number">1</span>)<br>    head.right = TreeNode(<span class="hljs-number">4</span>)<br>    head.left.right = TreeNode(<span class="hljs-number">2</span>)<br>    print(s.isBalanced(head))<br></code></pre></td></tr></table></figure><h1 id="56-I-数组中数字出现的次数"><a href="#56-I-数组中数字出现的次数" class="headerlink" title="56. I 数组中数字出现的次数"></a>56. I 数组中数字出现的次数</h1><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。<br>要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,1,4,6]</span><br>输出：<span class="hljs-comment">[1,6]</span> 或 <span class="hljs-comment">[6,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,10,4,1,4,3,3]</span><br>输出：<span class="hljs-comment">[2,10]</span> 或 <span class="hljs-comment">[10,2]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10000</code></li></ul><p><strong>解：</strong></p><p>异或的骚操作，不看题解真想不到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumbers</span>(<span class="hljs-params">self, nums</span>):</span><br>        ox = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            ox ^= i<br>        m = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> ox &amp; m == <span class="hljs-number">0</span>:<br>            ox &lt;&lt;= <span class="hljs-number">1</span><br>        x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> i &amp; m == <span class="hljs-number">0</span>:<br>                x ^= i<br>            <span class="hljs-keyword">else</span>:<br>                y ^= i<br>        <span class="hljs-keyword">return</span> x,y<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.singleNumbers([<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]))<br></code></pre></td></tr></table></figure><h1 id="56-II-数组中数字出现的次数"><a href="#56-II-数组中数字出现的次数" class="headerlink" title="56.  II 数组中数字出现的次数"></a>56.  II 数组中数字出现的次数</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</a></p><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。<br>请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">3,4,3,3</span>]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[9,1,7,9,7,9,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10000</code></li><li><code>1 &lt;= nums[i] &lt; 2^31</code></li></ul><p><strong>解：</strong><br>用集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        oneTimeNumList = <span class="hljs-built_in">list</span>()<br>        numSet = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> numSet:<br>                numSet.add(i)<br>                oneTimeNumList.append(i)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> oneTimeNumList:<br>                    oneTimeNumList.remove(i)<br>        <span class="hljs-keyword">return</span> oneTimeNumList.pop()<br></code></pre></td></tr></table></figure><h1 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57. 和为s的两个数字"></a>57. 和为s的两个数字</h1><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。<br>如果有多对数字的和等于s，则输出任意一对即可。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[2,7]</span> 或者 <span class="hljs-comment">[7,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[10,26,30,31,47,60]</span>, target = 40<br>输出：<span class="hljs-comment">[10,30]</span> 或者 <span class="hljs-comment">[30,10]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li></ul><p><strong>解：</strong><br>先折半查找确定位置，后双指针对撞</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums, target</span>):</span><br>        <span class="hljs-keyword">if</span> nums <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> nums[<span class="hljs-number">0</span>] &gt; target:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        left = <span class="hljs-number">0</span><br>        right = self.dichotomous(nums,target)<br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            t = nums[left] + nums[right]<br>            <span class="hljs-keyword">if</span> t == target:<br>                <span class="hljs-keyword">return</span> [nums[left], nums[right]]<br>            <span class="hljs-keyword">elif</span> t &lt; target:<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dichotomous</span>(<span class="hljs-params">self, arr, target</span>):</span><br>        <span class="hljs-keyword">if</span> arr[<span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span>] &lt; target:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span>(left &lt; right):<br>            mid = (left + right)//<span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> arr[mid] &gt; target:<br>                right = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> arr[mid] &lt; target:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> arr[mid] == target:<br>                <span class="hljs-keyword">return</span> mid -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> left<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    nums = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>]<br>    print(s.twoSum(nums,<span class="hljs-number">12</span>))<br></code></pre></td></tr></table></figure><h1 id="57-II和为s的连续正数序列"><a href="#57-II和为s的连续正数序列" class="headerlink" title="57 . II和为s的连续正数序列"></a>57 . II和为s的连续正数序列</h1><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：target = <span class="hljs-number">9</span><br>输出：<span class="hljs-string">[[2,3,4],[4,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：target = <span class="hljs-number">15</span><br>输出：<span class="hljs-string">[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= target &lt;= 10^5</code></li></ul><p><strong>解:</strong></p><p>滑动窗口双指针，用求和公式降低时间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">self, target</span>):</span><br>        left = <span class="hljs-number">1</span><br>        right = <span class="hljs-built_in">int</span>((<span class="hljs-built_in">pow</span>((<span class="hljs-number">0.25</span> + <span class="hljs-number">2</span>*target),<span class="hljs-number">0.5</span>) - <span class="hljs-number">0.5</span>))<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> left != right:<br>            <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left,right+<span class="hljs-number">1</span>):<br>                <span class="hljs-built_in">sum</span> += i<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &gt; target:<br>                right -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> &lt; target:<br>                left += <span class="hljs-number">1</span><br>                right += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                output.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(left,right+<span class="hljs-number">1</span>)))<br>                left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    output = s.findContinuousSequence(<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> output:<br>        print(i)<br></code></pre></td></tr></table></figure><h1 id="58-I-翻转单词顺序"><a href="#58-I-翻转单词顺序" class="headerlink" title="58. I 翻转单词顺序"></a>58. I 翻转单词顺序</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。<br>为简单起见，标点符号和普通字母一样处理。<br>例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例 1：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入: <span class="hljs-comment">&quot;the sky is blue&quot;</span><br>输出: <span class="hljs-comment">&quot;blue is sky the&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;  hello world!  &quot;</span><br><span class="hljs-section">输出: &quot;world! hello&quot;</span><br><span class="hljs-section">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入: <span class="hljs-comment">&quot;a good   example&quot;</span><br>输出: <span class="hljs-comment">&quot;example good a&quot;</span><br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><p><strong>解：</strong></p><p>用栈，python3特性，双指针都可以解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWordsByStack</span>(<span class="hljs-params">self, s</span>):</span><br>        stack = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s.split():<br>            stack.insert(<span class="hljs-number">0</span>,c)<br>        s = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(stack)):<br>            s += <span class="hljs-string">&quot; &quot;</span> + stack.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> s[<span class="hljs-number">1</span>:]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWordsByPy3</span>(<span class="hljs-params">self, s</span>):</span><br>        strList = s.split()[::-<span class="hljs-number">1</span>]<br>        s = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strList:<br>            s += <span class="hljs-string">&quot; &quot;</span> + i<br>        <span class="hljs-keyword">return</span> s[<span class="hljs-number">1</span>:]<br></code></pre></td></tr></table></figure><h1 id="59-I-滑动窗口的最大值"><a href="#59-I-滑动窗口的最大值" class="headerlink" title="59. I 滑动窗口的最大值"></a>59. I 滑动窗口的最大值</h1><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br>解释: <br><br>  滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</a></p><p><strong>提示：</strong></p><p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-comment"># 滑动窗口暴力破解</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSlidingWindowByBP</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        q = k - <span class="hljs-number">1</span><br>        maxList = <span class="hljs-built_in">list</span>()<br>        maxNum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; maxNum:<br>                maxNum = nums[i]<br>        maxList.append(maxNum)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            q += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> q &gt;= <span class="hljs-built_in">len</span>(nums):<br>                <span class="hljs-keyword">break</span><br>            maxNum = nums[i]<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums[j] &gt;  maxNum:<br>                    maxNum = nums[j]<br>            maxList.append(maxNum)<br>        <span class="hljs-keyword">return</span> maxList<br>    <span class="hljs-comment"># 单调队列优化解法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">monoQueuePush</span>(<span class="hljs-params">self, monoQueue, element</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoQueue) == <span class="hljs-number">0</span>:<br>            monoQueue.append(element)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> element &lt;= monoQueue[-<span class="hljs-number">1</span>]:<br>            monoQueue.append(element)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(monoQueue) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> element &gt; monoQueue[-<span class="hljs-number">1</span>]:<br>                monoQueue.pop()<br>            monoQueue.append(element)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSlidingWindowByMonoQueues</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums<br>        maxList = <span class="hljs-built_in">list</span>()<br>        monoQueue = <span class="hljs-built_in">list</span>()<br><br>        monoQueue.append(nums[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,k):<br>            self.monoQueuePush(monoQueue, nums[i])<br>        maxList.append(monoQueue[<span class="hljs-number">0</span>])<br><br>        p = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> monoQueue[<span class="hljs-number">0</span>] == nums[p]:<br>                monoQueue.pop(<span class="hljs-number">0</span>)<br>            p += <span class="hljs-number">1</span><br>            self.monoQueuePush(monoQueue, nums[i])<br>            maxList.append(monoQueue[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> maxList<br></code></pre></td></tr></table></figure><h1 id="59-II-队列的最大值"><a href="#59-II-队列的最大值" class="headerlink" title="59. II 队列的最大值"></a>59. II 队列的最大值</h1><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p><strong>示例 1：</strong><br>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出:<br>[null,null,null,2,1,2]</p><p><strong>示例 2：</strong><br>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出:<br>[null,-1,-1]</p><p><strong>限制：</strong><br>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a></p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.queue = <span class="hljs-built_in">list</span>()<br>        self.maxQueue = <span class="hljs-built_in">list</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_value</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.maxQueue) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.maxQueue[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_back</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>):</span><br>        self.queue.append(value)<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(self.maxQueue) !=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> self.maxQueue[-<span class="hljs-number">1</span>] &lt; value:<br>            self.maxQueue.pop()<br>        self.maxQueue.append(value)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop_front</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.queue) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        x = self.queue.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> x == self.maxQueue[<span class="hljs-number">0</span>]:<br>            self.maxQueue.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><h1 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60. n个骰子的点数"></a>60. n个骰子的点数</h1><p><strong>描述:</strong><br>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。<br>输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/</a></p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: <span class="hljs-number">1</span><br>输出: [<span class="hljs-number">0.16667,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">16667</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: <span class="hljs-number">2</span><br>输出: [<span class="hljs-number">0.02778,0</span>.<span class="hljs-number">05556,0</span>.<span class="hljs-number">08333,0</span>.<span class="hljs-number">11111,0</span>.<span class="hljs-number">13889,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">13889,0</span>.<span class="hljs-number">11111,0</span>.<span class="hljs-number">08333,0</span>.<span class="hljs-number">05556,0</span>.<span class="hljs-number">02778</span>]<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dicesProbability</span>(<span class="hljs-params">self, n</span>):</span><br>        dp = [<span class="hljs-number">0</span>]*n<br>        dp[<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>]*<span class="hljs-number">6</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>            dp[i] = [<span class="hljs-number">0</span>]*((i+<span class="hljs-number">1</span>)*<span class="hljs-number">6</span>-i)<br>            p = <span class="hljs-number">0</span><br>            q = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dp[i])):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">6</span>:<br>                    print(<span class="hljs-string">&quot;good6&quot;</span>)<br>                <span class="hljs-keyword">if</span> q == <span class="hljs-built_in">len</span>(dp[i-<span class="hljs-number">1</span>])-<span class="hljs-number">1</span>:<br>                    p += <span class="hljs-number">1</span>                  <br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> q - p == <span class="hljs-number">5</span>:<br>                        p += <span class="hljs-number">1</span><br>                        q += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        q += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p,q+<span class="hljs-number">1</span>):<br>                    dp[i][j] += dp[i-<span class="hljs-number">1</span>][k]<br>        total = <span class="hljs-built_in">pow</span>(<span class="hljs-number">6</span>,n)<br>        output = dp[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(output)):<br>            output[i] = <span class="hljs-built_in">float</span>(output[i] / total)<br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.dicesProbability(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><h1 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a>63. 股票的最大利润</h1><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/</a></p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,1,5,3,6,4]</span><br><span class="hljs-section">输出: 5</span><br><span class="hljs-section">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 数组长度 &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(prices)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        minPrice = prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>],prices[i]-minPrice)<br>            <span class="hljs-keyword">if</span> prices[i] &lt; minPrice:<br>                minPrice = prices[i]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66. 构建乘积数组"></a>66. 构建乘积数组</h1><p><strong>描述:</strong><br>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是数组 <code>A</code> 中除了下标 <code>i</code> 以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/</a></p><p><strong>示例:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: <span class="hljs-string">[1,2,3,4,5]</span><br>输出: <span class="hljs-string">[120,60,40,30,24]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有元素乘积之和不会溢出 32 位整数</li><li><code>a.length &lt;= 100000</code></li></ul><p><strong>解:</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210925225643388.png" srcset="/img/loading.gif" alt="image-20210925225643388"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constructArr</span>(<span class="hljs-params">self, a</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> a<br>        b = [<span class="hljs-number">1</span>]*<span class="hljs-built_in">len</span>(a)<br>        t = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(a)):<br>            b[i] = b[i-<span class="hljs-number">1</span>] * a[i-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            t *= a[j+<span class="hljs-number">1</span>]<br>            b[j] *= t<br>        <span class="hljs-keyword">return</span> b<br></code></pre></td></tr></table></figure><h1 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67. 把字符串转换成整数"></a>67. 把字符串转换成整数</h1><p><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</a></p><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><blockquote><p>注意：<br>假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p></blockquote><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;42&quot;</span><br><span class="hljs-section">输出: 42</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;   -42&quot;</span><br><span class="hljs-section">输出: -42</span><br><span class="hljs-section">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;4193 with words&quot;</span><br><span class="hljs-section">输出: 4193</span><br><span class="hljs-section">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;words and 987&quot;</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br>     因此无法执行有效的转换。<br></code></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: &quot;-<span class="hljs-number">91283472332</span>&quot;<br>输出: -<span class="hljs-number">2147483648</span><br>解释: 数字 &quot;-<span class="hljs-number">91283472332</span>&quot; 超过 <span class="hljs-number">32</span> 位有符号整数范围。 <br>     因此返回 INT_MIN (−<span class="hljs-number">231</span>) 。<br></code></pre></td></tr></table></figure><p>解：</p><p>愣做，多考虑特殊情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strToInt</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>.strip()                      <span class="hljs-comment"># 删除首尾空格</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">str</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                   <span class="hljs-comment"># 字符串为空则直接返回</span><br>        res, i, sign = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>        int_max, int_min, bndry = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>, -<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>, <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> // <span class="hljs-number">10</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>: sign = -<span class="hljs-number">1</span>            <span class="hljs-comment"># 保存负号</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;+&#x27;</span>: i = <span class="hljs-number">0</span>              <span class="hljs-comment"># 若无符号位，则需从 i = 0 开始数字拼接</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>[i:]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;9&#x27;</span> : <span class="hljs-keyword">break</span>     <span class="hljs-comment"># 遇到非数字的字符则跳出</span><br>            <span class="hljs-keyword">if</span> res &gt; bndry <span class="hljs-keyword">or</span> res == bndry <span class="hljs-keyword">and</span> c &gt; <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-keyword">return</span> int_max <span class="hljs-keyword">if</span> sign == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> int_min <span class="hljs-comment"># 数字越界处理</span><br>            res = <span class="hljs-number">10</span> * res + <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment"># 数字拼接</span><br>        <span class="hljs-keyword">return</span> sign * res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>New2048开发文档</title>
    <link href="/2021/07/01/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <url>/2021/07/01/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="New2048开发日志"><a href="#New2048开发日志" class="headerlink" title="New2048开发日志"></a>New2048开发日志</h1><p><strong>项目信息：</strong><br>项目负责人：买烤麸烤饼<br>主程序：买烤麸烤饼<br>美工：买烤麸烤饼<br>音效：洛一<br>配音：小鸠<br>项目开发周期：2021.6.25-2021.7.4</p><p><strong>版本信息：</strong></p><ul><li>v1.0 完成2048的基础玩法</li><li>v2.0 增加球球新玩法</li></ul><h1 id="1-玩法分析"><a href="#1-玩法分析" class="headerlink" title="1. 玩法分析"></a>1. 玩法分析</h1><h2 id="1-1-经典模式"><a href="#1-1-经典模式" class="headerlink" title="1.1 经典模式"></a>1.1 经典模式</h2><p><strong>游戏原型：</strong>2048</p><p><strong>游戏目标：</strong><br>合成更多数字块以得到更高的分数</p><p><strong>得分计算：</strong><br>当两个相同数字块合并时，得分+=新数字块的数字</p><p><strong>玩家操作：</strong></p><ul><li>向上滑动<br>上方向键</li><li>向下滑动<br>下方向键</li><li>向左滑动<br>左方向键</li><li>向右滑动<br>右方向键</li></ul><p><strong>失败判定：</strong><br>棋盘被数字填满，无法进行有效移动，判负，游戏结束。</p><p><strong>流程简述：</strong><br>开始时棋盘内随机出现两个数字<br>出现的数字仅可能为2或4。</p><p>玩家可以选择上下左右四个方向<br>若棋盘内的数字出现位移或合并，视为有效移动。</p><p>玩家选择的方向上若有相同的数字则合并<br>每次有效移动可以同时合并，但不可以连续合并。</p><p>合并所得的所有新生成数字想加即为该步的有效得分。</p><p>玩家选择的方向行或列前方有空格则出现位移。</p><p>每有效移动一步，棋盘的空位(无数字处)随机出现一个数字(依然可能为2或4)。</p><p>棋盘被数字填满，无法进行有效移动，判负，游戏结束。</p><p>棋盘上出现2048，判胜，游戏结束。<br>也可以继续游戏，攒出更大的数字</p><h2 id="1-1-球球模式"><a href="#1-1-球球模式" class="headerlink" title="1.1 球球模式"></a>1.1 球球模式</h2><p><strong>游戏原型：</strong>合成大西瓜</p><p><strong>游戏目标：</strong><br>合成更多数字球以得到更高的分数</p><p><strong>得分计算：</strong><br>当两个相同数字球合并时，得分+=新数字块的数字</p><p><strong>玩家操作：</strong></p><ul><li>触摸控制球球生成位置<br>鼠标控制球球生成位置</li><li>长按抖动水池<br>按空格抖动水池</li></ul><p><strong>失败判断：</strong><br>当水池被球球填满时游戏结束</p><p><strong>流程简述：</strong><br>随机生成2，4，8的球，掉落至水池中<br>遇到相同数字的球则合并</p><p>玩家可以在水池上方控制潜水艇的左右位置决定新生成球的位置</p><p>当水池被填满时游戏结束</p><h1 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h1><h2 id="2-1-游戏实体分析"><a href="#2-1-游戏实体分析" class="headerlink" title="2.1 游戏实体分析"></a>2.1 游戏实体分析</h2><h3 id="2-1-1-经典模式"><a href="#2-1-1-经典模式" class="headerlink" title="2.1.1 经典模式"></a>2.1.1 经典模式</h3><ul><li>数字块<br>有数字2,4,8,16,32…<br>不同数字使用不同的精灵图片<br>但是是同一个预制体</li><li>棋盘<br>能放下4*4=16个数字块的棋盘</li></ul><h3 id="2-1-2-球球模式"><a href="#2-1-2-球球模式" class="headerlink" title="2.1.2 球球模式"></a>2.1.2 球球模式</h3><ul><li>数字球<br>有数字2,4,8,16,32…<br>不同数字使用不同的精灵图片，有不同的大小<br>但是是同一个预制体</li><li>水池<br>左，右，下三个方向有碰撞体积<br>上方有触发器<br>可以晃动</li><li>潜水艇<br>通过潜水艇来释放数字球<br>潜水艇在水池上方固定高度移动</li></ul><h2 id="2-2-UI需求分析"><a href="#2-2-UI需求分析" class="headerlink" title="2.2 UI需求分析"></a>2.2 UI需求分析</h2><p>UI需求树如下：</p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210911211247880.png" srcset="/img/loading.gif" alt="UI需求树"></p><h2 id="2-3-音效需求分析"><a href="#2-3-音效需求分析" class="headerlink" title="2.3 音效需求分析"></a>2.3 音效需求分析</h2><p><strong>配音内容：</strong></p><table><thead><tr><th>用于</th><th>内容</th><th>描述</th></tr></thead><tbody><tr><td>游戏开始</td><td>Game Start！</td><td>日式大佐英语，元气语气</td></tr><tr><td>游戏开始</td><td>游戏开始了哦！</td><td>中文，认真系美少女语气</td></tr><tr><td>游戏结束</td><td>Game Over…</td><td>日式大佐英语，惋惜语气</td></tr><tr><td>游戏结束</td><td>失敗しました(失败啦…)</td><td>日语，无口少女棒读</td></tr><tr><td>新纪录</td><td>New Score！</td><td>日式大佐英语，元气语气</td></tr></tbody></table><p>配音员：小鸠</p><ul><li>BGM 一条</li><li>人声配音5条</li></ul><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h1><h2 id="3-1-工程类图"><a href="#3-1-工程类图" class="headerlink" title="3.1 工程类图"></a>3.1 工程类图</h2><h3 id="3-1-1-主场景-HomePageScene"><a href="#3-1-1-主场景-HomePageScene" class="headerlink" title="3.1.1 主场景(HomePageScene)"></a>3.1.1 主场景(HomePageScene)</h3><p><strong>实体类图设计</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210704201328215.png" srcset="/img/loading.gif" alt="主场景(HomePageScene)实体类图设计"></p><p><strong>活动图</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210704203522669.png" srcset="/img/loading.gif" alt="主场景活动图"></p><p><strong>View视图类：</strong></p><p>该场景为游戏开始时的主场景，用于玩家选择模式，加载游戏，查看游戏介绍等功能的实现。<br>在该场景下有一个主画布，该主画布下有3个功能面板，详细情况如下：</p><ul><li>HomePanel<br>主面板<br>是游戏的入口界面</li><li>AboutPanel<br>关于面板<br>是游戏的介绍界面</li><li>ModeChosePanel<br>模式选择面板<br>用于选择开始与加载的游戏模式</li></ul><p>该场景的所有视图对象(UI)由<strong>HomePageUIManager</strong>类控制，它作为组件挂载在主画布<strong>Canvas</strong>上，其中包含了各个面板的全部按键响应函数。</p><p><strong>Controller控制类：</strong></p><p><strong>PlayerSetting</strong>类是该场景的唯一控制类，该类用于记录用户两种游戏设置：</p><ul><li>bool Mute<br>游戏是否静音</li><li>bool IsLoad<br>是否加载之前保存的游戏进度</li></ul><p>该类的脚本挂载至一个名叫<strong>PlayerSetting</strong>的空物体上，并设置为<strong>DontDestroyOnLoad</strong>(切换场景时不销毁该GO)。它会传递到下一个场景，即游戏场景，来决定是否加载之前保存的游戏进度。</p><h3 id="3-1-2-经典模式场景-GameScene1"><a href="#3-1-2-经典模式场景-GameScene1" class="headerlink" title="3.1.2 经典模式场景(GameScene1)"></a>3.1.2 经典模式场景(GameScene1)</h3><p><strong>实体类图设计:</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt="经典模式实体类图"></p><p><strong>场景活动图:</strong></p><p><img src="images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2048-%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%BC%8F%E5%9C%BA%E6%99%AF%E6%B4%BB%E5%8A%A8%E5%9B%BE.png" srcset="/img/loading.gif" alt="2048-经典模式场景活动图"></p><p><strong>View视图类:</strong></p><p>该场景为经典模式游戏的场景，用于玩家游玩经典模式的2048小游戏。<br>在该场景下有三个画布，详细情况如下：</p><ul><li>GameCanvas<br>游戏画布<br>是进行游戏的界面</li><li>PauseCanvas<br>暂停画布<br>是游戏暂停时的功能性画布</li><li>GGCanvas<br>游戏失败画布<br>是游戏失败后弹出的画布</li></ul><p>该场景的所有视图对象(UI)由<strong>GamePageUIManager</strong>类控制，它作为组件挂载在EventSystem上，其中包含了各个画布的全部按键响应函数。</p><p>值得注意的是，因为UI与游戏物体高度融合，Map应当显示在UI背景的前方。因此画布应当设置为<strong>Screen Space-Camera渲染模式</strong>。相关知识详见<a href="https://mycroftcooper.github.io/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/">UGUI详解-画布</a></p><h3 id="3-1-3-球球模式场景-GameScene2"><a href="#3-1-3-球球模式场景-GameScene2" class="headerlink" title="3.1.3 球球模式场景(GameScene2)"></a>3.1.3 球球模式场景(GameScene2)</h3><p><strong>实体类图设计:</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2048-%E7%90%83%E7%90%83%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt="2048-球球模式设计类图"></p><h2 id="3-2-UI实现"><a href="#3-2-UI实现" class="headerlink" title="3.2 UI实现"></a>3.2 UI实现</h2><p><strong>开始界面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629220904860.png" srcset="/img/loading.gif" alt="开始界面"></p><p><strong>模式选择页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221015700.png" srcset="/img/loading.gif" alt="模式选择页面"></p><p><strong>经典模式页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221144410.png" srcset="/img/loading.gif" alt="经典模式页面"></p><p><strong>球球模式页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221506826.png" srcset="/img/loading.gif" alt="球球模式页面"></p><p><strong>暂停页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221318433.png" srcset="/img/loading.gif" alt="暂停页面"></p><p><strong>失败页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221350145.png" srcset="/img/loading.gif" alt="失败页面"></p><h2 id="3-3-技术实现亮点与难点"><a href="#3-3-技术实现亮点与难点" class="headerlink" title="3.3 技术实现亮点与难点"></a>3.3 技术实现亮点与难点</h2><h3 id="3-3-1-2048经典模式核心玩法算法"><a href="#3-3-1-2048经典模式核心玩法算法" class="headerlink" title="3.3.1 2048经典模式核心玩法算法"></a>3.3.1 2048经典模式核心玩法算法</h3><h4 id="数字块的抽象"><a href="#数字块的抽象" class="headerlink" title="数字块的抽象"></a>数字块的抽象</h4><p>将每个数字抽象为一个数字块类，放入棋盘的格子中。</p><p>是用Block类的二维数组存储数字块</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> GameController_Mode1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Map</span>:<span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> sideLength;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> blockCounter;<br>    <span class="hljs-keyword">private</span> Block [][] blocks;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Score &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> BestScore &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitMap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> sideLength</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.sideLength = sideLength;<br>        blocks = <span class="hljs-keyword">new</span> Block[sideLength][];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sideLength; i++)<br>        &#123;<br>            blocks[i] = <span class="hljs-keyword">new</span> Block[sideLength];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; sideLength; j++)<br>            &#123;<br>                blocks[i][j] = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">new</span> Vector2Int(i, j), screenPosition[i, j]);<br>            &#125;<br>        &#125;<br>        blockCounter = <span class="hljs-number">0</span>;<br>        transform.position = originalPosition;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DestroyMap</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Block[] i <span class="hljs-keyword">in</span> blocks)<br>        &#123;<br>            <span class="hljs-keyword">foreach</span>(Block j <span class="hljs-keyword">in</span> i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!j.isEmpty())<br>                &#123;<br>                    GameObject.Destroy(j.Entity.gameObject);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//剩下的代码在下面</span><br></code></pre></td></tr></table></figure><h4 id="数字块的生成与合并"><a href="#数字块的生成与合并" class="headerlink" title="数字块的生成与合并"></a>数字块的生成与合并</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 生成数字块</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNewNumber</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//在哪里生成</span><br><span class="hljs-built_in">int</span> putWhere = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">15</span> - blockCounter);<br><span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sideLength; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; sideLength; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!blocks[i][j].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (counter == putWhere)<br>            &#123;<br>                blocks[i][j].Entity = EntityControllerMode1.createNewEntity(blocks[i][j]);<br>                blockCounter++;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> counter++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//合并数字块</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeNumber</span>(<span class="hljs-params">Block blockA,Block blockB</span>)</span><br><span class="hljs-function"></span>&#123;<br>    blockA.Entity.isChanged = <span class="hljs-literal">true</span>;<br>    Score += blockB.Entity.Num;<br>    GameObject.Destroy(blockB.Entity.gameObject);<br>    blockCounter--;<br>    blockB.Entity = blockA.Entity;<br>    blockA.Entity = <span class="hljs-literal">null</span>;<br>    blockB.Entity.doEntityMove(blockB);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数字块的移动"><a href="#数字块的移动" class="headerlink" title="数字块的移动"></a>数字块的移动</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveNumber</span>(<span class="hljs-params">Block blockA, Block blockB</span>)<span class="hljs-comment">//AtoB</span></span><br><span class="hljs-function"></span>&#123;<br>    blockB.Entity = blockA.Entity;<br>    blockA.Entity = <span class="hljs-literal">null</span>;<br>    blockB.Entity.doEntityMove(blockB);<br>&#125;<br><br><span class="hljs-comment">//判断是否有数字块正在移动(其实可以用回调函数)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">isNowMoving</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (transform.localPosition != originalPosition)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sideLength;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;sideLength;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!blocks[i][j].isEmpty() &amp;&amp;<br>                !blocks[i][j].Entity.isOnPosition( blocks[i][j].ScreenPosition))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//向四个方向移动的算法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveUp</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">1</span>; row &lt; sideLength; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; sideLength; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextRow = row - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[nextRow][col].isEmpty() &amp;&amp; nextRow != <span class="hljs-number">0</span>)<br>                nextRow--;<br>            <span class="hljs-keyword">if</span> (!blocks[nextRow][col].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[nextRow][col].Entity.Num &amp;&amp; !blocks[nextRow][col].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[nextRow][col]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>; <br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextRow == (row - <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextRow++;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[nextRow][col]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveDown</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = sideLength<span class="hljs-number">-2</span>; row &gt;=<span class="hljs-number">0</span>; row--)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; sideLength; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextRow = row + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[nextRow][col].isEmpty() &amp;&amp; nextRow != sideLength<span class="hljs-number">-1</span>)<br>                nextRow++;<br>            <span class="hljs-keyword">if</span> (!blocks[nextRow][col].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[nextRow][col].Entity.Num &amp;&amp; !blocks[nextRow][col].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[nextRow][col]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextRow == (row + <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextRow--;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[nextRow][col]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveLeft</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; sideLength; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">1</span>; col &lt; sideLength; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextCol = col - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[row][nextCol].isEmpty() &amp;&amp; nextCol != <span class="hljs-number">0</span>)<br>                nextCol--;<br>            <span class="hljs-keyword">if</span> (!blocks[row][nextCol].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[row][nextCol].Entity.Num &amp;&amp; !blocks[row][nextCol].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[row][nextCol]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextCol == (col - <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextCol++;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[row][nextCol]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveRight</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; sideLength; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = sideLength - <span class="hljs-number">2</span>; col &gt;=<span class="hljs-number">0</span>; col--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextCol = col + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[row][nextCol].isEmpty() &amp;&amp; nextCol != sideLength - <span class="hljs-number">1</span>)<br>                nextCol++;<br>            <span class="hljs-keyword">if</span> (!blocks[row][nextCol].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[row][nextCol].Entity.Num &amp;&amp; !blocks[row][nextCol].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[row][nextCol]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextCol == (col + <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextCol--;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[row][nextCol]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是逻辑层面移动数字块，实际上每个数字块的移动是用协程实现的。<br>协程是用法可见：<br><a href="https://mycroftcooper.github.io/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/">https://mycroftcooper.github.io/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/</a></p><h4 id="判断游戏结束"><a href="#判断游戏结束" class="headerlink" title="判断游戏结束"></a>判断游戏结束</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">isLose</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (blockCounter != (<span class="hljs-built_in">int</span>)Mathf.Pow((<span class="hljs-built_in">float</span>)sideLength, <span class="hljs-number">2f</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;sideLength;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;sideLength<span class="hljs-number">-1</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[i][j].Entity.Num == blocks[i][j + <span class="hljs-number">1</span>].Entity.Num) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(blocks[j][i].Entity.Num == blocks[j+<span class="hljs-number">1</span>][i].Entity.Num) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-3-球球模式的潜水艇控制"><a href="#3-3-3-球球模式的潜水艇控制" class="headerlink" title="3.3.3 球球模式的潜水艇控制"></a>3.3.3 球球模式的潜水艇控制</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//用户输入检测</span><br><span class="hljs-keyword">private</span> Touch touch;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PhoneInput</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!GC.IsPause() &amp;&amp; !GC.isShaking)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Input.touchCount != <span class="hljs-number">1</span> &amp;&amp; Input.touchCount != <span class="hljs-number">2</span>) <br>            <span class="hljs-keyword">return</span>;<br>        touch = Input.GetTouch(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (Input.touchCount == <span class="hljs-number">2</span>)<br>        &#123;<br>            GC.dropTheEntity();<br>            GC.shakePool();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Input.GetTouch(<span class="hljs-number">0</span>).phase == TouchPhase.Moved)<br>            GC.moveSubmarine(Camera.main.ScreenToWorldPoint(touch.position));<br>        <span class="hljs-keyword">if</span> (!GC.hasNewEntity() <br>            &amp;&amp; touch.phase==TouchPhase.Began &amp;&amp; Input.touchCount ==<span class="hljs-number">1</span>)<br>            GC.createNewEntity();<br>        <span class="hljs-keyword">if</span> (touch.phase == TouchPhase.Ended)<br>            GC.dropTheEntity();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//潜水艇移动响应函数</span><br><span class="hljs-keyword">private</span> Vector3 LeftLimiter = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-2f</span>, <span class="hljs-number">2.65f</span>, <span class="hljs-number">0f</span>);<br><span class="hljs-keyword">private</span> Vector3 RightLimiter = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">2f</span>, <span class="hljs-number">2.65f</span>, <span class="hljs-number">0f</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move_EventHandle</span>(<span class="hljs-params">Vector3 targetPosition</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (targetPosition.x &lt; LeftLimiter.x)<br>        transform.position = LeftLimiter;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetPosition.x &gt; RightLimiter.x)<br>        transform.position = RightLimiter;<br>    <span class="hljs-keyword">else</span><br>        transform.position = <span class="hljs-keyword">new</span> Vector3(targetPosition.x, <span class="hljs-number">2.65f</span>, <span class="hljs-number">0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目开发文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader 标准光照模型(一)理论基础</title>
    <link href="/2021/06/22/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/06/22/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>虽然光照模型有很多种类，但在早期的游戏引擎中往往只使用一个光照模型，这个模型被称为标准光照模型。</p><p>在1975年，著名学者<strong>裴祥风(Bui Tuong Phong)</strong> 提出了标准光照模型背后的基本理念。</p><p>标准光照模型只关心**直接光照(directlight)**，也就是那些直接从光源发射出来照射到物体表面后,经过物体表面的一次反射直接进入摄像机的光线。</p><p>它的基本方法是，把进入到摄像机内的光线分为4个部分，每个部分使用一种方法来计算它的贡献度。</p><p>这4个部分是：</p><ul><li><p><strong>自发光 (emissive)</strong><br>这个部分用于描述当给定一个方向时，一个表面本身会向该方向发射多少辐射量。<br>需要注意的是：<br>如果没有使用<strong>全局光照(globalillumination)技术</strong>，这些自发光的表面并不会真的照亮周围的物体，而是它本身看起来更亮了而已。</p></li><li><p><strong>高光反射(specular)</strong><br>这个部分用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。</p></li><li><p><strong>漫反射(diffuse)</strong><br>这个部分用于描述，当光线从光源照射到模型表面时，该表面会向每个方向散射多少辐射量。</p></li><li><p><strong>环境光 (ambient)</strong><br>它用于描述其他所有的间接光照。</p></li></ul><p>标准光照模型仅仅是一个经验模型，它并不完全符合真实世界中的光照现象。<br>但由于它的易用性、计算速度和得到的效果都比较好，因此仍然被广泛使用。</p><p>但这种模型有很多局限性。</p><ul><li>有很多重要的物理现象无法用<strong>Blinn-Phong模型</strong>表现出来，<br>例如**菲涅耳反射(Fresnel reflection)**。</li><li><strong>Blinn-Phong 模型</strong>是<strong>各项同性(isotropic)</strong> 的<br>当我们固定视角和光源方向旋转这个表面时，反射不会发生任何改变。<br>但有些表面是具有**各向异性(anisotropic)**反射性质的例如拉丝金属、毛发等。<br>所以它看起来不够真实</li></ul><h1 id="2-理论基础"><a href="#2-理论基础" class="headerlink" title="2. 理论基础"></a>2. 理论基础</h1><h2 id="2-1-环境光"><a href="#2-1-环境光" class="headerlink" title="2.1 环境光"></a>2.1 环境光</h2><p>虽然标准光照模型的重点在于描述直接光照，但在真实的世界中，物体也可以被间接光照(indirect light)所照亮。</p><p>间接光照指：光线通常会在多个物体之间反射，最后进入摄像机。<br>也就是说，在光线进入摄像机之前，经过了不止一次的物体反射。<br>例如：<br>在红地毯上放置一个浅灰色的沙发，那么沙发底部也会有红色，这些红色是由红地毯反射了一部分光线，再反弹到沙发上的。</p><p>在标准光照模型中，我们使用了一种被称为环境光的部分来近似模拟间接光照。<br>环境光的计算非常简单，它通常是一个 全局变量，即场景中的所有物体都使用这个环境光。</p><p><strong>环境光计算公式：</strong><br>$c_{ambient}=g_{ambient}$<br><strong>物体环境光=全局环境光</strong></p><h2 id="2-2-自发光"><a href="#2-2-自发光" class="headerlink" title="2.2 自发光"></a>2.2 自发光</h2><p>光线也可以直接由光源发射进入摄像机，而不需要经过任何物体的反射。</p><p>标准光照模型使用自发光来计算这个部分的贡献度。<br>它的计算也很简单，就是直接使用了该材质的自发光颜色:</p><p><strong>自发光计算公式：</strong><br>$c_{emissive}=m_{emissive}$<br><strong>物体自发光=该物体材质自发光</strong></p><blockquote><p>通常在实时渲染中，自发光的表面往往并不会照亮周围的表面<br>也就是说，这个物体并不会被当成一个光源。<br>Unity5引入的全新的全局光照系统则可以模拟这类自发光物体对周围物体的影响</p></blockquote><h2 id="2-3-漫反射"><a href="#2-3-漫反射" class="headerlink" title="2.3 漫反射"></a>2.3 漫反射</h2><p>漫反射光照是用于对那些被物体表面随机散射到各个方向的辐射度进行建模的。</p><p>在漫反射中，视角的位置是不重要的，因为反射是完全随机的，因此可以认为在任何反射方向上的分布都是一样的。但是，入射光线的角度很重要。</p><p>漫反射光照符合<strong>兰伯特定律(Lambert’s law)</strong>:<br>反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比。</p><p><strong>漫反射计算公式：</strong><br>$c_{diffuse}=(c_{light}·m_{diffuse})max(0,n·I)$<br><strong>物体漫反射光=(光源颜色·物体材质漫反射颜色)·取大值(0,法线方向矢量·光源方向矢量)</strong><br>其中：</p><ul><li><p>n是表面法线</p></li><li><p>I是指向光源的单位矢量</p></li><li><p>$m_{diffuse}$是材质的漫反射颜色</p></li><li><p>$c_{light}$ 是光源颜色。</p></li></ul><blockquote><p>需要注意的是:<br>我们需要防止法线和光源方向点乘的结果为负值，<br>为此，我们使用取最大值的函数来将其截取到0，<br>这可以防止物体被从后面来的光源照亮。</p></blockquote><h2 id="2-4-高光反射"><a href="#2-4-高光反射" class="headerlink" title="2.4 高光反射"></a>2.4 高光反射</h2><h3 id="2-4-1-Phong模型"><a href="#2-4-1-Phong模型" class="headerlink" title="2.4.1 Phong模型"></a>2.4.1 Phong模型</h3><p>这里的高光反射是一种经验模型， 也就是说，它并不完全符合真实世界中的高光反射现象。</p><p>它可用于计算那些沿着完全镜面反射方向被反射的光线，这可以让物体看起来是有光泽的，例如金属材质。</p><p>计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。<br>我们假设这些矢量都是单位矢量。如下图所示：<br><img src="/images/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/image-20210622112428355.png" srcset="/img/loading.gif" alt="image-20210622112428355"></p><p>在这四个矢量中，我们实际上只需要知道其中3个矢量即可，而反射方向可以通过其他信息计算得到：<br>$\hat r=2(\hat n·I)\hat n-I$</p><p>这样，我们就可以利用Phong 模型来计算高光反射的部分:<br><strong>高光反射计算公式(Phong模型)：</strong><br>$c_{spscular}=(c_{light}·m_{specular})max(0,\hat v·\hat r)^{m_{gloss}} $<br><strong>物体高光反射=(光源颜色·物体材质高光反射颜色)·取大值(0,视角向量方向·反射向量方向)物体光泽度次幕</strong><br>其中:</p><ul><li><p>$m_{specular}$是材质的光泽度(gloss)， 也被称为反光度(shininess)。<br>它用于控制高光区域的亮点”有多宽，mgloss越大，亮点就越小。</p></li><li><p>$m_{specular}$是材质的高光反射颜色，<br>它用于控制该材质对于高光反射的强度和颜色。</p></li><li><p>$c_{light}$ 则是光源的颜色和强度。</p></li></ul><p>同样，这里也需要防止$\hat v·\hat r$的结果为负数。</p><h3 id="2-4-2-Blinn模型"><a href="#2-4-2-Blinn模型" class="headerlink" title="2.4.2 Blinn模型"></a>2.4.2 Blinn模型</h3><p>和上述的Phong 模型相比，Blinn 提出了一个简单的修改方法来得到类似的效果。<br>它的基本思想是，避免计算反射方向$\hat r$。<br>为此，Blin 模型引入了一个新的矢量$\hat h$，它是通过对$\hat v$和$\hat I$的取平均后再归一化得到的。</p><p>即:<br>$\hat h=\frac {\hat v+I}{|\hat v+I|}$<br>然后，使用$\hat h$和$\hat n$之间的夹角进行计算，而非$\hat v$和$\hat r$之间的夹角如下图所示：<br><img src="/images/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/image-20210622114447454.png" srcset="/img/loading.gif" alt="image-20210622114447454"><br><strong>高光反射计算公式(Blinn模型)：</strong><br>$c_{spscular}=(c_{light}·m_{specular})max(0,\hat n·\hat h)^{m_{gloss}} $<br><strong>物体高光反射=(光源颜色·物体材质高光反射颜色)·取大值(0,法线方向·向量h方向)物体光泽度次幕</strong></p><p>$\hat h=\frac {\hat v+I}{|\hat v+I|}$<br><strong>$向量h方向=\frac {视角方向向量+光源方向向量}{|视角方向向量+光源方向向量|}$</strong></p><p>在硬件实现时:</p><ul><li>若摄像机和光源距离模型足够远<br>Blinn 模型会快于Phong模型<br>因为此时可以认为$\hat v$和$\hat I$都是定值，因此$\hat h$将是一个常量。</li><li>当$\hat v$和$\hat I$不是定值时，Phong 模型可能反而更快一些。</li></ul><blockquote><p>注意:<br>这两种光照模型都是经验模型<br>也就是说，我们不应该认为Blinn 模型是对“正确的”Phong模型的近似。<br>实际上，在一些情况下，Blinn 模型更符合实验结果。</p></blockquote><h2 id="2-5-标准光照模型的两种着色"><a href="#2-5-标准光照模型的两种着色" class="headerlink" title="2.5 标准光照模型的两种着色"></a>2.5 标准光照模型的两种着色</h2><p>计算光照模型通有两种选择:</p><ul><li><p><strong>在片元着色器中计算——逐像素光照(per-pixel lighting)</strong><br>也被称为<strong>Phong着色(Phong shading)**或</strong>Phong插值<strong>或</strong>法线插值**着色技术<br>在逐像素光照中，我们会以每个像素为基础，得到它的法线<br>(可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的)，然后进行光照模型的计算。</p><blockquote><p>这不同于我们之前讲到的Phong光照模型。</p></blockquote></li><li><p><strong>在顶点着色器中计算——逐顶点光照(per-vertex lighting)</strong><br>也被称为**高洛德着色(Gouraud shading)**。<br>我们在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。<br>由于顶点数目往往远小于像素数目，因此逐顶点光照的计算量往往要小于逐像素光照。</p><blockquote><p>注意：<br>由于逐顶点光照依赖于线性插值来得到像素光照<br>因此，当光照模型中有非线性的计算( 例如计算高光反射时)时，逐顶点光照就会出问题。<br>而且，由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，<br>这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，这在某些情况下会产生明显的棱角现象。</p></blockquote></li></ul><h1 id="3-动手实践"><a href="#3-动手实践" class="headerlink" title="3.动手实践"></a>3.动手实践</h1><h2 id="3-1-在Unity中实现环境光与自发光"><a href="#3-1-在Unity中实现环境光与自发光" class="headerlink" title="3.1 在Unity中实现环境光与自发光"></a>3.1 在Unity中实现环境光与自发光</h2><p>在标准光照模型中，环境光和自发光的计算是最简单的。<br>在Unity中,场景中的环境光可以在：<br>Window-&gt;Lighting -&gt; Ambient Source/Ambient Color/Ambient Intensity(英文)<br>窗口-&gt;渲染-&gt;光照-&gt;场景-&gt;环境中控制，</p><p>如下图所示：<br><img src="/images/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/image-20210622131750865.png" srcset="/img/loading.gif" alt="image-20210622131750865"></p><p>在Shader中，我们只需要通过Unity的内置变量UNITY_ LIGHTMODEL AMBIENT就可以得到环境光的颜色和强度信息。</p><p>而大多数物体是没有自发光特性的。<br>如果要计算自发光也非常简单，我们只需要在片元着色器输出最后的颜色之前，把材质的自发光颜色添加到输出颜色上即可。</p><h2 id="3-2-在UnityShader中实现漫反射光照模型"><a href="#3-2-在UnityShader中实现漫反射光照模型" class="headerlink" title="3.2 在UnityShader中实现漫反射光照模型"></a>3.2 在UnityShader中实现漫反射光照模型</h2><p>从公式可以看出，要计算漫反射需要知道4个参数:入射光线的颜色和强度Cight, 材质的漫<br>反射系数mdij<br>lifuse<br>表面法线介 以及光源方向I。2<br>为了防止点积结果为负值，我们需要使用max操作，而CG提供了这样的函数。在本例中，<br>使用CG的另一个函数可以达到同样的目的，即saturate函数。<br>函数: saturate(x)<br>参数: x:为用于操作的标量或矢量，可以是float、 float2、 float3 等类型。<br>描述:把x截取在[0, 1]范围内，如果x是一一个矢量，那么会对它的每一一个分量进行这样的操作。</p><h3 id="3-2-1-逐项点光照"><a href="#3-2-1-逐项点光照" class="headerlink" title="3.2.1 逐项点光照"></a>3.2.1 逐项点光照</h3><p>我们首先来看如何实现-一个逐顶点的漫反射光照效果。在学习完本节后，我们会得到类似<br>图6.6中的效果。<br>为此，我们进行如下准备工作。<br>(1)在Unity中新建一一个场景。在本书资源中，该场景名为Scene_ 6 _4。 在Unity 5.2中，默<br>认情况下场景将包含一个摄像机和一个平行光，并且使用了内置的天空盒子。在Window -&gt;</p><p>Lighting -&gt; Skybox中去掉场景中的天空盒子。<br>(2) 新建一个材质。在本书资源中，该材质名为DiffuseVertexLevelMato<br>(3)新建一一个 Unity Shader.在本书资源中，该Shader<br>名为Chapter6-DiffuseVertexLevel。 把新的Shader 赋给<br>第2步中创建的材质。<br>(4)在场景中创建一个胶囊体，并把第2步中的材<br>质赋给该胶囊体。<br>(5)保存场景。<br>下面，我们需要编写自己的Shader来实现–个逐顶<br>点的漫反射效果。打开第3步中创建的Unity Shader,<br>删除所有已有代码，并进行如下修改。<br>(1)首先，我们需要为这个Shader起一 一个名字:<br>Shader “Unity Shaders Book/Chapter 6/Dlffuse Vertex-Level” {<br>(2)为了得到并且控制材质的漫反射颜色，我们首先在Shader的Properties语义块中声明了<br>个Color类型的属性，并把它的初始值设为白色:<br>Properties {.<br>Diffuse (“Diffuse”, Color) = (1, 1, 1, 1)<br>(3)然后，我们在SsubShader语义块中定义了一个Pass 语义块。这是因为顶点/片元着色器的<br>代码需要写在Pass 语义块，而非SubShader语义块中。而且，我们在Pass的第一行指明 了该Pass<br>的光照模式:<br>SubShader {<br>Pass<br>Tags { “LightMode “= “ForwardBase” }<br>LightMode标签是Pass标签中的一种，它用于定义该Pass在Unity的光照流水线中的角色，<br>在第9章中我们会更加详细地解释它。在这里，我们只需要知道，只有定义了正确的LightMode,<br>我们才能得到一些Unity的内置光照变量，例如下面要讲到的_ LightColor0。<br>(4)然后，我们使用CGPROGRAM和ENDCG米包围CG代码片，以定义最重要的顶点着色<br>器和片元着色器代码。首先，我们使用#pragma指令来告诉Unity,我们定义的顶点着色器和片元<br>着色器叫什么名字。在本例中，它们的名字分别是vert和frag:<br>CGPROGRAM<br>#pragma vertex vert<br>#pragma fragment frag<br>(5)为了使用Unity内置的一些变量， 如后面要讲到的<em>LightColor0， 还需要包含进Unity的<br>内置文件Lighting.cginc:<br>#include “Lighting. cginc”<br>(6) 为了在Shader中使用Properties语义块中声明的属性，我们需要定义一个和该属性类型<br>相匹配的变量:<br>fixed4</em> Diffuse;<br>通过这样的方式，我们就可以得到漫反射公式中需要的参数之一一一材 质的漫反射属性。由<br>于颜色属性的范围在0到1之间，因此我们可以使用fixed精度的变量来存储它。</p><p>(7)然后，我们定义了顶点着色器的输入和输出结构体(输出结构体同时也是片元着色器的<br>输入结构体):<br>struct a2v {<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>struct v2f (<br>float4 pos : SV_ POSITION;<br>fixed3 color : COLOR;<br>;<br>为了访问顶点的法线，我们需要在a2v中定义-个normal变量，并通过使用NORMAL语义<br>来告诉Unity要把模型项点的法线信息存储到normal变量中。为了把在项点着色器中计算得到的<br>光照颜色传递给片元着色器，我们需要在v2f中定义-一个color变量，且并不是必须使用COLOR<br>语义，一些资料中会使用TEXCOORDO语义。<br>(8)接下来是关键的顶点着色器。由于本小节关注如何实现一一个逐顶点的漫反射光照，因此<br>漫反射部分的计算都将在顶点着色器中进行:<br>v2f vert(a2v v) {<br>v2f o;<br>// Transform the vertex from object. space, to projection space<br>o.pos = mul (UNITY_ MATRIX MVP，v.vertex);<br>/ Get ambient term<br>fixed3 ambient = UNITY_ LIGHTMODEL_ AMBIENT 。xyz;<br>// Transform the normal fram object space to world space<br>fixed3 worldNormal = normalize (mul (v.normal, (f1oat3x3)_ Wor1d20bject));<br>// Get the 1ight direction in world space<br>fixed3 worldLight . normalize(_ WorldSpaceLightPos0.xyz);<br>// Compute diffuse term<br>fixed3 diffuse = LightColor0.rgb * Diffuse.rgb * saturate (dot (worldNormal,<br>worldLight));<br>o.color = ambient + diffuse;<br>return o;<br>在第一行，我们首先定义了返回值0。我们已经重复过很多次，顶点着色器最基本的任务就<br>是把顶点位置从模型空间转换到裁剪空间中，因此我们需要使用Unity内置的模型<em>世界</em>投影矩<br>阵UNITY MATRIX MVP来完成这样的坐标变换。接下来，我们通过Unity 的内置变量<br>UNITY LIGHTMODEL_ AMBIENT得到了环境光部分。<br>然后，就是真正计算漫反射光照的部分。回忆一下，为了计算漫反射光照我们需要知道4个<br>参数。在前面的步骤中，我们已经知道了材质的漫反射颜色<em>Diffuse 以及顶点法线v.normal。我们<br>还需要知道光源的颜色和强度信息以及光源方向。Unity 提供给我们一“个内置变量LightColor0 来<br>访问该Pass 处理的光源的颜色和强度信息(注意，想要得到正确的值需要定义合适的LightMode<br>标签)，而光源方向可以由</em> WorldSpaceLightPos0 来得到。需要注意的是，这里对光源方向的计算<br>并不具有通用性。在本节中，我们假设场景中只有一个光源且该光源的类型是平行光。但如果场<br>景中有多个光源并且类型可能是点光源等其他类型，直接使用_ WorldSpaceLightPos0就不能得到<br>正确的结果。我们将在6.6节中学习如何使用内置函数来处理更复杂的光源类型。<br>在计算法线和光源方向之间的点积时，我们需要选择它们所在的坐标系，只有两者处于同一<br>坐标空间下，它们的点积才有意义。在这里，我们选择了世界坐标空间。而由a2v得到的顶点法<br>线是位于模型空间下的，因此我们首先需要把法线转换到世界空间中。在4.7节中，我们已经知</p><h3 id="3-2-2-逐像素光照"><a href="#3-2-2-逐像素光照" class="headerlink" title="3.2.2 逐像素光照"></a>3.2.2 逐像素光照</h3>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-协程</title>
    <link href="/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/"/>
    <url>/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>unity的<strong>协程（Coroutine）</strong>只是在c#的基础上做了一层封装，其实yield是C#的关键字。</p><p>unity协程是一个能够暂停协程执行，暂停后立即返回主函数，执行主函数剩余的部分，直到中断指令完成后，从中断指令的下一行继续执行协程剩余的函数。<br>函数体全部执行完成，协程结束。<br>由于中断指令的出现，使得可以将一个函数分割到多个帧里去执行。</p><p>协程不是进程，也不是线程，它就是一个特殊的函数——可以在某个地方挂起，并且可以重新在挂起处继续运行。</p><p><strong>协程方法与普通方法的区别：</strong></p><ul><li>普通方法<br>被调用时，原来执行的部分保留现场，停止执行，然后去执行要调用的方法，并且，被调用的方法执行完之后才能返回到调用前的状态接着往下执行。</li><li>协同方法<br>执行不用等协同方法执行完再执行调用之前原来方法的代码，而是两者异步执行。</li></ul><p>协程不是多线程，它与主线程同时运行，它在主线程运行的同时开启另一段逻辑处理。<br>类似一个子线程单独出来处理一些问题，性能开销较小。<br>Unity的协程会在每帧结束之后去检测yield的条件是否满足，满足则执行yield return之后的代码。</p><p>在一个MonoBehaviour提供的主线程里只能有一个处于运行状态的协程，而其他协程处于休眠状态。<br>协程实际上是在一个线程中，只不过每个协程对CUP进行分时，协程可以访问和使用unity的所有方法和component。</p><p><strong>性能：</strong><br>在性能上相比于一般函数没有更多的开销</p><p><strong>协程的好处：</strong><br>让原来要使用异步 + 回调方式写的非人类代码, 可以用看似同步的方式写出来。<br>能够分步做一个比较耗时的事情，如果需要大量的计算，将计算放到一个随时间进行的协程来处理，能分散计算压力</p><p><strong>协程的坏处：</strong><br>协程本质是迭代器，且是基于unity生命周期的，大量开启协程会引起gc<br>如果同时激活的协程较多，就可能会出现多个高开销的协程挤在同一帧执行导致的卡帧</p><p><strong>协程书写时的性能优化：</strong><br>常见的问题是直接new 一个中断指令，带来不必要的 GC 负担，可以复用一个全局的中断指令对象，优化掉开销；在 Yielders.cs 这个文件里，已经集中地创建了上面这些类型的静态对象<br>这个链接分析了一下<a href="https://link.zhihu.com/?target=https://blog.csdn.net/liujunjie612/article/details/70623943">https://blog.csdn.net/liujunjie612/article/details/70623943</a></p><p><strong>协程是在什么地方执行？</strong><br>协程不是线程，不是异步执行；协程和monobehaviour的update函数一样也是在主线程中执行<br>unity在每一帧都会处理对象上的协程，也就是说，协程跟update一样都是unity每帧会去处理的函数<br>经过测试，协程至少是每帧的lateUpdate后运行的。<br>参照unity的生命周期图</p><p><strong>前驱知识：</strong></p><ul><li>设计模式——迭代器模式</li><li>C#中的IEnumerator、IEnumerable接口</li></ul><h1 id="2-协程的实现"><a href="#2-协程的实现" class="headerlink" title="2. 协程的实现"></a>2. 协程的实现</h1><p>协程的实现需要在Unity中继承MonoBehaviour并使用C#的迭代器IEnumrator，格式如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumrator 函数名(形参表)  <span class="hljs-comment">//最多只能有一个形参 </span><br>&#123;   <br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> xxx; <span class="hljs-comment">//恢复执行条件</span><br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在IEnumerator类型的方法中写入需要执行的操作，遇到yield后会暂时挂起，等到yield return后的条件满足才继续执行yield语句后面的内容。</p><h1 id="3-协程的开启与中止"><a href="#3-协程的开启与中止" class="headerlink" title="3. 协程的开启与中止"></a>3. 协程的开启与中止</h1><p>相关测试：<a href="https://blog.csdn.net/qq_37421018/article/details/88560239?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">Unity 协程的一些基本用法及测试</a></p><h2 id="3-1-协程的开启"><a href="#3-1-协程的开启" class="headerlink" title="3.1 协程的开启"></a>3.1 协程的开启</h2><p>开启协程需要使用StartCoroutine()方法：</p><ul><li><p>开启无参数的协程：<br><code>StartCoroutine(协程名());</code>或<code>StartCoroutine(&quot;协程名&quot;);</code></p></li><li><p>开启单参数的协程：<br><code>StartCoroutine(协程名(参数));</code>或<code>StartCoroutine(&quot;协程名&quot;,参数);</code></p></li><li><p>开启多参数的协程：<br><code>StartCoroutine(协程名(参数1,......));</code><br>或</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//开启协程的函数</span></span><br><span class="hljs-function"></span>&#123;<br>    IEnumerator coroutine = Test(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>    StartCoroutine(coroutine);<br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)<span class="hljs-comment">//协程</span></span><br><span class="hljs-function"></span> &#123;<br>     <span class="hljs-comment">//等待帧画面渲染结束</span><br>     <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForEndOfFrame</span>(<span class="hljs-params"></span>)</span>;<br>     a=<span class="hljs-number">2</span>;<br>     b=<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>用“协程名”启动的方式不允许传入 一个以上的参数</p></blockquote></li></ul><h2 id="3-2-协程的结束"><a href="#3-2-协程的结束" class="headerlink" title="3.2 协程的结束"></a>3.2 协程的结束</h2><p>结束协程有两种情况：</p><ul><li><p>当协程的方法体执行完毕将会自动结束</p></li><li><p>调用StopCoroutine();方法中止协程执行</p></li></ul><p>中止协程的几种情况：</p><ul><li><p>中止所有协程：<br><code>StopAllCoroutines();</code></p></li><li><p>使用对象实例中止指定协程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#">Coroutine c;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    c = StartCoroutine(CountSeconds());        <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.J))<br>    &#123;<br>        StopCoroutine(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用字符串中止指定协程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">StartCoroutine(<span class="hljs-string">&quot;协程名&quot;</span>);<br>StopCoroutine(<span class="hljs-string">&quot;协程名&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>只有以协程名字符串启动的协程可以用此方法中止<br>既：<strong>StartCoroutine(“协程名”);**或</strong>StartCoroutine(“协程名”,参数);**</p><p>允许使用**StopCoroutine(“协程名”);**中止协程</p></blockquote><blockquote><p>不允许使用直接调用协程方法的方式中止指定协程<br>既：**StopCoroutine(协程名([参数]));**不被允许</p></blockquote></li></ul><h1 id="4-yield-协程回复条件语句"><a href="#4-yield-协程回复条件语句" class="headerlink" title="4. yield 协程回复条件语句"></a>4. yield 协程回复条件语句</h1><p><strong>快查表：</strong></p><table><thead><tr><th>yield语句</th><th>功能</th></tr></thead><tbody><tr><td>yield return null;</td><td>下一帧再执行后续代码</td></tr><tr><td>yield return 0;</td><td>下一帧再执行后续代码</td></tr><tr><td>yield return 6;(任意数字)</td><td>下一帧再执行后续代码</td></tr><tr><td>yield break;</td><td>直接结束该协程的后续操作</td></tr><tr><td>yield return asyncOperation;</td><td>等异步操作结束后再执行后续代码</td></tr><tr><td>yield return StartCoroution(其它协程);</td><td>调用执行其它协程后再执行后续代码</td></tr><tr><td>yield return WWW();</td><td>等待WWW操作完成后再执行后续代码</td></tr><tr><td>yield return new WaitForEndOfFrame();</td><td>等待帧结束,等待直到所有的摄像机和GUI被渲染完成后，在该帧显示在屏幕之前执行</td></tr><tr><td>yield return new WaitForSeconds(0.3f);</td><td>等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间会受到Time.timeScale的影响）;</td></tr><tr><td>yield return new WaitForSecondsRealtime(0.3f);</td><td>等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间不受到Time.timeScale的影响）;</td></tr><tr><td>yield return WaitForFixedUpdate();</td><td>等待下一次FixedUpdate开始时再执行后续代码</td></tr><tr><td>yield return new WaitUntil()</td><td>将协同执行直到当输入的参数（或者委托）为true的时候</td></tr><tr><td>yield return new WaitWhile()</td><td>将协同执行直到 当输入的参数（或者委托）为false的时候</td></tr></tbody></table><p><strong>生命周期图：</strong><br><img src="/images/Unity-%E5%8D%8F%E7%A8%8B/image-20210619124505977.png" srcset="/img/loading.gif" alt="image-20210619124505977"></p><h2 id="4-1-yield-return-null"><a href="#4-1-yield-return-null" class="headerlink" title="4.1 yield return null;"></a>4.1 yield return null;</h2><p>从生命周期图中可以看到，在GameLogic部分对协程中挂起的条件进行了判断。</p><p>也就是说，协程顺序为：<br>（当前帧为第1帧）<br>第1帧在start中开启协程，执行协程（自上而下），遇到yield return null 将后面的内容挂起。<br>这时继续执行第1帧剩下的东西直到第1帧Update执行结束，这时对挂起的协程进行判断 是否满足return条件，<br>满足则在第2帧Update之后，在LateUpdate前执行协程中yield return 以后的代码；<br>不满足条件则继续执行第1帧的LateUpdate。<br>第2帧同第1帧相同。</p><p><strong>测试如下：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CorTest2</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//update中判断次数的变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;start 1&quot;</span>);<br>        <span class="hljs-comment">//开启协程1</span><br>        StartCoroutine(Test());<br>        Debug.Log(<span class="hljs-string">&quot;start 2&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;第&quot;</span> + ++i + <span class="hljs-string">&quot;帧开始&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;帧结束&quot;</span>);<br>    &#125;<br>    <span class="hljs-function">IEnumerator <span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;协程1第一次&quot;</span>);<br>            <span class="hljs-comment">//挂起时机</span><br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            Debug.Log(<span class="hljs-string">&quot;协程1第二次&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="/images/Unity-%E5%8D%8F%E7%A8%8B/image-20210619124653298.png" srcset="/img/loading.gif" alt="image-20210619124653298"></p><p>可以看到，协程运行到一半在第一帧被挂起，第二帧Update执行完后满足条件继续执行。</p><h2 id="4-2-yield-return-StartCoroutine"><a href="#4-2-yield-return-StartCoroutine" class="headerlink" title="4.2 yield return StartCoroutine();"></a>4.2 yield return StartCoroutine();</h2><p><strong>测试如下：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>   &#123;<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>       &#123;<br>           Debug.Log(<span class="hljs-string">&quot;协程1第一次&quot;</span>);<br>           <span class="hljs-comment">//挂起时机</span><br>           <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">Test2(</span>))</span>;<br>           Debug.Log(<span class="hljs-string">&quot;协程1第二次&quot;</span>);<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-function">IEnumerator <span class="hljs-title">Test2</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>   &#123;<br>       Debug.Log(<span class="hljs-string">&quot;协程2第一次&quot;</span>);<br>       <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       Debug.Log(<span class="hljs-string">&quot;协程2第二次&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>结果如下：</strong><br><img src="/images/Unity-%E5%8D%8F%E7%A8%8B/image-20210619125001267.png" srcset="/img/loading.gif" alt="image-20210619125001267"></p><p>原理都是一样的，执行完yield return 后挂起（注意不是遇到就挂起，而是执行），在每一帧的update与lateupdate之间对挂起的内容进行判断，满足则继续执行被挂起的协程的剩余部分。</p><h2 id="4-3-yield-return-new-WaitUntil"><a href="#4-3-yield-return-new-WaitUntil" class="headerlink" title="4.3 yield return new WaitUntil();"></a>4.3 yield return new WaitUntil();</h2><p><strong>案例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter;<br><span class="hljs-function">IEnumerator <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    counter=<span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitUntil</span>(<span class="hljs-params">TestWait</span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;Start执行完毕&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TestWait</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当方法TestWait的返回值为true的时候<br>Start会一次性执行完。</li><li>当方法TestWait的返回值为false的时候<br>Start会一直等待着，只要返回值为false，那么Start的最后一句打印就不会执行。</li></ul><blockquote><p>可以使用lambda表达式</p></blockquote><h2 id="4-4-yield-return-new-WaitWhile"><a href="#4-4-yield-return-new-WaitWhile" class="headerlink" title="4.4 yield return new WaitWhile()"></a>4.4 yield return new WaitWhile()</h2><p><strong>案例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter;<br><span class="hljs-function">IEnumerator <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    counter=<span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitWhile</span>(<span class="hljs-params">TestWait</span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;Start执行完毕&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TestWait</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当方法TestWait的返回值为true的时候<br>Start会一直等待着，只要返回值为true，那么Start的最后一句打印就不会执行。</li><li>当方法TestWait的返回值为false的时候<br>Start会一次性执行完。</li></ul><blockquote><p>可以使用lambda表达式</p></blockquote><h1 id="5-协程的嵌套"><a href="#5-协程的嵌套" class="headerlink" title="5. 协程的嵌套"></a>5. 协程的嵌套</h1><p>利用<code>yield return StartCoroution(其它协程);</code>可以实现多个协程的嵌套使用。<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">SaySomeThings</span>(<span class="hljs-params"></span>)   </span><br><span class="hljs-function"></span>&#123;       <br>    Debug.Log(<span class="hljs-string">&quot;The routine has started&quot;</span>);       <br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">RepeatMessage(<span class="hljs-number">1</span>, <span class="hljs-number">1f</span>, <span class="hljs-string">&quot;Hello&quot;</span></span>))</span>;       <br>    Debug.Log(<span class="hljs-string">&quot;1 second has passed since the last message&quot;</span>);       <br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">RepeatMessage(<span class="hljs-number">1</span>, <span class="hljs-number">2.5f</span>, <span class="hljs-string">&quot;Hello&quot;</span></span>))</span>;       <br>    Debug.Log(<span class="hljs-string">&quot;2.5 seconds have passed since the last message&quot;</span>);   <br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/Unity-%E5%8D%8F%E7%A8%8B/image-20210619123813192.png" srcset="/img/loading.gif" alt="image-20210619123813192"></p><h1 id="6-注意"><a href="#6-注意" class="headerlink" title="6. 注意"></a>6. 注意</h1><ul><li>IEnumerator 类型的方法不能带 ref 或者 out 型的参数，但可以带被传递的引用</li><li>在函数 Update 和 FixedUpdate 中不能使用 yield 语句，否则会报错， 但是可以启动协程</li><li>在一个协程中，StartCoroutine()和 yield return StartCoroutine()是不一样的。<br>前者仅仅是开始一个新的Coroutine，这个新的Coroutine和现有Coroutine并行执行。<br>后者是返回一个新的Coroutine，是一个中断指令，当这个新的Coroutine执行完毕后，才继承执行现有Coroutine。</li></ul><h1 id="7-使用案例"><a href="#7-使用案例" class="headerlink" title="7. 使用案例"></a>7. 使用案例</h1><h2 id="7-1-运动到某一位置"><a href="#7-1-运动到某一位置" class="headerlink" title="7.1 运动到某一位置"></a>7.1 运动到某一位置</h2><p>在Inspector面板中设置目标位置和运动速度，在游戏开始时将一个物体移动到目标位置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Vector3 targetPosition;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> moveSpeed=<span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    c = StartCoroutine(MoveToPosition(targetPosition));<br>&#125;<br><span class="hljs-function">IEnumerator <span class="hljs-title">MoveToPosition</span>(<span class="hljs-params">Vector3 target</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (transform.position != target)<br>    &#123;<br>        transform.position = Vector3.MoveTowards(transform.position,target,moveSpeed*Time.deltaTime);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-按指定路径前进"><a href="#7-2-按指定路径前进" class="headerlink" title="7.2 按指定路径前进"></a>7.2 按指定路径前进</h2><p>我们可以让运动到某一位置的程序做更多，不仅仅是一个指定位置，我们还可以通过数组来给它赋值更多的位置，通过MoveToPosition() ，我们可以让它在这些点之间持续运动。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> List&lt;Vector3&gt; path;    <br><span class="hljs-function">IEnumerator <span class="hljs-title">MoveOnPath</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> loop</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> point <span class="hljs-keyword">in</span> path)<br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">MoveToPosition(point</span>))</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (loop);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-倒计时"><a href="#7-3-倒计时" class="headerlink" title="7.3 倒计时"></a>7.3 倒计时</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">CountDown</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> time</span>)</span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> t = time;t &gt;= <span class="hljs-number">0</span>;t -= <span class="hljs-number">1</span>)<br>        &#123;<br>            print(time);<br>            time -= <span class="hljs-number">1</span>; <br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSecondsRealtime</span>(<span class="hljs-params"><span class="hljs-number">1f</span></span>)</span>; <span class="hljs-comment">//WaitForSecondsRealtime不受时间缩放影响</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>底层机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>协程 - yield</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 资源处理</title>
    <link href="/2021/06/17/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/"/>
    <url>/2021/06/17/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>实际的游戏开发中，其实有相当一部分静态数据是可以放在客户端的。<br>所以势必会产生要动态读取这些文件的需求，比如csv（其实就是文本文件），xml等等。</p><p>做unity3d开发时，都一定要先在editor中去实现基本的功能，再具体到各个移动平台上去调试。<br>所以作为要读取外部文件的第一步，显然我们要先在editor也就是pc上实现这个功能。</p><p>既然是用Unity3D来开发游戏，那么自然要使用Unity3D规定的操作方式，而不是我们在PC上很原始的那种操作方式来操作。</p><p>否则就会写出移动端无法使用的很傻的代码来。</p><h1 id="2-资源处理分类"><a href="#2-资源处理分类" class="headerlink" title="2. 资源处理分类"></a>2. 资源处理分类</h1><p>Unity中的资源资源的处理种类大致分为：Resources、StreamingAssets、AssetBundle、PersistentDataPath 四类。</p><h2 id="2-1-Resources"><a href="#2-1-Resources" class="headerlink" title="2.1 Resources"></a>2.1 Resources</h2><p>是作为一个Unity的保留文件夹出现的，也就是如果你新建的文件夹的名字叫Resources，那么里面的内容在打包时都会被无条件的打到发布包中。</p><h3 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点"></a>2.1.1 特点</h3><ul><li>只读，即不能动态修改。所以想要动态更新的资源不要放在这里。</li><li>会将文件夹内的资源打包集成到.asset文件里面。因此建议可以放一些Prefab，因为Prefab在打包时会自动过滤掉不需要的资源，有利于减小资源包的大小。</li><li>资源读取使用Resources.Load()。</li></ul><h3 id="2-1-2-使用方法"><a href="#2-1-2-使用方法" class="headerlink" title="2.1.2 使用方法"></a>2.1.2 使用方法</h3><h4 id="2-1-2-1-加载"><a href="#2-1-2-1-加载" class="headerlink" title="2.1.2.1 加载"></a>2.1.2.1 加载</h4><ul><li>Resources.Load<br>加载Resources目录的一个asset</li><li>Resources.LoadAsync<br>Resources.Load的异步方法</li><li>Resources.LoadAll<br>类似Resources.Load，但是用于加载某目录下所有asset</li><li>Resources.LoadAssetAtPath<br>加载Asset/目录下的资源，只能用于编辑器模式，写打包工具时可能用到</li></ul><p>Resources类只能加载Resources文件夹下的资源，若出现嵌套，都会加载</p><p>Resources加载资源时应使用相对路径，且不包含扩展名。<br>如 Resources.Load&lt;Texture2D&gt;(“images/texture1”); </p><blockquote><p>建议在Assets下放一个Resource文件夹就好；</p></blockquote><h4 id="2-1-2-2-卸载资源："><a href="#2-1-2-2-卸载资源：" class="headerlink" title="2.1.2.2 卸载资源："></a>2.1.2.2 卸载资源：</h4><ul><li>Resources.UnloadAsset(Object assetToUnload)<br>卸载指定的asset，只能用于从磁盘加载的；<br>如果场景中有此asset的引用，Unity会自动重新加载它，CPU开销小。</li><li>Resources.UnloadUnusedAssets<br>卸载所有未被引用的asset，可以在画面切换时调用，或定时调用释放全局未使用资源。<br>被脚本的静态变量引用的资源不会被卸载。<br>尽量避免在游戏进行中调用，因为该接口开销较大，容易引起卡顿<br>可尝试用Resources.Unload(obj)逐个卸载，保证游戏的流畅度。</li></ul><h3 id="2-1-3-案例"><a href="#2-1-3-案例" class="headerlink" title="2.1.3 案例"></a>2.1.3 案例</h3><p>需要新建一个Resources目录，并且并将资源放在这目录中。<br>使用Resources.Load(Path)静态方法加载该目录路径下的资源。</p><p>示例：</p><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617174912162.png" srcset="/img/loading.gif" alt="image-20210617174912162"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine; <br><span class="hljs-keyword">using</span> System.Collections; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadResources</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123; <br><span class="hljs-keyword">public</span> Image image; <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-built_in">string</span> str = Resources.Load (<span class="hljs-string">&quot;Text&quot;</span>).ToString(); <br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2-2-StreamingAssets"><a href="#2-2-StreamingAssets" class="headerlink" title="2.2 StreamingAssets"></a>2.2 StreamingAssets</h2><p>StreamingAssets和Resources很像。<br>同样作为一个只读的Unity3D的保留文件夹出现。</p><p>不过两者也有很大的区别。<br>那就是Resources文件夹中的内容在打包时会被压缩和加密。<br>而StreamingAsset文件夹中的内容则会原封不动的打入包中，因此StreamingAssets主要用来存放一些二进制文件。</p><h3 id="2-2-1-特点"><a href="#2-2-1-特点" class="headerlink" title="2.2.1 特点"></a>2.2.1 特点</h3><ul><li>只读不可写。</li><li>主要用来存放二进制文件。</li><li>只能用过WWW类来读取。</li></ul><h3 id="2-2-2-使用方法"><a href="#2-2-2-使用方法" class="headerlink" title="2.2.2 使用方法"></a>2.2.2 使用方法</h3><p>首先我们新建一个StreamingAssets目录，并且并将资源放在这目录中。</p><blockquote><p>StreamingAssets文件夹内的东西并不会被压缩和加密，放进去什么就是什么<br>所以一般是要放二进制文件的<br>在实际操作中切记不要直接把数据文件放到这个目录中打包</p></blockquote><p>示例：</p><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617175047000.png" srcset="/img/loading.gif" alt="image-20210617175047000"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine; <br><span class="hljs-keyword">using</span> System.Collections; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadResources</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123; <br>    <span class="hljs-built_in">string</span> _result;  <br>    Start () <br>    &#123;  <br>        StartCoroutine(LoadXML());  <br>    &#125;  <br>    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadXML</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-built_in">string</span> sPath= Application.streamingAssetsPath + <span class="hljs-string">&quot;/Test.xml&quot;</span>; <br>        WWW www = <span class="hljs-keyword">new</span> WWW(sPath); <br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> www; <br>        _result = www.text; <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2-3-AssetBundle"><a href="#2-3-AssetBundle" class="headerlink" title="2.3 AssetBundle"></a>2.3 AssetBundle</h2><p>AssetBundle就是把prefab或者二进制文件封装成AssetBundle文件。</p><h3 id="2-3-1-生存周期"><a href="#2-3-1-生存周期" class="headerlink" title="2.3.1 生存周期"></a>2.3.1 生存周期</h3><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617180330593.png" srcset="/img/loading.gif" alt="image-20210617180330593"></p><p>1.Unity 在使用 WWW 方法时会分配一系列的内存空间来存放 WWW 实例对象、 WebStream 数据。该数据包括原始的 AssetBundle 数据、解压后的 AssetBundle 数据以及一个用于解压的 Decompression Buffer 。（一般情况下， Decompression Buffer 会在原始的 AssetBundle 解压完成后自动销毁，但需要注意的是， Unity 会自动保留一个 Decompression Buffer ，不被系统回收，这样做的好处是不用过于频繁的开辟和销毁解压 Buffer ，从而在一定程度上降低 CPU 的消耗。）</p><p>2.当把AssetBundle 解压到内存后，可以使用WWW .assetBundle属性来获取AssetBundle 对象，从而可以得到各种Asset，进而对这些Assets进行加载或者实例化操作。加载过程中，Unity 会将AssetBundle 中的数据流转变为引擎可以识别的信息类型(纹理、材质、对象等)。加载完成后，开发者可以对其进行进一步的操作，比如对象的实例化、纹理和材质的复制和替换等。</p><p>更新：</p><p>游戏一开始运行时，通过文件里面记录的版本号，和服务器上文件中的版本号比对。如果本地版本号低，下载对应的AB包到可读写目录，并对本地资源进行替换，这样进入游戏中加载的就是新下载的AB包资源。</p><p>更新流程如下：</p><pre><code>   1.  将更新包资源(安装包中的资源)复制到可读写目录下   2.  复制完成开始比对哈希文件,开始更新资源   3.  下载添加资源,替换旧资源,删除原来可读写目录下的无用资源   4.  初始化assetbundle依赖关系   5.  完成整个流程</code></pre><p>更新注意：</p><pre><code>   1.  要有下载失败重试几次机制；   2.  要进行超时检测；   3.  要记录更新日志，例如哪几个资源时整个更新流程失败。</code></pre><h3 id="2-3-1-特点"><a href="#2-3-1-特点" class="headerlink" title="2.3.1 特点"></a>2.3.1 特点</h3><ul><li>是Unity3D定义的一种二进制类型。</li><li>使用WWW类来下载。</li></ul><h3 id="2-3-2-使用方法"><a href="#2-3-2-使用方法" class="headerlink" title="2.3.2 使用方法"></a>2.3.2 使用方法</h3><p>这里就和上面两个不一样了。</p><p>首先我们要把我们的文件Test.xml打成AssetBundle文件，由于本案例AssetBundle的平台选择为Andorid。</p><p>如图，我们创建了一个AssetBundle文件，并命名为TextXML。<br>并且按照二进制文件放入StreamingAssets文件夹中的惯例，将这个AssetBundle文件放入StreamingAssets文件夹。</p><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617175300313.png" srcset="/img/loading.gif" alt="image-20210617175300313"></p><p>下面是从AssetBudle中读取Test.xml的代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> EggToolkit;<br><span class="hljs-keyword">using</span> System.Xml.Linq;<br><span class="hljs-keyword">using</span> System.Xml;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _result;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123;<br>LoadXML();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadXML</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>AssetBundle AssetBundleCsv = <span class="hljs-keyword">new</span> AssetBundle();<br><span class="hljs-comment">//读取放入StreamingAssets文件夹中的bundle文件</span><br><span class="hljs-built_in">string</span> str = Application.streamingAssetsPath + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-string">&quot;TestXML.bundle&quot;</span>;<br>WWW www = <span class="hljs-keyword">new</span> WWW(str);<br>www = WWW.LoadFromCacheOrDownload(str, <span class="hljs-number">0</span>);<br>AssetBundleCsv = www.assetBundle;<br><span class="hljs-built_in">string</span> path = <span class="hljs-string">&quot;Test&quot;</span>;<br>TextAsset test = AssetBundleCsv.Load(path, <span class="hljs-keyword">typeof</span>(TextAsset)) <span class="hljs-keyword">as</span> TextAsset;<br>_result = test.ToString();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-PersistentDataPath"><a href="#2-4-PersistentDataPath" class="headerlink" title="2.4 PersistentDataPath"></a>2.4 PersistentDataPath</h2><p>这个路径下是可读写。<br>而且在IOS上就是应用程序的沙盒，但是在Android可以是程序的沙盒，也可以是sdcard。<br>并且在Android打包的时候，ProjectSetting页面有一个选项Write Access，可以设置它的路径是沙盒还是sdcard。</p><h3 id="2-4-1-特点"><a href="#2-4-1-特点" class="headerlink" title="2.4.1 特点"></a>2.4.1 特点</h3><ul><li>内容可读写，不过只能运行时才能写入或者读取。 <strong>提前将数据存入这个路径是不可行的</strong>。</li><li>无内容限制。你可以从 StreamingAsset 中读取二进制文件或者从 AssetBundle 读取文件来写入 PersistentDataPath 中。</li><li>写下的文件，可以在电脑上查看。同样也可以清掉。</li><li>需要使用WWW类来读取。</li></ul><h3 id="2-4-2-使用方法"><a href="#2-4-2-使用方法" class="headerlink" title="2.4.2 使用方法"></a>2.4.2 使用方法</h3><p>之前我们说过，内容可读写，不过只能运行时才能写入或者读取。 <strong>提前将数据存入这个路径是不可行的</strong>。也就是说，PersistentDataPath是在运行时生成的，例如通过网络下载资源存在放PersistentDataPath中。</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine; <br><span class="hljs-keyword">using</span> System.Collections; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadResources</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123; <br>    <span class="hljs-built_in">string</span> _result; <br>    Start () <br>    &#123;  <br>        StartCoroutine(LoadXML());  <br>    &#125;  <br>    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadXML</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-built_in">string</span> sPath= Application.persistentDataPath + <span class="hljs-string">&quot;/test.xml&quot;</span>; <br>        sPath = <span class="hljs-string">&quot;file://&quot;</span> + sPath; WWW www = <span class="hljs-keyword">new</span> WWW(sPath); <br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> www; <br>        _result = www.text; <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>这加载方式看起来与StreamingAssets很相识，但是注意这里多了行<code>sPath = &quot;file://&quot; + sPath;</code><br>这很重要！！</p><p>想要通过WWW类加载PersistentDataPath必须使用**file://**协议实现加载。</p><h1 id="3-各平台下的资源路径"><a href="#3-各平台下的资源路径" class="headerlink" title="3. 各平台下的资源路径"></a>3. 各平台下的资源路径</h1><p>想读取文件就必须找到文件所在的目录，我们先来了解一下Unity下各个资源路径的特点和在各平台下资源路径的存放位置吧。</p><h2 id="3-1-Unity3D中的资源路径"><a href="#3-1-Unity3D中的资源路径" class="headerlink" title="3.1 Unity3D中的资源路径"></a>3.1 Unity3D中的资源路径</h2><table><thead><tr><th align="left">路径属性</th><th align="left">路径说明</th></tr></thead><tbody><tr><td align="left">Application.dataPath</td><td align="left">此属性用于返回程序的数据文件所在文件夹的路径。例如在Editor中就是Assets了。</td></tr><tr><td align="left">Application.streamingAssetsPath</td><td align="left">此属性用于返回流数据的缓存目录，返回路径为相对路径，适合设置一些外部数据文件的路径。放在Unity工程StreamingAssets文件夹中的资源发布后都可以通过这个路径读取出来。</td></tr><tr><td align="left">Application.persistentDataPath</td><td align="left">此属性用于返回一个持久化数据存储目录的路径，可以在此路径下存储一些持久化的数据文件。</td></tr><tr><td align="left">Application.temporaryCachePath</td><td align="left">此属性用于返回一个临时数据的缓存目录。</td></tr></tbody></table><h2 id="3-2-android平台"><a href="#3-2-android平台" class="headerlink" title="3.2 android平台"></a>3.2 android平台</h2><table><thead><tr><th align="left">路径属性</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left">Application.dataPath</td><td align="left">/data/app/xxx.xxx.xxx.apk</td></tr><tr><td align="left">Application.streamingAssetsPath</td><td align="left">jar:file:///data/app/xxx.xxx.xxx.apk/!/assets</td></tr><tr><td align="left">Application.persistentDataPath</td><td align="left">/data/data/xxx.xxx.xxx/files</td></tr><tr><td align="left">Application.temporaryCachePath</td><td align="left">/data/data/xxx.xxx.xxx/cache</td></tr></tbody></table><h2 id="3-3-ios平台"><a href="#3-3-ios平台" class="headerlink" title="3.3 ios平台"></a>3.3 ios平台</h2><table><thead><tr><th align="left">路径属性</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left">Application.dataPath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data</td></tr><tr><td align="left">Application.streamingAssetsPath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw</td></tr><tr><td align="left">Application.persistentDataPath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents</td></tr><tr><td align="left">Application.temporaryCachePath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches</td></tr></tbody></table><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1><p>本文90%的内容都是参考：<br><a href="http://www.tuicool.com/articles/qMNnmm6">http://www.tuicool.com/articles/qMNnmm6</a></p><p><a href="https://blog.csdn.net/jfy307596479/article/details/84975736">https://blog.csdn.net/jfy307596479/article/details/84975736</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>资源处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGUI详解-画布</title>
    <link href="/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/"/>
    <url>/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h1><ul><li><p>UI组件</p><ul><li><p><a href="https://mycroftcooper.github.io/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/">画布</a></p></li><li><p><a href="">图片</a></p></li><li><p>文本</p></li><li><p>按钮</p></li><li><p>单选框</p></li><li><p>滑动条</p></li><li><p>滚动条</p></li><li><p>下拉菜单</p></li><li><p>输入框</p></li><li><p>视频播放</p></li></ul></li><li><p>控制组件</p><ul><li>矩形变换组件</li><li>布局元素组件</li><li>布局控制组件</li></ul></li><li><p>UI事件</p></li><li><p>图集</p></li><li><p>渲染顺序</p></li></ul><h1 id="1-画布"><a href="#1-画布" class="headerlink" title="1. 画布"></a>1. 画布</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>画布组件是UI渲染最主要的组件。</p><p>我们可以将画布组件理解成一个容器，其他UI元素都必须填充到该容器中，最终形成我们看到的一个UI界面。</p><p>如果场景中没有画布，那么我们创建任何一个UI元素，都会自动创建画布，并且将新元素置于其下。</p><p>因此可以游戏中用到画布组件的地方均可以作为一个独立的游戏界面。</p><blockquote><p>当容器的渲染属性发生改变时，所有子物体均会受到影响。</p></blockquote><h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><ul><li>只有放在画布组件下的子物体才会参与UI的渲染。</li><li>形状大小取决于屏幕分辨率， 创建出来的画布组件是一个矩形，我们可以修改Game窗口的分辨率选项来修改矩形的大小。<blockquote><p>窗口分辨率默认设置为Free Aspect我们可以把它切换成90像素x1080像素这样具体数值的分辨率，这样我们的界面就不容易易出现变形。</p></blockquote></li><li>子物体的渲染层级取决于UI元素在层次结构中出现的顺序<br>两个UI元素在位置上重叠，层级结构下方的UI元素会遮挡上方的UI元素</li></ul><h2 id="1-3-渲染模式"><a href="#1-3-渲染模式" class="headerlink" title="1.3 渲染模式"></a>1.3 渲染模式</h2><p>三种渲染模式的区别：</p><table><thead><tr><th>渲染模式</th><th>画布对应屏幕</th><th>摄像机</th><th>像素对应</th><th>适合类型</th></tr></thead><tbody><tr><td>Screen Space-Overlay</td><td>是</td><td>不需要</td><td>可选</td><td>2D UI</td></tr><tr><td>Screen Space-Camera</td><td>是</td><td>需要</td><td>可选</td><td>2D UI</td></tr><tr><td>World Space</td><td>否</td><td>需要</td><td>不可选</td><td>3D UI</td></tr></tbody></table><h3 id="1-3-1-覆盖渲染模式"><a href="#1-3-1-覆盖渲染模式" class="headerlink" title="1.3.1 覆盖渲染模式"></a>1.3.1 覆盖渲染模式</h3><p><strong>Screen Space-Overlay</strong>（屏幕控件-覆盖模式）的画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层，或者说画布的画面永远“覆盖”其他普通的3D画面，如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕，如下图效果：</p><p><img src="/images/Unity-UGUI-%E7%94%BB%E5%B8%83/image-20210615154529500.png" srcset="/img/loading.gif" alt="image-20210615154529500"></p><blockquote><p>在此模式下，虽然在Canvas前放置了3D人物，但是在Game窗口中并不能观察到3D人物</p></blockquote><p><strong>Screen Space-Overlay</strong>模式的画布有三个参数：</p><ul><li><strong>Pixel Perfect</strong> 抗锯齿渲染<br>只有RenderMode为Screen类型时才有的选项。<br>使UI元素像素对应，效果就是边缘清晰不模糊。</li><li><strong>Sort Layer</strong> 渲染排序<br>是UGUI专用的设置，用来指示画布的深度。</li><li><strong>TargetDisplay</strong> 显示目标<br>与多屏幕显示相关</li></ul><h3 id="1-3-2-摄像机渲染模式"><a href="#1-3-2-摄像机渲染模式" class="headerlink" title="1.3.2 摄像机渲染模式"></a>1.3.2 摄像机渲染模式</h3><p><strong>Screen Space-Camera</strong>（屏幕空间-摄影机模式）和<strong>Screen Space-Overlay</strong>模式类似，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。</p><p>所不同的是，在该模式下，画布会被放置到摄影机前方。<br>在这种渲染模式下，画布看起来 绘制在一个与摄影机固定距离的平面上。<br>所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。<br>在此模式下，UI元素是由<strong>perspective</strong>也就是视角设定的，视角广度由Filed of View设置。</p><p>这种模式可以用来实现在UI上显示3D模型的需求，比如:<br>很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。<br>通过设置<strong>Screen Space-Camera</strong>模式就可以实现上述的需求，效果如下图所示：<img src="/images/Unity-UGUI-%E7%94%BB%E5%B8%83/image-20210615155308173.png" srcset="/img/loading.gif" alt="image-20210615155308173"></p><p>它比<strong>Screen Space-Overlay</strong>模式的画布多了下面几个参数：</p><ul><li><strong>Render Camera</strong><br>渲染摄像机</li><li><strong>Plane Distance</strong><br>画布距离摄像机的距离</li><li><strong>Sorting Layer</strong><br>是UGUI专用的设置，用来指示画布的深度。<br>可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单-&gt;edit-&gt;Project Settings-&gt;Tags and Layers进入该页面。<br>可以点击“+”添加Layer，或者点击“-”删除Layer。<br>画布所使用的Sorting Layer越排在下面，显示的优先级也就越高。</li><li><strong>Order in Layer</strong><br>在相同的Sort Layer下的画布显示先后顺序。<br>数字越高，显示的优先级也就越高。</li></ul><h3 id="1-3-3-世界空间渲染"><a href="#1-3-3-世界空间渲染" class="headerlink" title="1.3.3 世界空间渲染"></a>1.3.3 世界空间渲染</h3><p>World Space即世界控件模式。<br>在此模式下，画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体。</p><p>画布的尺寸可以通过RectTransform设置，所有的UI元素可能位于普通3D物体的前面或者后面显示。</p><p>当UI为场景的一部分时，可以使用这个模式。</p><p>它有一个单独的参数:</p><ul><li><strong>Event Camera</strong><br>用来指定接受事件的摄像机，可以通过画布上的GraphicRaycaster组件发射射线产生事件。</li></ul><p>这种模式可以用来实现跟随人物移动的血条或者名称，如下图所示：</p><p><img src="/images/Unity-UGUI-%E7%94%BB%E5%B8%83/image-20210615155346268.png" srcset="/img/loading.gif" alt="image-20210615155346268"></p><h2 id="1-4-Canvas-Scale画布缩放组件"><a href="#1-4-Canvas-Scale画布缩放组件" class="headerlink" title="1.4 Canvas Scale画布缩放组件"></a>1.4 Canvas Scale画布缩放组件</h2><h3 id="1-4-1-作用"><a href="#1-4-1-作用" class="headerlink" title="1.4.1 作用"></a>1.4.1 作用</h3><p><strong>Canvas Scalerde</strong>的作用：</p><ul><li>控制整体界面UI元素的大小</li><li>UI界面比例自适应</li></ul><p>Canvas Scale画布缩放组件用于控制整体界面的缩放和画布上UI元素的像素密度。<br>这种缩放影响画布中的所有内容，包括文字大小和图像边框。</p><p>由于游戏会存在不同的分辨率模式，UI需要能在不同的分辨率下保持一个恰当的显示效果。<br>因此，我们需要让UI有一个可以适应的区域范围，比如屏幕由长方形变成正方形时，UI界面不会发生太严重的变形。</p><p>这个时候就需要设置画布缩放组件，以调节我们的UI界面始终保持和屏幕对齐。</p><h3 id="1-4-2-完美像素"><a href="#1-4-2-完美像素" class="headerlink" title="1.4.2 完美像素"></a>1.4.2 完美像素</h3><p><strong>Pixelperfect</strong><br>指一个UI素材本身的像素对应屏幕上一个像素的情况。<br>这种情况下UI素材映射到屏幕上时没有任何拉伸和压缩，这种情况下UI显示效果非常清晰完美。</p><h3 id="1-4-3-缩放组件的渲染模式"><a href="#1-4-3-缩放组件的渲染模式" class="headerlink" title="1.4.3 缩放组件的渲染模式"></a>1.4.3 缩放组件的渲染模式</h3><p>有三种UI缩放渲染模式，每种模式都有其相关参数：</p><ul><li><strong>Constant Pixel Size</strong><br>固定像素尺寸大小<br>不管屏幕尺寸如何变化, UI元素保持相同的像素大小</li><li><strong>Scale With Screen Size</strong><br>随屏幕缩放尺寸<br>使UI随着屏幕大小变化</li><li><strong>Constant Physical Size</strong><br>恒定物理尺寸<br>不管屏幕大小和分辨率如何变化, UI元素保持相同的物理尺寸</li></ul><h3 id="1-4-4-固定像素尺寸大小模式"><a href="#1-4-4-固定像素尺寸大小模式" class="headerlink" title="1.4.4 固定像素尺寸大小模式"></a>1.4.4 固定像素尺寸大小模式</h3><h4 id="1-4-4-1-缩放系数参数"><a href="#1-4-4-1-缩放系数参数" class="headerlink" title="1.4.4.1 缩放系数参数"></a>1.4.4.1 缩放系数参数</h4><p><strong>Scale Factor参数</strong><br>Canvas整体的缩放比例</p><ul><li>在<strong>Screen Space – Overlay</strong> 的情况下默认为1</li><li>在<strong>Screen Space – Camera</strong> 的情况下则不一定为1，会受到渲染UI的摄像机参数影响<blockquote><p>如果为Perspective 相机，会受到 Field Of View影响<br>如果是 Orthographic相机，会受到 Size影响</p></blockquote></li></ul><blockquote><p>默认推荐为1，表示正常大小</p></blockquote><h4 id="1-4-4-2-每单元参考像素大小参数"><a href="#1-4-4-2-每单元参考像素大小参数" class="headerlink" title="1.4.4.2 每单元参考像素大小参数"></a>1.4.4.2 每单元参考像素大小参数</h4><p><strong>ReferencePixelsPerUnit参数</strong></p><p>一般用这个是来缩放图片的，用这个Factor（因子）值我可以一张图实现很多的大小还不失真。<br>这种模式保证了恒定像素的来缩放的。<br>这个对美术来说是个好组建，不用每个大小的都做一张，只要调好Factor因子值就好了。</p><h3 id="1-4-5-随屏幕缩放尺寸模式"><a href="#1-4-5-随屏幕缩放尺寸模式" class="headerlink" title="1.4.5 随屏幕缩放尺寸模式"></a>1.4.5 随屏幕缩放尺寸模式</h3><h4 id="1-4-5-1-参考分辨率"><a href="#1-4-5-1-参考分辨率" class="headerlink" title="1.4.5.1 参考分辨率"></a>1.4.5.1 参考分辨率</h4><p><strong>Reference Resolution参数</strong><br>参照当前UI布局所依据的分辨率，随屏幕分辨率的变化而变化。</p><blockquote><p>游戏运行的最理想分辨率，就是你做游戏时采用的分辨率</p></blockquote><h4 id="1-4-5-2-屏幕匹配模式参数"><a href="#1-4-5-2-屏幕匹配模式参数" class="headerlink" title="1.4.5.2 屏幕匹配模式参数"></a>1.4.5.2 屏幕匹配模式参数</h4><p><strong>Screen Match Mode参数</strong><br>一共有以下三种屏幕匹配模式：</p><h5 id="1-4-5-2-1-匹配宽高模式"><a href="#1-4-5-2-1-匹配宽高模式" class="headerlink" title="1.4.5.2.1 匹配宽高模式"></a>1.4.5.2.1 匹配宽高模式</h5><p><strong>Match Width Or Height模式</strong><br>参考宽，或者高，或者两者来布局画布<br>一个滑条，拉在最左时是Width ，最右时是Height，中间则是按比例混合。</p><ul><li>当处于最左边时，屏幕高度对于UI大小完全没有任何影响，只有宽度会对UI大小产生影响。<br>假设宽度为Reference Resolution宽度的x倍，则UI整体缩放为Reference Resolution状态下的x倍。<br>也就是说只有宽度等于Reference Resolution宽度时，才能做到pixel perfect，否则像素就会有拉伸</li><li>当处于最右边时，与上述情况正好相反，决定整体缩放值的是高度，而宽度则没有任何影响</li><li>处于中间某处时，对上述两者的影响进行权重加成</li></ul><blockquote><p>一般来说：</p><ul><li><p>手机适配用高度适配</p></li><li><p>PC适配用宽度适配</p></li></ul><p>自适应并不是一定要适应全屏，它只会找一个最合适的匹配模式来显示。</p></blockquote><h5 id="1-4-5-2-2-扩展模式"><a href="#1-4-5-2-2-扩展模式" class="headerlink" title="1.4.5.2.2 扩展模式"></a>1.4.5.2.2 扩展模式</h5><p><strong>Expand模式</strong><br>当屏幕分辨率大于参考分辨率时，选择变化较小的一个方向（横向还是纵向），作为放大Canvas Scale的标准，另一方向上的变化则是在整体缩放以后再进行补偿性的变化。<br>此举旨在减少扩大分辨率时由于非等比扩大而对UI整体布局造成影响。<br>适合制作较小标准尺寸，扩充到较大屏幕。</p><p>例如：<br>假设Reference Resolution为800*600，Canvas Scale为(1,1,1)。<br>如果实际分辨率为800*800,那么Canvas Scale还保持为(1,1,1)因为宽度没有发生变化，只是单纯的高度增加了200。<br>所以势必对布局造成一定得影响。</p><p>1000*600的情况也是一样，Canvas Scale没有变化，只是单纯宽度增加了200。</p><p>但如果实际分辨率变为1000*800,那么Canvas Scale就变成(1.25,1.25,1.25)。<br>因为宽度是参考分辨率宽度的1.25倍，高度是1.33倍，那么取较小的1.25。 </p><p>这个1.25倍的意义是：<br>整体Canvas渲染放大1.25倍，横向或纵向的变化超过了1.25倍，则靠拉伸Canvas来变化，此时因为这部分变化，可能会对布局产生一些相对较小的影响，例如相对位置、某些元素的长宽比。</p><h5 id="1-4-5-2-3-收缩模式"><a href="#1-4-5-2-3-收缩模式" class="headerlink" title="1.4.5.2.3 收缩模式"></a>1.4.5.2.3 收缩模式</h5><p><strong>Shrink模式</strong><br>和Expand类似，但是更适合于缩小的情形。<br>它会在屏幕尺寸缩小时，通过缩小CanvasScale尽量减少由于非等比缩小对布局产生的影响。<br>按照影响较小的一个方向缩小的比例去缩小CanvasScale，然后再通过变形调整另外一个方向。</p><h3 id="1-4-6-恒定物理尺寸模式"><a href="#1-4-6-恒定物理尺寸模式" class="headerlink" title="1.4.6 恒定物理尺寸模式"></a>1.4.6 恒定物理尺寸模式</h3><p><strong>Contant Physical Size 恒定物理尺寸模式</strong>和Constant Pixel Size类似，但是只能通过RectTransform来改变大小。</p><p>很少用到，就略述了。</p><p><strong>参数表</strong></p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>物理单位</td><td>指定位置和大小的物理单位</td></tr><tr><td>Fallback Screen DPI</td><td>屏幕DPI未知时采用的DPI</td></tr><tr><td>默认屏幕DPI</td><td>每英寸像素数，用于具有“每单位像素数”属性的sprites ,该属性与“每单位参考像素数”匹配</td></tr><tr><td>每单位像素数</td><td>如果一个sprite具有“每单位像素数”属性,它的DPI会匹配”默认的spriteDPI”设置</td></tr></tbody></table><h1 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h1><p><a href="https://www.cnblogs.com/crazytomato/p/7832838.html">https://www.cnblogs.com/crazytomato/p/7832838.html</a></p><p><a href="https://www.cnblogs.com/morning-lee/p/7135782.html">https://www.cnblogs.com/morning-lee/p/7135782.html</a></p><p><a href="https://www.cnblogs.com/msxh/p/6337338.html">https://www.cnblogs.com/msxh/p/6337338.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>UGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>UGUI</tag>
      
      <tag>画布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程基本知识</title>
    <link href="/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1进程-线程"><a href="#1-1进程-线程" class="headerlink" title="1.1进程/线程"></a>1.1进程/线程</h2><h3 id="1-1-1-进程"><a href="#1-1-1-进程" class="headerlink" title="1.1.1 进程"></a>1.1.1 进程</h3><p>进程指一个应用程序所运行的操作系统单元，它是操作系统环境中的基本成分、是系统进行资源分配的基本单位。</p><p>进程是执行程序的实例。<br>当运行一个应用程序后，就生成了一个进程，这个进程拥有自己的独立内存空间。<br>每一个进程对应一个活动的程序，当进程激活时，操作系统就将系统的资源包括内存、I/O和CPU等分配给它，使它执行。</p><ul><li><p>进程在运行时创建的资源随着进程的终止而死亡。</p></li><li><p>进程间获得专用数据或内存的唯一途径就是通过协议来共享内存块，这是一种协作策略。</p></li><li><p>一个进程可以创建多个线程及子进程（启动外部程序）。</p></li><li><p>一个进程内部的线程可以共享该进程所分配的资源。</p></li></ul><p>由于进程之间的切换非常消耗资源和时间，为了提高操作系统的并发性，提高CPU的利用率，在进程下面又加入了线程的概念。<br>线程的创建与撤销、线程之间的切换所占用的资源比进程少很多。</p><h3 id="1-1-2-线程"><a href="#1-1-2-线程" class="headerlink" title="1.1.2 线程"></a>1.1.2 线程</h3><p>进程可以分为若干个独立执行流（路径），这些执行流被称为线程。</p><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>线程是进程的一个实体，是CPU调度和分配时间的基本单位。</p><p>线程基本不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同一进程的其它线程共享进程所拥有的全部资源。<br>所以线程间共享内存空间很容易做到，多线程协作也很容易和便捷。</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程间可以并发执行。</p><p>线程提供了多任务处理的能力。</p><h3 id="1-1-3-线程与进程的异同"><a href="#1-1-3-线程与进程的异同" class="headerlink" title="1.1.3  线程与进程的异同"></a>1.1.3  线程与进程的异同</h3><ul><li><p>地址空间：</p><ul><li><p>进程拥有自己独立的内存地址空间；</p></li><li><p>线程共享进程的地址空间；</p><blockquote><p>换句话说就是进程间彼此是完全隔绝的，同一进程的所有线程共享(堆heap)内存；</p></blockquote></li></ul></li><li><p>资源拥有：</p><ul><li>进程是资源分配和拥有的单位</li><li>同一进程内的线程共享进程的资源；</li></ul></li><li><p>系统粒度：</p><ul><li>进程是分配资源的基本单位</li><li>线程则是系统（处理器）调度的基本单位；</li></ul></li><li><p>执行过程：</p><ul><li>每个独立的进程都有一个程序运行的入口、顺序执行序列和程序的出口；</li><li>线程不能独立执行，必须依存于进程中；</li></ul></li><li><p>系统开销：</p><p>创建或撤销进程时，系统都要为之分配或回收资源（如内存空间、IO设备）<br>进程间的切换也要消耗远大于线程切换的开销。</p></li></ul><p>二者均可并发执行。</p><p>一个程序至少有一个进程，一个进程至少有一个线程（主线程）。<br>主线程以函数地址的形式，如Main或WinMain函数，提供程序的启动点，当主线程终止时，进程也随之终止。<br>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</p><h2 id="1-2-并发-并行"><a href="#1-2-并发-并行" class="headerlink" title="1.2 并发/并行"></a>1.2 并发/并行</h2><p>在单CPU系统中，系统调度在某一刻只能让一个线程运行，虽然这种调度机制有多种形式（时分/频分），但无论如何，要通过不断切换需要运行的线程，这种运行模式称为并发（Concurrent）。</p><p>而在多CPU系统中，可以让两个以上的线程同时运行，这种运行模式称为并行（Parallel）。</p><h2 id="1-3-同步-异步操作"><a href="#1-3-同步-异步操作" class="headerlink" title="1.3 同步/异步操作"></a>1.3 同步/异步操作</h2><h3 id="1-3-1-同步与异步的定义"><a href="#1-3-1-同步与异步的定义" class="headerlink" title="1.3.1 同步与异步的定义"></a>1.3.1 同步与异步的定义</h3><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p><ul><li><p>同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。</p></li><li><p>异步，和同步相反 调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回掉函数来处理这个调用。</p></li></ul><p>所有的程序最终都会由计算机硬件来执行，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。<br>这些无须消耗CPU时间的I/O操作是异步操作的硬件基础。<br>硬盘、光驱、网卡、声卡、显卡都具有DMA功能。</p><p>DMA（DirectMemory Access）是直接内存访问的意思，它是不经过CPU而直接进行内存数据存储的数据交换模式。</p><p>I/O操作包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。</p><p>异步操作可达到避免调用线程堵塞的目的，从而提高软件的可响应性。</p><h3 id="1-3-2-同步与异步的对比"><a href="#1-3-2-同步与异步的对比" class="headerlink" title="1.3.2 同步与异步的对比"></a>1.3.2 同步与异步的对比</h3><p>线程不是一个计算机的硬件功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。</p><p>异步模式无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必共享变量，减少了死锁的可能。</p><p>不过，编写异步操作的复杂程度比较高，程序主要使用回调方式进行处理，与人的思维方式有出入，而且难以调试。</p><p>计算密集型工作使用多线程（如图形处理、算法）；IO密集型工作使用异步机制。</p><h2 id="1-4-任务管理器"><a href="#1-4-任务管理器" class="headerlink" title="1.4 任务管理器"></a>1.4 任务管理器</h2><p>映射名称列：<br>进程并不拥有独立于其所属实例的映射名称；</p><blockquote><p>如果运行5个Notepad拷贝，你会看到5个称为Notepad.exe的进程；</p></blockquote><p>它们是根据进程ID进行区分的，该进程ID是由系统维护，并可以循环使用。</p><p>CPU列：<br>它是进程中线程所占用的CPU时间百分比</p><p>每个任务管理器中的进程，其实内部都包含若干个线程，每个时间点都是某个程序进程中的某个线程在运行。</p><h2 id="1-5-线程是如何工作的"><a href="#1-5-线程是如何工作的" class="headerlink" title="1.5 线程是如何工作的"></a>1.5 线程是如何工作的</h2><p>线程被一个线程协调程序管理着——一个CLR委托给操作系统的函数。<br>线程协调程序确保将所有活动的线程被分配适当的执行时间；<br>并且那些等待或阻止的线程——比如说在排它锁中、或在用户输入——都是不消耗CPU时间的。</p><p>在单核处理器的电脑中，线程协调程序完成一个时间片之后迅速地在活动的线程之间进行切换执行。<br>这就导致“波涛汹涌”的行为，例如在第一个例子，每次重复的X 或 Y 块相当于分给线程的时间片。<br>在Windows XP中时间片通常在10毫秒内选择要比CPU开销在处理线程切换的时候的消耗大的多。(即通常在几微秒区间)</p><p>在多核的电脑中，多线程被实现成混合时间片和真实的并发——不同的线程在不同的CPU上运行。<br>但这仍然会出现一些时间切片,因为操作系统的服务线程、以及一些其他的应用程序都会争夺对CPU的使用权。</p><p>线程由于外部因素（比如时间片）被中断被称为被抢占，在大多数情况下,一个线程在被抢占的那一刻就失去了对它的控制权。</p><h2 id="1-6-线程安全"><a href="#1-6-线程安全" class="headerlink" title="1.6 线程安全"></a>1.6 线程安全</h2><p>当使用线程（Thread）时，程序员必须注意同步处理的问题</p><p>理论上每个Thread都是独立运行的个体，由CLR来主导排程，视Thread的优先权的设置，每个Thread会分到特定的运行时间，当某个Thread的运行时间用完时，CLR就会强制将运行权由该Thread取回，转交给下个Thread<br>这也就意味着Thread本身无法得知自己何时会丧失运行权，所以会发生所谓的race condition（竞速状态）。</p><p>当两个线程争夺一个锁的时候（在这个例子里是locker），一个线程等待，或者说被阻止到那个锁变的可用。<br>在这种情况下，就确保了在同一时刻只有一个线程能进入临界区，所以”Done”只被打印了1次。代码以如此方式在不确定的多线程环境中被叫做线程安全。</p><p>临时暂停，或阻止是多线程的协同工作，同步活动的本质特征。<br>等待一个排它锁被释放是一个线程被阻止的原因，另一个原因是线程想要暂停或Sleep一段时间：</p><p>Thread.Sleep (TimeSpan.FromSeconds (30));  // 阻止30秒</p><p>一个线程也可以使用它的Join方法来等待另一个线程结束：</p><p>Threadt = new Thread(Go);  // 假设Go是某个静态方法</p><p>t.Start();</p><p>t.Join();  // 等待（阻止）直到线程t结束</p><h1 id="2-使用多线程的情况分析"><a href="#2-使用多线程的情况分析" class="headerlink" title="2. 使用多线程的情况分析"></a>2. 使用多线程的情况分析</h1><h2 id="2-1-为什么要使用多线程"><a href="#2-1-为什么要使用多线程" class="headerlink" title="2.1 为什么要使用多线程"></a>2.1 为什么要使用多线程</h2><ul><li>并发需要<br>在C/S或B/S模式下的服务端需要处理来自不同终端的并发请求，使用单线程是不可思议的。</li><li>提高应用程序的响应速度<br>当一个耗时的操作进行时，当前程序都会等待这个操作结束<br>此时程序不会响应键盘、鼠标、菜单等操作，程序处于假死状态；<br>使用多线程可将耗时长的操作（Time Consuming）置于一个新的线程，此时程序仍能响应用户的其它操作</li><li>提高CPU利用率<br>在多CPU体系中，操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li><li>改善程序结构<br>一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分<br>这样的程序会利于理解和修改。</li><li>花销小、切换快<br>线程间的切换时间很小，可以忽略不计</li><li>方便的通信机制<br>线程间共享内存，互相间交换数据很简单。</li></ul><p>多线程的意义在于<br>一个应用程序中，有多个执行部分可以同时执行：<br>一个线程可以在后台读取数据，而另一个线程可以在前台展现已读取的数据。</p><p>C#支持通过多线程并行地执行代码，一个线程有它独立的执行路径，能够与其它的线程同时地运行。<br>一个C#程序开始于一个单线程，这个单线程是被CLR和操作系统（也称为“主线程”）自动创建的，并具有多线程创建额外的线程。</p><h2 id="2-2-何时使用多线程"><a href="#2-2-何时使用多线程" class="headerlink" title="2.2 何时使用多线程"></a>2.2 何时使用多线程</h2><p>多线程程序一般被用来在后台执行耗时的任务：主线程保持运行，而工作线程执行后台工作。</p><ul><li><p>对于Windows Forms程序来说，如果主线程执行了一个冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应，进入假死的状态，可能导致用户强制结束程序进程而出现错误。<br>有鉴于此，应该在主线程运行一个耗时任务时另外添加一个工作线程，同时在主线程上有一个友好的提示“处理中…”，允许继续接收事件（比如响应鼠标、键盘操作）。<br>同时程序还应该实现“取消”功能，允许取消/结束当前工作线程。<br>BackgroundWorker类就提供这一功能。</p></li><li><p>在没有用户界面的程序里，比如说WindowsService中使用多线程特别的有意义。<br>当一个任务有潜在的耗时（在等待被请求方的响应——比如应用服务器，数据库服务器），用工作线程完成任务意味着主线程可以在发送请求后立即做其它的事情。</p></li><li><p>另一个多线程的用途是在需要完成一个复杂的计算工作时,它会在多核的电脑上运行得更快，如果工作量被多个线程分开的话（C#中可使用Environment.ProcessorCount属性来侦测处理芯片的数量）。</p></li></ul><p>远程服务器，或WebServices或ASP.NET程序将别无选择，必须使用多线程；<br>一个单线程的ASP.NET Web Service是不可想象的；<br>幸运的是，应用服务器中多线程是相当普遍的；<br>唯一值得关心的是提供适当锁机制的静态变量问题。</p><h2 id="2-3-何时不用多线程"><a href="#2-3-何时不用多线程" class="headerlink" title="2.3 何时不用多线程"></a>2.3 何时不用多线程</h2><p>多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂<br>拥有多线程本身并不复杂，复杂是的线程的交互作用<br>无论交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的Bugs。<br>因此，要么多线程的交互设计简单一些，要么就根本不使用多线程，除非你有强烈的重写和调试欲望。</p><p>当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。<br>在某些情况下，太多的I/O操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务快的多。</p><h1 id="3-C-中的线程"><a href="#3-C-中的线程" class="headerlink" title="3. C#中的线程"></a>3. C#中的线程</h1><h2 id="3-1-程序域"><a href="#3-1-程序域" class="headerlink" title="3.1 程序域"></a>3.1 程序域</h2><p>在.Net中Process由AppDomain对象所取代。</p><p>虽然AppDomain在CLR中被视为Process的替代品，但实际上AppDomain跟Process是属于主从关系的，AppDomain被放置在一个Process中，<br>每个Process可以拥有多个AppDomain，<br>每个AppDomain又可拥有多个Thread对象。</p><p>Process、AppDomain、Thread的关系如下图所示：</p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/image-20210528201620106.png" srcset="/img/loading.gif" alt="进程、域、线程关系图"></p><p>AppDomain定义了一些事件供程序员使用。</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>AssemblyLoad</td><td>触发于AppDomain载入一个Assembly时</td></tr><tr><td>DomainUnLoad</td><td>触发于AppDomain卸载时，也就是Unload函数被调用或是该AppDomain被消灭前</td></tr><tr><td>ProcessExit</td><td>当默认的AppDomain被卸载时触发，多半是应用程序退出时</td></tr></tbody></table><p>各AppDomain间互不影响。</p><h2 id="3-2-C-中实现线程的方法"><a href="#3-2-C-中实现线程的方法" class="headerlink" title="3.2 C#中实现线程的方法"></a>3.2 C#中实现线程的方法</h2><p>一个C#程序成为多线程可以通过2种方式来实现：</p><ul><li><p>明确地创建和运行多线程</p></li><li><p>使用.NET Framework中封装了多线程的类<br>比如:</p><ul><li><p>BackgroundWorker类</p></li><li><p>线程池</p></li><li><p>Threading Timer</p></li></ul></li></ul><p>更多C#中实现线程的方法请看<br><a href="https://mycroftcooper.github.io/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/">C#中实现线程的方法</a></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>计算机基本知识</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#多线程</title>
    <link href="/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在学习本篇文章前你需要学习的相关知识：<br><a href="https://mycroftcooper.github.io/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">线程基本知识</a></p><p>此篇文章简单总结了C#中主要的多线程实现方法，包括：</p><ul><li>Thread<br>线程</li><li>ThreadPool<br>线程池</li><li>Parallel</li><li>Task<br>任务</li><li>BackgroundWorker组件</li></ul><h1 id="2-Thread类"><a href="#2-Thread类" class="headerlink" title="2. Thread类"></a>2. Thread类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li><p>使用Thread类通过ThreadStart（无参数）或ParameterizedThreadStart（一个输入参数）类型的委托创建一个Thread对象，开启一个新线程，执行该委托传递的任务，此时线程尚未处于运行状态。</p></li><li><p>调用Start()函数启动线程，当前线程继续执行。</p></li><li><p>调用Join()函数可以阻塞当前线程，直到调用Join()的线程终止。</p></li><li><p>调用Abort()方法，如需中止线程，在调用该方法的线程上抛出ThreadAbortException异常，以结束该线程</p></li><li><p>可以通过Thread.ResetAbort()方法阻止线程的中止。</p></li></ul><h2 id="2-1-属性表"><a href="#2-1-属性表" class="headerlink" title="2.1 属性表"></a>2.1 属性表</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Name</td><td>属性，获取或设置线程的名称</td></tr><tr><td>Priority</td><td>属性，获取或设置线程的优先级</td></tr><tr><td>ThreadState</td><td>属性，获取线程当前的状态</td></tr><tr><td>IsAlive</td><td>属性，获取当前线程是否处于启动状态</td></tr><tr><td>IsBackground</td><td>属性，获取或设置值，表示该线程是否为后台线程</td></tr><tr><td>CurrentThread</td><td>属性，获取当前正在运行的线程</td></tr></tbody></table><h2 id="2-2-方法表"><a href="#2-2-方法表" class="headerlink" title="2.2 方法表"></a>2.2 方法表</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Start()</td><td>方法，启动线程</td></tr><tr><td>Sleep(int millisecondsTimout)</td><td>方法，将当前线程暂停指定的毫秒数</td></tr><tr><td>Suspend()</td><td>方法，挂起当前线程（已经被弃用）</td></tr><tr><td>Join()</td><td>方法，阻塞调用线程，直到某个线程终止为止</td></tr><tr><td>Interrupt()</td><td>方法，中断当前线程</td></tr><tr><td>Resume()</td><td>方法，继续已经挂起的线程（已经被弃用）</td></tr><tr><td>Abort()</td><td>方法，终止线程（已经被弃用）</td></tr></tbody></table><h2 id="2-3-开启线程"><a href="#2-3-开启线程" class="headerlink" title="2.3 开启线程"></a>2.3 开启线程</h2><p>首先用new申请Thread对象，然后对象调用Start()方法启用线程。</p><p>代码如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Thread.CurrentThread.ManagedThreadId获取当前线程的ID，便于管理。</p></blockquote><p>用Lambda表达式代替函数调用，也能达到相同的效果</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>        &#125;);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-传递参数"><a href="#2-4-传递参数" class="headerlink" title="2.4 传递参数"></a>2.4 传递参数</h2><p>有两种为线程传递参数的方法：</p><ul><li><p>Start()函数传参法</p></li><li><p>对象成员方法传参法</p></li><li><p>匿名方法传参法</p><h3 id="2-4-1-Start-函数传参"><a href="#2-4-1-Start-函数传参" class="headerlink" title="2.4.1 Start()函数传参"></a>2.4.1 Start()函数传参</h3></li></ul><p>为某方法创建新线程后，在使用Start()方法启动线程时传递该方法需要的参数。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> name</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + name);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start(<span class="hljs-string">&quot;April&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-1-对象传递"><a href="#2-4-1-对象传递" class="headerlink" title="2.4.1 对象传递"></a>2.4.1 对象传递</h3><p>初始化一个对象，然后用对象的方法初始化Thread，这样该线程就可以使用这个对象的所有成员。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Download</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> Id;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> Name;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Download</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, <span class="hljs-built_in">string</span> name</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Id = id;<br>            Name = name;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownloadFile</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + <span class="hljs-string">&quot;ID: &quot;</span> + Id + <span class="hljs-string">&quot; Name: &quot;</span> + Name);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);              <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Download download = <span class="hljs-keyword">new</span> Download(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;人民日报&quot;</span>);<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(download.DownloadFile);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-5-匿名方法"><a href="#2-4-5-匿名方法" class="headerlink" title="2.4.5 匿名方法"></a>2.4.5 匿名方法</h3><p>需要接收多个参数的解决方案是使用一个匿名方法调用，方法如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (<span class="hljs-string">&quot;Hello&quot;</span>); &#125;);<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure><p>它的优点是目标方法（这里是WriteText），可以接收任意数量的参数，并且没有装箱操作。</p><p>不过这需要将一个外部变量放入到匿名方法中，如下示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">voidMain</span>(<span class="hljs-params"></span>)</span> &#123;<br>stringtext = <span class="hljs-string">&quot;Before&quot;</span>;<br><br>Threadt = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (text); &#125;);<br><br>text = <span class="hljs-string">&quot;After&quot;</span>;<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是:<br>当外部变量的值被修改，匿名方法可能进行无意的互动，导致一些古怪的现象。<br>一旦线程开始运行，外部变量最好被处理成只读的——除非有人愿意使用适当的锁。</p></blockquote><h2 id="2-5-线程命名"><a href="#2-5-线程命名" class="headerlink" title="2.5 线程命名"></a>2.5 线程命名</h2><p>线程可以通过它的Name属性进行命名，这非常有利于调试：<br>可以用Console.WriteLine打印出线程的名字<br>Microsoft Visual Studio可以将线程的名字显示在调试工具栏的位置上。</p><p>线程的名字可以在被任何时间设置——但只能设置一次，重命名会引发异常。</p><p>程序的主线程也可以被命名，下面例子里主线程通过CurrentThread命名：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#">Class ThreadNaming &#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread.CurrentThread.Name= <span class="hljs-string">&quot;main&quot;</span>;<br><br>Thread worker = <span class="hljs-keyword">new</span> Thread(Go);<br><br>worker.Name= <span class="hljs-string">&quot;worker&quot;</span>;<br><br>worker.Start();<br><br>Go();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Go</span>(<span class="hljs-params"></span>)</span> &#123;<br>Console.WriteLine (<span class="hljs-string">&quot;Hello from &quot;</span>+ Thread.CurrentThread.Name);<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><p>Hellofrom main</p><p>Hellofrom worker</p><h2 id="2-6-前台线程和后台线程"><a href="#2-6-前台线程和后台线程" class="headerlink" title="2.6 前台线程和后台线程"></a>2.6 前台线程和后台线程</h2><ul><li>前台线程(用户界面线程)<br>只要存在有一个前台线程在运行，应用程序就在运行<br>通常用来处理用户的输入并响应各种事件和消息</li><li>后台线程(工作线程)<br>应用程序关闭时，如果后台线程没有执行完，会被强制性的关闭<br>用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等</li></ul><p>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-built_in">string</span>[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//设为后台线程</span><br>        thread.IsBackground = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上例中，thread被设置为后台线程。<br>Main执行完后，没有前台线程了，应用程序就结束，虽然后台线程thread此时尚未执行完，也被终止。</p><blockquote><p>改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。</p></blockquote><p>拥有一个后台工作线程是有益的，<br>最直接的理由是当提到结束程序它总是可能有最后的发言权。<br>交织以不会消亡的前台线程，保证程序的正常退出。</p><p>抛弃一个前台工作线程是尤为险恶的，尤其对Windows Forms程序，<br>因为程序直到主线程结束时才退出（至少对用户来说），但是它的进程仍然运行着。<br>在Windows任务管理器它将从应用程序栏消失不见，但却可以在进程栏找到它。<br>除非用户找到并结束它，它将继续消耗资源，并可能阻止一个新的实例的运行从开始或影响它的特性。</p><p>对于程序失败退出的普遍原因就是存在“被忘记”的前台线程。</p><table><thead><tr><th>线程类型</th><th>动作</th><th>结束</th><th>后续处理</th></tr></thead><tbody><tr><td>前台线程</td><td>主程序关闭</td><td>否</td><td>显示关闭线程/杀掉当前进程</td></tr><tr><td>后台线程</td><td>主程序关闭</td><td>是</td><td>无</td></tr></tbody></table><h2 id="2-7-注意事项"><a href="#2-7-注意事项" class="headerlink" title="2.7 注意事项"></a>2.7 注意事项</h2><ul><li><p>Thread类创建的线程默认为前台线程，可以通过IsBackground属性设置其为前台或后台线程。</p><blockquote><p>用Thread类创建的线程是前台线程，线程池中的线程总是后台线程</p></blockquote></li><li><p>可以通过Priority属性设置线程的优先级。</p></li><li><p>线程内部可以通过try catch捕获该异常，在catch模块中进行一些必要的处理<br>如释放持有的锁和文件资源等</p></li><li><p>慎重使用Abort()方法<br>如果在当前线程中抛出该异常，其结果是可预测的<br>但是对于其他线程，它会中断任何正在执行的代码，有可能中断静态对象的生成，造成不可预测的结果。</p></li></ul><h1 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>ThreadPool类维护一个线程的列表，提供给用户以执行不同的小任务，减少频繁创建线程的开销。<br>该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</p><p>线程池其实就是一个存放线程对象的“池子(pool)”，他提供了一些基本方法，如：设置pool中最小/最大线程数量、把要执行的方法排入队列等等。ThreadPool是一个静态类，因此可以直接使用，不用创建对象。</p><h2 id="3-2-线程池的优点"><a href="#3-2-线程池的优点" class="headerlink" title="3.2 线程池的优点"></a>3.2 线程池的优点</h2><p>每新建一个线程都需要占用内存空间和其他资源<br>而新建了那么多线程，有很多在休眠，或者在等待资源释放；<br>又有许多线程只是周期性的做一些小工作，如刷新数据等等，太浪费了，划不来。<br>实际编程中大量线程突发，然后在短时间内结束的情况很少见。</p><p>于是，就提出了线程池的概念。</p><p>线程池中的线程执行完指定的方法后并不会自动消除，而是以挂起状态返回线程池，如果应用程序再次向线程池发出请求，那么处以挂起状态的线程就会被激活并执行任务，而不会创建新线程，这就节约了很多开销。<br>只有当线程数达到最大线程数量，系统才会自动销毁线程。</p><p>因此，使用线程池可以避免大量的创建和销毁的开支，具有更好的性能和稳定性，其次，开发人员把线程交给系统管理，可以集中精力处理其他任务。</p><h2 id="3-3-线程池的使用"><a href="#3-3-线程池的使用" class="headerlink" title="3.3 线程池的使用"></a>3.3 线程池的使用</h2><ul><li><p>设置线程池最大最小：<br><strong>ThreadPool.SetMaxThreads (int workerThreads,int completionPortThreads)</strong><br>设置可以同时处于活动状态的线程池的请求数目。<br>所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。<br>还可以设置最小线程数。</p></li><li><p>将任务添加进线程池:<br><strong>ThreadPool.QueueUserWorkItem(new WaitCallback(方法名));**或<br>**ThreadPool.QueueUserWorkItem(new WaitCallback(方法名), 参数);</strong></p></li></ul><p>但是线程池的使用也有一些限制：</p><ul><li>线程池中的线程均为后台线程，并且不能修改为前台线程</li><li>不能给入池的线程设置优先级或名称</li><li>对于COM对象，入池的所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA）  线程</li><li>入池的线程只适合时间较短的任务，如果线程需要长时间运行，应使用Thread类创建线程或使用Task的LongRunning选项</li><li>.Net下线程池最小默认允许4个工作线程，最大允许2048个工作线程。<br>并发线程启动后，瞬间会启动4个线程。<br>而剩下的会依据环境每0.5秒或者1秒启动一个。<br>如果同时运行的线程达到Max工作线程，那么剩下的就会挂起<br>直到线程池中的线程有空闲得了，才会去执行。</li></ul><h1 id="4-Parallel类"><a href="#4-Parallel类" class="headerlink" title="4.  Parallel类"></a>4.  Parallel类</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>整理自<a href="https://blog.csdn.net/honantic/article/details/46876871">https://blog.csdn.net/honantic/article/details/46876871</a></p><p>Parallel和Task类都位于System.Threading.Task命名空间中，是对Thread和ThreadPool类更高级的抽象。</p><p>Parrallel类有For()、ForEach()、Invoke()三个方法</p><ul><li><p>Invoke()<br>实现任务并行性<br>允许同时调用不同的方法，</p></li><li><p>Parallel.For()和 Parallel.ForEach()<br>实现数据并行性<br>在每次迭代中调用相同的代码</p></li></ul><h2 id="4-2-常用方法"><a href="#4-2-常用方法" class="headerlink" title="4.2 常用方法"></a>4.2 常用方法</h2><h3 id="4-2-1-Parallel-For"><a href="#4-2-1-Parallel-For" class="headerlink" title="4.2.1 Parallel.For()"></a>4.2.1 Parallel.For()</h3><p>Parallel.For()方法类似于 C#的 for循环语旬,也是多次执行一个任务。<br>使用Parallel.For()方法,可以并行运行迭代。 </p><p>迭代的顺序没有定义，不能保证。</p><p>在For()方法中：</p><ul><li>前两个参数定义了循环的开头和结束。示例从0迭代到 9。</li><li>第 3个参数是一个Action<int>委托<br>是要并行运行迭代的方法</li><li>整数参数是循环的迭代次数,该参数被传递给Action<int>委托引用的方法。</li><li>Parallel.For()方法的返回类型是ParalleLoopResult结构,它提供了循环是否结束的信息。</li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    ParallelLoopResult result = Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, i =&gt;<br>    &#123;<br>        Console.WriteLine<br>        (<span class="hljs-string">&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;</span>, i, Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Console.WriteLine(<span class="hljs-string">&quot;Is completed: &#123;0&#125;&quot;</span>, result.IsCompleted);<br><br>    <span class="hljs-comment">//i: 0, thread id: 9</span><br>    <span class="hljs-comment">//i: 2, thread id: 10</span><br>    <span class="hljs-comment">//i: 1, thread id: 9</span><br>    <span class="hljs-comment">//i: 3, thread id: 10</span><br>    <span class="hljs-comment">//i: 4, thread id: 9</span><br>    <span class="hljs-comment">//i: 6, thread id: 11</span><br>    <span class="hljs-comment">//i: 7, thread id: 10</span><br>    <span class="hljs-comment">//i: 5, thread id: 9</span><br>    <span class="hljs-comment">//i: 8, thread id: 12</span><br>    <span class="hljs-comment">//i: 9, thread id: 11</span><br>    <span class="hljs-comment">//Is completed: True</span><br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><p>同For()循环类似，Parallel.For()方法也可以中断循环的执行。</p><p>Parallel.For()方法的一个重载版本接受第3个Action&lt;int, ParallelLoopState&gt;类型的参数。<br>使用这些参数定义一个方法,就可以调用ParalleLoopState的Break()或Stop()方法,以影响循环的结果。</p><blockquote><p>注意,迭代的顺序没有定义</p></blockquote><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tsx">public static void Main()<br>&#123;<br>    ParallelLoopResult result &#x3D; Parallel.For(0, 100, (i, state) &#x3D;&gt;<br>    &#123;<br>        Console.WriteLine(&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;, i, Thread.CurrentThread.ManagedThreadId);<br><br>        if (i &gt; 10)<br>            state.Break();<br><br>        Thread.Sleep(10);<br>    &#125;);<br><br>    Console.WriteLine(&quot;Is completed: &#123;0&#125;&quot;, result.IsCompleted);<br>    Console.WriteLine(&quot;Lowest break iteration: &#123;0&#125;&quot;, result.LowestBreakIteration);<br><br>    &#x2F;&#x2F;i: 0, thread id: 10<br>    &#x2F;&#x2F;i: 25, thread id: 6<br>    &#x2F;&#x2F;i: 1, thread id: 10<br>    &#x2F;&#x2F;i: 2, thread id: 10<br>    &#x2F;&#x2F;i: 3, thread id: 10<br>    &#x2F;&#x2F;i: 4, thread id: 10<br>    &#x2F;&#x2F;i: 5, thread id: 10<br>    &#x2F;&#x2F;i: 6, thread id: 10<br>    &#x2F;&#x2F;i: 7, thread id: 10<br>    &#x2F;&#x2F;i: 8, thread id: 10<br>    &#x2F;&#x2F;i: 9, thread id: 10<br>    &#x2F;&#x2F;i: 10, thread id: 10<br>    &#x2F;&#x2F;i: 11, thread id: 10<br>    &#x2F;&#x2F;Is completed: False<br>    &#x2F;&#x2F;Lowest break iteration: 11<br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-Parallel-For-lt-TLocal-gt"><a href="#4-2-2-Parallel-For-lt-TLocal-gt" class="headerlink" title="4.2.2 Parallel.For &lt; TLocal &gt;"></a>4.2.2 Parallel.For &lt; TLocal &gt;</h3><p>Parallel.For()方法可能使用几个线程来执行循环 。</p><p>如果需要对每个线程进行初始化,就可以使用Parallel.For<TLocal>方法。<br>除了from和to对应的值之外,For()方法的泛型版本还接受3个委托参数:</p><ul><li><p>第一个参数的类型是Func&lt; TLocal &gt;<br>因为这里的例子对于TLocal使用字符串,所以该方法需要定义为Func&lt; string &gt;,即返回string的方法。<br>这个方法仅对于用于执行迭代的每个线程调用一次</p></li><li><p>第二个委托参数为循环体定义了委托<br>在示例中,该参数的类型是Func&lt;int, ParallelLoopState, string, string&gt;。<br>其中第一个参数是循环迭代,第二个参数 ParallelLoopstate允许停止循环,如前所述 。<br>循环体方法通过第3个参数接收从init方法返回的值,循环体方法还需要返回一个值,其类型是用泛型for参数定义的。</p></li><li><p>For()方法的最后一个参数指定一个委托Action&lt; TLocal &gt;;在该示例中,接收一个字符串。<br>这个方法仅对于每个线程调用一次,这是一个线程退出方法。</p></li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">Parallel.For&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>,() =&gt;<br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;init thread &#123;0&#125;,\t task &#123;1&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;t&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);<br>                &#125;,<br>            (i, pls, str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;body i &#123;0&#125; \t str &#123;1&#125; \t thread &#123;2&#125; \t task &#123;3&#125;&quot;</span>, i, str, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                Thread.Sleep(<span class="hljs-number">10</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;i \t&#123;0&#125;&quot;</span>, i);<br>            &#125;,<br>            (str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;finally\t &#123;0&#125;&quot;</span>, str);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><p><strong>Parallel.For<TLocal> 方法 (Int32, Int32, Func<TLocal>, Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;, Action<TLocal>)</strong></p><p>参数表：</p><table><thead><tr><th>参数名</th><th>数据类型</th><th>作用</th></tr></thead><tbody><tr><td></td><td>TLoca</td><td>线程本地数据的类型</td></tr><tr><td>fromInclusive</td><td>System.Int32</td><td>开始索引（含）</td></tr><tr><td>toExclusive</td><td>System.Int32</td><td>结束索引（不含）</td></tr><tr><td>localInit</td><td>System.Func<TLocal></td><td>用于返回每个任务的本地数据的初始状态的函数委托</td></tr><tr><td>body</td><td>System.Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;</td><td>将为每个迭代调用一次的委托</td></tr><tr><td>localFinally</td><td>System.Action<TLocal></td><td>用于对每个任务的本地状态执行一个最终操作的委托</td></tr><tr><td>返回值</td><td>System.Threading.Tasks.ParallelLoopResult</td><td></td></tr></tbody></table><p>在迭代范围 (fromInclusive，toExclusive) ，为每个值调用一次body 委托。<br>为它提供以下参数：</p><ul><li>迭代次数 (Int32)</li><li>可用来提前退出循环的ParallelLoopState实例</li><li>可以在同一线程上执行的迭代之间共享的某些本地状态。</li></ul><p>对于参与循环执行的每个任务调用 localInit 委托一次，并返回每个任务的初始本地状态。<br>这些初始状态传递给第一个在该任务上 调用的 body。<br>然后，每个后续正文调用返回可能修改过的状态值，传递到下一个正文调用。<br>最后，每个任务上的最后正文调用返回传递给 localFinally 委托的状态值。<br>每个任务调用 localFinally 委托一次，以对每个任务的本地状态执行最终操作。<br>此委托可以被多个任务同步调用；<br>因此您必须同步对任何共享变量的访问。</p><p>Parallel.For方法比在它执行生存期的线程可能使用更多任务，作为现有的任务完成并被新任务替换。<br>这使基础 TaskScheduler 对象有机会添加、更改或移除服务循环的线程。</p><p>如果 fromInclusive 大于或等于 toExclusive，则该方法立即返回，而无需执行任何迭代。</p><h3 id="4-2-3-Parallel-ForEach"><a href="#4-2-3-Parallel-ForEach" class="headerlink" title="4.2.3 Parallel.ForEach()"></a>4.2.3 Parallel.ForEach()</h3><p>Parallel.ForEach()方法遍历实现了IEnumerable的集合,其方式类似于foreach语句,但以异步方式遍历。<br>这里也没有确定遍历顺序。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s) =&gt;<br>            &#123;<br>                Console.WriteLine(s);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><p>中断循环<br>如果需要中断循环,就可以使用ForEach()方法的重载版本和ParallelLoopState参数。其方式与前面的For()方法相同。<br>ForEach()方法的一个重载版本也可以用于访问索引器,从而获得迭代次数<br>如下所示:　</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s, pls, l) =&gt;<br>             &#123;<br>                 Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;\t&#123;1&#125;&quot;</span>, s, l);<br>                 <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">10</span>)<br>                 &#123;<br>                     pls.Break();<br>                 &#125;<br>             &#125;);<br>            Console.WriteLine(<span class="hljs-string">&quot;Lowest break iteration: &#123;0&#125;&quot;</span>, result.LowestBreakIteration);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><h3 id="4-2-4-Parallel-Invoke"><a href="#4-2-4-Parallel-Invoke" class="headerlink" title="4.2.4 Parallel.Invoke()"></a>4.2.4 Parallel.Invoke()</h3><p>如果多个任务应并行运行,就可以使用Parallel.Invoke()方法。<br>Parallel.Invoke()方法允许传递一个Action委托数组,在其中可以指定应运行的方法。<br>示例代码传递了要并行调用的Foo()和Bar()方法:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Foo, Bar);<br>    Console.ReadKey();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Foo&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Bar&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如需同时执行多个不同的任务，可以使用Parallel.Invoke()方法，它允许传递一个Action委托数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Func1, Func2, Func3);<br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Task类"><a href="#5-Task类" class="headerlink" title="5. Task类"></a>5. Task类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>相比于Thread类，Task类为控制线程提供了更大的灵活性。</p><ul><li><p>Task类可以获取线程的返回值</p></li><li><p>可以定义连续的任务：在一个任务结束结束后开启下一个任务</p></li><li><p>可以在层次结构中安排任务，在父任务中可以创建子任务<br>这样就创建了一种依赖关系，如果父任务被取消，子任务也随之取消</p></li></ul><blockquote><p>注意：<br>Task类默认使用线程池中的线程，如果该任务需长期运行，应使用TaskCreationOptions.LongRunning属性告诉任务管理器创建一个新的线程，而不是使用线程池中的线程。</p></blockquote><h2 id="5-2-任务Task和线程Thread的区别："><a href="#5-2-任务Task和线程Thread的区别：" class="headerlink" title="5.2 任务Task和线程Thread的区别："></a>5.2 任务Task和线程Thread的区别：</h2><ul><li>任务是架构在线程之上的<br>也就是说任务最终还是要<strong>抛给线程</strong>去执行。</li><li><strong>任务跟线程不是一对一的关系</strong><br>比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。</li><li>Task和Thread一样，位于System.Threading命名空间下!</li></ul><h2 id="5-3-Task的生存周期与状态"><a href="#5-3-Task的生存周期与状态" class="headerlink" title="5.3 Task的生存周期与状态"></a>5.3 Task的生存周期与状态</h2><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Created</td><td>表示默认初始化任务，但是“工厂创建的”实例直接跳过。</td></tr><tr><td>WaitingToRun</td><td>这种状态表示等待任务调度器分配线程给任务执行。</td></tr><tr><td>RanToCompletion</td><td>任务执行完毕。</td></tr></tbody></table><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//查看Task中的状态</span><br>   <span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>         &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Begin&quot;</span>);<br>            System.Threading.Thread.Sleep(<span class="hljs-number">2000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;Finish&quot;</span>);<br>         &#125;);<br>         Console.WriteLine(<span class="hljs-string">&quot;Before start:&quot;</span> + task1.Status);<br>         task1.Start();<br>         Console.WriteLine(<span class="hljs-string">&quot;After start:&quot;</span> + task1.Status);<br>         task1.Wait();<br>         Console.WriteLine(<span class="hljs-string">&quot;After Finish:&quot;</span> + task1.Status);<br></code></pre></td></tr></table></figure><h2 id="5-4-Task的使用方法"><a href="#5-4-Task的使用方法" class="headerlink" title="5.4 Task的使用方法"></a>5.4 Task的使用方法</h2><h3 id="5-4-1-启动任务"><a href="#5-4-1-启动任务" class="headerlink" title="5.4.1 启动任务"></a>5.4.1 启动任务</h3><p>以下程序演示了几种通过Task类启动任务的方式：</p><ul><li><p>实例化后手动start()</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>    &#123;<br>       <span class="hljs-comment">//TODO you code</span><br>    &#125;);<br>   task1.Start();<br></code></pre></td></tr></table></figure></li><li><p>使用Task工厂对象创建新任务并执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>工厂创建，直接执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadExample</span><br> &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>     &#123;<br>         TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>         Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br><br>         Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br><br>         Task t3 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task constructor and start&quot;</span>);<br>         t3.Start();<br><br>         <span class="hljs-comment">//需要.NetFramework 4.5以上</span><br>         <span class="hljs-keyword">var</span> t4 = Task.Run(() =&gt; TaskMethod.DoTask(<span class="hljs-string">&quot;using Run method&quot;</span>));<br><br>         Console.ReadKey();<br>     &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">TaskMethod</span><br> &#123;<br>     <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> taskLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> msg</span>)</span><br><span class="hljs-function"></span>     &#123;<br>         <span class="hljs-keyword">lock</span> (taskLock)<br>         &#123;<br>             Console.WriteLine(msg);<br>             Console.WriteLine(<span class="hljs-string">&quot;Task id:&#123;0&#125;, Thread id :&#123;1&#125;&quot;</span>,<br>                            Task.CurrentId == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;no task&quot;</span> : Task.CurrentId.ToString(),<br>                            Thread.CurrentThread.ManagedThreadId);<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-2-任务控制"><a href="#5-4-2-任务控制" class="headerlink" title="5.4.2 任务控制"></a>5.4.2 任务控制</h3><h4 id="5-4-2-1-Task-Wait"><a href="#5-4-2-1-Task-Wait" class="headerlink" title="5.4.2.1 Task.Wait()"></a>5.4.2.1 Task.Wait()</h4><p>就是等待任务执行（task1）完成，task1的状态变为Completed。</p><h4 id="5-4-2-2-Task-WaitAll"><a href="#5-4-2-2-Task-WaitAll" class="headerlink" title="5.4.2.2 Task.WaitAll()"></a>5.4.2.2 Task.WaitAll()</h4><p>等待所有的任务都执行完成：<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAll(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;All task finished!&quot;</span>);<br></code></pre></td></tr></table></figure><p>即当task,task2,task3…N全部任务都执行完成之后才会往下执行代码（打印出：“All task finished!”）</p><h4 id="5-4-2-3-Task-WaitAny"><a href="#5-4-2-3-Task-WaitAny" class="headerlink" title="5.4.2.3 Task.WaitAny()"></a>5.4.2.3 Task.WaitAny()</h4><p>同Task.WaitAll，等待任何一个任务完成就继续向下执行，将上面的代码WaitAll替换为WaitAny</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAny(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;Any task finished!&quot;</span>);<br></code></pre></td></tr></table></figure><p> 即当task,task2,task3…N任意一个任务都执行完成之后就会往下执行代码（打印出：” Any task finished!”）</p><h4 id="5-4-2-4-Task-ContinueWith"><a href="#5-4-2-4-Task-ContinueWith" class="headerlink" title="5.4.2.4 Task.ContinueWith()"></a>5.4.2.4 Task.ContinueWith()</h4><p>在第一个Task完成后自动启动下一个Task，实现Task的延续，编写如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>    Task t1 = tf.StartNew(()=&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务1\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t2 = t1.ContinueWith((t) =&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务2\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t3 = t2.ContinueWith(<span class="hljs-built_in">delegate</span>(Task t) <br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务3\r\n&quot;</span>);<br>    &#125;, TaskContinuationOptions.OnlyOnRanToCompletion);<br><br>    Console.ReadKey(); <br>&#125;<br>    <span class="hljs-comment">//执行结果</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//Current Task id = 1</span><br>    <span class="hljs-comment">//执行任务1</span><br><br>    <span class="hljs-comment">//Last Task id = 1</span><br>    <span class="hljs-comment">//Current Task id = 2</span><br>    <span class="hljs-comment">//执行任务2</span><br><br>    <span class="hljs-comment">//Last Task id = 2</span><br>    <span class="hljs-comment">//Current Task id = 3</span><br>    <span class="hljs-comment">//执行任务3</span><br></code></pre></td></tr></table></figure><p>从执行结果可以看出，任务1，2，3被顺序执行，同时通过 TaskContinuationOptions 还可以指定何种情况下继续执行该任务，常用的值包括OnlyOnFaulted, OnlyOnCanceled, NotOnFaulted, NotOnCanceled等。如将上例中的OnlyOnRanToCompletion改为OnlyOnFaulted，任务2结束之后，任务3将不被执行。</p><p>对于ContinueWith()的使用，MSDN演示了更加优雅的“流式”调用方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)  </span><br><span class="hljs-function"></span>&#123;  <br>   <span class="hljs-keyword">var</span> backgroundScheduler = TaskScheduler.Default;  <br>   <span class="hljs-keyword">var</span> uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  <br>   Task.Factory.StartNew(<span class="hljs-built_in">delegate</span> &#123; DoBackgroundComputation(); &#125;,  <br>                         backgroundScheduler).  <br>   ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUI(); &#125;, uiScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; DoAnotherBackgroundComputation(); &#125;,  <br>                             backgroundScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUIAgain(); &#125;, uiScheduler);  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="5-4-2-5-RunSynchronously"><a href="#5-4-2-5-RunSynchronously" class="headerlink" title="5.4.2.5 RunSynchronously()"></a>5.4.2.5 RunSynchronously()</h4><p>用于实现同步调用，直接在当前线程上调用该任务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskMethod.DoTask(<span class="hljs-string">&quot;Just Main thread&quot;</span>);<br>    Task t1 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using Run Sync&quot;</span>);<br>    t1.RunSynchronously();<br>    <span class="hljs-comment">//输出结果</span><br>    <span class="hljs-comment">//Just Main thread</span><br>    <span class="hljs-comment">//Task id: no task, Thread id: 9</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//using Run Sync</span><br>    <span class="hljs-comment">//Task id:1, Thread id :9</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-3-任务取消"><a href="#5-4-3-任务取消" class="headerlink" title="5.4.3 任务取消"></a>5.4.3 任务取消</h3><p>当我们启动了一个task,出现异常或者用户点击取消等等，我们可以取消这个任务。</p><p>我们通过cancellation的tokens来取消一个Task。<br>在很多Task的Body里面包含循环，我们可以在轮询的时候判断IsCancellationRequested属性是否为True<br>如果是True的话就return或者抛出异常，抛出异常后面再说，因为还没有说异常处理的东西。</p><p>下面在代码中看下如何实现任务的取消，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#">　　　　<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br><span class="hljs-keyword">var</span> token = tokenSource.Token;<br><span class="hljs-keyword">var</span> task = Task.Factory.StartNew(() =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>    &#123;<br>        System.Threading.Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">if</span> (token.IsCancellationRequested)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Abort mission success!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;, token);<br>token.Register(() =&gt;<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>&#125;);<br>Console.WriteLine(<span class="hljs-string">&quot;Press enter to cancel task...&quot;</span>);<br>Console.ReadKey();<br>tokenSource.Cancel();<span class="hljs-number">123456789101112131415161718192021</span><br></code></pre></td></tr></table></figure><p>这里开启了一个Task,并给token注册了一个方法，输出一条信息，然后执行ReadKey开始等待用户输入，用户点击回车后，执行tokenSource.Cancel方法，取消任务。</p><blockquote><p>注意：<br>因为任务通常运行以异步方式在线程池线程上，创建并启动任务的线程将继续执行，一旦该任务已实例化。<br>在某些情况下，当调用线程的主应用程序线程，该应用程序可能会终止之前任何任务实际开始执行。<br>其他情况下，应用程序的逻辑可能需要调用线程继续执行，仅当一个或多个任务执行完毕。<br>您可以同步调用线程的执行，以及异步任务它启动通过调用 Wait 方法来等待要完成的一个或多个任务。<br>若要等待完成一项任务，可以调用其 Task.Wait 方法。<br>调用 Wait 方法将一直阻塞调用线程直到单一类实例都已完成执行。</p></blockquote><h3 id="5-4-4-接收任务的返回值"><a href="#5-4-4-接收任务的返回值" class="headerlink" title="5.4.4 接收任务的返回值"></a>5.4.4 接收任务的返回值</h3><p>对于任务有返回值的情况，可使用Task<TResult>泛型类，TResult定义了返回值的类型，以下代码演示了调用返回int值的任务的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">var</span> t5 = <span class="hljs-keyword">new</span> Task&lt;<span class="hljs-built_in">int</span>&gt;(TaskWithResult, Tuple.Create&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    t5.Start();<br>    t5.Wait();<br>    Console.WriteLine(<span class="hljs-string">&quot;adder results: &#123;0&#125;&quot;</span>, t5.Result);<br><br>    Console.ReadKey(); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">TaskWithResult</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> o</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; adder = (Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;)o;<br>    <span class="hljs-keyword">return</span> adder.Item1 + adder.Item2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-任务的层次结构"><a href="#5-5-任务的层次结构" class="headerlink" title="5.5 任务的层次结构"></a>5.5 任务的层次结构</h2><p>如果在一个Task内部创建了另一个任务，这两者间就存在父/子的层次结构，当父任务被取消时，子任务也会被取消。</p><p>如果不希望使用该层次结构，可在创建子任务时选择TaskCreationOptions.DetachedFromParent。</p><h1 id="6-BackgroundWorker控件"><a href="#6-BackgroundWorker控件" class="headerlink" title="6. BackgroundWorker控件"></a>6. BackgroundWorker控件</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>C#提供了BackgroundWorker控件帮助用户更简单、安全地实现多线程运算。</p><p>该控件提供了DoWork, ProgressChanged 和 RunWorkerCompleted事件<br>为DoWork添加事件处理函数，再调用RunWorkerAsync()方法，即可创建一个新的线程执行DoWork任务</p><p>ProgressChanged和RunWorkerCompleted事件均在UI线程中执行，添加相应的处理函数，即可完成任务线程与UI线程间的交互，可用于显示任务的执行状态（完成百分比）、执行结果等。</p><p>同时，该控件还提供了CancleAsync()方法，以中断线程的执行<br>需注意的是，调用该方法后，只是将控件的CancellationPending属性置True，用户需在程序执行过程中查询该属性以判定是否应中断线程。</p><p>具体用法可参考MSDN：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker?view=netframework-4.7.2">BackgroundWorker用法范例</a><br>可以看的出来，BackgroundWorker组件提供了一种执行异步操作（后台线程）的同时，并且还能妥妥的显示操作进度的解决方案。</p><h2 id="6-2-属性表"><a href="#6-2-属性表" class="headerlink" title="6.2 属性表"></a>6.2 属性表</h2><h3 id="6-2-1-WorkerReportsProgress"><a href="#6-2-1-WorkerReportsProgress" class="headerlink" title="6.2.1 WorkerReportsProgress"></a>6.2.1 WorkerReportsProgress</h3><p>bool类型，指示BackgroundWorker是否可以报告进度更新。</p><ul><li>True时，可以成功调用ReportProgress方法</li><li>否则将引发InvalidOperationException异常</li></ul><p>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> BackgroundWorker bgWorker = <span class="hljs-keyword">new</span> BackgroundWorker();<br>bgWorker.WorkerReportsProgress = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-2-WorkerSupportsCancellation"><a href="#6-2-2-WorkerSupportsCancellation" class="headerlink" title="6.2.2 WorkerSupportsCancellation"></a>6.2.2 WorkerSupportsCancellation</h3><p>bool类型，指示BackgroundWorker是否支持异步取消操作</p><ul><li><p>True时，将可以成功调用CancelAsync方法</p></li><li><p>否则将引发InvalidOperationException异<br>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">bgWorker.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-3-CancellationPending"><a href="#6-2-3-CancellationPending" class="headerlink" title="6.2.3 CancellationPending"></a>6.2.3 CancellationPending</h3><p>bool类型，指示应用程序是否已请求取消后台操作。<br>此属性通常放在用户执行的异步操作内部，用来判断用户是否取消执行异步操作。<br>当执行BackgroundWorker.CancelAsync()方法时，该属性值将变为True。<br>用法：</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在DoWork中键入如下代码</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (bgWorker.CancellationPending)<br>      &#123;<br>          e.Cancel = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>          bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>          System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>      &#125;<br>  &#125;   <br></code></pre></td></tr></table></figure><h3 id="6-2-4-IsBusy"><a href="#6-2-4-IsBusy" class="headerlink" title="6.2.4 IsBusy"></a>6.2.4 IsBusy</h3><p>bool类型，指示BackgroundWorker是否正在执行一个异步操作。<br>此属性通常放在BackgroundWorker.RunWorkerAsync()方法之前，避免多次调用RunWorkerAsync()方法引发异常。<br>当执行BackgroundWorker.RunWorkerAsync()方法是，该属性值将变为True。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//防止重复执行异步操作引发错误</span><br> <span class="hljs-keyword">if</span> (bgWorker.IsBusy)<br>     <span class="hljs-keyword">return</span>;<br> bgWorker.RunWorkerAsync();<br></code></pre></td></tr></table></figure><h2 id="6-3-方法表"><a href="#6-3-方法表" class="headerlink" title="6.3 方法表"></a>6.3 方法表</h2><h3 id="6-3-1-RunWorkerAsync"><a href="#6-3-1-RunWorkerAsync" class="headerlink" title="6.3.1 RunWorkerAsync()"></a>6.3.1 RunWorkerAsync()</h3><p>开始执行一个后台操作。</p><p>调用该方法后，将触发BackgroundWorker.DoWork事件，并以异步的方式执行DoWork事件中的代码。<br>该方法还有一个带参数的重载方法：RunWorkerAsync(Object)。<br>该方法允许传递一个Object类型的参数到后台操作中，并且可以通过DoWork事件的DoWorkEventArgs.Argument属性将该参数提取出来。</p><blockquote><p>注：当BackgroundWorker的IsBusy属性为True时，调用该方法将引发InvalidOperationException异常。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在启动异步操作的地方键入代码</span><br>bgWorker.RunWorkerAsync(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="6-3-2-ReportProgress-Int-percentProgress"><a href="#6-3-2-ReportProgress-Int-percentProgress" class="headerlink" title="6.3.2 ReportProgress(Int percentProgress)"></a>6.3.2 ReportProgress(Int percentProgress)</h3><p>报告操作进度。</p><p>调用该方法后，将触发BackgroundWorker. ProgressChanged事件。<br>另外，该方法包含了一个int类型的参数percentProgress，用来表示当前异步操作所执行的进度百分比。</p><p>该方法还有一个重载方法：ReportProgress(Int percentProgress, Object userState)。<br>允许传递一个Object类型的状态对象到 ProgressChanged事件中<br>并且可以通过ProgressChanged事件的ProgressChangedEventArgs.UserState属性取得参数值。</p><blockquote><p>注：调用该方法之前需确保WorkerReportsProgress属性值为True，否则将引发InvalidOperationException异常。</p></blockquote><p>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>&#123;c<br>    <span class="hljs-comment">//向ProgressChanged报告进度</span><br>    bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>    System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-3-CancelAsync"><a href="#6-3-3-CancelAsync" class="headerlink" title="6.3.3 CancelAsync()"></a>6.3.3 CancelAsync()</h3><p>请求取消当前正在执行的异步操作。</p><p>调用该方法将使BackgroundWorker.CancellationPending属性设置为True。<br>但需要注意的是，并非每次调用CancelAsync()都能确保异步操作，CancelAsync()通常不适用于取消一个紧密执行的操作，更适用于在循环体中执行。<br>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在需要执行取消操作的地方键入以下代码</span><br>bgWorker.CancelAsync();<br></code></pre></td></tr></table></figure><h2 id="6-4-事件表"><a href="#6-4-事件表" class="headerlink" title="6.4 事件表"></a>6.4 事件表</h2><h3 id="6-4-1-DoWork"><a href="#6-4-1-DoWork" class="headerlink" title="6.4.1 DoWork"></a>6.4.1 DoWork</h3><p>用于承载异步操作。当调用BackgroundWorker.RunWorkerAsync()时触发。</p><p>需要注意的是：<br>由于DoWork事件内部的代码运行在非UI线程之上，所以在DoWork事件内部应避免于用户界面交互，<br>而于用户界面交互的操作应放置在ProgressChanged和RunWorkerCompleted事件中。</p><h3 id="6-4-2-ProgressChanged"><a href="#6-4-2-ProgressChanged" class="headerlink" title="6.4.2 ProgressChanged"></a>6.4.2 ProgressChanged</h3><p>当调用BackgroundWorker.ReportProgress(int percentProgress)方式时触发该事件。<br>该事件的ProgressChangedEventArgs.ProgressPercentage属性可以接收来自ReportProgress方法传递的percentProgress参数值,ProgressChangedEventArgs.UserState属性可以接收来自ReportProgress方法传递的userState参数。</p><h3 id="6-4-3-RunWorkerCompleted"><a href="#6-4-3-RunWorkerCompleted" class="headerlink" title="6.4.3 RunWorkerCompleted"></a>6.4.3 RunWorkerCompleted</h3><p>异步操作完成或取消时执行的操作，当调用DoWork事件执行完成时触发。</p><p>该事件的RunWorkerCompletedEventArgs参数包含三个常用的属性Error,Cancelled,Result。其中，Error表示在执行异步操作期间发生的错误；Cancelled用于判断用户是否取消了异步操作；Result属性接收来自DoWork事件的DoWorkEventArgs参数的Result属性值，可用于传递异步操作的执行结果。</p><h2 id="6-3-案例"><a href="#6-3-案例" class="headerlink" title="6.3 案例"></a>6.3 案例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.ComponentModel;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br> <br><span class="hljs-keyword">namespace</span> <span class="hljs-title">bcworker</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br>        <span class="hljs-comment">//后台工作</span><br>        <span class="hljs-keyword">private</span> BackgroundWorker bw = <span class="hljs-keyword">new</span> BackgroundWorker();<br> <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>            <span class="hljs-comment">//后台工作初始化</span><br>            bw.WorkerReportsProgress = <span class="hljs-literal">true</span>;<span class="hljs-comment">//报告进度</span><br>            bw.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<span class="hljs-comment">//支持取消</span><br>            bw.DoWork += <span class="hljs-keyword">new</span> DoWorkEventHandler(bgWorker_DoWork);<span class="hljs-comment">//开始工作</span><br>            bw.ProgressChanged += <span class="hljs-keyword">new</span> ProgressChangedEventHandler(bgWorker_ProgessChanged);<span class="hljs-comment">//进度改变事件</span><br>            bw.RunWorkerCompleted += <span class="hljs-keyword">new</span> RunWorkerCompletedEventHandler(bgWorker_WorkerCompleted);<span class="hljs-comment">//进度完成事件</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnStart_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//后台工作运行中，避免重入</span><br>            <span class="hljs-keyword">if</span> (bw.IsBusy) <span class="hljs-keyword">return</span>;<br>            bw.RunWorkerAsync(<span class="hljs-string">&quot;参数&quot;</span>);<span class="hljs-comment">//触发DoWork事件并异步执行，IsBusy置为True</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作将异步执行</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_DoWork</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, DoWorkEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.Argument == &quot;参数&quot;;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>            &#123;<br> <br>                <span class="hljs-keyword">if</span> (bw.CancellationPending)<br>                &#123;<span class="hljs-comment">//用户取消了工作</span><br>                    e.Cancel = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    bw.ReportProgress(i, <span class="hljs-string">&quot;Working&quot;</span>);<span class="hljs-comment">//报告进度，触发ProgressChanged事件</span><br>                    Thread.Sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//模拟工作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//进度改变事件</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_ProgessChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, ProgressChangedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.UserState==&quot;Working&quot;</span><br>            progressBar1.Value = e.ProgressPercentage;<span class="hljs-comment">//取得进度更新控件，不用Invoke了</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作执行完毕,IsBusy置为False</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_WorkerCompleted</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//e.Error == null 是否发生错误</span><br>            <span class="hljs-comment">//e.Cancelled 完成是由于取消还是正常完成</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span> (bw.IsBusy) bw.CancelAsync();<span class="hljs-comment">//设置CancellationPending属性为True</span><br>        &#125;<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InvalidOperationException</title>
    <link href="/2021/05/23/InvalidOperationException/"/>
    <url>/2021/05/23/InvalidOperationException/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是InvalidOperationException"><a href="#1-什么是InvalidOperationException" class="headerlink" title="1. 什么是InvalidOperationException"></a>1. 什么是InvalidOperationException</h1><p>操作无效异常。当方法调用对对象的当前状态无效时引发的异常。</p><h1 id="2-继承树"><a href="#2-继承树" class="headerlink" title="2. 继承树"></a>2. 继承树</h1><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netframework-4.8">Object</a></p><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.exception?view=netframework-4.8">Exception</a></p><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.systemexception?view=netframework-4.8">SystemException</a></p><p>InvalidOperationException</p><h1 id="3-详细说明"><a href="#3-详细说明" class="headerlink" title="3. 详细说明"></a>3. 详细说明</h1><p>如果调用方法失败是由无效参数以外的其他原因导致的,则使用该异常。<br>通常, 当对象的状态不支持方法调用时, 将引发此异常。<br>例如, 以下方法或原因会引发异常nvalidOperationException:</p><ul><li>IEnumerator.MoveNext如果在创建枚举器后修改集合的对象,。</li><li>ResourceSet.GetString如果在执行方法调用前关闭资源集,。</li><li>XContainer.Add如果要添加的对象将导致结构不正确的 XML 文档,。</li><li>尝试从非主线程或 UI 线程的线程操作 UI 的方法。</li><li>从非 UI 线程更新 UI 线程</li><li>在循环访问集合时更改集合</li><li>对其对象无法进行比较的数组或集合进行排序</li><li>将为 null <T>转换为其基础类型</li><li>对空集合调用 system.exception 方法</li><li>对没有一个元素的序列调用 SingleOrDefault 或可枚举的。</li><li>动态跨应用程序域字段访问</li></ul><p>由于InvalidOperationException异常可以在多种情况下引发，因此读取由message属性返回的异常消息非常重要。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#BUG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>C#BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#序列化</title>
    <link href="/2021/05/23/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2021/05/23/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是序列化"><a href="#1-1-什么是序列化" class="headerlink" title="1.1 什么是序列化"></a>1.1 什么是序列化</h2><p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。<br>在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p><h2 id="1-2-序列化的目的"><a href="#1-2-序列化的目的" class="headerlink" title="1.2 序列化的目的"></a>1.2 序列化的目的</h2><p>1、方便对象长久存储</p><p>2、方便对象传输</p><p>3、使程序更具维护性</p><h2 id="1-3-序列化操作"><a href="#1-3-序列化操作" class="headerlink" title="1.3 序列化操作"></a>1.3 序列化操作</h2><ul><li><p>序列化<br>将对象转换为字符串或二进制数据，以便存储或传输</p></li><li><p>反序列化<br>将字符串或二进制数据还原成对象</p></li><li><p>无序列化<br>标明对象的属性中哪些属性不需要序列化<br><img src="../images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523182615355.png" srcset="/img/loading.gif" alt="image-20210523182615355"></p></li></ul><h2 id="1-4-常用的序列化格式"><a href="#1-4-常用的序列化格式" class="headerlink" title="1.4 常用的序列化格式"></a>1.4 常用的序列化格式</h2><ul><li><p>Binary(二进制)</p><ul><li>protocol buffer</li></ul></li><li><p>XML</p></li><li><p>JSON(最先进，最推荐)</p><blockquote><p><a href="https://www.bejson.com/">在线JSON格式化校验</a></p></blockquote></li></ul><p>性能指标：Binary&gt;JSON&gt;XML</p><h1 id="2-Binary序列化"><a href="#2-Binary序列化" class="headerlink" title="2. Binary序列化"></a>2. Binary序列化</h1><p>略，求求你，用json吧！</p><p><strong>protocol buffer</strong>是Google的一种<strong>独立和轻量级</strong>的数据交换格式。以<strong>二进制结构</strong>进行存储。</p><h1 id="3-XML序列化"><a href="#3-XML序列化" class="headerlink" title="3. XML序列化"></a>3. XML序列化</h1><p>略，求求你，用json吧！</p><p><strong>XML</strong> 指可扩展标记语言（e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage）。是一种<strong>通用和重量级</strong>的数据交换格式。以<strong>文本结构</strong>存储。</p><p>格式很像HTML</p><h1 id="4-JSON序列化"><a href="#4-JSON序列化" class="headerlink" title="4. JSON序列化"></a>4. JSON序列化</h1><h2 id="4-1-JSON简介"><a href="#4-1-JSON简介" class="headerlink" title="4.1 JSON简介"></a>4.1 JSON简介</h2><p><strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JSON">JSON</a></strong>(<strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">J</a></strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">ava</a><strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">S</a></strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">cript</a> <strong>O</strong>bject <strong>N</strong>otation, JS 对象简谱) 是一种<strong>通用和轻量级</strong>的数据交换格式。以<strong>文本结构</strong>存储，它是完全独立于语言的。</p><h3 id="4-1-1-支持的数据结构"><a href="#4-1-1-支持的数据结构" class="headerlink" title="4.1.1 支持的数据结构"></a>4.1.1 支持的数据结构</h3><p>Json支持下面两种数据结构：</p><ul><li>键值对的集合–各种不同的编程语言，都支持这种数据结构；</li><li>有序的列表类型值的集合–这其中包含数组，集合，矢量，或者序列，等等。</li></ul><h3 id="4-1-2-表现形式"><a href="#4-1-2-表现形式" class="headerlink" title="4.1.2 表现形式"></a>4.1.2 表现形式</h3><h4 id="4-1-2-1-对象"><a href="#4-1-2-1-对象" class="headerlink" title="4.1.2.1 对象"></a>4.1.2.1 对象</h4><p>一个没有顺序的“键/值”,一个对象以花括号“{”开始，并以花括号”}”结束，在每一个“键”的后面，有一个冒号，并且使用逗号来分隔多个键值对。</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var user =  &#123;``&quot;name&quot;``:``&quot;Manas&quot;``,``&quot;gender&quot;``:``&quot;Male&quot;``,``&quot;birthday&quot;``:``&quot;1987-8-8&quot;``&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-2-数组"><a href="#4-1-1-2-数组" class="headerlink" title="4.1.1.2 数组"></a>4.1.1.2 数组</h4><p>设置值的顺序，一个数组以中括号”[“开始,并以中括号”]”结束，并且所有的值使用逗号分隔</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var userlist = [&#123;``&quot;user&quot;``:&#123;``&quot;name&quot;``:``&quot;Manas&quot;``,``&quot;gender&quot;``:``&quot;Male&quot;``,``&quot;birthday&quot;``:``&quot;1987-8-8&quot;``&#125;&#125;, ``&#123;``&quot;user&quot;``:&#123;``&quot;name&quot;``:``&quot;Mohapatra&quot;``,``&quot;Male&quot;``:``&quot;Female&quot;``,``&quot;birthday&quot;``:``&quot;1987-7-7&quot;``&#125;&#125;]<br></code></pre></td></tr></table></figure><h4 id="4-1-1-3-字符串"><a href="#4-1-1-3-字符串" class="headerlink" title="4.1.1.3 字符串"></a>4.1.1.3 字符串</h4><p>任意数量的Unicode字符，使用引号做标记，并使用反斜杠来分隔。</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var userlist = ``&quot;&#123;\&quot;ID\&quot;:1,\&quot;Name\&quot;:\&quot;Manas\&quot;,\&quot;Address\&quot;:\&quot;India\&quot;&#125;&quot;<br></code></pre></td></tr></table></figure><h2 id="4-2-C-使用JSON序列化"><a href="#4-2-C-使用JSON序列化" class="headerlink" title="4.2 C#使用JSON序列化"></a>4.2 C#使用JSON序列化</h2><p><strong>序列化和反序列化有三种方式：</strong></p><ol><li><p>使用<code>JavaScriptSerializer</code>类</p></li><li><p>使用<code>DataContractJsonSerializer</code>类</p></li><li><p>使用JSON.NET类库</p></li></ol><blockquote><p>第三种最好，求求你直接看第三种吧</p></blockquote><h3 id="4-2-1-使用JavaScriptSerializer类"><a href="#4-2-1-使用JavaScriptSerializer类" class="headerlink" title="4.2.1 使用JavaScriptSerializer类"></a>4.2.1 使用JavaScriptSerializer类</h3><p><code>DataContractJsonSerializer</code>类帮助我们序列化和反序列化Json，他在程序集<code> System.Runtime.Serialization.dll</code>下的<code>System.Runtime.Serialization.Json</code>命名空间里。</p><p><strong>首先，这里，我新建一个控制台的程序，新建一个类Student</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Runtime.Serialization;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">JsonSerializerAndDeSerializer</span><br>&#123;<br> [<span class="hljs-meta">DataContract</span>]<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br> &#123;<br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Sex &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>上面的Student实体中的契约 [DataMember]，[DataContract]，是使用<code>DataContractJsonSerializer</code>序列化和反序列化必须要加的，对于其他两种方式不必加，也可以的。</p><p><strong>我们程序的代码：</strong></p><p>要先引用程序集，在引入这个命名空间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//使用DataContractJsonSerializer方式需要引入的命名空间，在System.Runtime.Serialization.dll.中</span><br><span class="hljs-keyword">using</span> System.Runtime.Serialization.Json;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 1.DataContractJsonSerializer方式序列化和反序列化</span><br>   Student stu = <span class="hljs-keyword">new</span> Student()<br>    &#123;<br>     ID = <span class="hljs-number">1</span>,<br>     Name = <span class="hljs-string">&quot;曹操&quot;</span>,<br>     Sex = <span class="hljs-string">&quot;男&quot;</span>,<br>     Age = <span class="hljs-number">1000</span><br>    &#125;;<br>   <span class="hljs-comment">//序列化</span><br>   DataContractJsonSerializer js = <span class="hljs-keyword">new</span> DataContractJsonSerializer(<span class="hljs-keyword">typeof</span>(Student));<br>   MemoryStream msObj = <span class="hljs-keyword">new</span> MemoryStream();<br>   <span class="hljs-comment">//将序列化之后的Json格式数据写入流中</span><br>   js.WriteObject(msObj, stu);<br>   msObj.Position = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">//从0这个位置开始读取流中的数据</span><br>   StreamReader sr = <span class="hljs-keyword">new</span> StreamReader(msObj, Encoding.UTF8);<br>   <span class="hljs-built_in">string</span> json = sr.ReadToEnd();<br>   sr.Close();<br>   msObj.Close();<br>   Console.WriteLine(json);<br><br>   <span class="hljs-comment">//反序列化</span><br>   <span class="hljs-built_in">string</span> toDes = json;<br>   <span class="hljs-comment">//string to = &quot;&#123;\&quot;ID\&quot;:\&quot;1\&quot;,\&quot;Name\&quot;:\&quot;曹操\&quot;,\&quot;Sex\&quot;:\&quot;男\&quot;,\&quot;Age\&quot;:\&quot;1230\&quot;&#125;&quot;;</span><br>   <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> ms = <span class="hljs-keyword">new</span> MemoryStream(Encoding.Unicode.GetBytes(toDes)))<br>   &#123;<br>    DataContractJsonSerializer deseralizer = <span class="hljs-keyword">new</span> DataContractJsonSerializer(<span class="hljs-keyword">typeof</span>(Student));<br>    Student model = (Student)deseralizer.ReadObject(ms);<span class="hljs-comment">// //反序列化ReadObject</span><br>    Console.WriteLine(<span class="hljs-string">&quot;ID=&quot;</span> + model.ID);<br>    Console.WriteLine(<span class="hljs-string">&quot;Name=&quot;</span> + model.Name);<br>    Console.WriteLine(<span class="hljs-string">&quot;Age=&quot;</span> + model.Age);<br>    Console.WriteLine(<span class="hljs-string">&quot;Sex=&quot;</span> + model.Sex);<br>   &#125;<br>   Console.ReadKey(); <br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><p>运行之后结果是：</p><p><img src="/images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181440077.png" srcset="/img/loading.gif" alt="image-20210523181440077"></p><h3 id="4-2-2-使用JavaScriptJsonSerializer类"><a href="#4-2-2-使用JavaScriptJsonSerializer类" class="headerlink" title="4.2.2 使用JavaScriptJsonSerializer类"></a>4.2.2 使用JavaScriptJsonSerializer类</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-comment">//使用JavaScriptSerializer方式需要引入的命名空间，这个在程序集System.Web.Extensions.dll.中</span><br><span class="hljs-keyword">using</span> System.Web.Script.Serialization;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 2.JavaScriptSerializer方式实现序列化和反序列化</span><br>   Student stu = <span class="hljs-keyword">new</span> Student()<br>    &#123;<br>     ID = <span class="hljs-number">1</span>,<br>     Name = <span class="hljs-string">&quot;关羽&quot;</span>,<br>     Age = <span class="hljs-number">2000</span>,<br>     Sex = <span class="hljs-string">&quot;男&quot;</span><br>    &#125;;<br><br>   JavaScriptSerializer js = <span class="hljs-keyword">new</span> JavaScriptSerializer();<br>   <span class="hljs-built_in">string</span> jsonData = js.Serialize(stu);<span class="hljs-comment">//序列化</span><br>   Console.WriteLine(jsonData);<br><br><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span>/反序列化方式一：</span><br>   <span class="hljs-built_in">string</span> desJson = jsonData;<br>   <span class="hljs-comment">//Student model = js.Deserialize&lt;Student&gt;(desJson);// //反序列化</span><br>   <span class="hljs-comment">//string message = string.Format(&quot;ID=&#123;0&#125;,Name=&#123;1&#125;,Age=&#123;2&#125;,Sex=&#123;3&#125;&quot;, model.ID, model.Name, model.Age, model.Sex);</span><br>   <span class="hljs-comment">//Console.WriteLine(message);</span><br>   <span class="hljs-comment">//Console.ReadKey(); </span><br><br><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span>/反序列化方式2</span><br>   <span class="hljs-built_in">dynamic</span> modelDy = js.Deserialize&lt;<span class="hljs-built_in">dynamic</span>&gt;(desJson); <span class="hljs-comment">//反序列化</span><br>   <span class="hljs-built_in">string</span> messageDy = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;动态的反序列化,ID=&#123;0&#125;,Name=&#123;1&#125;,Age=&#123;2&#125;,Sex=&#123;3&#125;&quot;</span>,<br>    modelDy[<span class="hljs-string">&quot;ID&quot;</span>], modelDy[<span class="hljs-string">&quot;Name&quot;</span>], modelDy[<span class="hljs-string">&quot;Age&quot;</span>], modelDy[<span class="hljs-string">&quot;Sex&quot;</span>]);<span class="hljs-comment">//这里要使用索引取值，不能使用对象.属性</span><br>   Console.WriteLine(messageDy);<br>   Console.ReadKey(); <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span> </span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181633952.png" srcset="/img/loading.gif" alt="image-20210523181633952"></p><h3 id="4-2-3-使用JSON-NET类库-推荐"><a href="#4-2-3-使用JSON-NET类库-推荐" class="headerlink" title="4.2.3 使用JSON.NET类库(推荐)"></a>4.2.3 使用JSON.NET类库(推荐)</h3><p>首先在NuGet上下载Json.NET类库。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//使用Json.NET类库需要引入的命名空间</span><br><span class="hljs-keyword">using</span> Newtonsoft.Json;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 3.Json.NET序列化</span><br>   List&lt;Student&gt; lstStuModel = <span class="hljs-keyword">new</span> List&lt;Student&gt;() <br>   &#123;<br>   <br>   <span class="hljs-keyword">new</span> Student()&#123;ID=<span class="hljs-number">1</span>,Name=<span class="hljs-string">&quot;张飞&quot;</span>,Age=<span class="hljs-number">250</span>,Sex=<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>   <span class="hljs-keyword">new</span> Student()&#123;ID=<span class="hljs-number">2</span>,Name=<span class="hljs-string">&quot;潘金莲&quot;</span>,Age=<span class="hljs-number">300</span>,Sex=<span class="hljs-string">&quot;女&quot;</span>&#125;<br>   &#125;;<br><br>   <span class="hljs-comment">//Json.NET序列化</span><br>   <span class="hljs-built_in">string</span> jsonData = JsonConvert.SerializeObject(lstStuModel);<br><br>   Console.WriteLine(jsonData);<br>   Console.ReadKey();<br><br><br>   <span class="hljs-comment">//Json.NET反序列化</span><br>   <span class="hljs-built_in">string</span> json = <span class="hljs-string">@&quot;&#123; &#x27;Name&#x27;:&#x27;C#&#x27;,&#x27;Age&#x27;:&#x27;3000&#x27;,&#x27;ID&#x27;:&#x27;1&#x27;,&#x27;Sex&#x27;:&#x27;女&#x27;&#125;&quot;</span>;<br>   Student descJsonStu = JsonConvert.DeserializeObject&lt;Student&gt;(json);<span class="hljs-comment">//反序列化</span><br>   Console.WriteLine(<span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;反序列化： ID=&#123;0&#125;,Name=&#123;1&#125;,Sex=&#123;2&#125;,Sex=&#123;3&#125;&quot;</span>, descJsonStu.ID, descJsonStu.Name, descJsonStu.Age, descJsonStu.Sex));<br>   Console.ReadKey(); <br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181908106.png" srcset="/img/loading.gif" alt="image-20210523181908106"></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader的形式</title>
    <link href="/2021/05/23/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/"/>
    <url>/2021/05/23/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>UnityShader最重要的任务是：指定各种着色器所需的代码</p><p>而代码的编写形式有以下三种</p><h1 id="2-长子：顶点-片元着色器"><a href="#2-长子：顶点-片元着色器" class="headerlink" title="2. 长子：顶点/片元着色器"></a>2. 长子：顶点/片元着色器</h1><p>在Unity中我们可以使用<strong>CG/HLSL语言</strong>来编写**顶点/片元着色器(Vertex/Fragment Shader)**。<br>它更复杂也更灵活。</p><p>它写在Pass语句块内，格式如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">Shader <span class="hljs-string">&quot;Unlit/MyFirstShader&quot;</span><br>&#123;<br>Properties<br>&#123;<br>_Color(<span class="hljs-string">&quot;Color&quot;</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>&#125;<br><br>SubShader<br>&#123;<br>Pass<br>&#123;<br><span class="hljs-built_in">CGPROGRAM</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span><br><br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>#pragma是Unity内置的编绎指令用的命令<br>在Pass中我们就利用此命令来声明所需要的顶点着色器与片元着色器。</p><ul><li><p>#pragma vertexName<br>定义顶点着色器为*name,*通常情况下会起名为vert。</p></li><li><p>#pragma fragmentName<br>定义片元着色器为*name,*通常情况下会起名为frag。</p></li></ul><h2 id="2-1-顶点着色器"><a href="#2-1-顶点着色器" class="headerlink" title="2.1 顶点着色器"></a>2.1 顶点着色器</h2><p>顶点着色器就是处理顶点的着色器，每个顶点都会执行一次顶点着色器。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">float4 <span class="hljs-title">vert</span><span class="hljs-params">(float4 vertex:POSITION)</span>:SV_POSITION</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> UnityObjectToClipPos(vertex);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/image-20210523163930947.png" srcset="/img/loading.gif" alt="image-20210523163930947"></p><p>首先呢，我们先来解释下顶点这个函数的结构。</p><ol><li>顶点着色器函数的名称，在上面我们已经指定了顶点着色器的名称就是vert，所以这里我们必须要用vert作为名称。</li><li>其中float4 vertex是我们自己定义的一个四维向量，名字叫vertex（名字我们可以随便起），仅仅定义一个四维向量并不能使它拥有我们模型的顶点信息，所以这里我们需要为它指定一个语义——POSITION，POSITION就是代表着模型的顶点位置信息。此时变量vertex就表示着我们模型的顶点位置。</li><li>在顶色着色器中最主要的事情就是将顶点从模型坐标转换到裁剪坐标（将模型显示在二维显示器上时需要做的一些矩阵转换）。<br>不会矩阵转换怎么办，没关系，Unity已经为我们准备好现成的命令了，只需调用UnityObjectToClipPos即可，后面括号中加上我们的顶点位置变量就可以了。</li><li>在后面片断着色器中我们需要顶点着色器中的输出结果，所以3中需要加上return来将转换后的顶点返回，float4就是用来定义我们返回的是四维向量。</li><li>经过变换后返回的顶点位置，我们也需要利用语义来标记一下，以便片元着色器可以知道哪个是从顶点着色器输出过来的顶点位置信息。所以我们在函数的后面加上: SV_POSITION。</li></ol><blockquote><p>简单地说：<br>POSITION语义是用于顶点着色器，用来指定模型的顶点位置，是在变换前的顶点的本地空间坐标。<br>SV_POSITION语义则用于像素着色器，用来标识经过顶点着色器变换之后的顶点坐标。</p><p>在顶点着色器中处理顶点时，我们首先需要获取到模型的顶点数据（比如顶点位置、法线信息、顶点颜色等等），那么这些数据都是直接存储在模型中的，我们在Shader中只需要通过标识语义就可以自动获得。</p></blockquote><p>此时我们的Shader还不能正常编译，因为了除了顶点着色器外，还们需要一个片断着色器。</p><h2 id="2-2-片元着色器"><a href="#2-2-片元着色器" class="headerlink" title="2.2 片元着色器"></a>2.2 片元着色器</h2><p>片元着色器也被称作像素着色器，主要是处理最终显示在屏幕上的像素结果。</p><p>经过顶点着色器的处理，我们已经得到了最终显示在屏幕上的顶点矩阵，内部会自动进行插值计算，以获得当前模型的所有片元像素，然后每个像素都会执行一次片元着色器，得到最终每个像素的颜色值。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">fixed4 _Color;<br><span class="hljs-function">fixed4 <span class="hljs-title">frag</span> <span class="hljs-params">()</span> : SV_Target</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _Color;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/image-20210523164629339.png" srcset="/img/loading.gif" alt="image-20210523164629339"></p><ol><li><p>片断着色器的函数名，其中()中是空的，因为在这个简单的示例中我们并不需要额外的数据传过来，所以暂时为空。</p></li><li><p>在Cg/HLSL中使用Properties中的变量前还需要在Cg/HLSL中再重新声明一次，名称要求一致。<br>这是死规则，我们只能按照要求来执行。<br>float、half、fixed，这三都是浮点数的表示，只是分别对应的精度不一样，主要用此可以进行更进一步的优化。</p></li><li><p>直接返回_Color,也就是直接返回我们在材质面板中定义的颜色，这也是我们这个小例子想要的效果。</p></li><li><p>返回的值是个四维向量，我们用float4来表示，如果想优化的话就用fixed4来表示，精度问题，这里不是重点。</p></li><li><p>SV_TARGET是系统值，表示该函数返回的是用于下一个阶段输出的颜色值，也就是我们最终输出到显示器上的值。</p></li></ol><h2 id="2-3-最终代码"><a href="#2-3-最终代码" class="headerlink" title="2.3 最终代码"></a>2.3 最终代码</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs text">Shader &quot;Unlit/MyFirstShader&quot;<br>&#123;<br>Properties<br>&#123;<br>_Color(&quot;Color&quot;, Color) = (1,1,1,1)<br>&#125;<br><br>SubShader<br>&#123;<br>Pass<br>&#123;<br>CGPROGRAM<br>#pragma vertex vert<br>#pragma fragment frag<br><br>fixed4 _Color;<br><br>float4 vert ( float4 vertex : POSITION ) : SV_POSITION<br>&#123;<br>return UnityObjectToClipPos(vertex);<br>&#125;<br><br>fixed4 frag () : SV_Target<br>&#123;<br>return _Color;<br>&#125;<br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们已经可以正常编译并实时更换颜色得到反馈了。</p><h2 id="2-4-注意"><a href="#2-4-注意" class="headerlink" title="2.4 注意"></a>2.4 注意</h2><p>顶点着色器与片断着色器的执行并不是1:1的</p><p>例如:<br>一个三角面片，只有三个顶点，顶点着色器只需执行3次，而片断着色器由最终的像素数来决定，执行几百上千都是很正常的。</p><p>所以从性能的角度来考虑，我们要尽量把计算放在顶点着色器中去执行。<br>其次在片断着色器中也要尽量的简化算法，节省开支。</p><h1 id="3-宠儿：表面着色器"><a href="#3-宠儿：表面着色器" class="headerlink" title="3. 宠儿：表面着色器"></a>3. 宠儿：表面着色器</h1><p>表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型。</p><p>特点是：</p><ul><li><p>代码量少，使用方便简单</p></li><li><p>渲染代价大</p></li></ul><p>实际上，表面着色器在运行时会被Unity编译成对应的顶点/片元着色器。<br>我们可以理解为表面着色器是Unity对顶点/片元着色器的封装抽象。</p><p>一个非常简单的表面着色器示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Custom/simple surface Shader&quot;</span> <br>&#123;<br>SubShader<br>&#123;<br>Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span> = <span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>CGPROGRAM<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> surface surf Lambert</span><br>struct Input <br>&#123;<br>float4 color : COLOR;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> </span><br><span class="hljs-function"></span>&#123;<br>o.Albedo = <span class="hljs-number">1</span>;<br>&#125;<br>ENDCG<br>&#125;<br>Fallback <span class="hljs-string">&quot;Di ffuse&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>从上述程序中可以看出，表面着色器被定义在SubShader语义块(而非Pass语义块)中的CGPROGRAM和ENDCG之间。<br>因为表面着色器不需要开发者关心使用多少个Pass每个如何渲染等问题，Unity 会在背后为我们做好这些事情。</p><blockquote><p>注意：<br>这里的Cg/HLSL是Unity经封装后提供的，它的语法和标准的CgHLSL语法几乎一样， 但还是有细微的不同<br>例如有些原生的函数和用法Unity并没有提供支持。</p></blockquote><h1 id="4-孤儿：固定函数着色器"><a href="#4-孤儿：固定函数着色器" class="headerlink" title="4. 孤儿：固定函数着色器"></a>4. 孤儿：固定函数着色器</h1><p>上述两种UnityShader形式都使用了可编程管线，而对于一些不支持可编程管线的旧设备，就需要用**固定函数着色器(Fixed Function Shader)**。</p><p>这种着色器往往只能完成非常简单的效果。</p><p>固定函数着色器的代码被定义在Pass语句块中，且只是用ShaderLab的语法，不支持Cg/HLSL。</p><p>因为时代变了，现在大多数GPU都支持可编程管线，所以固定函数着色器成了孤儿。<br>实际上，固定函数着色器在运行时会被Unity编译成对应的顶点/片元着色器，因此真正的固定函数着色器已经不存在了。</p><blockquote><p>所以就略过吧，别学，没用的。</p></blockquote><h1 id="5-着色器的选择"><a href="#5-着色器的选择" class="headerlink" title="5. 着色器的选择"></a>5. 着色器的选择</h1><ul><li>除非你有非常明确的需求必须要使用固定函数着色器<br>例如需要在非常旧的设备上运行你的游戏(这些设备非常少见)<br>否则<strong>不要使用固定函数着色器</strong></li><li>如果你想和<strong>各种光源</strong>打交道<br>使用表面着色器<br>但需要小心它在<strong>移动平台的性能表现</strong></li><li>如果你使用的<strong>光照数目非常少</strong><br>使用顶点/片元着色器</li><li>如果你有<strong>很多自定义的渲染效果</strong><br>请选择顶点/片元着色器</li></ul><blockquote><p>其它两种着色器在编译时都会编译成顶点/片选着色器<br>因此从本质上来讲，Unity中只存在顶点/片选着色器</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader的结构</title>
    <link href="/2021/05/23/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <url>/2021/05/23/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是shader"><a href="#1-1-什么是shader" class="headerlink" title="1.1 什么是shader"></a>1.1 什么是shader</h2><p>Shader的中文翻译是着色器，是一类面对GPU编程语言的总称。<br>Shader其实就是一段代码，这段代码的作用是告诉GPU具体怎样去绘制模型的每一个顶点的颜色以及最终每一个像素点的颜色。</p><p>更具体的讲：</p><ul><li>GPU流水线上–些可高度编程的阶段,而由着色器编译出来的最终代码是会在GPU.上运行的(对于固定管线的渲染来说，着色器有时等同于–些特定的渲染设置);</li><li>有一些特定类型的着色器，如顶点着色器、片元着色器等;</li><li>依靠着色器我们可以控制流水线中的渲染细节,例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</li></ul><h2 id="1-2-shader语言有哪些"><a href="#1-2-shader语言有哪些" class="headerlink" title="1.2 shader语言有哪些"></a>1.2 shader语言有哪些</h2><p>既然Shader是一段代码，那必然要用一种语言来书写它，目前主流的有三种语言：</p><ul><li>基于OpenGL<br>OpenGL Shading Language，简称GLSL。</li><li>基于DirectX<br>High Level Shading Language,简称HLSL。</li><li>基于NVIDIA<br>C for Graphic，简称Cg语言。</li></ul><p>GLSL与HLSL分别是基于OpenGL和Direct3D的接口，两者不能混用。</p><p>而Cg语言是用于图形的C语言。<br>这其实说明了当时设计人员的一个初衷，就是<strong>让基于图形硬件的编程变得和C语言编程一样方便，自由</strong>。<br>正如C++和 Java的语法是基于C的，Cg语言本身也是基于C语言的。<br>如果您使用过C、C++、Java其中任意一个，那么Cg的语法也是比较容易掌握的。<br>Cg语言极力保留了C语言的大部分语义，力图让开发人员从硬件细节中解脱出来，Cg同时拥有高级语言的好处，如代码的易重用性，可读性高等。</p><blockquote><p>Cg语言是Microsoft和NVIDIA相互协作在标准硬件光照语言的语法和语义上达成了一致。<br>所以，HLSL和Cg其实是同一种语言。</p></blockquote><h2 id="1-3-什么是UnityShader"><a href="#1-3-什么是UnityShader" class="headerlink" title="1.3 什么是UnityShader"></a>1.3 什么是UnityShader</h2><p>Unity Shader严格来说并不是传统上的Shader,而是Unity自身封装后的一种便于书写的Shader，又称为ShaderLab。</p><p><img src="/images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/image-20210523140053736.png" srcset="/img/loading.gif" alt="UnityShader是封装"></p><p>其实在Unity中反而一切变的简单起来了，我们只需关心如何去这实现我们想要的效果就好了，其余的事情全部交给Unity来自动处理。<br>因为我们在Unity中编写的Shader最终会根据不同的平台来编绎成不同的着色器语言。</p><p>官方建议使用Cg/HLSL来编写ShaderLab，因为Cg/HLSL有更好的跨平台性。</p><h1 id="2-UnityShader的结构"><a href="#2-UnityShader的结构" class="headerlink" title="2. UnityShader的结构"></a>2. UnityShader的结构</h1><p>一段完整UnityShader代码的结构应该如下面的例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Shader">Shader &quot;Path&#x2F;ShaderName&quot;<br>&#123;<br>Properties<br>&#123;<br><br>&#125;<br>SubShader<br>&#123;<br>Pass<br>&#123;<br><br>&#125;<br>&#125;<br>FallBack &quot;Diffuse&quot;<br>CustomEditor &quot;EditorName&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>从整体来看的话，大致是这样的一个框架结构：</p><p><strong>Shader “name” { [Properties] SubShaders [FallBack] [CustomEditor] }</strong></p><blockquote><p>[]方括号表示可选</p></blockquote><p>可以拆分成以下几个大部分：</p><ul><li>Shader “name”</li><li>Properties</li><li>SubShaders</li><li>FallBack</li><li>CustomEditor</li></ul><h2 id="2-1-Shader-“name”-路径名称"><a href="#2-1-Shader-“name”-路径名称" class="headerlink" title="2.1 Shader “name”-路径名称"></a>2.1 Shader “name”-路径名称</h2><p>每个Unity Shader文件的第一行都需要通过Shader语句来指定该Unity Shader 的名字。<br>当为材质选择使用的UnityShader时,这些名称就会出现在材质面板的下拉列表里。</p><p>通过在字符串中添加斜杠(“/”)， 可以控制UnityShader在材质面板中出现的位置<br>例如:<code>Shader &quot;Custom/ MyShader&quot; &#123;...&#125;</code><br>那么这个UnityShader在材质面板中的位置就是:Shader -&gt; Custom -&gt; MyShader</p><blockquote><p>如果我们把路径名称放在Hidden下面的话<br>比如：<code>Shader &quot;Hidden/TA/MyFirstShader&quot;</code><br>则表示在材质面板中隐藏此Shader,你将无法通过材质下拉列表中找到它。<br>这在做一些不需暴露的Shader时很有用处，可以使Shader下拉列表更精简整洁。</p></blockquote><blockquote><p>而Shader文件的名称，也就是我们在Project面板中的资源文件的名称，是可以与Shader内部的路径名称不一样的，这点与C#是不同的。<br>在定义内部路径名称时，建议统一规划下，不要Shader过多后导致很混乱，不便于美术去使用。</p></blockquote><h2 id="2-2-Properties-属性"><a href="#2-2-Properties-属性" class="headerlink" title="2.2 Properties-属性"></a>2.2 Properties-属性</h2><p>Properties是UnityShader与材质的桥梁，语句块中的属性会出现在材质面板。</p><p>格式如下：<br><code>[Attribute]_Name (&quot;Display Name&quot;,Type) = Default Value</code></p><h3 id="2-2-1-Attribute"><a href="#2-2-1-Attribute" class="headerlink" title="2.2.1 Attribute"></a>2.2.1 Attribute</h3><p>属性标记，说白了就是Unity内置的几个属性标记关键字，用于对当前这条属性进行一些特殊的处理，在下面会进行详细介绍。</p><blockquote><p>此标记不是必选项，可以不添加，同时一条属性上也可以有多条属性标记。</p></blockquote><h3 id="2-2-2-Name"><a href="#2-2-2-Name" class="headerlink" title="2.2.2 _Name"></a>2.2.2 _Name</h3><p>属性的名称，也就是变量名。<br>在Shader的CG代码中就是通过这个名称来调用此属性内容的，在外部利用脚本调用时也是这个名称，所以一定要用英文。</p><p><strong>在名称前一定要加上下划线，否则会出现编绎错误！</strong></p><blockquote><p>关于此变量名，有一点很重要！<br>如果此Shader有FallBack的话，一定要将此Shader中的变量名与FallBack中的变量名保持一致，否则会出现FallBack后原有的属性值获取不到的情况<br>切记！</p></blockquote><h3 id="2-2-3-Display-Name"><a href="#2-2-3-Display-Name" class="headerlink" title="2.2.3 Display Name"></a>2.2.3 Display Name</h3><p>显示在材质面板上的名称，主要起到说明解释的作用，可用中文</p><blockquote><p>（正式项目中建议最好还是用英文）</p></blockquote><h3 id="2-2-4-Type"><a href="#2-2-4-Type" class="headerlink" title="2.2.4 Type"></a>2.2.4 Type</h3><p>属性的类型，常用的有以下几种：</p><table><thead><tr><th>属性类型</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>Int</td><td>整数</td><td>_Int(“我是Int”, Int) = 1</td></tr><tr><td>Float</td><td>浮点数(小数)</td><td>_Float(“我是Float”, Float) = 0.5</td></tr><tr><td>Range</td><td>有范围的浮点数(使用滑块)</td><td>_Float(“我是Float”, Range( 0 , 1)) = 0.5</td></tr><tr><td>PowerSlider</td><td>有曲度变化的Range(非线性滑块)</td><td>[PowerSlider(3)]_Float(“我是Float”, Range( 0 , 1)) = 0.5</td></tr><tr><td>IntRange</td><td>向下取整(使用滑块)</td><td>[IntRange]_Float(“我是Float”, Range( 0 , 1)) = 1</td></tr><tr><td>Toggle</td><td>一个checkbook，选中为1，不选为0</td><td>[Toggle]_Float(“我是Float”, Range( 0 , 1)) = 1</td></tr><tr><td>Enum</td><td>枚举(下拉列表)</td><td>[Enum(UnityEngine.Rendering.CullMode)]_Float(“我是Float”, Float) = 1</td></tr><tr><td>Color</td><td>RGBA颜色</td><td>_Color(“我是Color”, Color) = (1,1,1,1)</td></tr><tr><td>HDR</td><td>带亮度的颜色</td><td>[HDR]_Color(“Color”, Color) = (1,1,0,1)</td></tr><tr><td>Vector</td><td>四维向量</td><td>_Vector(“我是Vector”, Vector) = (0,0,0,0)</td></tr><tr><td>2D</td><td>2D纹理</td><td>_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>NoScaleOffset</td><td>没有Tiling (贴图重复度)与Offset (贴图偏移值)的2D纹理</td><td>[NoScaleOffset]_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>Normal</td><td>法线贴图</td><td>[Normal]_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>3D</td><td>3D纹理</td><td>_MainTex(“我是3D纹理”, 3d) = “” {}</td></tr><tr><td>Cube</td><td>立方体纹理</td><td>_MainTex(“我是Cube纹理”, CUBE) = “” {}</td></tr></tbody></table><blockquote><p>其他属性类型</p><p><strong>[Header]</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">Properties<br>&#123;<br>[Header(This is Header )]_Int(&quot;我是Int&quot;, Int) = 1<br>_Float(&quot;我是Float&quot;, Range( 0 , 1)) = 1<br>&#125;<br></code></pre></td></tr></table></figure><p>在材质面板上进行标注，通常用作分类组别用，注意只支持英文、数字、空格以及下划线。</p><p><strong>[HideInInspector]</strong><br>在材质面板中隐藏此条属性，在不希望暴露某条属性时可以快速将其隐藏。</p></blockquote><h3 id="2-2-5-Default-Value"><a href="#2-2-5-Default-Value" class="headerlink" title="2.2.5 Default Value"></a>2.2.5 Default Value</h3><p>默认值。<br>当第一次指定此Shader时，或者在材质面板上执行Reset时，属性的值会自动恢复到默认值。</p><ul><li><p>Int、 Float、 Range<br>其默认值就是一个单独的数字;</p></li><li><p>Color和Vector<br>默认值是用圆括号包围的一个四维向量;</p></li><li><p>2D、Cube、 3D这3种纹理类型<br>默认值的定义稍微复杂，它们的默认值是通过一个字符串 后跟一个花括号来指定的。</p><ul><li>字符串要么是空的，要么是内置的纹理名称<br>如“white”“black” “gray”或者“bump”。 </li></ul></li></ul><blockquote><p>花括号的用处原本是用于指定一些纹理属性的。<br>例如在Unity 5.0以前的版本中，我们可以通过TexGenCubeReflect、TexGen CubeNormal等选项来控制固定管线的纹理坐标的生成。<br>但在Unity 5.0以后的版本中，这些选项被移除了，如果我们需要类似的功能，就需要自己在顶点着色器中编写计算相应纹理坐标的代码。</p></blockquote><h3 id="2-2-6-案例"><a href="#2-2-6-案例" class="headerlink" title="2.2.6 案例"></a>2.2.6 案例</h3><p>下面的代码给出了一个展示所有属性类型的例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php">Properties<br>&#123;<br><span class="hljs-comment">//Numbers and Sliders</span><br>_Int (<span class="hljs-string">&quot;Int&quot;</span>， <span class="hljs-keyword">Int</span>) = <span class="hljs-number">2</span><br><span class="hljs-keyword">Float</span> (<span class="hljs-string">&quot;Float&quot;</span>, <span class="hljs-keyword">Float</span>) = <span class="hljs-number">1.5</span><br>_Range (<span class="hljs-string">&quot;Range&quot;</span> ,Range(<span class="hljs-number">0.0</span>, <span class="hljs-number">5.0</span>)) = <span class="hljs-number">3.0</span><br><br>   <span class="hljs-comment">// Colors and Vectors .</span><br>Color (<span class="hljs-string">&quot;Color&quot;</span>, color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>_Vector (<span class="hljs-string">&quot;Vector&quot;</span>, Vector) = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// Textures</span><br><span class="hljs-number">2</span>D (<span class="hljs-string">&quot;2D&quot;</span>， <span class="hljs-number">2</span>D) =”<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">Cube (&quot;</span>Cube<span class="hljs-string">&quot;, Cube) = &quot;</span>white<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">_3D (&quot;</span><span class="hljs-number">3</span>D<span class="hljs-string">&quot;, 3D) = &quot;</span>black<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>下图是该案例在属性面板中的显示：</p><p><img src="/images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/03B62754D758D194E8F6A1E8F9704AD1.jpg" srcset="/img/loading.gif" alt="属性面板"></p><h2 id="2-3-SubShaders-子着色器"><a href="#2-3-SubShaders-子着色器" class="headerlink" title="2.3 SubShaders-子着色器"></a>2.3 SubShaders-子着色器</h2><p>每个Shader中都可以包含多个SubShader，不可以没有，必须至少有一个。</p><p>Shader的核心算法实现就是在SubShader中来实现的。</p><p>在加载Shader时，Unity将遍历所有SubShader列表，并最终选择用户机器支持的第一个。</p><p>作用：<br>我们都知道不同的硬件性能是不一样的，游戏内通常把机器配置分为高中低三种，假如我们做了一个效果很好的Shader，但只能在高配机上有较好的性能表现，中低端就显的太费性能，SubShader在这时就可以派上用场了，我们可以在这个Shader内做三个SubShader，分别对应于高中低不同的配置。</p><p>SubShaders语句块中包含的定义通常如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">SubShader<br>&#123;<br>[Tags]<span class="hljs-regexp">//</span>可选的<br>[RenderSetup]<span class="hljs-regexp">//</span>可选的<br>Pass<br>&#123;<br>...<br>&#125;<br><span class="hljs-regexp">//</span>可有多个Pass<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可见，SubShader语句块由以下三个部分组成</p><ul><li><p>Tags 标签</p></li><li><p>RenderSetup状态</p></li><li><p>Pass</p></li></ul><h3 id="2-3-1-Tags-标签"><a href="#2-3-1-Tags-标签" class="headerlink" title="2.3.1 Tags 标签"></a>2.3.1 Tags 标签</h3><p>标签(Tags) 是一个键值对(Key/Value Pair),它的键和值都是字符串类型。<br>这些键值对是SubShader和渲染引擎之间的沟通桥梁。<br>它们用来告诉Unity的渲染引擎:我希望怎样以及何时渲染这个对象。</p><p>标签的结构如下:<br><code>Tags &#123;&quot;TagNamo1&quot;=&quot;Value1&quot; &quot;TagNamo2&quot;=&quot;Value2&quot;&#125;</code></p><p><img src="images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/image-20210523155428768.png" srcset="/img/loading.gif" alt="标签"></p><blockquote><p>注意:<br>上述标签仅可以在SubShader中声明，而不可以在Pass块中声明。<br>Pass块虽然也可以定义标签，但这些标签是不同于SubShader的标签类型。这是我们下面将要讲到的。</p></blockquote><h3 id="2-3-2-RenderSetup-状态"><a href="#2-3-2-RenderSetup-状态" class="headerlink" title="2.3.2 RenderSetup 状态"></a>2.3.2 RenderSetup 状态</h3><p>ShaderLab提供了一系列渲染状态的设置指令， 这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等。</p><p>下表给出了ShaderLab中常见的渲染状态设置选项。</p><table><thead><tr><th>状态名称</th><th>设置指令</th><th>解释</th></tr></thead><tbody><tr><td>Cull</td><td>Cull Back |Front |Off</td><td>设置剔除模式:剔除背面/正面/关闭剔除</td></tr><tr><td>ZTest</td><td>ZTest Less Greater |LEqual |GEqual I Equal |NotEqual |Always</td><td>设置深度测试时使用的函数</td></tr><tr><td>ZWrite</td><td>ZWrite On |Off</td><td>开启/关闭深度写入</td></tr><tr><td>Blend</td><td>Blend SrcFactor DstFactor</td><td>开启并设置混合模式</td></tr></tbody></table><p>当在SubShader块中设置了上述渲染状态时，将会应用到所有的Pass。<br>如果我们不想这样，可以在Pass语义块中单独进行上面的设置。</p><h3 id="2-3-3-Pass语句块"><a href="#2-3-3-Pass语句块" class="headerlink" title="2.3.3 Pass语句块"></a>2.3.3 Pass语句块</h3><h4 id="2-3-3-1-Pass的结构"><a href="#2-3-3-1-Pass的结构" class="headerlink" title="2.3.3.1 Pass的结构"></a>2.3.3.1 Pass的结构</h4><p>Pass语句块的格式如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Pass<br>&#123;<br><span class="hljs-string">[Name]</span><br><span class="hljs-string">[Tags]</span><br><span class="hljs-string">[RenderSetup]</span><br><br><span class="hljs-comment">//code</span><br>CGPROGRAM<br>...<br>ENDCG<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>[Name]<br>规定该Pass的名称，如<code>Name &quot;MyPassName&quot;</code><br>通过名称可以使用UsePass直接调用其它UnityShader中的Pass，如：<code>UsePase &quot;MyShader/MYPASSNAME&quot;</code></p><blockquote><p>使用UsePage指令时必须使用大写形式的名字</p></blockquote></li><li><p>[Tags]标签</p><p>用于告诉渲染引擎如何渲染物体<br>暂略，没看懂</p></li><li><p>[RenderSetup] 状态<br>与SubShader中的相同</p></li><li><p>CGPROGRAM-ENDCG<br>CG代码段</p></li></ul><h4 id="2-3-3-2-Pass的分类"><a href="#2-3-3-2-Pass的分类" class="headerlink" title="2.3.3.2 Pass的分类"></a>2.3.3.2 Pass的分类</h4><ul><li>Pass<br>普通的Pass</li><li>UsePass<br>复用其它UnityShader中的Pass</li><li>GrabPass<br>抓取屏幕，将结果存在一张纹理中以便后续的Pass处理</li></ul><h2 id="2-4-FallBack指令"><a href="#2-4-FallBack指令" class="headerlink" title="2.4 FallBack指令"></a>2.4 FallBack指令</h2><p>当我们写的Shader在一些机器上不支持时（最终显示成粉红色），只要添加了FallBack，并在双引号内写上了其它Shader的有效路径名称，那么在碰到不支持的硬件时这个Shader就会自动切换成FallBack内的Shader。</p><p>如果FallBack内的Shader也不支持呢，那就继续从FallBack内的Shader中再找FallBack……</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">FallBack <span class="hljs-string">&quot;name&quot;</span><br><span class="hljs-regexp">//</span>或者<br>FallBack Off<span class="hljs-regexp">//</span>关闭fallback功能<br></code></pre></td></tr></table></figure><blockquote><p>FallBack会影响阴影的投射<br>在渲染阴影纹理时，Unity 会在每个Unity Shader中寻找一个阴影投射的Pass。<br>通常情况下，我们不需要自己专门实现一个Pass。<br>这是因为Fallback使用的内置Shader中包含了这样一个通用的Pass。<br>因此，为每个Unity Shader正确设置Fallback是非常重要的。</p></blockquote><h2 id="2-5-CustomEditor-自定义面板编辑器"><a href="#2-5-CustomEditor-自定义面板编辑器" class="headerlink" title="2.5 CustomEditor-自定义面板编辑器"></a>2.5 CustomEditor-自定义面板编辑器</h2><p>自定义界面，也就是说我们可以通过这个功能来自由定义材质面板的显示结果，它可以改写Properties中定义的显示方式。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#is与as</title>
    <link href="/2021/05/16/is%E4%B8%8Eas/"/>
    <url>/2021/05/16/is%E4%B8%8Eas/</url>
    
    <content type="html"><![CDATA[<h1 id="1-C-类型的转换"><a href="#1-C-类型的转换" class="headerlink" title="1. C#类型的转换"></a>1. C#类型的转换</h1><p>在c#中类型的转换分两种：显式和隐式，基本的规则如下：</p><ul><li>基类对象转化为子类对象，必须显式转换，规则：(类型名) 对象。</li><li>值类型和引用类型的转换采用装箱(boxing)或拆箱(unboxing).</li><li>子类转化为基类对象。</li><li>基本类型互相之间转化可以用Covent类来实现。</li><li>字符串类型转换为对应的基本类型用Parse方法，除了String类型外其他的类型都可以用Parse方法。</li><li>用GetType可以取得对象的精确类型。</li><li>子类转化为基类，采用隐式转换。</li></ul><h1 id="2-C-中的is"><a href="#2-C-中的is" class="headerlink" title="2. C#中的is"></a>2. C#中的is</h1><p>检查一个对象是否兼容于其他指定的类型,并返回一个Bool值,如果一个对象是某个类型或是其父类型的话就返回为true，否则的话就会返回为false。永远不会抛出异常<br>如果对象引用为null，那么is操作符总是返回为false，因为没有对象可以检查其类型。</p><p>　　代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>　　<span class="hljs-keyword">if</span> (o <span class="hljs-keyword">is</span> Label)<br>　　&#123;<br>  　 Label lb = (Label)o;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换成功&quot;</span>);<br>　　&#125;<br>　　<span class="hljs-keyword">else</span><br>　　&#123;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换失败&quot;</span>);  <br>　　&#125;<br></code></pre></td></tr></table></figure><h1 id="3-C-中as的转换规则"><a href="#3-C-中as的转换规则" class="headerlink" title="3. C#中as的转换规则"></a>3. C#中as的转换规则</h1><ul><li>检查对象类型的兼容性，并返回转换结果，如果不兼容则返回null；</li><li>不会抛出异常；</li><li>如果结果判断为空，则强制执行类型转换将抛出NullReferenceException异常；</li><li>用as来进行类型转换的时候，所要转换的对象类型必须是目标类型或者转换目标类型的派生类型</li></ul><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();  <br>　　Label lb = o <span class="hljs-keyword">as</span> Label;  <br>　　<span class="hljs-keyword">if</span> (lb == <span class="hljs-literal">null</span>)<br>　　&#123;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换失败&quot;</span>);<br>　　&#125;<br>　　<span class="hljs-keyword">else</span><br>　　&#123;   <br>  　 Response.Write(<span class="hljs-string">&quot;类型转换成功&quot;</span>); <br>　　&#125;<br></code></pre></td></tr></table></figure><p>使用as操作符有如下几点限制</p><p>第一个就是，不用在类型之间进行类型转化，即如下编写就会出现编译错误。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">NewType newValue = <span class="hljs-keyword">new</span> NewType();<br>NewType1 newValue = newValue <span class="hljs-keyword">as</span> NewType1;<br></code></pre></td></tr></table></figure><p>第二个就是，不能应用在值类型数据，即不能如下写（也会出现编译错误）。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> objTest = <span class="hljs-number">11</span>;<br><span class="hljs-built_in">int</span> nValue = objTest <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>;<br></code></pre></td></tr></table></figure><h1 id="4-as与is的区别"><a href="#4-as与is的区别" class="headerlink" title="4. as与is的区别"></a>4. as与is的区别</h1><ul><li><p>AS在转换的同事兼判断兼容性<br>如果无法进行转换，则 as 返回 null（没有产生新的对象）而不是引发异常。<br>有了AS我想以后就不要再用try-catch来做类型转换的判断了。<br>因此as转换成功要判断是否为null。</p></li><li><p>AS是引用类型类型的转换或者装箱转换，不能用与值类型的转换<br>如果是值类型只能结合is来强制转换</p></li><li><p>IS只是做类型兼容判断，并不执行真正的类型转换<br>返回true或false，不会返回null，对象为null也会返回false。</p></li><li><p>AS模式的效率要比IS模式的高<br>因为借助IS进行类型转换的化，需要执行两次类型兼容检查。<br>而AS只需要做一次类型兼容，一次null检查，null检查要比类型兼容检查快。</p></li></ul><h1 id="5-int-，Int32-Parse-，Convert-ToInt32-的区别"><a href="#5-int-，Int32-Parse-，Convert-ToInt32-的区别" class="headerlink" title="5. (int)，Int32.Parse()，Convert.ToInt32()的区别"></a>5. (int)，Int32.Parse()，Convert.ToInt32()的区别</h1><ul><li>(int)转换：<br>用在数值范围大的类型转换成数值范围小的类型时使用<br>但是如果被转换的数值大于或者小于数值范围，则得到一个错误的结果<br>利用这种转换方式不能将string转换成int，会报错。</li><li>Int32.Parse()转换：<br>在符合数字格式的string到int类型转换过程中使用，并可以对错误的string数字格式的抛出相应的异常。</li><li>Convert.ToInt32()转换：<br>使用这种转换，所提供的字符串必须是数值的有效表达方式，该数还必须不是溢出的数。否则抛出异常。</li></ul><h1 id="6-常用类型转换"><a href="#6-常用类型转换" class="headerlink" title="6. 常用类型转换"></a>6. 常用类型转换</h1><ul><li><p>Object =&gt; 已知引用类型<br>使用as操作符来完成</p></li><li><p>Object =&gt; 已知值类型<br>先使用is操作符来进行判断，再用类型强转方式进行转换</p></li><li><p>已知引用类型之间转换<br>首先需要相应类型提供转换函数，再用类型强转方式进行转换</p></li><li><p>已知值类型之间转换<br>最好使用系统提供的Convert类所涉及的静态方法</p></li></ul><p>希望本文所述对大家的C#程序设计有所帮助。</p><p>转载自：<a href="http://www.jb51.net/article/56657.htm%E3%80%82">http://www.jb51.net/article/56657.htm。</a></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-资源与样式</title>
    <link href="/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/"/>
    <url>/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-资源"><a href="#1-资源" class="headerlink" title="1.资源"></a>1.资源</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>WPF资源系统是一种保管一系列有用对象（如常用的画刷、样式和模板）的简单方法，从而使您可以更容易地重用这些对象。<br>每个元素都有Resources属性，该属性存储了一个资源字典集合（它是ResourceDictionary类的实例）。<br>资源集合可包含任意类型的对象，根据字符串编写索引。</p><h2 id="1-2-写法"><a href="#1-2-写法" class="headerlink" title="1.2 写法"></a>1.2 写法</h2><ul><li><p>Window的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Window&gt;</span><br>   <span class="hljs-section">&lt;Window.Resources&gt;</span><br>   <span class="hljs-section">&lt;/Window.Resources&gt;</span><br><span class="hljs-section">&lt;/Window&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Control的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Control&gt;</span><br>      <span class="hljs-section">&lt;Control.Resources&gt;</span><br>       <span class="hljs-section">&lt;/Control.Resources&gt;</span><br><span class="hljs-section">&lt;/Control&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-样式"><a href="#2-样式" class="headerlink" title="2. 样式"></a>2. 样式</h1></li></ul><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>样式是修改View（窗体、控件）样式的主要手段，主要作用更改控件的外观以及增强用户体验。</p><h2 id="2-2-样式的属性"><a href="#2-2-样式的属性" class="headerlink" title="2.2 样式的属性"></a>2.2 样式的属性</h2><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>Setterts</td><td>设置属性值以及自动关联事件处理程序的Setter对象或EventSetter对象的集合是Style类中最重要的属性，但并非唯一属性。</td></tr><tr><td>Triggers</td><td>继承自TriggerBase类能自动改变样式设置的对象集合。例如，当另一个属性改变时，或者当发生某个时间时，可以修改样式。</td></tr><tr><td>Resources</td><td>希望用于样式的资源集合。</td></tr><tr><td>BasedOn</td><td>通过该属性可创建继承自其它样式设置的更具体的样式</td></tr><tr><td>TargetType</td><td>该属性标识应用样式的元素类型。通过该属性可创建只影响特定类型元素的设置器，还可以创建能够为恰当的元素类型自动起作用的设置器</td></tr></tbody></table><h2 id="2-3-如何关联样式"><a href="#2-3-如何关联样式" class="headerlink" title="2.3 如何关联样式"></a>2.3 如何关联样式</h2><ul><li>DynamicResource（动态资源）<br><code> &lt;Button Style=&quot;&#123;StaticResource BtnStyle&#125;&quot; /&gt;</code></li><li>StaticResource（静态资源）<br><code>&lt;Button Style=&quot;&#123;DynamicResource BtnStyle&#125;&quot; /&gt;</code></li></ul><blockquote><p>二者区别<br>静态资源在第一次编译后即确定其对象或值，之后不能对其进行修改。<br>动态资源在运行时决定，当运行过程中真正需要时，才到资源目标中查找其值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>样式</tag>
      
      <tag>资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataResult与DataTable类</title>
    <link href="/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/"/>
    <url>/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>DataTable和DataSet可以看做是数据容器，比如你查询数据库后得到一些结果，可以放到这种容器里。</p><p>那你可能要问：我不用这种容器，自己读到变量或数组里也一样可以存起来啊，为什么用容器？</p><p>原因是，这种容器的功能比较强大，除了可以存数据，还可以有更大用途。</p><p>举例：<br>在一个c/s结构的桌面数据库系统里，你可以把前面存放查询结果的容器里的数据显示到你客户端界面上，用户在界面上对数据进行添加、删除、修改，你可以把用户的操作更新到容器。<br>等用户操作完毕了，要求更新，然后你才把容器整个的数据变化更新到中心数据库。</p><blockquote><p>这样做的好处是什么？<br>就是减少了数据库操作，客户端速度提高了，数据库压力减小了。</p></blockquote><p> DataSet可以比作一个内存中的数据库，DataTable是一个内存中的数据表，DataSet里可以存储多个DataTable。</p><h1 id="2-DataTable"><a href="#2-DataTable" class="headerlink" title="2. DataTable"></a>2. DataTable</h1><h2 id="2-1-类成员"><a href="#2-1-类成员" class="headerlink" title="2.1 类成员"></a>2.1 类成员</h2><h3 id="2-1-1-构造函数"><a href="#2-1-1-构造函数" class="headerlink" title="2.1.1 构造函数"></a>2.1.1 构造函数</h3><table><thead><tr><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td>DataTable()</td><td>不带参数初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName)</td><td>用指定的表名初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName, string tableNamespace)</td><td>用指定的表名和命名空间初始化DataTable类的新实例</td></tr></tbody></table><h3 id="2-1-2-常用属性"><a href="#2-1-2-常用属性" class="headerlink" title="2.1.2 常用属性"></a>2.1.2 常用属性</h3><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>CaseSensitive</td><td>指示表中的字符串比较是否区分大小写</td></tr><tr><td>ChildRelations</td><td>获取此DataTable 的子关系的集合</td></tr><tr><td>Columns</td><td>获取属于该表的列的集合</td></tr><tr><td>Constraints</td><td>获取由该表维护的约束的集合</td></tr><tr><td>DataSet</td><td>获取此表所属的DataSet</td></tr><tr><td>DefaultView</td><td>获取可能包括筛选视图或游标位置的表的自定义视图</td></tr><tr><td>HasErrors</td><td>获取一个值，该值指示该表所属的DataSet 的任何表的任何行中是否有错误</td></tr><tr><td>MinimumCapacity</td><td>获取或设置该表最初的起始大小。该表中行的最初起始大小。默认值为 50</td></tr><tr><td>Rows</td><td>获取属于该表的行的集合</td></tr><tr><td>TableName</td><td>获取或设置DataTable 的名称</td></tr></tbody></table><h3 id="2-1-3-常用方法"><a href="#2-1-3-常用方法" class="headerlink" title="2.1.3 常用方法"></a>2.1.3 常用方法</h3><table><thead><tr><th>方法名</th><th>含义</th></tr></thead><tbody><tr><td>AcceptChanges()</td><td>提交自上次调用AcceptChanges() 以来对该表进行的所有更改</td></tr><tr><td>BeginInit()</td><td>开始初始化在窗体上使用或由另一个组件使用的DataTable。初始化发生在运行时</td></tr><tr><td>Clear()</td><td>清除所有数据的DataTable</td></tr><tr><td>Clone()</td><td>克隆DataTable 的结构，包括所有DataTable 架构和约束</td></tr><tr><td>EndInit()</td><td>结束在窗体上使用或由另一个组件使用的DataTable 的初始化。初始化发生在运行时</td></tr><tr><td>ImportRow(DataRow row)</td><td>将DataRow 复制到DataTable 中，保留任何属性设置以及初始值和当前值</td></tr><tr><td>Merge(DataTable table)</td><td>将指定的DataTable 与当前的DataTable 合并</td></tr><tr><td>NewRow()</td><td>创建与该表具有相同架构的新DataRow</td></tr></tbody></table><h2 id="2-2-使用技巧"><a href="#2-2-使用技巧" class="headerlink" title="2.2 使用技巧"></a>2.2 使用技巧</h2><h3 id="2-2-1-创建表"><a href="#2-2-1-创建表" class="headerlink" title="2.2.1 创建表"></a>2.2.1 创建表</h3><p><code>DataTable dt = new DataTable(&quot;Table_AX&quot;); </code></p><h3 id="2-2-2-添加列属性"><a href="#2-2-2-添加列属性" class="headerlink" title="2.2.2 添加列属性"></a>2.2.2 添加列属性</h3><p>方法1：<br><code>dt.Columns.Add(&quot;column0&quot;, System.Type.GetType(&quot;System.String&quot;));</code><br>方法2：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataColumn dc = <span class="hljs-keyword">new</span> DataColumn(<span class="hljs-string">&quot;column1&quot;</span>, System.Type.GetType(<span class="hljs-string">&quot;System.Boolean&quot;</span>));<br>dt.Columns.Add(dc); <br></code></pre></td></tr></table></figure><h3 id="2-2-3-添加数据行"><a href="#2-2-3-添加数据行" class="headerlink" title="2.2.3 添加数据行"></a>2.2.3 添加数据行</h3><p>初始化行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr = dt.NewRow();<br>dr[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AX&quot;</span>;<br>dr[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">true</span>;<br>dt.Rows.Add(dr);<br></code></pre></td></tr></table></figure><p>空行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr1 = dt.NewRow();<br>dt.Rows.Add(dr1);    <br></code></pre></td></tr></table></figure><h3 id="2-2-4-选择数据行"><a href="#2-2-4-选择数据行" class="headerlink" title="2.2.4 选择数据行"></a>2.2.4 选择数据行</h3><p>选择表中所有第0列属性为’AX’的数据行<br><code>DataRow[] drss = dt.Select(&quot;column0 = &#39;AX&#39;&quot;);</code></p><blockquote><p>空属性时用<strong>is null</strong><br>例：<code> DataRow[] drs = dt.Select(&quot;column1 is null&quot;);</code></p></blockquote><h3 id="2-2-5-复制表-包括数据"><a href="#2-2-5-复制表-包括数据" class="headerlink" title="2.2.5 复制表(包括数据)"></a>2.2.5 复制表(包括数据)</h3><p><code>DataTable dtNew = dt.Copy();</code></p><h3 id="2-2-6-复制表-仅结构"><a href="#2-2-6-复制表-仅结构" class="headerlink" title="2.2.6 复制表(仅结构)"></a>2.2.6 复制表(仅结构)</h3><p><code>DataTable dtOnlyScheme = dt.Clone(); </code></p><h3 id="2-2-7-数据行操作"><a href="#2-2-7-数据行操作" class="headerlink" title="2.2.7 数据行操作"></a>2.2.7 数据行操作</h3><ul><li><p>方法一</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow drOperate = dt.Rows[<span class="hljs-number">0</span>];<br>drOperate[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">drOperate[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法三</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法四</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; <br></code></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>  <span class="hljs-keyword">foreach</span> (DataColumn column <span class="hljs-keyword">in</span> dt.Columns) <br>  &#123; <br> Console.WriteLine(row[column]); <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>row[column] 中的column是检索出来的表个列名。</p><p>如果想把某列的值拼接字符串，那就去掉内层循环就行了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">StringBuilder mailList = <span class="hljs-keyword">new</span> StringBuilder(); <br><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>   mailList.Append(row[<span class="hljs-string">&quot;Email&quot;</span>]); <br>   mailList.Append(<span class="hljs-string">&quot;;&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-8-复制数据行到当前数据表"><a href="#2-2-8-复制数据行到当前数据表" class="headerlink" title="2.2.8 复制数据行到当前数据表"></a>2.2.8 复制数据行到当前数据表</h3></li></ul><p><code>dtOnlyScheme.Rows.Add(dt.Rows[0].ItemArray); </code></p><h3 id="2-2-9-转换为字符串"><a href="#2-2-9-转换为字符串" class="headerlink" title="2.2.9 转换为字符串"></a>2.2.9 转换为字符串</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">System.IO.StringWriter sw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>System.Xml.XmlTextWriter xw = <span class="hljs-keyword">new</span> System.Xml.XmlTextWriter(sw);<br>dt.WriteXml(xw);<br><span class="hljs-built_in">string</span> s = sw.ToString();<br></code></pre></td></tr></table></figure><h3 id="2-2-10-筛选数据表"><a href="#2-2-10-筛选数据表" class="headerlink" title="2.2.10 筛选数据表"></a>2.2.10 筛选数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 &lt;&gt; true&quot;</span>;<br>dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 = true&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-11-行排序"><a href="#2-2-11-行排序" class="headerlink" title="2.2.11 行排序"></a>2.2.11 行排序</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.Sort = <span class="hljs-string">&quot;ID ,Name ASC&quot;</span>;<br>dt=dt.DefaultView.ToTable();   <br></code></pre></td></tr></table></figure><h3 id="2-2-12-绑定数据表"><a href="#2-2-12-绑定数据表" class="headerlink" title="2.2.12 绑定数据表"></a>2.2.12 绑定数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">gvTestDataTable.DataSource = dt;<br>gvTestDataTable.DataBind();<br></code></pre></td></tr></table></figure><blockquote><p>绑定的其实是DefaultView</p></blockquote><h3 id="2-2-13-判断一个字符串是否为数据表的列名"><a href="#2-2-13-判断一个字符串是否为数据表的列名" class="headerlink" title="2.2.13 判断一个字符串是否为数据表的列名"></a>2.2.13 判断一个字符串是否为数据表的列名</h3><p><code>dtInfo.Columns.Contains(&quot;AX&quot;);</code></p><h3 id="2-2-14-序列化"><a href="#2-2-14-序列化" class="headerlink" title="2.2.14 序列化"></a>2.2.14 序列化</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataTable convert to XML <span class="hljs-keyword">and</span> XML convert to DataTable<br>     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Page_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>     &#123;<br>       DataTable dt_AX = <span class="hljs-keyword">new</span> DataTable();<br>       <span class="hljs-comment">//dt_AX.Columns.Add(&quot;Sex&quot;, typeof(System.Boolean));</span><br>       <span class="hljs-comment">//DataRow dr = dt_AX.NewRow();</span><br>       <span class="hljs-comment">//dr[&quot;Sex&quot;] = true;</span><br>       <span class="hljs-comment">//dt_AX.Rows.Add(dr);</span><br>       <span class="hljs-built_in">string</span> xml=ConvertBetweenDataTableAndXML_AX(dt_AX);<br>       DataTable dt = ConvertBetweenDataTableAndXML_AX(xml);<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params">DataTable dtNeedCoveret</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextWriter tw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>       <span class="hljs-comment">//if TableName is empty, WriteXml() will throw Exception.         </span><br><br>dtNeedCoveret.TableName=dtNeedCoveret.TableName.Length==<span class="hljs-number">0</span>?<span class="hljs-string">&quot;Table_AX&quot;</span>:dtNeedCoveret.TableName;<br>       dtNeedCoveret.WriteXml(tw);<br>       dtNeedCoveret.WriteXmlSchema(tw);<br>       <span class="hljs-keyword">return</span> tw.ToString();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> DataTable <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> xml</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextReader trDataTable = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(<span class="hljs-number">0</span>, xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       System.IO.TextReader trSchema = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       DataTable dtReturn = <span class="hljs-keyword">new</span> DataTable();<br>       dtReturn.ReadXmlSchema(trSchema);<br>       dtReturn.ReadXml(trDataTable);<br>       <span class="hljs-keyword">return</span> dtReturn;<br>    &#125;<br> dt.Compute(<span class="hljs-string">&quot;sum(SaleNum)&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>) ; <br><span class="hljs-comment">// 对列SaleNum 汇总支持所以sql 聚合函数 如：sum(),count(),avg()等等。。。  </span><br><br>linq<br><br><span class="hljs-keyword">var</span> productNames = <span class="hljs-keyword">from</span> products <span class="hljs-keyword">in</span> dt.AsEnumerable() <span class="hljs-keyword">select</span> products.Field&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;ProductName&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>C#常用类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-依赖属性</title>
    <link href="/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>依赖属性就是一种自己可以没有值，并且可以通过绑定从其他数据源获取值。<br>依赖属性可支持WPF中的样式设置、数据绑定、继承、动画及默认值。</p><p>将所有的属性都设置为依赖属性并不总是正确的解决方案，具体取决于其应用场景。<br>有时，使用私有字段实现属性的典型方法便能满足要求。</p><p>MSDN中给出了下面几种应用依赖属性的场景：</p><ol><li><p>希望可在样式中设置属性。</p></li><li><p>希望属性支持数据绑定。</p></li><li><p>希望可使用动态资源引用设置属性。</p></li><li><p>希望从元素树中的父元素自动继承属性值。</p></li><li><p>希望属性可进行动画处理。</p></li><li><p>希望属性系统在属性系统、环境或用户执行的操作或者读取并使用样式更改了属性以前的值时报告。</p></li><li><p>希望使用已建立的、WPF 进程也使用的元数据约定，例如报告更改属性值时是否要求布局系统重新编写元素的可视化对象。</p><blockquote><p>总结自<a href="https://www.cnblogs.com/dotnet261010/p/6286475.html">https://www.cnblogs.com/dotnet261010/p/6286475.html</a></p></blockquote></li></ol><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><h2 id="2-1-属性变更通知"><a href="#2-1-属性变更通知" class="headerlink" title="2.1 属性变更通知"></a>2.1 属性变更通知</h2><p>无论什么时候，只要依赖属性的值发生改变，wpf就会自动根据属性的元数据触发一系列的动作，这些动作可以重新呈现UI元素，也可以更新当前的布局，刷新数据绑定等等。<br>这种变更的通知最有趣的特点之一就是属性触发器，它可以在属性值改变的时候，执行一系列自定义的动作，而不需要更改任何其他的代码来实现。通过下面的示例来演示属性变更通知</p><p>示例：当鼠标移动到Button按钮上面时，文字的前景色变为红色，离开时变为默认颜色黑色，采用传统方式和依赖属性两种方式实现：</p><h3 id="2-1-1-使用传统方式实现"><a href="#2-1-1-使用传统方式实现" class="headerlink" title="2.1.1 使用传统方式实现"></a>2.1.1 使用传统方式实现</h3><p>在Button按钮上定义MouseEnter和MouseLeave两个事件，分别处理鼠标移动到按钮上面和离开，</p><p>XAML界面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span>              <br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">MouseEnter</span>=<span class="hljs-string">&quot;Button_MouseEnter&quot;</span> <span class="hljs-attr">MouseLeave</span>=<span class="hljs-string">&quot;Button_MouseLeave&quot;</span> &gt;</span>鼠标移动到上面，前景色变为红色<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>        <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>C#后台代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Collections.Generic;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Linq;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Text;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Threading.Tasks;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Controls;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Data;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Documents;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.<span class="hljs-keyword">Input</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Navigation;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Shapes;<br> <br>namespace WpfDemo<br>&#123;<br>     // MainWindow.xaml 的交互逻辑<br>     <span class="hljs-built_in">public</span> partial <span class="hljs-keyword">class</span> MainWindow : <span class="hljs-keyword">Window</span><br>     &#123;<br>        <span class="hljs-built_in">public</span> MainWindow()<br>         &#123;<br>             InitializeComponent();<br>         &#125;<br>          // 鼠标移动到按钮上面<br>          // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>          // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseEnter(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Red;<br>             &#125;<br>        &#125;<br>         // 鼠标离开按钮<br>        // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>         // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseLeave(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Black;<br>             &#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-2-使用依赖属性实现"><a href="#2-1-2-使用依赖属性实现" class="headerlink" title="2.1.2 使用依赖属性实现"></a>2.1.2 使用依赖属性实现</h3><p>XAML界面代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">&lt;</span><span class="hljs-variable">Window</span> <span class="hljs-variable">x</span><span class="hljs-operator">:</span><span class="hljs-variable">Class</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">:</span><span class="hljs-variable">x</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br>        <span class="hljs-variable">Title</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;237&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;525&quot;</span> <span class="hljs-variable">WindowStartupLocation</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;CenterScreen&quot;</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Grid</span> <span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;30&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span><span class="hljs-operator">&gt;</span>鼠标移动到上面，前景色变为红色<br>            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span> <span class="hljs-variable">TargetType</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Button&quot;</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Trigger</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;IsMouseOver&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span><span class="hljs-operator">&gt;</span><br>                            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Setter</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Foreground&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Red&quot;</span><span class="hljs-operator">&gt;&lt;/</span><span class="hljs-built_in">Setter</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Trigger</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>           <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Grid</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;/</span><span class="hljs-variable">Window</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>使用上面的两种方式都可以实现Button按钮的前景色改变，效果如下：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230351681-1555534511.png" srcset="/img/loading.gif" alt="img"></p><p>在判断属性IsMouseOver的值为false的时候，自动将Foreground的值改为之前的值，因此就不需要写IsMouseOver的值为false的时候，将Foreground的值改为Black。</p><h2 id="2-2-属性值继承"><a href="#2-2-属性值继承" class="headerlink" title="2.2 属性值继承"></a>2.2 属性值继承</h2><p>是指属性值自顶向下沿着元素树进行传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;依赖属性&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我使用的是继承的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span>我使用的是自己的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>界面运行效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230206494-1555380756.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-3-节省内存空间"><a href="#2-3-节省内存空间" class="headerlink" title="2.3 节省内存空间"></a>2.3 节省内存空间</h2><p>依赖属性和CLR属性在内存的使用上是截然不同的，每个CLR属性都包含一个非static的字段。<br>因此当我们实例化一个类型的时候，就会创建该类型所拥有的所有CLR属性。<br>也就是说一个对象所占用的内存在调用new操作进行实例化的时候就已经决定了。</p><p>而wpf允许对象在创建的时候并不包含用于存储数据的空间，只保留在需要用到数据的时候能够获得该默认值，即用其他对象数据或者实时分配空间的能力。</p><h1 id="３-如何自定义依赖属性"><a href="#３-如何自定义依赖属性" class="headerlink" title="３. 如何自定义依赖属性"></a>３. 如何自定义依赖属性</h1><h2 id="3-1-声明依赖属性变量"><a href="#3-1-声明依赖属性变量" class="headerlink" title="3.1 声明依赖属性变量"></a>3.1 声明依赖属性变量</h2><p>依赖属性的声明都是通过public static来公开一个静态变量，变量的类型必须是DependencyProperty</p><h2 id="3-2-在属性系统中进行注册"><a href="#3-2-在属性系统中进行注册" class="headerlink" title="3.2 在属性系统中进行注册"></a>3.2 在属性系统中进行注册</h2><p>使用DependencyProperty.Register方法来注册依赖属性，或者是使用DependencyProperty.RegisterReadOnly方法来注册</p><h2 id="3-3-使用-NET属性包装依赖属性"><a href="#3-3-使用-NET属性包装依赖属性" class="headerlink" title="3.3 使用.NET属性包装依赖属性"></a>3.3 使用.NET属性包装依赖属性</h2><p>在类上实现属性时，只要该类派生自 DependencyObject，便可以选择使用 DependencyProperty 标识符来标示属性，从而将其设置为依赖属性。</p><p>其语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DependencyProperty TextProperty;<br>        TextProperty =<br>        DependencyProperty.Register(<span class="hljs-string">&quot;Text&quot;</span>, <span class="hljs-comment">//属性名称</span><br>        <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-comment">//属性类型</span><br>        <span class="hljs-keyword">typeof</span>(TestDependencyPropertyWindow), <span class="hljs-comment">//该属性所有者，即将该属性注册到那个类上</span><br>        <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">//属性默认值</span><br>         <br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Text<br> &#123;<br>    <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(TextProperty); &#125;<br>    <span class="hljs-keyword">set</span> &#123; SetValue(TextProperty, <span class="hljs-keyword">value</span>); &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p> 示例：自定义一个依赖属性，界面包括一个TextBox和TextBlock，TextBlock上面字体的前景色随TextBox里面输入的颜色而改变，如果TextBox里面输入的值可以转换成颜色，TextBlock字体的前景色会显示输入的颜色值，如果不能转换，显示默认的前景色。</p><ul><li>1、在当前项目里面添加一个WPF版的用户控件，命名为“MyDependencyProperty”，在MyDependencyProperty.xaml.cs文件里面自定义一个依赖属性：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Windows;<br><span class="hljs-keyword">using</span> System.Windows.Controls;<br><span class="hljs-keyword">using</span> System.Windows.Data;<br><span class="hljs-keyword">using</span> System.Windows.Documents;<br><span class="hljs-keyword">using</span> System.Windows.Input;<br><span class="hljs-keyword">using</span> System.Windows.Media;<br><span class="hljs-keyword">using</span> System.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> System.Windows.Navigation;<br><span class="hljs-keyword">using</span> System.Windows.Shapes;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">WpfDemo</span><br>&#123;<br>    <span class="hljs-comment">// MyDependencyProperty.xaml 的交互逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDependencyProperty</span> : <span class="hljs-title">UserControl</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-comment">//1、声明依赖属性变量</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyColorProperty;<br><br>        <span class="hljs-comment">//2、在属性系统中进行注册</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            MyColorProperty = DependencyProperty.Register(<span class="hljs-string">&quot;MyColor&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-keyword">typeof</span>(MyDependencyProperty),<br>                <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;Red&quot;</span>, (s, e) =&gt; <br>                &#123;<br>                    <span class="hljs-keyword">var</span> mdp = s <span class="hljs-keyword">as</span> MyDependencyProperty;<br>                    <span class="hljs-keyword">if</span> (mdp != <span class="hljs-literal">null</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">try</span><br>                        &#123;<br>                           <span class="hljs-keyword">var</span> color = (Color)ColorConverter.ConvertFromString(e.NewValue.ToString());<br>                            mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(color);<br>                        &#125;<br>                        catch<br>                        &#123;<br>                           mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(Colors.Black);<br>                        &#125;<br>                    &#125;<br>                <br>                &#125;));<br>        &#125;<br><br>        <span class="hljs-comment">//3、使用.NET属性包装依赖属性:属性名称与注册时候的名称必须一致，</span><br>       <span class="hljs-comment">//即属性名MyColor对应注册时的MyColor</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> MyColor <br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>               <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(MyColorProperty);<br>          &#125;<br>           <span class="hljs-keyword">set</span><br>            &#123;<br>               SetValue(MyColorProperty, <span class="hljs-keyword">value</span>);<br>            &#125;<br>        &#125;                    <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速定义依赖属性的快捷方式：</p><p>输入propdp，连续按两下Tab健，自动生成定义依赖属性的语法。</p><p>和输入cw连续按两下Tab健，自动生成Console.Write()一样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty<br>        &#123;<br>            <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)GetValue(MyPropertyProperty); &#125;<br>            <span class="hljs-keyword">set</span> &#123; SetValue(MyPropertyProperty, <span class="hljs-keyword">value</span>); &#125;<br>        &#125;<br><br>       <span class="hljs-comment">// Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc...</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyPropertyProperty =<br>           DependencyProperty.Register(<span class="hljs-string">&quot;MyProperty&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>), <span class="hljs-keyword">typeof</span>(ownerclass), <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><ul><li>2、在MyDependencyProperty.xaml里面添加一个TextBlock</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MyDependencyProperty&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:mc</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:d</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">mc:Ignorable</span>=<span class="hljs-string">&quot;d&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">d:DesignHeight</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">d:DesignWidth</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我是自定义的依赖属性<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>3、在MainWindow.xaml里面引用新创建的用户控件，并添加一个TextBox，用于输入颜色值，并将自定义的依赖属性MyColor绑定到TextBox</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span></span><br><span class="xml">         xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="xml">         xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;       </span><br><span class="xml">        xmlns:p=&quot;clr-namespace:WpfDemo&quot;</span><br><span class="xml">         Title=&quot;依赖属性&quot; Height=&quot;237&quot; Width=&quot;525&quot; WindowStartupLocation=&quot;CenterScreen&quot;&gt;</span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">TextBox</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;tbColor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextBox</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">p:MyDependencyProperty</span> <span class="hljs-attr">MyColor</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;Binding Path=Text,ElementName=tbColor&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p:MyDependencyProperty</span>&gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span>        </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在设计界面显示的效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115122217947-1972572422.png" srcset="/img/loading.gif" alt="img"></p><p>4、程序运行效果：</p><p>在TextBox里面输入正确的颜色值，前景色会显示为当前输入的颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121945931-691430131.png" srcset="/img/loading.gif" alt="img"></p><p>在TextBox里面输入错误的颜色值，前景色会显示为默认颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121956713-612253816.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>依赖属性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-MVVC</title>
    <link href="/2021/04/24/WPF-MVVC/"/>
    <url>/2021/04/24/WPF-MVVC/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MVVM是一种开发模式，是一种开发标准。<br>在WPF中应用到MVVM是非常常见的，MVVM全称为Model、View、ViewModel。</p><p>开发模式有</p><ul><li><p>MVC<br>模型-视图-控制器</p></li><li><p>MVP<br>模型-视图-演示者</p></li><li><p>MVVM<br>模型-视图-视图模型</p></li></ul><p>MVP, MVVM都是由MVC衍生出。<br>所有这些设计模式大体上都有助于开发松散组合、易于测试和维护的应用程序。</p><p><a href="https://www.php.cn/faq/417265.html">开发模式</a></p><p><img src="/images/WPF-MVVC/image-20210424155250844.png" srcset="/img/loading.gif" alt="image-20210424155250844"></p><h1 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h1><ul><li>View<br>代表窗体、控件等可视化资源</li><li>ViewModel<br>代表View的业务处理类，<br>将获取到的数据处理好与View进行关联绑定</li><li>Model<br>通常代表数据模型，它将支持ViewModel中所使用的到的<br>还有一种用法就是在Model里完成业务逻辑的编写ViewModel只需要写出关联逻辑代码，具体的使用方式视情况而定。</li></ul><p><img src="/images/WPF-MVVC/image-20210424154619430.png" srcset="/img/loading.gif" alt="image-20210424154619430"></p><h1 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h1><ul><li>优点<br>前后端逻辑分离，解耦，代码配置灵活，易维护，为数据驱动奠定基础。</li><li>缺点<br>开发耗时较长，对于新手掌握起来略微有难度。<br>基于MVVM再实现绑定难度会有一个小幅度的提升。<br>需多实践积累经验即可。</li></ul><h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4. 文件管理"></a>4. 文件管理</h1><p><img src="/images/WPF-MVVC/image-20210424154830937.png" srcset="/img/loading.gif" alt="image-20210424154830937"></p><p>如图所示</p><ul><li><p>请将与页面可视化相关的xaml文件放于Views文件夹下</p></li><li><p>请将页面逻辑交互相关的cs文件放于ViewModels文件夹下</p></li><li><p>请将数据处理，事务实现相关的cs文件放于Models文件夹下</p></li></ul><blockquote><p>.MainWindow稍微特殊点<br>因为它是主窗体作为整个程序的起始点，它可以单独放在外面</p></blockquote><blockquote><p>App.xaml是程序启动配置文件<br>如果需要更换起始运行窗体则需要修改StartupUri=“xxxView.xaml”即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>MVVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-命令</title>
    <link href="/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>命令有许多可变的部分组成，但它们都具有以下4个重要元素：</p><ul><li>命令<br>命令表示应用程序任务，并且跟踪任务是否能够被执行。<br>然而，命令实际上不包含执行应用程序任务的代码。</li><li>命令绑定<br>每个命令绑定针对用户界面的具体元素，将命令连接到相关的应用程序逻辑。<br>这种分解的设计是非常重要的，因为单个命令可用于应用程序中的多个地方，并且在每个地方具有不同的意义。<br>为处理这一问题，需要将同一命令与不同的命令绑定。</li><li>命令源<br>命令源触发命令。<br>例如，button就是命令源。<br>单击它们都会执行绑定命令。</li><li>命令目标<br>命令目标是在其中执行命令的元素。</li></ul><p><img src="/images/WPF-%E5%91%BD%E4%BB%A4/image-20210424153346796.png" srcset="/img/loading.gif" alt="image-20210424153346796"></p><h1 id="2-如何实现一个命令"><a href="#2-如何实现一个命令" class="headerlink" title="2.如何实现一个命令"></a>2.如何实现一个命令</h1><p>WPF命令的核心是System.Windows.Input.ICommand接口，该接口定义了命令的工作原理。<br>该接口包含两个方法和一个事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICommand</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">CanExecute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-keyword">event</span> EventHandler CanExecuteChanged;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>Execute</td><td>将包含引用程序任务逻辑</td></tr><tr><td>CanExecute</td><td>返回命令的状态。可用为true，不可用为false；</td></tr><tr><td>CanExecuteChanged</td><td>当命令状态改变是引发该事件。对于使用命令的任何控件，这是指示信号，表示他们应当调用</td></tr></tbody></table><blockquote><p>Execute和CanExecute方法都接受一个附加的对象参数，可使用该对象传递所需的任何附加信息。</p></blockquote><blockquote><p>CanExecute方法检查命令的状态。<br>通过使用该事件，当命令可用时，命令源（如button）可自动启用自身；<br>当命令不可用时，禁用自身。</p></blockquote><h1 id="3-如何让控件支持命令"><a href="#3-如何让控件支持命令" class="headerlink" title="3. 如何让控件支持命令"></a>3. 如何让控件支持命令</h1><p>支持命令的实现是在“命令源”这个环节实现ICommandSource。</p><p>ICommandSource接口定义了三个属性:</p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>Command</td><td>指向连接的命令，这是唯一必须的细节</td></tr><tr><td>CommandParameter</td><td>提供其他希望随命令发送的数据</td></tr><tr><td>CommandTarget</td><td>确定将在其中执行命令的元素</td></tr></tbody></table><blockquote><p>不是每个控件都直接支持command绑定的<br>需要将他们关联到实现了ICommandSource接口的控件<br>其中包括继承自ButtonBase类的控件（button和Checkbox等）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-布局</title>
    <link href="/2021/04/24/WPF-%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/24/WPF-%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>又称容器，面板。<br>在WPF中是最基础也是最重要的一环，它直接决定你界面的样子。掌握熟练度决定它的美观度和可交互性。</p><p>WPF与JavaSwing的布局(容器)有相似之处但又不完全相同。</p><p>WPF的面板主要有6个：</p><ul><li><p>Grid（网格面板）</p></li><li><p>StackPanel(栈面板)</p></li><li><p>Canvas（画布）</p></li><li><p>WrapPanel（环绕面板）</p></li><li><p>DockPanel（停靠面板）</p></li><li><p>UniformGrid(均布网格)</p></li></ul><p>其中前三个最为常用。</p><h1 id="2-Gird-布局"><a href="#2-Gird-布局" class="headerlink" title="2. Gird 布局"></a>2. Gird 布局</h1><p>可以理解为一个表格，类似于HTML中的Table标签。</p><p>它是由行和列组成。</p><h2 id="2-1-标签"><a href="#2-1-标签" class="headerlink" title="2.1 标签"></a>2.1 标签</h2><ul><li><p><code>&lt;Grid&gt;&lt;/Grid&gt;</code><br>该标签对内写入表格内容</p></li><li><p><code>&lt;Grid.RowDefinitions&gt;</code><br>该标签内写入<code>&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</code>标签对<br>用于定义Gird布局中有几行</p></li><li><p><code>&lt;Grid.ColumnDefinitions&gt;</code><br>该标签内写入<code>&lt;ColumnDefinition&gt;&lt;/ColumnDefinition&gt;</code>标签对<br>用于定义Gird布局中有几列</p></li></ul><h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><ul><li><p>Grid.Column<br>当前元素在Gird布局中的第几列</p></li><li><p>Grid.Row<br>当前元素在Gird布局中的第几行</p><blockquote><p>都从0开始数，且该属性写在元素标签内</p></blockquote></li></ul><h2 id="2-3-案例"><a href="#2-3-案例" class="headerlink" title="2.3 案例"></a>2.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上代码的效果是：</p><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424125742746.png" srcset="/img/loading.gif" alt="Grid布局"></p><h1 id="3-StackPanel-布局"><a href="#3-StackPanel-布局" class="headerlink" title="3 StackPanel 布局"></a>3 StackPanel 布局</h1><p>是一个可以将自身内容横向或纵向排列的容器。</p><h2 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 标签"></a>3.1 标签</h2><ul><li><code>&lt;StackPanel&gt;&lt;/StackPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p><ul><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul></li></ul><blockquote><p>默认情况下：<br>水平排列时，每个元素都与面板一样高；<br>垂直排列时，每个元素都与面板一样宽。<br>如果包含的元素超过了面板空间，它只会截断多出的内容。<br>元素的Margin属性用于使元素之间产生一定得间隔，当元素空间大于其内容的空间时，剩余空间将由HorizontalAlignment和 VerticalAlignment属性来决定如何分配。</p></blockquote><h2 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h2><p>垂直排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Vertical&quot;</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131943534.png" srcset="/img/loading.gif" alt="竖直排列"></p><p>水平排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Horizontal&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131833665.png" srcset="/img/loading.gif" alt="水平排列"></p><h1 id="4-WrapPanel-布局"><a href="#4-WrapPanel-布局" class="headerlink" title="4. WrapPanel 布局"></a>4. WrapPanel 布局</h1><p>WrapPanel面板以一行或者一列的形式来布置控件，当一行（列）放满之后自动转到下一行（列）。</p><blockquote><p>除了自动换行外，基本与StackPanel相同</p></blockquote><h2 id="4-1-标签"><a href="#4-1-标签" class="headerlink" title="4.1 标签"></a>4.1 标签</h2><ul><li><code>&lt;WrapPanel&gt;&lt;/WrapPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="4-2-属性"><a href="#4-2-属性" class="headerlink" title="4.2 属性"></a>4.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p></li><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul><h1 id="5-Canvas-布局"><a href="#5-Canvas-布局" class="headerlink" title="5 Canvas 布局"></a>5 Canvas 布局</h1><p>它比较特殊。它属于“任意布局”的一种概念，就是你拖控件到UI上的时候你把它放在哪里它就在那里了。</p><h2 id="5-1-标签"><a href="#5-1-标签" class="headerlink" title="5.1 标签"></a>5.1 标签</h2><ul><li><code>&lt;Canvas&gt;&lt;/Canvas&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="5-2-属性"><a href="#5-2-属性" class="headerlink" title="5.2 属性"></a>5.2 属性</h2><ul><li>Canvas.Top<br>设置元素距Canvas顶部的距离</li><li>Canvas.Bottom<br>设置元素距Canvas底部的距离</li><li>Canvas.Left<br>设置元素距Canvas左边界的距离</li><li>Canvas.Right<br>设置元素距Canvas右边界的距离</li></ul><blockquote><p>当同时设置left和right,top和bottom,以left和top为准</p></blockquote><h2 id="5-3-案例"><a href="#5-3-案例" class="headerlink" title="5.3 案例"></a>5.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Canvas</span> <span class="hljs-attr">Background</span>=<span class="hljs-string">&quot;LightBlue&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Top</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Top=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Bottom</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Bottom=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Left</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Left=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Right</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Right=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Canvas</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-控件</title>
    <link href="/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/"/>
    <url>/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul><li>常用控件表</li></ul><table><thead><tr><th>控件名</th><th>作用</th></tr></thead><tbody><tr><td>Label</td><td>一般用户描述性文字显示</td></tr><tr><td>TextBlock</td><td>只读的文本框，无法进行编辑，比较适合显示文本，该文本内容不允许编辑的情况</td></tr><tr><td>TextBox</td><td>支持编辑的基本控件</td></tr><tr><td>PassWordBox</td><td>一般用于用户输入验证或者注册时使用</td></tr><tr><td>DataGrid</td><td>列表数据显示控件</td></tr><tr><td>ListView</td><td>一般ListView都可以用DataGrid替代</td></tr><tr><td>ListBox</td><td>下拉列表级控件</td></tr><tr><td>GroupBox</td><td>用于组织页面相关元素放到一起，方便用户使用等方面提供帮助。</td></tr><tr><td>RichTextBox</td><td>支持富文本和简单文本等，可以实现出类似Word的那样的效果。</td></tr><tr><td>MediaElement</td><td>对媒体文件的操作和访问</td></tr><tr><td>Menu</td><td>菜单栏方式的多级菜单的管理和操作</td></tr><tr><td>TabControl</td><td>分页标签</td></tr></tbody></table><p><img src="/images/WPF-%E6%8E%A7%E4%BB%B6/image-20210424140413545.png" srcset="/img/loading.gif" alt="image-20210424140413545"></p><ul><li>控件的基础属性<br>宽、高、背景色、字体颜色、字体大小、禁用、启用、显示、隐藏等</li><li>控件显示的值内容<br>Content、Text、Value等</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>控件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-绑定</title>
    <link href="/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/"/>
    <url>/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p> 绑定顾名思义，是将我们获取到的数据和UI上的控件绑定起来利用数据的变化来更新界面所看到的内容。</p><p>绑定的五个步骤:</p><ul><li>1.绑定目标 </li><li>2.绑定属性 </li><li>3.绑定模式 </li><li>4.绑定数据源 </li><li>5.关联资源</li></ul><h1 id="2-绑定步骤"><a href="#2-绑定步骤" class="headerlink" title="2. 绑定步骤"></a>2. 绑定步骤</h1><h2 id="2-1-绑定目标"><a href="#2-1-绑定目标" class="headerlink" title="2.1 绑定目标"></a>2.1 绑定目标</h2><p>绑定目标很好理解，其实就是你要操作绑定的控件。例如：Button，TextBox。</p><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot;&gt;&lt;/TextBox&gt;</code></p><p><img src="D:\码田\项目\MyBlog\source\images\WPF-绑定\image-20210424143754327.png" srcset="/img/loading.gif" alt="image-20210424143754327"></p><h2 id="2-2绑定属性（依赖项属性）"><a href="#2-2绑定属性（依赖项属性）" class="headerlink" title="2.2绑定属性（依赖项属性）"></a>2.2绑定属性（依赖项属性）</h2><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot; Text=&quot;&#123;Bingding Name&#125;&quot;&gt;&lt;/TextBox&gt;</code></p><ul><li>Text绑定属性</li><li>Bingding 绑定关键字</li><li>Name你要绑定的数据源的变量名</li></ul><h2 id="2-3-绑定模式"><a href="#2-3-绑定模式" class="headerlink" title="2.3 绑定模式"></a>2.3 绑定模式</h2><table><thead><tr><th>模式名称</th><th>含义</th></tr></thead><tbody><tr><td>TwoWay</td><td>无论是目标属性还是源属性，只要发生了更改，就会更新目标属性或源属性</td></tr><tr><td>OneWay</td><td>仅当源属性发生更改时更新目标属性</td></tr><tr><td>OneTime</td><td>仅当应用程序启动时或 DataContext 进行更改时更新目标属性</td></tr><tr><td>OneWayToSource</td><td>在目标属性更改时更新源属性</td></tr><tr><td>Default</td><td>模式根据实际情况来定，如果是可编辑的就是TwoWay,只读的就是OneWay</td></tr></tbody></table><h2 id="2-4-绑定数据源"><a href="#2-4-绑定数据源" class="headerlink" title="2.4 绑定数据源"></a>2.4 绑定数据源</h2><p>一般来说可以是单个变量（int , double,string）、也可以是一个数据集（List）。根据需求和场景去定义。</p><h2 id="2-5-关联资源-DataContext"><a href="#2-5-关联资源-DataContext" class="headerlink" title="2.5 关联资源 DataContext"></a>2.5 关联资源 DataContext</h2><p>在每一个窗体中，都有一个DataContext ，它是一个object类型主要用来存储绑定资源。</p><h1 id="3-绑定和窗体xaml-cs操作的区别"><a href="#3-绑定和窗体xaml-cs操作的区别" class="headerlink" title="3. 绑定和窗体xaml.cs操作的区别"></a>3. 绑定和窗体xaml.cs操作的区别</h1><p>区别在于，窗体后台文件直接访问控件的操作是事件驱动，如果没有事件的存在是改变不了界面的。</p><p>绑定操作，是以数据本身的变化来通知界面显示改变的。</p><p>UI代码和逻辑代码实现前后端分离。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>绑定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF快速入门</title>
    <link href="/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>整理自B站视频教程:<a href="https://www.bilibili.com/video/BV19K411M72o?p=1">https://www.bilibili.com/video/BV19K411M72o?p=1</a></p><h2 id="1-1-什么是WPF"><a href="#1-1-什么是WPF" class="headerlink" title="1.1 什么是WPF"></a>1.1 什么是WPF</h2><p>WPF全称Windows Presentation Foundation，是微软推出的一项基于windows操作系统的.net平台的c/s客户端构建技术。<br>最大的特征就是可以快速构建项目从而达到节约项目成本的目的。<br>在众多中小型企业比较受欢迎。</p><p>该项受欢迎的行业有医疗、工业、金融、硬件、物流、管理系统（ERP）等领域。</p><p>简而言之就是微软基于C#与.NET推出的一个可视化框架。</p><blockquote><p>微软的可视化框架发展路径：<br>MFC-&gt;WinForm-&gt;WPF</p></blockquote><h2 id="1-2-推荐书籍"><a href="#1-2-推荐书籍" class="headerlink" title="1.2 推荐书籍"></a>1.2 推荐书籍</h2><ul><li><p>《WPF编程宝典使用c#2012和.net4.5 第四版》</p></li><li><p>《c#高级编程》</p></li><li><p>《CLR Via C#》</p></li></ul><h2 id="1-3-前置知识体系"><a href="#1-3-前置知识体系" class="headerlink" title="1.3 前置知识体系"></a>1.3 前置知识体系</h2><ul><li><p>C#</p></li><li><p>学习过至少一种可视化框架或web框架</p></li></ul><h1 id="2-学习目录索引"><a href="#2-学习目录索引" class="headerlink" title="2 学习目录索引"></a>2 学习目录索引</h1><ul><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%B8%83%E5%B1%80/">布局(Pannel)</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/">控件</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/">依赖属性</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/">绑定</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/">命令</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-MVVC/">MVVM</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p><p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。<br>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。<br>这种方式简化了在复杂环境下的配置管理。</p><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><ul><li><p>单例类只能有一个实例</p></li><li><p>单例类必须自己创建自己的唯一实例</p></li><li><p>单例类必须给所有其他对象提供这一实例</p></li></ul><h2 id="2-1-优缺点"><a href="#2-1-优缺点" class="headerlink" title="2.1 优缺点"></a>2.1 优缺点</h2><h3 id="2-1-1-优点"><a href="#2-1-1-优点" class="headerlink" title="2.1.1 优点"></a>2.1.1 优点</h3><ul><li><p>在内存中只有一个对象，节省内存空间；</p></li><li><p>避免频繁的创建销毁对象，可以提高性能；</p></li><li><p>避免对共享资源的多重占用，简化访问；</p></li><li><p>为整个系统提供一个全局访问点。</p></li></ul><h3 id="2-1-2-缺点"><a href="#2-1-2-缺点" class="headerlink" title="2.1.2 缺点"></a>2.1.2 缺点</h3><ul><li><p>不适用于变化频繁的对象；</p></li><li><p>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</p></li><li><p>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</p></li></ul><h2 id="2-2-适用场景"><a href="#2-2-适用场景" class="headerlink" title="2.2 适用场景"></a>2.2 适用场景</h2><ul><li>需要生成唯一序列的环境</li><li>需要频繁实例化然后销毁的对象</li><li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象</li><li>方便资源相互通信的环境</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" alt="单例模式"></p><h1 id="4-实现步骤"><a href="#4-实现步骤" class="headerlink" title="4. 实现步骤"></a>4. 实现步骤</h1><ol><li>将该类的构造方法定义为私有方法：<br>这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</li><li>在该类内提供一个静态方法：<br>当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li></ol><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将为一个网站设计一个用于连接数据库的数据库连接池，它基于JDBC，并且要求具有以下几个功能：</p><ul><li>连接池内有数量可定的已连接对象随时供取用</li><li>当连接池内的连接对象不够时可生成新的对象取用</li><li>当连接操作完毕后，可将连接对象放回连接池</li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p>使用单例模式实现连接池：</p><ol><li><p>将该类的构造方法定义为私有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在该类内提供一个静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>   &#125;<br></code></pre></td></tr></table></figure><p>使用线性表存储连接对象，实现对连接对象操作的各个方法。</p></li></ol><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> EXP6;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;<br>    <span class="hljs-comment">//数据库地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String url;<br>    <span class="hljs-comment">//取得用户</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String user;<br>    <span class="hljs-comment">//登录密码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String password;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Connection&gt; connections;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConnectionPool connectionPool;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(String url,String user,String password)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.url=url;<span class="hljs-keyword">this</span>.user=user;<span class="hljs-keyword">this</span>.password=password;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">(String url,String user,String password)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool(url,user,password);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)<br>            &#123;<br>                connections.add(DriverManager.getConnection(url,user,password));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(connections.size()==<span class="hljs-number">0</span>) addConnection(<span class="hljs-number">1</span>);<br>        Connection t=connections.getFirst();<br>        connections.removeFirst();<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseConnection</span><span class="hljs-params">(Connection c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (c.isClosed()) connections.add(c);<br>                <span class="hljs-keyword">else</span> addConnection(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-进阶写法"><a href="#6-进阶写法" class="headerlink" title="6. 进阶写法"></a>6. 进阶写法</h1><h2 id="6-1-懒汉式-线程不安全"><a href="#6-1-懒汉式-线程不安全" class="headerlink" title="6.1 懒汉式(线程不安全)"></a>6.1 懒汉式(线程不安全)</h2><p>懒汉式其实是一种比较形象的称谓。<br>既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作。<br>因此在装载对象的时候不创建对象实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> (<span class="hljs-params"></span>)</span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         instance = <span class="hljs-keyword">new</span> Singleton();<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。<br>当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。<br>也就是说在多线程下不能正常工作。</p><h2 id="6-2-懒汉式-线程安全"><a href="#6-2-懒汉式-线程安全" class="headerlink" title="6.2 懒汉式(线程安全)"></a>6.2 懒汉式(线程安全)</h2><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。<br>因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。<br>这就引出了双重检验锁。</p><h2 id="6-3-双重检验锁"><a href="#6-3-双重检验锁" class="headerlink" title="6.3 双重检验锁"></a>6.3 双重检验锁</h2><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。<br>程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。<br>为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <span class="hljs-comment">//Single Checked</span><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                 <span class="hljs-comment">//Double Checked</span><br>                instance = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很完美，很可惜，它是有问题:<br>主要在于instance = new Singleton()这句，这<strong>并非是一个原子操作</strong>，事实上在 JVM 中这句话大概做了下面 3 件事情:</p><ul><li><p>给 instance 分配内存</p></li><li><p>调用 Singleton 的构造函数来初始化成员变量</p></li><li><p>将instance对象指向分配的内存空间<br>（执行完这步 instance 就为非 null 了）</p></li></ul><p>但是在 JVM 的即时编译器中存在指令重排序的优化。</p><p>也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。<br>如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance; <span class="hljs-comment">//声明成 volatile</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;       <br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。<br>但其实是不对的。</p><p><strong>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。</strong></p><p>也就是说，<strong>在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前</strong>。<br>比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</p><p>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。<br>这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p><h2 id="6-4-饿汉式-static-final-field"><a href="#6-4-饿汉式-static-final-field" class="headerlink" title="6.4 饿汉式 static final field"></a>6.4 饿汉式 static final field</h2><p>饿汉式其实是一种比较形象的称谓。<br>既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。</p><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-comment">//类加载时就初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点是它不是一种懒加载模式（lazy initialization），<strong>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。</strong></p><blockquote><p>饿汉式的创建方式在一些场景中将无法使用：<br>譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p></blockquote><h2 id="6-5-静态内部类-static-nested-class"><a href="#6-5-静态内部类-static-nested-class" class="headerlink" title="6.5 静态内部类 static nested class"></a>6.5 静态内部类 static nested class</h2><p>这种方法也是《Effective Java》上所推荐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE; <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法仍然使用JVM本身机制保证了线程安全问题。<br>由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，**第一次调用getInstance()时将加载内部类SingletonHolder **，在该内部类中定义了一个static类型的变量INSTANCE ，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><h2 id="6-6-枚举-Enum"><a href="#6-6-枚举-Enum" class="headerlink" title="6.6 枚举 Enum"></a>6.6 枚举 Enum</h2><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EasySingleton</span></span>&#123;<br>    <span class="hljs-type">INSTANCE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>我们可以总结出，要想实现效率高的线程安全的单例，我们必须注意以下两点：</p><ul><li><strong>尽量减少同步块的作用域</strong></li><li><strong>尽量使用细粒度的锁</strong></li></ul><p>一般来说，单例模式有五种写法：<br><strong>懒汉、饿汉、双重检验锁、静态内部类、枚举</strong><br>上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。</p><p>一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。<br>如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p><p>参考：<br><a href="https://www.jianshu.com/p/650593e69f59">https://www.jianshu.com/p/650593e69f59</a><br><a href="https://www.cnblogs.com/xuwendong/p/9633985.html">https://www.cnblogs.com/xuwendong/p/9633985.html</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket原理</title>
    <link href="/2021/04/07/Socket%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/07/Socket%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Socket"><a href="#1-什么是Socket" class="headerlink" title="1. 什么是Socket"></a>1. 什么是Socket</h1><h2 id="1-1-网络中进程之间如何通信"><a href="#1-1-网络中进程之间如何通信" class="headerlink" title="1.1 网络中进程之间如何通信"></a>1.1 网络中进程之间如何通信</h2><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信。</p><p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！<br>在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p><p>其实TCP/IP协议族已经帮我们解决了这个问题：<br>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><p>使用TCP/IP协议的应用程序通常采用应用编程接口：<br>UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。</p><p>就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。</p><h2 id="1-2-什么是TCP-IP、UDP"><a href="#1-2-什么是TCP-IP、UDP" class="headerlink" title="1.2 什么是TCP/IP、UDP"></a>1.2 什么是TCP/IP、UDP</h2><ul><li><p>TCP/IP（Transmission Control Protocol/Internet Protocol）<br>即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。</p></li><li><p>UDP（User Data Protocol，用户数据报协议）<br>是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p></li></ul><p>这里有一张图，表明了这些协议的关系。</p><p>​          <img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154451958.png" srcset="/img/loading.gif" alt="img">                              </p><h2 id="1-3-什么是Socket"><a href="#1-3-什么是Socket" class="headerlink" title="1.3 什么是Socket"></a>1.3 什么是Socket</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。<br>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p><blockquote><h3 id="socket一词的起源"><a href="#socket一词的起源" class="headerlink" title="socket一词的起源"></a>socket一词的起源</h3><p>在组网领域的首次使用是在1970年2月12日发布的文献<a href="http://datatracker.ietf.org/doc/rfc33/">IETF RFC33</a>中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p></blockquote><h2 id="1-4-Socket在哪里"><a href="#1-4-Socket在哪里" class="headerlink" title="1.4 Socket在哪里"></a>1.4 Socket在哪里</h2><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154523875.png" srcset="/img/loading.gif" alt="img"></p><h1 id="2-Socket的使用"><a href="#2-Socket的使用" class="headerlink" title="2. Socket的使用"></a>2. Socket的使用</h1><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154556909.png" srcset="/img/loading.gif" alt="img">   </p><ul><li>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。</li><li>在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。</li><li>客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</li></ul><h2 id="2-1-socket的基本操作"><a href="#2-1-socket的基本操作" class="headerlink" title="2.1 socket的基本操作"></a>2.1 socket的基本操作</h2><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。<br>下面以TCP为例，介绍几个基本的socket接口函数。</p><h3 id="2-1-1-socket-函数"><a href="#2-1-1-socket-函数" class="headerlink" title="2.1.1 socket()函数"></a>2.1.1 socket()函数</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> socket(<span class="hljs-type">int</span> <span class="hljs-keyword">domain</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">type</span>, <span class="hljs-type">int</span> protocol);<br></code></pre></td></tr></table></figure><p>socket函数对应于普通文件的打开操作。<br>普通文件的打开操作返回一个文件描述字，而**socket()**用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。<br>这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。<br>创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：<br>即协议域，又称为协议族（family）。<br>常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。<br>协议族决定了socket的地址类型，在通信中必须采用对应的地址。<br>如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：<br>指定socket类型。<br>常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li><li>protocol：<br>故名思意，就是指定协议。<br>常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等<br>它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li></ul><blockquote><p>注意：<br>并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。<br>当protocol为0时，会自动选择type类型对应的默认协议。</p></blockquote><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h3 id="2-1-2-bind-函数"><a href="#2-1-2-bind-函数" class="headerlink" title="2.1.2 bind()函数"></a>2.1.2 bind()函数</h3><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。<br>例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ul><li><p>sockfd：<br>即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。<br>bind()函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：<br>一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。<br>这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-keyword">sa_family_t</span>    sin_family; <br>    <span class="hljs-keyword">in_port_t</span>      sin_port;   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>   <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span>       s_addr;     <br>&#125;;<br></code></pre></td></tr></table></figure><p>ipv6对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span>     sin6_family;    <br>    <span class="hljs-keyword">in_port_t</span>       sin6_port;      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_flowinfo;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span>      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_scope_id;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> &#123;</span> <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   s6_addr[<span class="hljs-number">16</span>];    <br>&#125;;<br></code></pre></td></tr></table></figure><p>Unix域对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_PATH_MAX    108</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span> sun_family;                <br>    <span class="hljs-keyword">char</span>        sun_path[UNIX_PATH_MAX];   <br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>addrlen：对应的是地址的长度。</p></li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务。<br>客户就可以通过它来接连服务器；</p><p>而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。</p><p>这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p><blockquote><h3 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h3><p><strong>主机字节序</strong>就是我们平常说的大端和小端模式：<br>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。<br>引用标准的Big-Endian和Little-Endian的定义如下：</p><p>　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><p>　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p><strong>网络字节序</strong>：<br>4个字节的32 bit值以下面的次序传输：<br>首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。<br>这种传输次序称作大端字节序。<br><strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong><br>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p><p>所以： 在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。<br>由于 这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再 赋给socket。</p></blockquote><h3 id="2-1-3-listen-、connect-函数"><a href="#2-1-3-listen-、connect-函数" class="headerlink" title="2.1.3 listen()、connect()函数"></a>2.1.3 listen()、connect()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。<br>客户端通过调用connect函数来建立与TCP服务器的连接。</p><h3 id="2-1-4-accept-函数"><a href="#2-1-4-accept-函数" class="headerlink" title="2.1.4 accept()函数"></a>2.1.4 accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。<br>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。<br>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。<br>之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><blockquote><p>注意：<br>accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。<br>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。<br>内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p></blockquote><h3 id="2-1-5-read-、write-等函数"><a href="#2-1-5-read-、write-等函数" class="headerlink" title="2.1.5 read()、write()等函数"></a>2.1.5 read()、write()等函数</h3><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。</p><p>可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。</p><p>它们的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">const</span> struct sockaddr *dest_addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">                 struct sockaddr *src_addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>read函数<br>负责从fd中读取内容<br>当读成功时，read返回实际所读的字节数</p><ul><li>返回的值是0表示已经读到文件的结束了</li><li>返回的值小于0表示出现了错误。<ul><li>如果错误为EINTR说明读是由中断引起的</li><li>如果是ECONNREST表示网络连接出了问题。</li></ul></li></ul></li><li><p>write函数<br>将buf中的nbytes字节内容写入文件描述符fd。</p><ul><li><p>成功时返回写的字节数</p></li><li><p>失败时返回-1，并设置errno变量</p></li><li><p>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</p><ul><li><p>1)write的返回值大于0，表示写了部分或者是 全部的数据。</p></li><li><p>2)返回的值小于0，此时出现了错误。</p></li></ul><p>我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。<br>如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。</p></li></ul></li></ul><p>其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。</p><h3 id="2-1-6-close-函数"><a href="#2-1-6-close-函数" class="headerlink" title="2.1.6 close()函数"></a>2.1.6 close()函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。<br>该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><blockquote><p>注意：<br>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p></blockquote><h2 id="2-2-socket中TCP的三次握手建立连接详解"><a href="#2-2-socket中TCP的三次握手建立连接详解" class="headerlink" title="2.2 socket中TCP的三次握手建立连接详解"></a>2.2 socket中TCP的三次握手建立连接详解</h2><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><p>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0NzYyODYucG5n" srcset="/img/loading.gif" alt="image"></p><p>图1、socket中发送的TCP三次握手</p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><blockquote><p>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</p></blockquote><h2 id="2-3-socket中TCP的四次握手释放连接详解"><a href="#2-3-socket中TCP的四次握手释放连接详解" class="headerlink" title="2.3 socket中TCP的四次握手释放连接详解"></a>2.3 socket中TCP的四次握手释放连接详解</h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0OTQ2OTMucG5n" srcset="/img/loading.gif" alt="image"></p><p>图2、socket中发送的TCP四次握手</p><p>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p>这样每个方向上都有一个FIN和ACK。</p><p>6.下面给出实现的一个实例</p><p>首先，先给出实现的截图</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718155008892.png" srcset="/img/loading.gif" alt="img"></p><p>服务器端代码如下：</p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET sListen = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>//用来指定套接字使用的地址格式，通常使用AF_INET</li><li>//指定套接字的类型，若是SOCK_DGRAM，则用的是udp不可靠传输</li><li>//配合type参数使用，指定使用的协议类型（当指定套接字类型后，可以设置为0，因为默认为UDP或TCP）</li><li>if(sListen == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 填充sockaddr_in结构 ,是个结构体</li><li>sockaddr_in sin;</li><li>sin.sin_family = AF_INET;</li><li>sin.sin_port = htons(4567); //1024 ~ 49151：普通用户注册的端口号</li><li>sin.sin_addr.S_un.S_addr = INADDR_ANY;</li><li>// 绑定这个套节字到一个本地地址</li><li>if(::bind(sListen, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed bind() \n”);</li><li>return 0;</li><li>}</li><li>// 进入监听模式</li><li>//2指的是，监听队列中允许保持的尚未处理的最大连接数</li><li>if(::listen(sListen, 2) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed listen() \n”);</li><li>return 0;</li><li>}</li><li>// 循环接受客户的连接请求</li><li>sockaddr_in remoteAddr;</li><li>int nAddrLen = sizeof(remoteAddr);</li><li>SOCKET sClient = 0;</li><li>char szText[] = “ TCP Server Demo! \r\n”;</li><li>while(sClient==0)</li><li>{</li><li>// 接受一个新连接</li><li>//（(SOCKADDR*)&amp;remoteAddr）一个指向sockaddr_in结构的指针，用于获取对方地址</li><li>sClient = ::accept(sListen, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrLen);</li><li>if(sClient == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed accept()”);</li><li>}</li><li>printf(“接受到一个连接：%s \r\n”, inet_ntoa(remoteAddr.sin_addr));</li><li>continue ;</li><li>}</li><li>while(TRUE)</li><li>{</li><li>// 向客户端发送数据</li><li>gets(szText) ;</li><li>::send(sClient, szText, strlen(szText), 0);</li><li>// 从客户端接收数据</li><li>char buff[256] ;</li><li>int nRecv = ::recv(sClient, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“ 接收到数据：%s\n”, buff);</li><li>}</li><li>}</li><li>// 关闭同客户端的连接</li><li>::closesocket(sClient);</li><li>// 关闭监听套节字</li><li>::closesocket(sListen);</li><li>return 0;</li><li>}</li></ol><p>客户端代码：</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET s = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>if(s == INVALID_SOCKET)</li><li>{</li><li>printf(“ Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 也可以在这里调用bind函数绑定一个本地地址</li><li>// 否则系统将会自动安排</li><li>// 填写远程地址信息</li><li>sockaddr_in servAddr;</li><li>servAddr.sin_family = AF_INET;</li><li>servAddr.sin_port = htons(4567);</li><li>// 注意，这里要填写服务器程序（TCPServer程序）所在机器的IP地址</li><li>// 如果你的计算机没有联网，直接使用127.0.0.1即可</li><li>servAddr.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1”);</li><li>if(::connect(s, (sockaddr*)&amp;servAddr, sizeof(servAddr)) == -1)</li><li>{</li><li>printf(“ Failed connect() \n”);</li><li>return 0;</li><li>}</li><li>char buff[256];</li><li>char szText[256] ;</li><li>while(TRUE)</li><li>{</li><li>//从服务器端接收数据</li><li>int nRecv = ::recv(s, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“接收到数据：%s\n”, buff);</li><li>}</li><li>// 向服务器端发送数据</li><li>gets(szText) ;</li><li>szText[255] = ‘\0’;</li><li>::send(s, szText, strlen(szText), 0) ;</li><li>}</li><li>// 关闭套节字</li><li>::closesocket(s);</li><li>return 0;</li><li>}</li></ol><p>封装的InitSock.h</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include</li><li>#include</li><li>#include</li><li>#include</li><li>#pragma comment(lib, “WS2_32”) // 链接到WS2_32.lib</li><li>class CInitSock</li><li>{</li><li>public:</li><li>CInitSock(BYTE minorVer = 2, BYTE majorVer = 2)</li><li>{</li><li>// 初始化WS2_32.dll</li><li>WSADATA wsaData;</li><li>WORD sockVersion = MAKEWORD(minorVer, majorVer);</li><li>if(::WSAStartup(sockVersion, &amp;wsaData) != 0)</li><li>{</li><li>exit(0);</li><li>}</li><li>}</li><li>~CInitSock()</li><li>{</li><li>::WSACleanup();</li><li>}</li><li>};</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-输入操作</title>
    <link href="/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>输入操作是游戏的基础操作之一。</p><p>Unity支持的操作方式：</p><ul><li>鼠标、键盘，小键盘(PC)</li><li>手柄(主机)</li><li>触屏操作、重力传感器、手势（移动平台）</li><li>VR，AR</li><li>麦克风，摄像头</li></ul><h1 id="2-虚拟输入轴-Virtual-axes"><a href="#2-虚拟输入轴-Virtual-axes" class="headerlink" title="2. 虚拟输入轴(Virtual axes)"></a>2. 虚拟输入轴(Virtual axes)</h1><p>虚拟控制轴将不同的输入设备(比如键盘或摇杆的按键)都归纳到一个统一的虚拟控制系统中。<br>(比如键盘的w、S键以及手柄摇杆的上下运动默认都统一映射到竖直(Verica)输入轴上)<br>这样就屏蔽了不同设备之间的差异，让开发者可以用一套非常简单的输入逻辑，同时兼容多种输入设备。</p><p>使用**输入管理器(Input Manager)**可以查看、修改或增删虚拟轴。</p><p>现代的游戏中往往允许玩家在游戏中自定义按键，所以使用Unity的输入管理器就更为重要要了。<br>通过一层虚拟轴间接操作，可以避免在代码中直接写死操作按钮，而且还能通过动态修改虚拟轴的设置来改变键位的功能。</p><p>关于虚拟输入轴，还有一些需要知道的内容：</p><ol><li><p>脚本可以直接通过虚拟轴的名称读取那个轴的输入状态。</p></li><li><p>创建Unity工程时，默认创建了以下虚拟轴:</p><ul><li><p>横向输入和纵向输入被映射在键盘的W、A、S、 D键以及方向键上</p></li><li><p>Fire1、 Fire2、 Fire3这三个按钮映射到了鼠标的左、中、右键以及键盘的Ctrl. AIt等键位上</p></li><li><p>鼠标移动可以模拟摇杆输入(和鼠标光标在屏幕上的位置无关)，且被映射在专门的鼠标偏移轴上</p></li><li><p>其他常用虚拟轴，例如跳跃(Jump) 、确认(Submit) 和取消(Cancel) </p><h2 id="2-1-添加和编辑虚拟输入轴"><a href="#2-1-添加和编辑虚拟输入轴" class="headerlink" title="2.1 添加和编辑虚拟输入轴"></a>2.1 添加和编辑虚拟输入轴</h2></li></ul></li></ol><p>要添加新的虚拟输入轴，只需要单击主菜单的Edit &gt; Projet Setings &gt; Input 选项，单击路街检视窗口中会显示一个输入管理器，在里面就可以修改或添加虚拟轴了。</p><blockquote><p>注意:<br>虚拟轴具有正、负两个方向。英文记作Positive和Negative.。<br>某些相反的动作可以只用一个轴来表示。<br>比如，如果摇杆向上为正，那么向下就是同一个轴的负方向。</p></blockquote><p>每个虚拟轴可以映射两个按键，第二个按键作为备用，功能一样，备用的英文为Alterative。</p><h2 id="2-2-虚拟输入轴属性表"><a href="#2-2-虚拟输入轴属性表" class="headerlink" title="2.2 虚拟输入轴属性表"></a>2.2 虚拟输入轴属性表</h2><p>下表是虚拟输入轴的属性表：</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>Name</td><td>轴的名字。在脚本中用这个名字来访问这个轴</td></tr><tr><td>Descriptive Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(正方向)</td></tr><tr><td>Descriptive Negative Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(负方向)</td></tr><tr><td>Ncgative Button</td><td>该轴的负方向，用于绑定某个按键</td></tr><tr><td>Positive Button</td><td>该轴的正方向，用于绑定某个按键</td></tr><tr><td>Alt Negative Button</td><td>该轴的负方向，用于绑定某个备用按键</td></tr><tr><td>Alt Positive Button</td><td>该轴的正方向，用于绑定某个备用按键</td></tr><tr><td>Gravity</td><td>轴回中的力度</td></tr><tr><td>Dead</td><td>轴的死区</td></tr><tr><td>Sensitivity</td><td>敏感度</td></tr><tr><td>Snap</td><td>保持式按键。比如按住下方向键，则一直保持下的状态，直到再次按上方向键</td></tr><tr><td>Invert</td><td>如果勾选，则交换正负方向</td></tr><tr><td>Type</td><td>控制该虚拟轴的类型， 比如手柄、键盘是两种不同的类型</td></tr><tr><td>Axis</td><td>很多手柄的输入不是按钮式的，这时就不能配置到Button里面，而是要配置到这里。可以理解为实际的操作轴</td></tr><tr><td>Joy Num</td><td>当有多个控制器时，要填写控制器的编号</td></tr></tbody></table><p>上表中的Gravity、Dead 等属性需要解释一下。</p><h3 id="2-2-1-Gravity"><a href="#2-2-1-Gravity" class="headerlink" title="2.2.1 Gravity"></a>2.2.1 Gravity</h3><p>现代游戏的方向输入和早期游戏的方向输入不太一样。<br>早期游戏中，上、中、下都是离散的状态，可以直接用1、0、-1来表示。<br>而现代游戏输入往往具有中间状态，比如0、0.35、 0.5、0.7、1, 是带有多级梯度的。<br>比如轻推摇杆代表走路，推到底就是跑步。<br>所以现代游戏的输入默认都是采用多梯度的模式。</p><p>虽然键盘没有多级输入的功能，但Unity依然会模拟这个功能，也就是说当你按住W键时，这个轴的值会以很快的速度逐渐从0增加到1。</p><p>所以，上表中Gravity和Sensitivity的含义就不难理解了，它们影响着虚拟轴从1到0、从0到1的速度以及敏感度。</p><blockquote><p>具体调试方法这里不再介绍，建议使用默认值</p></blockquote><h3 id="2-2-2-Dead"><a href="#2-2-2-Dead" class="headerlink" title="2.2.2 Dead"></a>2.2.2 Dead</h3><p>还有死区需要单独说明。</p><p>由于实体手柄、摇杆会有一些误差，比如，手柄放着不动时，某些手柄的输出值可能会在0.05 和0.08之间浮动。这个误差有必要在程序中排除。<br>所以Unity设计了死区的功能，在该值范围内的抖动被忽略为0,这样就可以过滤掉输入设备的误差。</p><h2 id="2-3-在脚本中处理输入"><a href="#2-3-在脚本中处理输入" class="headerlink" title="2.3 在脚本中处理输入"></a>2.3 在脚本中处理输入</h2><p>读取输入轴的方法很简单，代码如下:</p><p><code>float value = Input.GetAxis (&quot;Horizontal&quot;);</code></p><p>得到的值的范围为-1~1,默认位置为0。<br>这个读取虚拟轴的方法与具体控制器是键盘还是手柄无关。</p><blockquote><p>如果用鼠标控制虚拟轴，就有可能由于移动过快导致值超出-1~1的范围。</p></blockquote><blockquote><p>注意:<br>可以创建多个相同名字的虚拟轴。<br>Unity 可以同时管理多个同名的轴，最终结果以变化最大的轴为准。<br>这样做的原因是很多游戏可以同时用多种设备进行操作。<br>比如PC游戏可以用键盘、鼠标或手柄进行操作，手机游戏可以用重力感应器或手柄进行操作。<br>这种设计有助于用户在多种操作设备之间切换，且在脚本中不用去关心这一点。</p></blockquote><h2 id="2-4-按键名称"><a href="#2-4-按键名称" class="headerlink" title="2.4 按键名称"></a>2.4 按键名称</h2><p>要映射按键到轴上，需要在正方向输入框或者负方向输入框中输入正确的按键名称。<br>按键名称的规则和例子如下。</p><ul><li><p>常规按键: A、B、……</p></li><li><p>数字键: 1、2、……</p></li><li><p>方向键: Up、 Down、 Left、 Right…..</p></li><li><p>小键盘键: [1]、 [2]、 [3]、 [+]、 [equals]…..</p></li><li><p>修饰键: Right+Shift、 Lef+Shift、Right+Ctrl、Left+Ctrl、Right+Alt、Left+Alt、Right+Cmd、Left+Cmd….</p></li><li><p>鼠标按钮: mouse 0、mouse 1、mouse2 …..</p></li><li><p>手柄按钮(不指定具体的手柄序号) : joystick button 0、joystick button 1…..</p></li><li><p>手柄按钮(指定具体的手柄序号): joystick 1 button 0、joystick 1 button 1……</p></li><li><p>特殊键: Backspace、 Tab、 Retur、 Escape、 Space、 Delete、 Enter、 Insert、 Home、Page Up…..</p></li><li><p>功能键: FI、F2、…..</p><blockquote><p>可以使用<strong>KeyCode枚举类</strong>型来指定案件，与用字符串的效果一致</p></blockquote></li></ul><h1 id="3-在PC端输入"><a href="#3-在PC端输入" class="headerlink" title="3. 在PC端输入"></a>3. 在PC端输入</h1><p>unity为开发者提供了input库，来支持键盘事件，鼠标事件以及触摸事件。</p><h2 id="3-1-键盘事件"><a href="#3-1-键盘事件" class="headerlink" title="3.1 键盘事件"></a>3.1 键盘事件</h2><p>一般的PC键盘有104个不同的按键，在程序中通过监听这些按键事件，从而进一步执行逻辑操作。<br>如：射击游戏中，W表示前进，S表示后退，A表示左移，D表示右移。</p><h3 id="3-1-1-按下事件"><a href="#3-1-1-按下事件" class="headerlink" title="3.1.1 按下事件"></a>3.1.1 按下事件</h3><p>在脚本中，用<strong>input.GetKeyDown( )方法</strong>将按键值作为参数，监听此按键是否被按下。<br>按下返回true，否者返回false。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了W键&quot;</span>);  <br>            &#125;  <br><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了空格键&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-2-抬起事件"><a href="#3-1-2-抬起事件" class="headerlink" title="3.1.2 抬起事件"></a>3.1.2 抬起事件</h3><p>抬起事件完全依赖于按下事件，因为只有按下才有抬起。</p><p>我们用<strong>Input.GetKeyUp( )方法</strong>监听抬起事件<br>按键抬起后，返回true，否则返回false。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.W))  <br>           &#123;  <br>               Debug.Log(<span class="hljs-string">&quot;您抬起了W键&quot;</span>);  <br>           &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-3-长按事件"><a href="#3-1-3-长按事件" class="headerlink" title="3.1.3 长按事件"></a>3.1.3 长按事件</h3><p>长按事件是监听某一按键是否处于一直按下的状态<br>通过**Input.GetKey( )**来判断键盘中某一按键是否被一直按着。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKey (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//记录按下的帧数  </span><br>                keyFrame++;  <br>                Debug.Log(<span class="hljs-string">&quot;A连按:&quot;</span> + keyFrame+<span class="hljs-string">&quot;帧&quot;</span>);  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//抬起后清空帧数  </span><br>                keyFrame=<span class="hljs-number">0</span>;  <br>                Debug.Log(<span class="hljs-string">&quot;A按键抬起&quot;</span>);  <br>            &#125;     <br></code></pre></td></tr></table></figure><h3 id="3-1-4-任意键事件"><a href="#3-1-4-任意键事件" class="headerlink" title="3.1.4 任意键事件"></a>3.1.4 任意键事件</h3><p>在程序中还可以监听按键中的任意按键是否被按下</p><p>常见于加载完游戏后，按任意键进入。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span>(Input.anyKeyDown)  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;任意键被按下&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-4实例——组合按键"><a href="#3-1-4实例——组合按键" class="headerlink" title="3.1.4实例——组合按键"></a>3.1.4实例——组合按键</h3><p>在经典的格斗游戏中，会有组合键发出牛逼的大招，而这个功能的事件思路其实不难：<br>在玩家按下某一键后，便开始时间记数，在某一时间内按出所需要的键便发出大招。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs c#">    <span class="hljs-keyword">using</span> UnityEngine;  <br>    <span class="hljs-keyword">using</span> System.Collections.Generic;  <br>    <span class="hljs-keyword">using</span> System;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Script_07_05</span> : <span class="hljs-title">MonoBehaviour</span>   <br>    &#123;  <br>        <span class="hljs-comment">//方向键上的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageUp;  <br>        <span class="hljs-comment">//方向键下的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageDown;  <br>        <span class="hljs-comment">//方向键左的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageLeft;  <br>        <span class="hljs-comment">//方向键右的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageRight;  <br>        <span class="hljs-comment">//按键成功的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageSuccess; <br>        <br>        <span class="hljs-comment">//自定义方向键的储存值  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_UP = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_DOWN = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_LEFT = <span class="hljs-number">2</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_RIGHT = <span class="hljs-number">3</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_FIRT = <span class="hljs-number">4</span>;  <br>        <br>        <span class="hljs-comment">//连续按键的事件限制  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> FRAME_COUNT = <span class="hljs-number">100</span>;  <br><br>        <span class="hljs-comment">//仓库中储存技能的数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_SIZE = <span class="hljs-number">3</span>;  <br><br>        <span class="hljs-comment">//每组技能的按键数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_COUNT = <span class="hljs-number">5</span>;  <br><br>        <span class="hljs-comment">//技能仓库  </span><br>        <span class="hljs-built_in">int</span>[,] Sample =   <br>        &#123;  <br>            <span class="hljs-comment">//下 + 前 + 下 + 前 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_RIGHT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 前 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 后 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_LEFT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>        &#125;;  <br>        <span class="hljs-comment">//记录当前按下按键的键值  </span><br>        <span class="hljs-built_in">int</span>  currentkeyCode =<span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//标志是否开启监听按键  </span><br>        <span class="hljs-built_in">bool</span> startFrame = <span class="hljs-literal">false</span>;  <br>        <span class="hljs-comment">//记录当前开启监听到现在的时间  </span><br>        <span class="hljs-built_in">int</span>  currentFrame = <span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//保存一段时间内玩家输入的按键组合  </span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; playerSample;  <br>        <span class="hljs-comment">//标志完成操作  </span><br>        <span class="hljs-built_in">bool</span> isSuccess= <span class="hljs-literal">false</span>;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//初始话按键组合链表  </span><br>            playerSample  = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();  <br>        &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获得按键组合链表中储存按键的数量  </span><br>            <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>            <span class="hljs-comment">//遍历该按键组合链表  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; size; i++)  <br>            &#123;  <br>                <span class="hljs-comment">//将按下按键对应的图片显示在屏幕中  </span><br>                <span class="hljs-built_in">int</span> key = playerSample[i];  <br>                Texture temp = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">switch</span>(key)  <br>                &#123;  <br>                    <span class="hljs-keyword">case</span> KEY_UP:  <br>                        temp = imageUp;  <br>                        <span class="hljs-keyword">break</span>;  <br>                    <span class="hljs-keyword">case</span> KEY_DOWN:<br>                        temp = imageDown;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_LEFT:<br>                        temp = imageLeft;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_RIGHT:<br>                        temp = imageRight;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp != <span class="hljs-literal">null</span>)  <br>                &#123;<br>                    GUILayout.Label(temp);  <br>                &#125;  <br>            &#125;<br>            <span class="hljs-keyword">if</span>(isSuccess)<br>            &#123;<br>                <span class="hljs-comment">//显示成功贴图</span><br>                GUILayout.Label(imageSuccess);<br>            &#125;<br>            <span class="hljs-comment">//默认提示信息</span><br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键1：下、前、下、前、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、前、下、后、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、后、下、后、拳&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//更新按键</span><br>            UpdateKey();<br>            <span class="hljs-keyword">if</span>(Input.anyKeyDown)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(isSuccess)<br>                &#123;<br>                    <span class="hljs-comment">//按键成功后重置</span><br>                    isSuccess = <span class="hljs-literal">false</span>;<br>                    Reset();<br>                &#125;<br>                <span class="hljs-keyword">if</span>(!startFrame)<br>                &#123;<br>                    <span class="hljs-comment">//启动时间计数器</span><br>                    startFrame = <span class="hljs-literal">true</span>;<br>                &#125;  <br>                <span class="hljs-comment">//将按键值添加如链表中  </span><br>                playerSample.Add(currentkeyCode);  <br>                <span class="hljs-comment">//遍历链表  </span><br>                <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>                <span class="hljs-keyword">if</span>(size == SAMPLE_COUNT)  <br>                &#123;  <br>                    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; SAMPLE_SIZE; i++)  <br>                    &#123;  <br>                        <span class="hljs-built_in">int</span> SuccessCount = <span class="hljs-number">0</span>;  <br>                        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j&lt; SAMPLE_COUNT; j++)  <br>                        &#123;  <br>                            <span class="hljs-built_in">int</span> temp = playerSample[j];  <br>                            <span class="hljs-keyword">if</span>(temp== Sample[i,j])<br>                            &#123;  <br>                                SuccessCount++;  <br>                            &#125;  <br>                        &#125;  <br><span class="hljs-comment">//玩家按下的组合按键与仓库中的按键组合相同表示释放技能成功</span><br>                        <span class="hljs-keyword">if</span>(SuccessCount ==SAMPLE_COUNT)  <br>                        &#123;  <br>                            isSuccess = <span class="hljs-literal">true</span>;  <br>                            <span class="hljs-keyword">break</span>;  <br>                        &#125;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(startFrame)  <br>            &#123;  <br>                <span class="hljs-comment">//计数器++  </span><br>                currentFrame++;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(currentFrame &gt;= FRAME_COUNT)  <br>            &#123; <br>                <span class="hljs-comment">//计数器超时  </span><br>                <span class="hljs-keyword">if</span>(!isSuccess)  <br>                &#123;  <br>                    Reset();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>         <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span> (<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>         &#123;  <br>            <span class="hljs-comment">//重置按键相关信息  </span><br>            currentFrame = <span class="hljs-number">0</span>;  <br>            startFrame = <span class="hljs-literal">false</span>;  <br>            playerSample.Clear();  <br>         &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateKey</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获取当前键盘的按键信息  </span><br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                currentkeyCode = KEY_UP;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.S))  <br>            &#123;  <br>                currentkeyCode = KEY_DOWN;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.A))  <br>            &#123;  <br>                currentkeyCode = KEY_LEFT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.D))  <br>            &#123;  <br>                currentkeyCode = KEY_RIGHT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>               currentkeyCode = KEY_FIRT;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>按s,d,s,d,空格：<img src="./images/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/20160426162352358.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="3-2-鼠标事件"><a href="#3-2-鼠标事件" class="headerlink" title="3.2 鼠标事件"></a>3.2 鼠标事件</h2><p>和键盘事件一样，鼠标一般只有3个按键，左键、右键和中键。</p><p>具体如下：</p><h3 id="3-2-1-按下事件"><a href="#3-2-1-按下事件" class="headerlink" title="3.2.1 按下事件"></a>3.2.1 按下事件</h3><p><code>Input.GetMouseButtonDown()</code><br>来判断鼠标哪个按键被按下：</p><ul><li>返回值为0代表鼠标左键被按下</li><li>返回值为1代表鼠标右键被按下</li><li>返回值为2代表鼠标中键被按下</li></ul><h3 id="3-2-2-抬起事件"><a href="#3-2-2-抬起事件" class="headerlink" title="3.2.2 抬起事件"></a>3.2.2 抬起事件</h3><p><code>Input.GetMouseButtonUp()</code><br>方法监听鼠标按键的抬起事件</p><h3 id="3-2-3-长按事件"><a href="#3-2-3-长按事件" class="headerlink" title="3.2.3 长按事件"></a>3.2.3 长按事件</h3><p><code>Input.GetMouseButton()</code></p><p>监听鼠标某个按键是否一直处于按下状态</p><h1 id="4-在移动端输入"><a href="#4-在移动端输入" class="headerlink" title="4. 在移动端输入"></a>4. 在移动端输入</h1><p>对于移动设备来说，Ioput类还提供了触屏、加速度计以及访问地理位置的功能。<br>此外，移动设备上还经常会用到虚拟键盘，即在屏幕上操作的键盘，Uity中也有相应的访问方法。</p><p>本小节专门讨论移动设备特有的输入方式。</p><h2 id="4-1-多点触摸"><a href="#4-1-多点触摸" class="headerlink" title="4.1 多点触摸"></a>4.1 多点触摸</h2><p>iPhone、iPad、安卓等设备提供同时捕捉多个手指触摸操作的功能，通常可以处理最多5根手指同时触摸屏幕的情况。<br>通过访问Input.touches属性，可以以数组的方式处理多个手指当前的位置等信息。</p><p>安卓设备上多点触摸的规范相对灵活，不同的设备能捕捉的多点触摸操作的数量不尽相同。</p><ul><li><p>较老的设备可能只支持1到2个点同时触摸</p></li><li><p>新设备可能会支持5个点同时触摸</p></li></ul><p>每一个手指的触摸信息以Input.Touch结构体来表示。<br><strong>Input.Touch的属性列表：</strong></p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>fingerld</td><td>该触摸的序号</td></tr><tr><td>position</td><td>触摸在屏幕上的位置</td></tr><tr><td>dcllaPosition</td><td>当前触摸位置和前一个触摸位置的差距</td></tr><tr><td>doltaTime</td><td>最近两次改变触摸位置之间的操作时间的间隔</td></tr><tr><td>tapCount</td><td>IPhone/Ipad设备会记录用户短时间内单击屏幕的次数，它表示用户多次单击操作且没有将手拿开的次数。安卓设备没有这个功能，该值保持为1</td></tr><tr><td>phase</td><td>触摸的阶段。可以用它来判断是刚开始触摸、触摸时移动，还是手指刚刚离开屏幕</td></tr></tbody></table><p>phase的取值是个枚举，枚举值如下：</p><ul><li>Began<br>手指刚接触到屏幕</li><li>Moved<br>手指在屏幕上滑动</li><li>Stationary<br>手指接触到屏幕但还未滑动</li><li>Ended<br>手指离开了屏幕。<br>这个状态代表着一次触摸操作的结束</li><li>Cancceled<br>系统取滑了这次触屏操作。<br>例如当用户拿起手机进行通话，或者触损点多于9个的时候，这次触摸操作就会被取消。<br>这个状态也代表这次触摸操作结束</li></ul><h2 id="4-2-模拟鼠标操作"><a href="#4-2-模拟鼠标操作" class="headerlink" title="4.2 模拟鼠标操作"></a>4.2 模拟鼠标操作</h2><p>绝大部分移动设备可以用触屏模拟鼠标操作。<br>比如使用Input.mousePosition属性不仅可以获得鼠标光标的位置，也可以获得移动设备上触摸的位置。<br>这个功能的原理不难理解，毕竟触屏可以支持多点触摸，而鼠标则是单点操作，这个功能属于向下兼容。</p><p>在移动平台的游戏的开发阶段可以暂时用鼠标操作代替触屏操作，但是稍后应当修改为触屏专用的方式，因为操作手感和功能会有很大区别。</p><h2 id="4-3-加速度计"><a href="#4-3-加速度计" class="headerlink" title="4.3 加速度计"></a>4.3 加速度计</h2><p>当移动设备移动时，内置的加速度计会持续报告当前加速度的值，这个值是一个三维向量，因为物体的运动是任意方向的。<br>这个数值和重力加速度的表示方法类似：</p><ul><li><p>在某个轴方向上，1.0代表该轴具有+1.0g的加速度</p></li><li><p>而负值则代表该轴具有相反方向的加速度。</p></li></ul><p>正常竖直持手机(Home键在下方)时：</p><ul><li><p>X轴的正方向朝右</p></li><li><p>Y轴的正方向朝上</p></li><li><p>Z轴的正方向从手机指向用户</p></li></ul><p>通过Input.aceleation属性可以直接访问加速度计当前的数值。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>输入操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>观察者模式是一种对象行为模式。<br>在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。</p><p>它定义对象间的一种一对多的依赖关系：<br>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>主体是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅并接收通知。</p><p>观察者模式（Observer）完美的将观察者和被观察的对象分离开。<br>观察者模式被广泛应用于软件界面元素之间的交互，在业务对象之间的交互、权限管理等方面。</p><blockquote><p>此种模式通常被用来实现事件处理系统</p></blockquote><p>别名：</p><ul><li>发布-订阅(Publish/Subscribe)模式</li><li>模型-视图(Model/View)模式</li><li>源-监听器(Source/Listener)模式</li><li>从属者(Dependents)模式</li></ul><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>交互对象之间尽量采用低耦合设计</li><li>封装代码中经常变化的数据</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/3985563-8f775c097136a39d.png" srcset="/img/loading.gif" alt="img"></p><p>观察者模式所涉及的角色有：</p><ul><li><p><strong>抽象主题(Subject)角色：</strong><br>抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。<br>抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p></li><li><p><strong>具体主题(ConcreteSubject)角色：</strong><br>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。<br>具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p></li><li><p><strong>抽象观察者(Observer)角色：</strong><br>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p></li><li><p><strong>具体观察者(ConcreteObserver)角色：</strong><br>存储与主题的状态自恰的状态。<br>具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。<br>如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p></li></ul><h1 id="4-推模型与拉模型"><a href="#4-推模型与拉模型" class="headerlink" title="4. 推模型与拉模型"></a>4. 推模型与拉模型</h1><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><h2 id="4-1-推模型"><a href="#4-1-推模型" class="headerlink" title="4.1 推模型"></a>4.1 推模型</h2><p>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><h2 id="4-2-拉模型"><a href="#4-2-拉模型" class="headerlink" title="4.2 拉模型"></a>4.2 拉模型</h2><p>主题对象在通知观察者的时候，只传递少量信息。<br>如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。</p><p>一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><h2 id="4-3-二者比较"><a href="#4-3-二者比较" class="headerlink" title="4.3 二者比较"></a>4.3 二者比较</h2><ul><li><ul><li><p>推模型是假定主题对象知道观察者需要的数据</p></li><li><p>拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值</p></li></ul></li><li><ul><li><p>推模型可能会使得观察者对象难以复用<br>因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况<br>这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者</p></li><li><p>拉模型就不会造成这样的情况<br>因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p></li></ul></li></ul><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将设计一个气象监测应用，它要求具备以下几个功能：</p><ul><li><p>可以从气象站更新：温度，湿度，气压三项数据</p></li><li><p>可以给用户用多种视图展示数据：<br>初始三种视图：目前状况，天气统计，天气预报<br>可以随时增加新的视图</p></li><li><p>用户视图更新有两种方式：</p><ul><li><p>系统按事件自动更新数据同时更新视图</p></li><li><p>用户主动请求更新数据与视图</p></li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%A4%A9%E6%B0%94%E7%9B%91%E6%B5%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="天气监测应用设计类图"></p></li></ul><p>从上图可以分析出各个类在观察者模式中他们的角色：</p><ul><li><p>抽象主题(Subject)角色：Subject</p></li><li><p>具体主题(ConcreteSubject)角色：WeatherData</p></li><li><p>抽象观察者(Observer)角色：Observer</p></li><li><p>具体观察者(ConcreteObserver)角色：StatisticsDisplay;ThirdPartDisplay;ForecastDisplay;</p></li></ul><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><h3 id="5-3-1-抽象主题编写"><a href="#5-3-1-抽象主题编写" class="headerlink" title="5.3.1 抽象主题编写"></a>5.3.1 抽象主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//添加观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//移除观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//广播</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-抽象观察者编写"><a href="#5-3-2-抽象观察者编写" class="headerlink" title="5.3.2 抽象观察者编写"></a>5.3.2 抽象观察者编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span>;<span class="hljs-comment">//广播更新的数据(推模型)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//观察者申请数据更新(拉模型)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-具体主题编写"><a href="#5-3-3-具体主题编写" class="headerlink" title="5.3.3 具体主题编写"></a>5.3.3 具体主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherData</span>:<span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Data<br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> temperature;<span class="hljs-comment">//温度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> humidity;<span class="hljs-comment">//湿度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> pressure;<span class="hljs-comment">//气压</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> Data data;<br>    List&lt;Observer&gt; listeners;<span class="hljs-comment">//订阅的观察者名单</span><br>    <span class="hljs-keyword">public</span> Data Datas &#123; <span class="hljs-keyword">get</span> =&gt; data;&#125;<span class="hljs-comment">//用于实现拉模式的get属性</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherData</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123; <br>        listeners = <span class="hljs-keyword">new</span> List&lt;Observer&gt;();<br>        measurementsChanged();<br>        data = <span class="hljs-keyword">new</span> Data();<br>    &#125;<br>    <span class="hljs-comment">//对Subject接口的实现</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Add(a);<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Remove(a);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Observer i <span class="hljs-keyword">in</span> listeners)<br>        &#123;<br>            i.update(data);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//更新天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        getRandomDate();<br>        notifyObserver();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getRandomDate</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//随机产生天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        data.humidity = random.NextDouble();<br>      data.temperature=random.Next(<span class="hljs-number">-40</span>,<span class="hljs-number">40</span>)+random.NextDouble();<br>        data.pressure = random.Next(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)+random.NextDouble();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-4-具体观察者编写"><a href="#5-3-4-具体观察者编写" class="headerlink" title="5.3.4 具体观察者编写"></a>5.3.4 具体观察者编写</h3><p>显示模式的接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">DisplayElement</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>三种显示模式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentConditionsDisplay</span>:<span class="hljs-title">Observer</span>,<span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示当前观测值</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    <span class="hljs-keyword">private</span> Data d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CurrentConditionsDisplay</span>(<span class="hljs-params">Subject x</span>) </span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = x; <br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;---当前天气---&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;当前温度:&quot;</span> + d.temperature.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前气压:&quot;</span> <br>        + d.pressure.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前湿度:&quot;</span>+d.humidity.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StatisticsDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示统计最大最小平均值</span><br>&#123;<br>    Subject weatherData;<br>    <span class="hljs-keyword">private</span> Queue&lt;Data&gt; dates;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StatisticsDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>        dates = <span class="hljs-keyword">new</span> Queue&lt;Data&gt;();<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span>(dates.Count== <span class="hljs-number">3</span>)dates.Dequeue();<br>        dates.Enqueue(x);<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>=&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Double[] average = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">foreach</span> (Data i <span class="hljs-keyword">in</span> dates)<br>        &#123;<br>            average[<span class="hljs-number">0</span>] += i.temperature;<br>            average[<span class="hljs-number">1</span>] += i.pressure;<br>            average[<span class="hljs-number">2</span>] += i.humidity;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;***天气统计***&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;最高温度:&quot;</span> + dates.Max(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低温度:&quot;</span> + dates.Min(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均温度:&quot;</span> +<br>        (average[<span class="hljs-number">0</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高气压:&quot;</span> + dates.Max(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <br>        <span class="hljs-string">&quot;\t最低气压:&quot;</span> + dates.Min(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均气压:&quot;</span> +<br>        (average[<span class="hljs-number">1</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高湿度:&quot;</span> + dates.Max(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低湿度:&quot;</span> + dates.Min(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均湿度:&quot;</span> +<br>        (average[<span class="hljs-number">2</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ForecastDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示天气预报</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    Data d;<br>    String weather;<br>    <span class="hljs-built_in">double</span> t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForecastDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data data</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = data;<br>        <span class="hljs-keyword">if</span> (d.humidity &gt; <span class="hljs-number">0.5</span> &amp;&amp; d.pressure &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(d.temperature&lt;<span class="hljs-number">1</span>) weather = <span class="hljs-string">&quot;雪&quot;</span>;<br>                <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;雨&quot;</span>;<br>            &#125;<br>        <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;晴&quot;</span>;<br>        t = d.temperature;<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;===天气预报===&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;今日天气:&quot;</span> + weather + <span class="hljs-string">&quot;\t 温度:&quot;</span> + t.ToString(<span class="hljs-string">&quot;F2&quot;</span>)+<span class="hljs-string">&quot;\n&quot;</span>); ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-5-测试"><a href="#5-3-5-测试" class="headerlink" title="5.3.5 测试"></a>5.3.5 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    WeatherData weatherData = <span class="hljs-keyword">new</span> WeatherData();<br>    CurrentConditionsDisplay s1 = <span class="hljs-keyword">new</span> CurrentConditionsDisplay(weatherData);<br>    StatisticsDisplay s2 = <span class="hljs-keyword">new</span> StatisticsDisplay(weatherData);<br>    ForecastDisplay s3 = <span class="hljs-keyword">new</span> ForecastDisplay(weatherData);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>    &#123;<br>        weatherData.measurementsChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210325114238949.png" srcset="/img/loading.gif" alt="测试结果"></p><h1 id="6-java中的观察者模式类"><a href="#6-java中的观察者模式类" class="headerlink" title="6. java中的观察者模式类"></a>6. java中的观察者模式类</h1><blockquote><p>略 <a href="https://www.jianshu.com/p/fc4554cda68d">https://www.jianshu.com/p/fc4554cda68d</a></p></blockquote><h1 id="8-C-中实现观察者模式的方法"><a href="#8-C-中实现观察者模式的方法" class="headerlink" title="8. C#中实现观察者模式的方法"></a>8. C#中实现观察者模式的方法</h1><p>整理自：<a href="https://www.jb51.net/article/63077.htm">https://www.jb51.net/article/63077.htm</a></p><h2 id="8-1-利用事件"><a href="#8-1-利用事件" class="headerlink" title="8.1 利用事件"></a>8.1 利用事件</h2><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a></p></blockquote><p>我们将上面讲的天气数据监测应用改成用C#事件实现的观察者模式</p><ol><li><p>在WeatherData类中声明委托与事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WeatherdateUpdate</span>(<span class="hljs-params">Data data</span>)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> WeatherdateUpdate updata;<br></code></pre></td></tr></table></figure></li><li><p>在WeatherData类中编写事件触发函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyByEvent</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span>(updata!=<span class="hljs-literal">null</span>)<br>            &#123;<br>                updata(data);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>在三个具体观察者中编写事件处理函数并在构造函数中订阅到事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//写在构造函数里</span><br>WeatherData.updata += update;<span class="hljs-comment">//事件订阅</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)<span class="hljs-comment">//事件处理</span></span><br><span class="hljs-function"></span>        &#123;<br>            d = x; <br>            display();<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>触发事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            getRandomDate();<br>            <span class="hljs-comment">//notifyObserver();</span><br>            notifyByEvent();<br>        &#125;<br></code></pre></td></tr></table></figure><p>运行输出结果与用接口实现的效果完全相同。</p></li></ol><h2 id="8-2-利用IObservable和IObserver实现"><a href="#8-2-利用IObservable和IObserver实现" class="headerlink" title="8.2 利用IObservable和IObserver实现"></a>8.2 利用IObservable<out T>和IObserver<in T>实现</h2><p>与java中类似，略</p><h2 id="8-3-利用Action函数式"><a href="#8-3-利用Action函数式" class="headerlink" title="8.3 利用Action函数式"></a>8.3 利用Action函数式</h2><p>略</p><h1 id="7-优缺点"><a href="#7-优缺点" class="headerlink" title="7. 优缺点"></a>7. 优缺点</h1><h2 id="7-1-优点"><a href="#7-1-优点" class="headerlink" title="7.1 优点"></a>7.1 优点</h2><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</li><li>目标与观察者之间建立了一套触发机制。</li></ul><h2 id="7-2-缺点"><a href="#7-2-缺点" class="headerlink" title="7.2 缺点"></a>7.2 缺点</h2><ul><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>观察者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>策略模式属于对象的行为模式。<br>其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。<br>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><ul><li><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>找出项目中不稳定的代码（可能需要改动的地方），把它们独立出来，不要把它们和其它稳定的代码混在一起</li><li>针对接口编程而不是针对实现编程</li><li>多用组合少用继承</li></ul></li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p>策略模式是对算法的包装，是把调用算法的责任（行为）和算法本身（行为实现）分割开来，委派给不同的对象管理。</p><p>策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。下面就以一个示意性的实现讲解策略模式实例的结构。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-b97fa59581b3c88c.png" srcset="/img/loading.gif" alt="img"></p><p>这个模式涉及到三个角色：</p><ul><li>环境(Context)角色：<br>持有一个Strategy的引用，即具有复杂多变行为的对象。</li><li>抽象策略(Strategy)角色：<br>这是一个抽象角色，通常由一个接口或抽象类实现。<br>此角色给出所有的具体策略类所需的接口。</li><li>具体策略(ConcreteStrategy)角色：<br>包装了相关的算法或行为。</li></ul><h1 id="4-模式案例"><a href="#4-模式案例" class="headerlink" title="4. 模式案例"></a>4. 模式案例</h1><h2 id="4-1-案例描述"><a href="#4-1-案例描述" class="headerlink" title="4.1 案例描述"></a>4.1 案例描述</h2><p>你将设计一个ARPG文字冒险小游戏，你需要设计以下内容：</p><ul><li>四个角色：<br>女王Queen；国王King；骑士Knight；巨魔Troll；</li><li>四种武器：<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；</li></ul><p>每个角色一次只能使用一种武器，但是在游戏的过程中可以切换武器。</p><p>让他们相互攻击，直到有人胜出。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/423180E36C6DA4925016AA187CA09C05-1616508222683.jpg" srcset="/img/loading.gif" alt="423180E36C6DA4925016AA187CA09C05"></p><p>由上图可以看出类的结构为<br>女王Queen；国王King；骑士Knight；巨魔Troll；继承于Character。<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；实现了WeaponBehavior接口。</p><p>由此可以分析出在策略模式中他们的角色：</p><ul><li>环境(Context)角色：Character</li><li>抽象策略(Strategy)角色：WeaponBehavior</li><li>具体策略(ConcreteStrategy)角色：<br>KnifeBehavior，BowAndArrowBehavior，AxeBehavior，SwordBehavior</li></ul><h2 id="4-3-代码编写"><a href="#4-3-代码编写" class="headerlink" title="4.3 代码编写"></a>4.3 代码编写</h2><h3 id="4-3-1-环境角色编写"><a href="#4-3-1-环境角色编写" class="headerlink" title="4.3.1 环境角色编写"></a>4.3.1 环境角色编写</h3><p>编写所有角色的基类Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> hp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> energy;<br>    WeaponBehavior weapon;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span> =&gt; name; <span class="hljs-keyword">set</span> =&gt; name = <span class="hljs-keyword">value</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Hp &#123; <span class="hljs-keyword">get</span> =&gt; hp; <span class="hljs-keyword">set</span> =&gt; hp = <span class="hljs-keyword">value</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Energy &#123; <span class="hljs-keyword">get</span> =&gt; energy; <span class="hljs-keyword">set</span> =&gt; energy = <span class="hljs-keyword">value</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name,<span class="hljs-built_in">int</span> hp,<span class="hljs-built_in">int</span> energy</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.hp = hp;<br>        <span class="hljs-keyword">this</span>.energy = energy;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeapon</span>(<span class="hljs-params">WeaponBehavior weapon</span>)<span class="hljs-comment">//设置武器</span></span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.weapon = weapon;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">fight</span>(<span class="hljs-params">Character A</span>)<span class="hljs-comment">//攻击！</span></span><br><span class="hljs-function"></span>    &#123;<br>        weapon.useWeapon(<span class="hljs-keyword">this</span>,A);<br>        <span class="hljs-keyword">if</span> (A.Hp &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            Console.WriteLine(A.Name + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;杀死了&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showState</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//显示状态</span></span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(Name+<span class="hljs-string">&quot;:血量 &quot;</span>+ hp+<span class="hljs-string">&quot;精力 &quot;</span>+energy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写四种角色类继承Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Queen</span>:<span class="hljs-title">Character</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Queen</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">10</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> KnifeBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">King</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">King</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">5</span>, <span class="hljs-number">20</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Knight</span> : <span class="hljs-title">Character</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Knight</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">20</span>, <span class="hljs-number">10</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Troll</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Troll</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">15</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> AexBehavior());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-抽象策略角色编写"><a href="#4-3-2-抽象策略角色编写" class="headerlink" title="4.3.2 抽象策略角色编写"></a>4.3.2 抽象策略角色编写</h3><p>编写武器行为接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A,Character B</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-具体策略角色编写"><a href="#4-3-3-具体策略角色编写" class="headerlink" title="4.3.3 具体策略角色编写"></a>4.3.3 具体策略角色编写</h3><p>编写具体的武器行为，实现接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">KnifeBehavior</span>:<span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name+<span class="hljs-string">&quot;对&quot;</span>+B.Name+<span class="hljs-string">&quot;使用了 匕首 刺杀&quot;</span>);<br>        B.Hp--;<br>        A.Energy --;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BowandArrowBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;射了一箭&quot;</span>);<br>        B.Hp--;<br>        A.Energy--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AexBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 斧头 劈砍&quot;</span>);<br>        B.Hp-=<span class="hljs-number">3</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy-=<span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SwordBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 直剑 挥击&quot;</span>);<br>        B.Hp -= <span class="hljs-number">5</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy -= <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-测试"><a href="#4-3-4-测试" class="headerlink" title="4.3.4 测试"></a>4.3.4 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();<br>    List&lt;Character&gt; c = <span class="hljs-keyword">new</span> List&lt;Character&gt;(<span class="hljs-number">4</span>);<span class="hljs-comment">//将各种角色类都装箱成Character</span><br>    c.Add(<span class="hljs-keyword">new</span> King(<span class="hljs-string">&quot;大清皇帝&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Troll(<span class="hljs-string">&quot;林登万&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Knight(<span class="hljs-string">&quot;堂吉诃德&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Queen(<span class="hljs-string">&quot;玛丽&quot;</span>));<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (c.Count != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">int</span> a, b;<br>        a = random.Next(<span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">//随机选取两人PK，直到剩下最后一位角色活着</span><br>        <span class="hljs-keyword">while</span> ((b = random.Next(<span class="hljs-number">0</span>, i)) == a)<br>        &#123;<br>            b = random.Next(<span class="hljs-number">0</span>, i);<br>        &#125;<br>        c[a].showState();<br>        c[b].showState();<br>        <span class="hljs-keyword">if</span> (c[a].fight(c[b]))<br>        &#123;<br>            c.RemoveAt(b);<br>            i--;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//每回合恢复体力</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;c.Count;j++)<br>        &#123;<br>            c[j].Energy++;<br>        &#125;<br>    &#125;<br>    Console.WriteLine(<span class="hljs-string">&quot;胜者是:&quot;</span> + c[<span class="hljs-number">0</span>].Name + <span class="hljs-string">&quot;!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这次中世纪文字吃鸡的结果是：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95.png" srcset="/img/loading.gif" alt="策略模式测试"></p><h1 id="5-对策略模式的深入认识"><a href="#5-对策略模式的深入认识" class="headerlink" title="5.对策略模式的深入认识"></a>5.对策略模式的深入认识</h1><h2 id="5-1-策略模式对多态的使用"><a href="#5-1-策略模式对多态的使用" class="headerlink" title="5.1 策略模式对多态的使用"></a>5.1 策略模式对多态的使用</h2><p> 　通过让环境类持有一个抽象策略类（超类）的引用，在生成环境类实例对象时，让该引用指向具体的策略子类。再对应的方法调用中，就会通过Java的多态，调用对应策略子类的方法。从而可以相互替换，不需要修改环境类内部的实现。同时，在有新的需求的情况下，也只需要修改策略类即可，降低与环境类之间的耦合度。</p><h2 id="5-2-策略模式的重心"><a href="#5-2-策略模式的重心" class="headerlink" title="5.2 策略模式的重心"></a>5.2 策略模式的重心</h2><p>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p><h2 id="5-3算法的平等性"><a href="#5-3算法的平等性" class="headerlink" title="5.3算法的平等性"></a>5.3算法的平等性</h2><p>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p><p>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。</p><h2 id="5-4-运行时策略的唯一性"><a href="#5-4-运行时策略的唯一性" class="headerlink" title="5.4 运行时策略的唯一性"></a>5.4 运行时策略的唯一性</h2><p>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p><h2 id="5-5-公有的行为"><a href="#5-5-公有的行为" class="headerlink" title="5.5 公有的行为"></a>5.5 公有的行为</h2><p>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p><p>这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-398483227b01f042.png" srcset="/img/loading.gif" alt="img"></p><h1 id="6-策略模式的优缺点"><a href="#6-策略模式的优缺点" class="headerlink" title="6. 策略模式的优缺点"></a>6. 策略模式的优缺点</h1><h2 id="6-1-相较于纯继承的优点"><a href="#6-1-相较于纯继承的优点" class="headerlink" title="6.1 相较于纯继承的优点"></a>6.1 相较于纯继承的优点</h2><ul><li><p>代码复用度高，子类中几乎没有重复</p></li><li><p>很容易知道该类的全部策略（算法）</p></li><li><p>在运行时可以更容易的更改策略</p></li><li><p>改动时不会牵一发而动全身，代码耦合度低</p></li></ul><h2 id="6-2-策略模式的优点"><a href="#6-2-策略模式的优点" class="headerlink" title="6.2 策略模式的优点"></a>6.2 策略模式的优点</h2><ul><li>策略模式提供了管理相关的算法族的办法。<br>策略类的等级结构定义了一个算法或行为族。<br>恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。<br>多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li></ul><h2 id="6-3策略模式的缺点"><a href="#6-3策略模式的缺点" class="headerlink" title="6.3策略模式的缺点"></a>6.3策略模式的缺点</h2><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<br>这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p></li><li><p>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p></li></ul><p>总结自：</p><ul><li>《设计模式HeadFirst》</li><li><a href="https://www.jianshu.com/p/7fa8ad000a97">https://www.jianshu.com/p/7fa8ad000a97</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的标签 层级 静态物体 预制体</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-标签"><a href="#1-标签" class="headerlink" title="1. 标签"></a>1. 标签</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>标签(Tag)是一个可以标记在游戏物体上的记号，它一般是一个简单的单词。<br>比如：你可以为游戏人物添加一个Player标签，并为敌人角色添加一个Encemy 标签，还可以为地图上的道具添加一个Collectable标签。</p><p>在脚本中查找和指定物体时，使用标签是一种非常好的方法。<br>这种方法可以避免总是采用某个公开变量的方式来指定游戏物体，那样还需要通过拖曳的操作才能给变量赋初值。通过标签来查找物体可以简化编辑工作。</p><p>标签还特别适合用在处理碰撞的时候，当游戏人物与其他物体发生碰撞时，你可以通过判断碰到的物体是敌人、道具还是其他东西，来进行下一步处理。</p><h2 id="1-2-Unity预制标签"><a href="#1-2-Unity预制标签" class="headerlink" title="1.2. Unity预制标签"></a>1.2. Unity预制标签</h2><p>Uniy预置了一些常用的标签， 在标签管理器中你不能修改下面这些预置的标签：</p><table><thead><tr><th>标签名</th><th>含义</th></tr></thead><tbody><tr><td>Untagged</td><td>没有标签</td></tr><tr><td>Respawn</td><td>出生</td></tr><tr><td>Finish</td><td>完成</td></tr><tr><td>EditorOnly</td><td>编辑器专用</td></tr><tr><td>MainCamera</td><td>主摄像机</td></tr><tr><td>Player</td><td>玩家</td></tr><tr><td>GameController</td><td>游戏控制器</td></tr></tbody></table><h2 id="1-3-创建新标签"><a href="#1-3-创建新标签" class="headerlink" title="1.3. 创建新标签"></a>1.3. 创建新标签</h2><p>要创建一个新的标签，需要在标签下拉菜单中选择Add Tag,之后检视窗口会切换到标签与层级管理器(Tag and Layer Manager)。</p><blockquote><p>注意:标签一旦创建就不可以再被修改，只能删除并重新创建。</p></blockquote><h2 id="1-4-为物体设置标签"><a href="#1-4-为物体设置标签" class="headerlink" title="1.4. 为物体设置标签"></a>1.4. 为物体设置标签</h2><p>检视窗口的上方显示了标签(Tg)和层级(Layer) 的下拉菜单。</p><p>在标装的下技菜单中单击任意.个标签名称，就可以为物体指定该标签了</p><h2 id="1-5-使用标签查找游戏物体"><a href="#1-5-使用标签查找游戏物体" class="headerlink" title="1.5. 使用标签查找游戏物体"></a>1.5. 使用标签查找游戏物体</h2><blockquote><p>略，详见<a href="https://mycroftcooper.github.io/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/">在脚本中访问其他物体2.3</a></p></blockquote><h2 id="1-6-小提示"><a href="#1-6-小提示" class="headerlink" title="1.6. 小提示"></a>1.6. 小提示</h2><ul><li>一个游戏物体只能被指定一个标签</li><li>可以用任意一个单词作为标签的名称<br>甚至可以用一个很长的词组作为名称<br>但是那样非会不太方便，比如在界面中看不到完整的名字</li></ul><h1 id="2-层级"><a href="#2-层级" class="headerlink" title="2. 层级"></a>2. 层级</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>层级最有用、最常用的地方有：</p><ul><li>用来让摄像机仅渲染场景中的一部分物体</li><li>还可以让灯光只照亮一部分物体。</li><li>用来在进行碰撞检测、射线检测时，从而只让某些物体发生碰撞，让另一些物体不发生碰撞。</li></ul><h2 id="2-2-新建层级"><a href="#2-2-新建层级" class="headerlink" title="2.2 新建层级"></a>2.2 新建层级</h2><p>单击主菜单的Edit &gt; Project Settings &gt; Tagsand Layers选项，会在检视窗口中打开层级和标签窗口。<br>这步操作和之前介绍标签时的操作完全一样， 不同的是，在学习标签时我们展开了标签菜单，这里我们要展开层级菜单。<br>将新的层级User Layer8命名为Player,就建立了一个新的Player层级，序号为8.</p><h2 id="2-3-只渲染场景的一部分"><a href="#2-3-只渲染场景的一部分" class="headerlink" title="2.3 只渲染场景的一部分"></a>2.3 只渲染场景的一部分</h2><p>层级配合摄像机的剔除遮眾Culling Mas)使用，就可以有选择性地显示某些层级的物体，而不渲染另一些层级的物体。</p><p>要做到这一点， 只需要在摄像机中选中需要渲染的层级即可。<br>单击摄像机的剔除遮罩下拉菜单，打钩的层就是要显示的层。</p><blockquote><p>注意: Unity 中有很多类似这样的下拉菜单，菜单的最上面两项是特殊的：<br>单击Noting时，所有选项都会被取消勾选，表示全部不选<br>单击Everyhing 时，则所有选项都会被勾选。<br>使用这两个快捷选项有助于快速选中必要的层。<br>比如说，要仅选中Ul层和Player层，就可以先选择Nothing,然后再单独勾选UI层和Player层即可.</p></blockquote><blockquote><p>UI系统如果采用屏幕空间画布，则不会受摄像机别除遮罩的影响。</p></blockquote><h2 id="2-5-选择性的射线检测"><a href="#2-5-选择性的射线检测" class="headerlink" title="2.5 选择性的射线检测"></a>2.5 选择性的射线检测</h2><p>使用层级可以让射线检测忽略某些碰撞体，这种效果也是用“层级”和“遮罩”这两个概念来设置的。</p><p>例如，有时需要发射条射线， 仅和Player 层的物体发生碰撞， 而忽略其他层的物体。<br>Physics.Racast方法用来发射一条射线， 它可以带有一个叫作layerMask 的参数，layerMask是一个利用位标记作为遮罩的参数。</p><blockquote><p>用位(bit)作为标记是二进制相关的一种方法<br>原理是int型的变量由32个位组成，每个位的值只能是0或1<br>因此可以根据某个位是0还是1来选中或者忽略某一层</p></blockquote><ul><li>如果layerMask所有的位都是1,那么就会和所有的层发生碰撞。</li><li>如果layerMask等于0，那么它就不会和任何层、任何物体发生碰撞。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//将1左移8位</span><br><span class="hljs-built_in">int</span> layerMask =<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br><span class="hljs-comment">//将layerMask设置为只有从右数第8位是1,其他位是0，则只会和Layer 8 Player层发生碰撞</span><br><span class="hljs-keyword">if</span> (Physics .Raycast (transform.position, Vector3. forward, Mathf. Infinity, layerMask))<br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;The ray hit the player&quot;</span>) ;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是玩家的游戏人物射击发出的检测射线，就恰恰相反，需要和除玩家的游戏人物以外的所有物体发生碰撞，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//将1左移8位</span><br>    <span class="hljs-built_in">int</span> layerMask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">//按位取反，所有值为0的位变为1,值为1的位变为0</span><br>    layerMask = ~ layerMask;<br>    RaycastHit hit;<br>    <span class="hljs-comment">//发射射线，Debug. DrawRay用于画出辅助框线</span><br>    <span class="hljs-keyword">if</span> (Physics.Raycast(transform.position,traform.TransformDirection(Vector3.forward),<br>                        <span class="hljs-keyword">out</span> hit, Mathf.Infinity,layerMask))<br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<br>                      hit.distance,Color.yellow);<br>        Debug. Log(<span class="hljs-string">&quot;Did Hit&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<span class="hljs-number">1000</span><br>                      Color.white) ;<br>        Debug.Log(<span class="hljs-string">&quot;Did not Hit&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在调用Raycast方法时省略layerMask参数，则默认除了Ignore Raycast这层不会被碰撞，其他层都可能发生碰撞。</p><p>使用lgnore Raycast层可以专门指定某些物体不受射线检测碰撞。</p><blockquote><p>序号为31的最后一层是特别的，编辑器把它作为预览使用，开发者不要使用这一层，会造成冲突</p></blockquote><h1 id="3-静态物体"><a href="#3-静态物体" class="headerlink" title="3. 静态物体"></a>3. 静态物体</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>如果引擎事先知道了某一个物体在游戏进行中是否会移动，那么就可以针对性地应用一系列优化策略。</p><p>如果一个物体是静态的，即不会移动的，那么引擎就可以假定它不会受到任何其他物体或者事件的影响，从而预先计算好物体的信息。<br>比如说，渲染器可以将场景中许多静态物体台并为一个整体，这样就可以通过一次渲染就将它们全部处理完毕，这种做法也被称为批量渲染。</p><p>在检视窗口中，每个游戏物体名称的右侧都有一一个静态(Static) 复选框以及一个菜单，它用来指定物体是否是静态的，且可以进一步指定物体 在某些子系统中是否是静态的，还可以独立地设置游戏物体在每个子系统中是否是静态的，这样就可以对物体进行非常细致的优化。</p><p>下图是静态标记菜单，可以有针对性地设置物体在每个子系统中是否是静态的。</p><h2 id="3-2-子系统的静态特性内容"><a href="#3-2-子系统的静态特性内容" class="headerlink" title="3.2 子系统的静态特性内容"></a>3.2 子系统的静态特性内容</h2><p>静态菜单中的Everyhing和Nothing选项分别用于同时启用或禁用物体在所有子系统中的静态特性以便优化。</p><p>这些子系统包含如下内容：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Lightmap Static</td><td>场景中的高级光照特性</td></tr><tr><td>Occluder Static</td><td>根据物体在特定摄像机下的可见性，进行渲染优化</td></tr><tr><td>Batching Static</td><td>将多个物体合并为一个整体进行渲染</td></tr><tr><td>Navigation Static</td><td>在寻路系统中，将此物体作为静态的障碍物</td></tr><tr><td>Off Mesh Link Generation</td><td>寻路系统中的网格链接</td></tr><tr><td>Reflection Probe Static</td><td>反射探针优化</td></tr></tbody></table><p>某些子系统与内部渲染方式有较大关联，可以在相关文档中阅读它们的细节。</p><h1 id="4-预制体"><a href="#4-预制体" class="headerlink" title="4.预制体"></a>4.预制体</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>在场景中创建物体、添加组件并设置合适参数的操作一开始会令人觉得方便， 但是当场影的用到大量同样的NPC、障碍物或机关时，创建以及设置属性的操作就会带来巨大的麻烦。<br>复制这些物体看似可以解决问题，但是由于这些物体都是独立的，所以还是需要一个一个单独体改它们。</p><p>所以，Unity 提供了预制体这个概念。<br>它允许事先保存一个游戏物体，包括该物体上挂载的组件与设置的参数。<br>这样预制体就可以成为模板，可以用这个模板在场景中创建物体。</p><p>预制体具有以下两个优点</p><ul><li><p>对预制体文件的任何修改可以立即影响所有相关联的物体</p></li><li><p>每个物体还可以重载(override)一些些组件和参数， 以实现与模板有所区别的设置</p></li></ul><blockquote><p>注意:<br>当你拖曳一个资源文件(比如一个模型)到场景中时，Unity 会自动创建一个新的游戏物体，原始资源的修改也会影响到这些相关的游戏物体。<br>这种物体看起来像是预制体，但是和预制体是完全不同的，所以不适用下面介绍的预制体的特性。<br>这种“引用关系”仅仅是与预制体有相似之处。</p></blockquote><h2 id="4-2-使用预制体"><a href="#4-2-使用预制体" class="headerlink" title="4.2 使用预制体"></a>4.2 使用预制体</h2><p>创建预制体有两种常用方法: </p><ul><li>方法一:<br>在工程窗口中的某个文件夹内单击右键，选择Create&gt; Prefab创建一个空白预制体，然后将场景中制作好的某个游戏物体拖曳到空白预制体上。</li><li>方法二:<br>直接将某个游戏物体从场景拖曳到文件夹中。<br>在创建好预制体以后，将另一个游戏物体拖曳到预制体文件上，系统会提示是否替换预制体。</li></ul><blockquote><p>预制体是一个后缀为 .prefab的资源文件。<br>在层级视图中，所有与预制体关联的游戏物体的名称，都会以蓝色显示(普通物体的名称是以黑色显示的)</p></blockquote><blockquote><p>编辑器会用粗体字来显示游戏物体中与预制体不一样的独特属性</p></blockquote><h2 id="4-3-通过游戏物体实例修改预制体"><a href="#4-3-通过游戏物体实例修改预制体" class="headerlink" title="4.3 通过游戏物体实例修改预制体"></a>4.3 通过游戏物体实例修改预制体</h2><p>与预制体关联的游戏物体，会在检视窗口的上方多出三个按钮:</p><ul><li><p>选择( Select)<br>选中与物体相关联的那个预制体，单击后，在工程窗口中会高亮显示该预制体。<br>这有助于迅速找到相关的预制体。</p></li><li><p>回滚(Revert)<br>将游戏物体修改过的组件和属性恢复到和预制体一致。<br>这个功能用于试验性地修改某些参数以后，将物体恢复到原始状态。</p></li><li><p>应用(Apply)<br>将本物体上修改的那些组件和参数写回到原始的预制体中(但是变换组件的位置信息不会写回预制体)。<br>这有助于通过任何一个物体修改预制体，有时会非常方便，特别是在某些预制体只有一个实例的时候。</p></li></ul><h2 id="４-4-预制体实例化"><a href="#４-4-预制体实例化" class="headerlink" title="４.4 预制体实例化"></a>４.4 预制体实例化</h2><p>使用<strong>Instantiate函数</strong></p><p>Instantiate函数实例化是将传入对象的所有子物体和子组件完全复制，成为一个新的对象。<br>这个新的对象拥有与源对象完全一样的东西，包括坐标值等。</p><h3 id="4-4-1-参数"><a href="#4-4-1-参数" class="headerlink" title="4.4.1 参数"></a>4.4.1 参数</h3><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>original</td><td>用来做复制操作的对像物体，源对象</td></tr><tr><td>position</td><td>实例化的对象的位置坐标</td></tr><tr><td>rotation</td><td>实例化的对象的旋转坐标（旋转四元数）</td></tr><tr><td>parent</td><td>实例化对象的父对象，在完成实例化函数处理后，实例化对象将是父对象的子对象</td></tr><tr><td>instantiateWorldSpace</td><td>为TRUE，表示实例化对象相对于世界坐标系的位置（是位置，不是坐标值，比如实例化前在Canvas左上角，实例化后还在左上角）不变，相对于父对象的坐标值变了<br />为false，表示实例化对象相对于父对象的坐标值不变，但在世界坐标系中的位置变了。</td></tr></tbody></table><p><a href="https://blog.csdn.net/qq_29413829/article/details/78934579">https://blog.csdn.net/qq_29413829/article/details/78934579</a></p><h3 id="4-4-2-重载"><a href="#4-4-2-重载" class="headerlink" title="4.4.2 重载"></a>4.4.2 重载</h3><p>![Instantiate函数](./images/Unity中的标签 层级 静态物体/20171229171822891)</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>标签</tag>
      
      <tag>层级</tag>
      
      <tag>静态物体</tag>
      
      <tag>预制体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的事件</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity在C#Event特性的基础上进行了改良，Event只能用于纯代码编程，而UnityEvent可以和UnityEditor配合使用提高效率。</p><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a>！</p></blockquote><h1 id="2-Unity事件的改良"><a href="#2-Unity事件的改良" class="headerlink" title="2. Unity事件的改良"></a>2. Unity事件的改良</h1><p>在C#事件中我们举的例子中，可以看出.Net框架下的事件存在以下几个问题：</p><ul><li>订阅的时机受限<br>你必须在事件触发前完成事件的订阅<br>事件处理程序将收不到订阅前的事件动态</li><li>不方便管理<br>想要查看所有订阅事件的对象，我们就得查找项目中所有对事件的引用，然后再把每个对象的文件打开，可以说是非常麻烦了</li></ul><p>为了避免上述的缺点，Unity使用Serializable（序列化）让用户可以在Editor中直接绑定所有对象的调用，即一目了然又不用担心把握不准订阅的时机，这就是<strong>UnityEvent</strong>。</p><h1 id="3-UnityEvent类"><a href="#3-UnityEvent类" class="headerlink" title="3. UnityEvent类"></a>3. UnityEvent类</h1><p><strong>UnityEvent</strong> 可添加到任何 <strong>MonoBehaviour</strong>，并从标准 .net 委托之类的代码中执行。当 <strong>UnityEvent</strong>添加到 <strong>MonoBehaviour</strong>时，它会出现在 <strong>Inspector</strong> 中，并可添加持久回调。</p><h2 id="3-1-方法"><a href="#3-1-方法" class="headerlink" title="3.1 方法"></a>3.1 方法</h2><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>AddListener</td><td>将一个非持久性侦听器添加到UnityEvent</td></tr><tr><td>Invoke</td><td>调用所有已注册的回调（运行时和持久的）</td></tr><tr><td>RemoveListener</td><td>从UnityEvent中删除一个非持久性侦听器</td></tr></tbody></table><h2 id="3-2-继承的成员"><a href="#3-2-继承的成员" class="headerlink" title="3.2 继承的成员"></a>3.2 继承的成员</h2><p>普通方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetPersistentEventCount</td><td>获取已注册的持久性侦听器的数量</td></tr><tr><td>GetPersistentMethodName</td><td>获取索引为index的侦听器的目标方法名称</td></tr><tr><td>GetPersistentTarget</td><td>在索引index处获取侦听器的目标组件</td></tr><tr><td>RemoveAllListeners</td><td>从事件中删除所有侦听器</td></tr><tr><td>SetPersistentListenerState</td><td>修改持久侦听器的执行状态</td></tr></tbody></table><p>静态方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetValidMethodInfo</td><td>给定对象，函数名称和参数类型列表；找到匹配的方法</td></tr></tbody></table><h2 id="3-3-UnityEvent的使用"><a href="#3-3-UnityEvent的使用" class="headerlink" title="3.3 UnityEvent的使用"></a>3.3 UnityEvent的使用</h2><p>要在 Editor 中配置回调，需执行以下几个步骤：</p><ol><li>确保脚本导入/使用 <code>UnityEngine.Events</code>。</li><li>选择 + 图标为回调添加字段</li><li>选择要接收回调的 UnityEngine.Object（可使用对象选择器进行选择）</li><li>选择要调用的函数</li><li>可为事件添加多个回调</li></ol><p>在 <strong>Inspector</strong> 中配置 <strong>UnityEvent</strong> 时，支持两种类型的函数调用：</p><ul><li>静态。<br>静态调用是预配置的调用，具有在 UI 中设置的预配置值。<br>这意味着，在调用回调时，使用已在 UI 中输入的参数调用目标函数。</li><li>动态。<br>使用从代码发送的参数调用动态调用，并与正在调用的 UnityEvent 类型相关。<br>UI 会过滤回调，仅显示对 UnityEvent 有效的动态调用。</li></ul><h2 id="3-4-UnityEvent的多态（派生自定义事件）"><a href="#3-4-UnityEvent的多态（派生自定义事件）" class="headerlink" title="3.4 UnityEvent的多态（派生自定义事件）"></a>3.4 UnityEvent的多态（派生自定义事件）</h2><p>默认情况下，<strong>Monobehaviour</strong> 中的 UnityEvent 动态绑定到 void 函数。</p><p>但不一定非得如此，<strong>UnityEvent</strong> 的子类支持绑定到最多包含 4 个参数的函数。</p><p>为此，您可以定义一个支持多个参数的自定义 <strong>UnityEvent</strong> 类。</p><p>此定义十分简单：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringEvent</span> : <span class="hljs-title">UnityEvent</span> &lt;<span class="hljs-title">string</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>订阅时订阅此派生类的实例而不是基类 <strong>UnityEvent</strong>，即可回调时传递各种参数。</p><p>然后，可通过调用**Invoke()**函数来对其进行调用。</p><blockquote><p>UnityEvent 可在其通用定义中定义最多 4 个参数。</p></blockquote><h2 id="3-5-使用案例："><a href="#3-5-使用案例：" class="headerlink" title="3.5 使用案例："></a>3.5 使用案例：</h2><p>将C#事件中的用例代码改写成Unity引擎内继承于<strong>UnityEvent</strong>的脚本：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Events;<br><br><span class="hljs-comment">//使用Serializable序列化IdolEvent, 否则无法在Editor中显示</span><br>[<span class="hljs-meta">System.Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IdolEvent</span> : <span class="hljs-title">UnityEvent</span>&lt;<span class="hljs-title">string</span>&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">//public delegate void IdolBehaviour(string behaviour);</span><br>    <span class="hljs-comment">//public event IdolBehaviour IdolDoSomethingHandler;</span><br>    <span class="hljs-keyword">public</span> IdolEvent idolEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (idolEvent == <span class="hljs-literal">null</span>)<br>        &#123;<br>            idolEvent = <span class="hljs-keyword">new</span> IdolEvent();<br>        &#125;<br>        idolEvent.Invoke(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将三个脚本绑定在三个GameObject上，此时两个粉丝还未实现订阅。和Event不同，UnityEvent在序列化后可以在Editor上显示，并且可以在Editor上设置好需要执行的函数</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315164014120.png" srcset="/img/loading.gif" alt="image-20210315164014120"></p><p>运行</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315160434052.png" srcset="/img/loading.gif" alt="image-20210315160434052"></p><p>除此之外，UnityEvent依然提供和C# Event 类似的运行时绑定的功能，不过不同的是，UnityEvent是一个对象，向其绑定函数是通过AddListener()方法实现的。以SubscriberB为例，我们可以在代码中实现同等效果的绑定：</p><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">public</span> Idol myIdol;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        myIdol.idolEvent.AddListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        myIdol.idolEvent.RemoveListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于UnityEvent是一个对象，所以自然可以允许我们通过继承实现自己的Event，实际上Unity中包括Button在内的许多UI组件的点击事件都是通过继承自UnityEvent来复写的。<br>可访问性(public/private)决定了UnityEvent的默认值，当可访问性为public时，默认会为其分配空间(new UnityEvent())；当可访问性为private时，默认UnityEvent为null，需要在Start()中为其分配内存。</p></blockquote><h1 id="4-EventSystem"><a href="#4-EventSystem" class="headerlink" title="4. EventSystem"></a>4. EventSystem</h1><p>EventSystem在Unity中是一个看起来像是专门服务于UGUI系统的组件。<br>每当在场景里创建UGUI对象时，Unity编辑器都会自动产生一个EventSystem对象放在场景中，与之相对应的也有一个Canvas对象，这两个对象就组成了UGUI系统的基础。<br>所有开发人员能看到和能用到的UGUI功能都依附于这两个对象。</p><h2 id="4-1-UGUI中的EventSystem"><a href="#4-1-UGUI中的EventSystem" class="headerlink" title="4.1 UGUI中的EventSystem"></a>4.1 UGUI中的EventSystem</h2><p>使用<strong>UGUI</strong>制作游戏界面时，<strong>EventSystem</strong>的作用就像是一个专为<strong>UGUI</strong>设计好的消息中心，它管理着所有能参与消息处理的<strong>UGUI</strong>组件，包括但不仅限于<strong>Panel</strong>，<strong>Image</strong>，<strong>Button</strong>等。</p><p>如果在<strong>Unity</strong>创建好<strong>EventSystem</strong>之后观察该对象上附带的组件可以看到，至少有两个组件会被自动添加</p><ul><li><p><strong>EventSystem组件</strong>，也就是消息机制的核心；</p></li><li><p><strong>StandaloneInputModule组件</strong>，这个是负责产生输入的组件。<br>StandaloneInputModule本身是个继承自BaseInputModule的实现类，而类似的实现类Unity中还有另外几个，甚至用户也能自定义一个实现类用于事件处理。</p></li></ul><p>看起来这个系统似乎缺少一个部分，就是怎么确定某个事件是发给谁的。<br>因此为了确定操作对象究竟是哪个，一个必不可少的步骤就是检测。</p><p>在GUI之外的游戏场景编辑中，要感知当前鼠标对准的物体是哪个，最常用的方法就是射线检测了：<br>从摄像机对着鼠标指向的方向发出射线，通过碰撞来检测目标。</p><p>这个方案简单实用，可以说在游戏中随处可见，而UGUI所使用的机制也就是这一套射线检测，只不过射线的发射和碰撞处理都被隐藏在了组件之中。</p><p>所以，缺失的部分就是射线检测模块，这个模块不在EventSystem上，而是在Canvas上挂着。<br>这很好理解，Canvas是所有UGUI组件的根对象，所以由他来负责射线处理是相当正常的解决方案，至于射线到底碰到了谁，UGUI组件自然有射线接收反馈来确定。</p><p>Canvas上挂载的组件叫做GraphicRaycaster，它实际上是BaseRaycaster的实现类，专门负责Canvas之下的图形对象的射线检测与计算问题。</p><p>至此，UGUI中的情况就比较清晰了：</p><ul><li><p><strong>EventSystem对象</strong><br>负责管理所有事件相关对象<br>该对象下挂载了EventSystem组件和StandaloneInputModule组件，前者为管理脚本，后者为输入模块</p></li><li><p><strong>Canvas对象</strong><br>下挂载了GraphicRaycaster负责处理射线相关运算<br>用户的操作都会通过射线检测来映射到UGUI组件上，InputModule将用户的操作转化为射线检测，Raycaster则找到目标对象并通知EventSystem，最后EventSystem发送事件让目标对象进行响应</p><p>如下图所示：</p><img src="/images/Unity中的事件/UGUI结构.png" srcset="/img/loading.gif" alt="UGUI结构"  /></li></ul><h3 id="4-1-1-事件响应"><a href="#4-1-1-事件响应" class="headerlink" title="4.1.1 事件响应"></a>4.1.1 事件响应</h3><p>UGUI的事件响应处理有多种方式，这里我们介绍两种常用方法</p><h4 id="4-1-1-1-实现特定接口处理事件响应"><a href="#4-1-1-1-实现特定接口处理事件响应" class="headerlink" title="4.1.1.1 实现特定接口处理事件响应"></a>4.1.1.1 实现特定接口处理事件响应</h4><p>由于Canvas挂载了GraphicRaycaster组件，因此在Canvas对象之下的所有GUI对象都可以通过挂载脚本并且实现一些和事件相关的接口来处理事件，比如常见的IPointerClickHandler接口就是用于处理点击事件的接口。</p><p>可以实现的接口列表大概如下所示：</p><table><thead><tr><th>接口名</th><th>作用</th></tr></thead><tbody><tr><td>IPointerEnterHandler - OnPointerEnter</td><td>当光标进入对象时调用</td></tr><tr><td>IPointerExitHandler - OnPointerExit</td><td>当光标退出对象时调用</td></tr><tr><td>IPointerDownHandler - OnPointerDown</td><td>在对象上按下指针时调用</td></tr><tr><td>IPointerUpHandler - OnPointerUp</td><td>松开鼠标时调用（在指针正在点击的游戏对象上调用）</td></tr><tr><td>IPointerClickHandler - OnPointerClick</td><td>在同一对象上按下再松开指针时调用</td></tr><tr><td>IInitializePotentialDragHandler - OnInitializePotentialDrag</td><td>在找到拖动目标时调用，可用于初始化值</td></tr><tr><td>IBeginDragHandler - OnBeginDrag</td><td>即将开始拖动时在拖动对象上调用</td></tr><tr><td>IDragHandler - OnDrag</td><td>发生拖动时在拖动对象上调用</td></tr><tr><td>IEndDragHandler - OnEndDrag</td><td>拖动完成时在拖动对象上调用</td></tr><tr><td>IDropHandler - OnDrop</td><td>在拖动目标对象上调用</td></tr><tr><td>IScrollHandler - OnScroll</td><td>当鼠标滚轮滚动时调用</td></tr><tr><td>IUpdateSelectedHandler - OnUpdateSelected</td><td>每次勾选时在选定对象上调用</td></tr><tr><td>ISelectHandler - OnSelect</td><td>当对象成为选定对象时调用</td></tr><tr><td>IDeselectHandler - OnDeselect</td><td>取消选择选定对象时调用</td></tr><tr><td>IMoveHandler - OnMove</td><td>发生移动事件（上、下、左、右等）时调用</td></tr><tr><td>ISubmitHandler - OnSubmit</td><td>按下 Submit 按钮时调用</td></tr><tr><td>ICancelHandler - OnCancel</td><td>按下 Cancel 按钮时调用</td></tr></tbody></table><p>只要在挂载的脚本中实现所需要的接口，对应的事件回调也就可以执行了。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EventTest</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerClickHandler</span>, <span class="hljs-title">IDragHandler</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span> <br>&#123;<br>    <span class="hljs-comment">// Execute every update when dragging</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-comment">// quick down and up will perform click</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerClick</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer down</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer up</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Use this for initialization</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Update is called once per frame</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-2-利用EventTrigger组件处理事件响应"><a href="#4-1-1-2-利用EventTrigger组件处理事件响应" class="headerlink" title="4.1.1.2  利用EventTrigger组件处理事件响应"></a>4.1.1.2  利用EventTrigger组件处理事件响应</h4><p>EventTrigger组件是一个通用的事件触发器，它可以用来管理单个组件上的所有可能触发的事件。<br>其使用方法有两种：</p><ul><li><p>编辑器设定方法</p><p>指定组件上添加EventTrigger组件，然后为它添加触发事件类型，再为指定类型添加回调方法。</p></li></ul><p>这种做法的操作很简单，而且灵活性也相当高，想要跨脚本调用方法只需要鼠标拖一拖点一点就好。<br>但是这样在编辑器中设定事件回调会在项目变大时造成比较严重的管理障碍，尤其是当绑定了EventTrigger以及回调指向的物体有修改或者删除情况时，所造成的引用缺失需要花费更多的时间进行处理。</p><blockquote><p>略</p></blockquote><ul><li>动态设定方法</li></ul><p>想要更好地管理大量的事件触发和回调处理，可以尝试采用动态设置的方案。<br>所谓动态设置其实就是在代码中设置EventTrigger来处理事件回调，方法也很简单</p><blockquote><p>略</p></blockquote><h2 id="4-2-场景中的EventSystem"><a href="#4-2-场景中的EventSystem" class="headerlink" title="4.2 场景中的EventSystem"></a>4.2 场景中的EventSystem</h2><p>EventSystem也能在一般的场景中使用。<br>如果没有实现自己的事件系统而又需要一些回调处理的方案的话，可以试着直接将EventSystem应用到一般的游戏场景中。<br>要这样使用EventSystem的话，核心在于前文提到过的事件系统三大部分：</p><ul><li>EventSystem</li><li>InputModule</li><li>Raycaster。</li></ul><p>通过考察三者各自的作用可知，EventSystem和InputModule都和EventSystem对象紧密结合，而唯有Raycaster是孤零零地在Canvas对象上处理所有Canvas内部的射线检测。</p><p>那么想要借助EventSystem的能力来处理场景中的事件传递，肯定不能去动EventSystem对象，毕竟这是建立事件系统时自动创建的对象，不用说一定是要用到的。<br>那么就只剩下Raycaster了，这个组件在Canvas上挂载，用于处理射线检测，那么如果想要在场景里进行射线检测，应该把组件挂到哪里呢？</p><p>一般而言，摄像机是一个不错的选择，因为通常来说游戏大部分时候都只有一个摄像机，而且基本上可以操作的界面也只隶属于一个摄像机，因此将Raycaster挂载到游戏的主摄像机上就是个很自然的考虑了。<br>​ 而Unity编辑器提供的Raycaster一共有三种</p><ul><li>GraphicRaycaster 界面射线处理器，用于Canvas</li><li>Physics2DRaycaster 2D场景射线处理器，用于2D场景</li><li>PhysicsRaycaster 3D场景射线处理器，用于3D场景</li></ul><p>因此要用到的就是后两种了，根据当前场景的特点选择相应的Raycaster并挂载到主摄像机上即可，剩下的就和UGUI中很像了。</p><p>不过需要注意的是，在UGUI中想要让组件可以响应事件必须将组件的RaycasterTarget属性勾选上，而场景中则要在需要响应事件的对象上挂载碰撞器，满足需求的任何碰撞器都可以。<br>然后就和前文讲的一样，实现对应接口或者添加EventTrigger组件来实现各种事件回调。</p><p>使用这样的方案实现的回调，其传递的数据PointerEventData中包含的位置参数还是屏幕位置，而且跟像素相关，以屏幕左下角为原点的坐标。<br>如果希望获取触发事件时的世界坐标，则需要用到PointerEventData类中的pointerCurrentRaycast成员，该成员表示了射线检测的结果，因此其中包含碰撞点的世界坐标。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>底层机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity底层机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#委托</title>
    <link href="/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/"/>
    <url>/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>委托(delegate)是一种存储函数引用的类型。<br>委托是C#的一个语言级特性，而在Java语言中没有直接的对应，但是java利用反射即可实现委托。</p><p>委托最重要的用途在事件和事件处理时才能解释清楚，但这里也将介绍有关委托的许多内容。</p><p>委托是一种数据类型，和类是同级别的，我们可以将delegate与class类比：</p><ul><li>class里存放的是一系列方法，属性，字段，事件，索引。</li><li>delegate里存放的是一系列具有相同类型参数和返回回类型的方法的地址的地址。<br>可以看作为储存方法的载体。</li></ul><p>有了引用函数的变量后，就可以执行无法用其他方式完成的操作。<br>例如，可以把委托变量作为参数传递给-一个函数，这样，该函数就可以使用委托调用它引用的任何函数，而且在运行之前不必知道调用的是哪个函数。下面的示例使用委托访问两个函数中的一个。</p><blockquote><p><a href="https://baike.baidu.com/item/c%23%E5%A7%94%E6%89%98/6916387?fr=aladdin">委托百度百科</a>上看的最明白</p></blockquote><h1 id="2-委托的声明"><a href="#2-委托的声明" class="headerlink" title="2. 委托的声明"></a>2. 委托的声明</h1><p><strong>delegate &lt;函数返回类型&gt; 委托名（函数参数）</strong>   </p><p><strong>例：</strong> <code>public delegate void myDelegate(string name);</code></p><h1 id="3-委托的实例化"><a href="#3-委托的实例化" class="headerlink" title="3. 委托的实例化"></a>3. 委托的实例化</h1><ul><li><strong>&lt;委托名&gt;实例化名= new &lt;委托名&gt;（注册函数）</strong></li></ul><p>例 : <code> myDelegate delegateinstance = new myDelegate(method);</code></p><blockquote><p>注意：注册函数不包含参数，或者可以直接将一个注册函数赋值给委托</p></blockquote><ul><li>匿名方法实例化委托</li></ul><p>​        <strong>&lt;委托类型&gt; &lt;实例化名&gt;=delegate(&lt;函数参数&gt;){函数体}</strong></p><ul><li>使用lamda表达式实例化委托</li></ul><p>实例化例子如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>   <br>&#123;     <br>    <span class="hljs-comment">//声明委托     </span><br>    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)     </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-comment">//实例化委托 </span><br>        <span class="hljs-comment">//1、使用new关键字       </span><br>        MyDelegate _myDelegate = <span class="hljs-keyword">new</span> MyDelegate(GetSum);<br>        <span class="hljs-comment">//2、使用匿名方法       </span><br>        MyDelegate myDelegate = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y)&#123;<span class="hljs-keyword">return</span> x + y;&#125;;<br>        <span class="hljs-comment">//3、使用Lambda表达式       </span><br>        MyDelegate myDelegateLambda = (<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) =&gt; &#123; <span class="hljs-keyword">return</span> x + y; &#125;;  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)     </span><br><span class="hljs-function"></span>    &#123;       <br>        <span class="hljs-keyword">return</span> x + y;     <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-多播委托"><a href="#4-多播委托" class="headerlink" title="4.多播委托"></a>4.多播委托</h1><p>实例化委托时必须将一个匹配函数注册到委托上来实例化一个委托对象，但是一个实例化委托不仅可以注册一个函数还可以注册多个函数。注册多个函数后，在执行委托的时候会根据注册函数的注册先后顺序依次执行每一个注册函数。</p><ul><li><p>多播委托实际上形成委托链 </p><p>函数注册委托的原型：</p><p>​            <strong>&lt;委托类型&gt; &lt;实例化名&gt;+=或者-=new &lt;委托类型&gt;(&lt;注册函数&gt;)</strong><br>如果在委托注册了多个函数后，如果委托有返回值，那么调用委托时，返回的将是最后一个注册函数的返回值。</p><blockquote><p>注意：委托必须先实例化以后，才能使用+=注册其他方法。如果对注册了函数的委托实例从新使用=号赋值，相当于是重新实例化了委托，之前在上面注册的函数和委托实例之间也不再产生任何关系。</p></blockquote></li></ul><blockquote><p>多播委托不支持返回值，也不支持数据引用，是单向广播</p></blockquote><h1 id="5-泛型委托"><a href="#5-泛型委托" class="headerlink" title="5.泛型委托"></a>5.泛型委托</h1><p>委托也支持泛型的使用<br>泛型委托原型：</p><ul><li><strong>delegate <T1> &lt;委托名&gt;&lt;T1,T2,T3…&gt; (T1 t1,T2 t2,T3 t3…)</strong></li></ul><h2 id="5-1-内置泛型委托"><a href="#5-1-内置泛型委托" class="headerlink" title="5.1 内置泛型委托"></a>5.1 内置泛型委托</h2><p>delegate      void   Action&lt;T1，T2，T3&gt;    泛型委托是可以达到16个参数的无返回值委托<br>delegate  Tresult Fun&lt;T1,T2,Tresult&gt;    Fun是内置泛型委托，具有返回值<br>delegate bool Predicate<T>(T obj)    内置泛型委托，返回bool值</p><h1 id="6-委托的清空"><a href="#6-委托的清空" class="headerlink" title="6. 委托的清空"></a>6. 委托的清空</h1><ol><li>在类中申明清空委托方法，依次循环去除委托引用。方法如下：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>&#123;<br>    <span class="hljs-keyword">public</span> DelegateMethod OnDelegate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearDelegate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.OnDelegate != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">this</span>.OnDelegate -= <span class="hljs-keyword">this</span>.OnDelegate;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>如果在类中没有申明清空委托的方法，我们可以利用GetInvocationList查询出委托引用，然后进行去除。</p><p>方法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">TestDelegate test = <span class="hljs-keyword">new</span> TestDelegate();<br><span class="hljs-keyword">if</span> (test.OnDelegate != <span class="hljs-literal">null</span>)<br>&#123;<br>  System.Delegate[] dels = test.OnDelegate.GetInvocationList();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; dels.Length; i++)<br>  &#123;<br>     test.OnDelegate -= dels[i] <span class="hljs-keyword">as</span> DelegateMethod;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-委托的应用"><a href="#7-委托的应用" class="headerlink" title="7.委托的应用"></a>7.委托的应用</h1></li></ol><ul><li>高内聚低耦合</li><li>用于事件系统</li><li>用于设计模式——观察者模式开发</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#事件</title>
    <link href="/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>C#事件的核心思想是基于windows消息处理机制的，只是封装的更好，让开发者无须知道底层的消息处理机制，就可以开发出强大的基于事件的应用程序来。</p><p>关于事件，比较形象的比喻就是广播者和订阅者。事件执行时会广播给订阅他函数，告诉每个函数该运行了，但不管函数的实现细节。</p><p>事件类似于异常，因为它们都由对象引发(抛出)，并且都可以通过我们提供的代码来处理。<br>但它们也有个重要区别：事件并没有与tny. catch类似的结构来处理事件，你必须订阅(Subseribe)它们。</p><p>订阅一个事件的含义是提供代码，在事件发生时执行这些代码，它们称为事件处理程序。</p><p>单个事件可供多个处理程序订阅，在该事件发生时，这些处理程序都会被调用，事件处理程序可以在引发事件的类中，也可以在其他类中。</p><p>事件处理程序本身都是简单方法。对事件处理方法的唯一限制是它必须匹配事件所要求的返回类型和参数，这个限制是事件定义的一部分，由一个委托指定。</p><blockquote><p>学习事件前请先学习<br><a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/">委托</a></p></blockquote><h1 id="2-事件与委托的关系与区别"><a href="#2-事件与委托的关系与区别" class="headerlink" title="2. 事件与委托的关系与区别"></a>2. 事件与委托的关系与区别</h1><p><strong>事件Event</strong>是在<strong>多播委托multicast delegate</strong>的基础上演变而来。</p><ul><li>event是升级版delegate，用event实现的功能用delegate同样可以实现。</li><li>event较之delegate具有继承方面的安全性。<br>用event，别的类只能订阅/取消订阅，如果用一个 public delegate成员变量，别的类可以调用或者覆盖我们的delegate变量。</li><li>一般来说，如果你要创建一个包含多个类的动态体系，使用event而不是delegate。</li></ul><h1 id="3-使用事件的优点"><a href="#3-使用事件的优点" class="headerlink" title="3. 使用事件的优点"></a>3. 使用事件的优点</h1><p>在以往我们编程时，往往采用等待机制，为了等待某件事情的发生，需要不断地检测某些判断变量，而引入事件编程后，大大简化了这种过程：</p><ul><li><p>可以很方便地确定程序执行顺序。</p></li><li><p>当事件驱动程序等待事件时，它不占用很多资源。<br>事件驱动程序与过程式程序最大的不同就在于，程序不再不停地检查输入设备，而是呆着不动，等待消息的到来,每个输入的消息会被排进队列，等待程序处理它。<br>如果没有消息在等待，则程序会把控制交回给操作系统，以运行其他程序。</p></li><li><p>简化了编程。<br>操作系统只是简单地将消息传送给对象，由对象的事件驱动程序确定事件的处理方法。<br>操作系统不必知道程序的内部工作机制，只是需要知道如何与对象进行对话，也就是如何传递消息。</p></li><li><p>在事件源和事件接收器之间启用非常小的耦合。<br>这两个组件可能不会由同一个组织编写，甚至可能会通过完全不同的计划进行更新。</p></li><li><p>订阅事件并从同一事件取消订阅应该非常简单。</p></li><li><p>事件源应支持多个事件订阅服务器。<br>它还应支持不附加任何事件订阅服务器。</p></li></ul><h1 id="4-使用事件需要的步骤"><a href="#4-使用事件需要的步骤" class="headerlink" title="4. 使用事件需要的步骤"></a>4. 使用事件需要的步骤</h1><p>我们编写一个偶像搞事事件来描述使用事件的步骤。</p><p>代码与步骤如下：</p><h2 id="4-1-创建一个委托"><a href="#4-1-创建一个委托" class="headerlink" title="4.1 创建一个委托"></a>4.1 创建一个委托</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像行为委托，参数是行为字符串，返回值为空</p></blockquote><h2 id="4-2-将委托与已有或自定义事件关联"><a href="#4-2-将委托与已有或自定义事件关联" class="headerlink" title="4.2 将委托与已有或自定义事件关联"></a>4.2 将委托与已有或自定义事件关联</h2><p>.Net类库中的很多事件都是已经定制好的，所以他们也就有相应的一个委托，在编写关联事件处理程序——也就是当有事件发生时我们要执行的方法的时候我们需要和这个委托有相同的签名</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像搞事事件，与IdolBehaviour偶像行为委托关联</p></blockquote><h2 id="4-3-编写事件处理程序"><a href="#4-3-编写事件处理程序" class="headerlink" title="4.3 编写事件处理程序"></a>4.3 编写事件处理程序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>&#125;<br><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>的两个事件处理程序函数</p></blockquote><h2 id="4-4-生成委托实例"><a href="#4-4-生成委托实例" class="headerlink" title="4.4 生成委托实例"></a>4.4 生成委托实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br>IdolBehaviour myIdolBehaviour=<span class="hljs-keyword">new</span> IdolBehaviour();<br></code></pre></td></tr></table></figure><blockquote><p>这步可以省略<br>我们在声明event delegate时并没有给它分配内存，使用时直接赋值或添加即可</p></blockquote><h2 id="4-5-订阅事件"><a href="#4-5-订阅事件" class="headerlink" title="4.5 订阅事件"></a>4.5 订阅事件</h2><p>把这个委托实例添加到产生事件对象的事件列表中去，这个过程又叫订阅事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += LikeIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= LikeIdol;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-comment">//OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += HateIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= HateIdol;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>中用于事件订阅</p></blockquote><h2 id="4-6-事件触发"><a href="#4-6-事件触发" class="headerlink" title="4.6 事件触发"></a>4.6 事件触发</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>&#123;<br>    IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>别编写在<strong>Idol.cs</strong>中需要触发事件的地方，Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</p></blockquote><h2 id="4-7-代码汇总"><a href="#4-7-代码汇总" class="headerlink" title="4.7 代码汇总"></a>4.7 代码汇总</h2><p>结果以上6个步骤后，一个自定义事件就完成了，代码汇总如下：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>        &#123;<br>            IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-事件产生和实现的流程"><a href="#5-事件产生和实现的流程" class="headerlink" title="5.事件产生和实现的流程"></a>5.事件产生和实现的流程</h1><ol><li><p>定义A为产生事件的实例，a为A产生的一个事件</p></li><li><p>定义B为接收事件的实例，b为处理事件的方法</p></li><li><p>A由于用户(程序编写者或程序使用者)或者系统产生一个a事件(例如点击一个Button，产生一个Click事件)</p></li><li><p>A通过事件列表中的委托对象将这个事件通知给B</p></li><li><p>B接到一个事件通知(实际是B.b利用委托来实现事件的接收)</p></li><li><p>调用B.b方法完成事件处理</p></li></ol><h1 id="6-参考网站"><a href="#6-参考网站" class="headerlink" title="6. 参考网站"></a>6. 参考网站</h1><ul><li><a href="https://www.jb51.net/article/133032.htm">https://www.jb51.net/article/133032.htm</a></li><li> <a href="https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/">https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的事件函数</title>
    <link href="/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity中的脚本组织不像传统的游戏循环，有一个持续进行的主循环并在循环体中处理游戏逻辑。</p><p>相对的，Unity 会在特定的事件发生时，调用脚本中特定的函数，然后执行逻辑的任务就交给了该脚本函数，函数执行完毕后，执行的权力重新还给Unty。</p><p>这些特定的函数通常被称为事件函数，因为是在特定事件发生时由引擎层调用的。</p><h1 id="2-必然事件"><a href="#2-必然事件" class="headerlink" title="2.必然事件"></a>2.必然事件</h1><table><thead><tr><th>事件函数</th><th>作用</th></tr></thead><tbody><tr><td>Awake</td><td>脚本实例被创建时调用（用于游戏对象的初始化，注意Awake的执行早于所有脚本的Start函数）</td></tr><tr><td>Start</td><td>Update函数第一次运行之前调用（用于游戏对象的初始化）</td></tr><tr><td>Reset</td><td>用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个最常用的默认值。</td></tr><tr><td>Update</td><td>每帧调用一次（用于更新游戏场景和状态）</td></tr><tr><td>FixedUpdate</td><td>每个固定物理时间间隔调用一次（用于物理引擎的参数更新）</td></tr><tr><td>LateUpdate</td><td>每帧调用一次，在Update之后（用于更新游戏场景和状态，和相机有关的更新一般放在这里）</td></tr></tbody></table><h2 id="2-1-Updata与FixedUpdate的区别"><a href="#2-1-Updata与FixedUpdate的区别" class="headerlink" title="2.1 Updata与FixedUpdate的区别"></a>2.1 Updata与FixedUpdate的区别</h2><ul><li><p>FixedUpdate</p><p>物理更新的事件函数，物理引擎也会按照物理帧更新，机制和<strong>Update函数</strong>类似，但是更新的时机完全不同。</p><p>它在每一次物理更新时被调用。</p></li><li><p>Updata</p><p>帧更新函数，每帧调用一次。</p></li></ul><blockquote><p>要认识到，物理更新的频率和时机与Update函数是相对独立的。尽可能在FixedUpdate函数中进行物理相关的操作，在Update函数中进行其他操作，只有选择正确的函数才能让游戏效果尽可能准确。</p></blockquote><h3 id="2-1-1-帧率"><a href="#2-1-1-帧率" class="headerlink" title="2.1.1 帧率"></a>2.1.1 帧率</h3><p>每一帧所经历的时间并不是一个固定值，所以通过<strong>Updata函数</strong>控制物体移动的速度将不会是稳定的。</p><p>主要是因为硬件负载的原因，引擎默认会按照每秒60帧运行游戏，但是当负载增大时，帧率可能会下降，无法达到60帧，这时可能就只有30帧，帧率降低了一半，每帧的时间增加了一倍。物体的运动由于帧率降低而变慢了。实践中一般不允许这种情况的发生。</p><p>解决方案是将两帧之间的间隔<strong>Time.deltaTime</strong>考虑进去。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleScript</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> distancePerSecond;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        transform.Translate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>，distancePerSecond*Time.deltaTime);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:通过乘以Time.deltaTime的运算，物体的移动不再以“每帧距离”为准，而变成了“每秒距离”。</p><p>物体移动的距离将根据每帧时间的长短而变化，从而在时间上看起来移动是匀速的。</p></blockquote><h3 id="2-1-2-物理帧率"><a href="#2-1-2-物理帧率" class="headerlink" title="2.1.2 物理帧率"></a>2.1.2 物理帧率</h3><p>与主更新函数Update不同，Unity的物理系统必须以固定的时间间隔工作，因为只有固定的时间间隔才能保证物理模拟的准确性。就算当前负载很高、帧率很低，Unity也会尽可能保证物理刷新的频率，因为如果物理刷新帧率无法保证，就可能出现不可预料的计算结果。</p><p>在主菜单的工程选项的TimeManager中可以修改物理更新的时间间隔。<br>在脚本中使用Time. fixedDeltaTime可以获得物理更新间隔。</p><p>较小的物理更新间隔会带来更高的更新频率，更准确、更细腻的运算结果，但是也会极大地增加硬件负担。<br>fixedDeltaTime 的默认值为0.02，当对物理运算的准确性非常在意时，可以考虑适当减小这个值。</p><h1 id="3-事件响应函数"><a href="#3-事件响应函数" class="headerlink" title="3. 事件响应函数"></a>3. 事件响应函数</h1><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>OnMouseEnter</td><td>鼠标移入GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseOver</td><td>鼠标停留在GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseExit</td><td>鼠标移出GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseDown</td><td>鼠标在GUI控件或者碰撞体上按下时调用</td></tr><tr><td>OnMouseUp</td><td>鼠标按键释放时调用</td></tr><tr><td>OnTriggerEnter</td><td>与其他碰撞体进入触发器时调用</td></tr><tr><td>OnTriggerExit</td><td>与其他碰撞体离开触发器时调用</td></tr><tr><td>OnTriggerStay</td><td>当其他碰撞体停留在触发器时调用</td></tr><tr><td>OnCollisionEnter</td><td>当碰撞体或者刚体与其他碰撞体或者刚体接触时调用</td></tr><tr><td>OnCollisionExit</td><td>当碰撞体或者刚体与其他碰撞体或者刚体停止接触时调用</td></tr><tr><td>OnCollisionStay</td><td>当碰撞体或者刚体与其他碰撞体或者刚体保持接触时调用</td></tr><tr><td>OnControllerColliderHit</td><td>当控制器移动时与碰撞体发生碰撞时调用</td></tr><tr><td>OnDestroy</td><td>脚本销毁时调用</td></tr><tr><td>OnGUI</td><td>渲染GUI和处理GUI消息时调用</td></tr><tr><td>OnBecameVisible</td><td>对于任意一个相机可见时调用</td></tr><tr><td>OnBecameInVisible</td><td>对于任意一个相机不可见时调用</td></tr><tr><td>OnEnable</td><td>对象启用或者激活时调用</td></tr><tr><td>OnDisable</td><td>对象禁用或者取消激活时调用</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameObject类</title>
    <link href="/2021/03/20/GameObject%E7%B1%BB/"/>
    <url>/2021/03/20/GameObject%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>GameObject 类是Unity场景中所有实体的基类。</p><p>一个GameObject对象通常由多个组件component组成，且至少含有一个transform组件。</p><p>详细可见<a href="https://blog.csdn.net/a1256242238/article/details/73189101">https://blog.csdn.net/a1256242238/article/details/73189101</a></p><h1 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h1><ul><li><p><code>public GameObject();</code></p></li><li><p><code>public GameObject(string name);</code></p></li><li><p><code>public GameObject(string name,params Type[] components);</code></p></li></ul><h1 id="3-常用成员变量"><a href="#3-常用成员变量" class="headerlink" title="3. 常用成员变量"></a>3. 常用成员变量</h1><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>继承于父类Object，对象的名称</td></tr><tr><td>tag</td><td>游戏对象的标签tag</td></tr><tr><td>layer</td><td>游戏对象所在的层layer，范围为[0…31]</td></tr><tr><td>activeSelf</td><td>游戏对象自身的激活状态</td></tr><tr><td>transform</td><td>游戏对象上的Transform组件，设置对象位置、旋转、缩放</td></tr><tr><td>rigidbody</td><td>游戏对象上的Rigidbody组件，设置物理引擎的刚体属性</td></tr><tr><td>camera</td><td>游戏对象上的Camera组件，设置相机属性</td></tr><tr><td>light</td><td>游戏对象上的Light组件，设置灯光属性</td></tr><tr><td>animation</td><td>游戏对象上的Animation组件，设置动画属性</td></tr><tr><td>renderer</td><td>游戏对象上的Renderer组件，渲染物体模型</td></tr><tr><td>audio</td><td>游戏对象上的AudioSource组件，设置声音属性</td></tr></tbody></table><h1 id="4-常用成员函数"><a href="#4-常用成员函数" class="headerlink" title="4.常用成员函数"></a>4.常用成员函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Find</td><td>静态函数，根据名称查找游戏对象</td></tr><tr><td>FindWithTag</td><td>静态函数，根据标签查找第一个符合条件的游戏对象</td></tr><tr><td>FindGameObjectsWithTag</td><td>静态函数，根据标签查找所有符合条件的游戏对象</td></tr><tr><td>CreatePrimitive</td><td>静态函数，创建一个基本形体的游戏对象（如正方体，球体等）</td></tr><tr><td>SetActive</td><td>激活/取消激活游戏对象</td></tr><tr><td>GetComponent</td><td>获取游戏对象</td></tr><tr><td>GetComponentInChildren</td><td>获取游戏对象或其子对象上指定类型的第一个组件</td></tr><tr><td>GetComponents</td><td>获取游戏对象上指定类型的所有组件</td></tr><tr><td>AddComponent</td><td>为游戏对象添加指定组件</td></tr><tr><td>SendMessage</td><td>调用游戏对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>SendMessageUpwards</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>BroadcastMessage</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>CompareTag</td><td>比较游戏对象的标签</td></tr></tbody></table><h1 id="5-继承自Object类的常用函数"><a href="#5-继承自Object类的常用函数" class="headerlink" title="5. 继承自Object类的常用函数"></a>5. 继承自Object类的常用函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Destroy</td><td>删除一个游戏物体、组件或资源</td></tr><tr><td>DestroyImmediate</td><td>立即销毁物体obj，强烈建议使用Destroy替代</td></tr><tr><td>Instantiate</td><td>克隆原始物体，并返回克隆的物体</td></tr><tr><td>DontDestroyOnLoad</td><td>加载新场景的时候使目标不被自动销毁</td></tr><tr><td>FindObjectOfType</td><td>返回Type类型第一个激活的加载的物体</td></tr></tbody></table><h2 id="5-1-Instantiate创建物体"><a href="#5-1-Instantiate创建物体" class="headerlink" title="5.1 Instantiate创建物体"></a>5.1 Instantiate创建物体</h2><p><strong>Instantiate函数</strong>专门用来创建一个新的物体，但是要提供一个预制体或者已经存在的游戏物体作为模板。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Gameobject enemy;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//以enemy为模板生成5个敌人</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-number">1</span><span class="hljs-number">-0</span>; <span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>; <span class="hljs-number">1</span>++)<br>    &#123;<br>        Instantiate(enemy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用已经存在的物体作为模板，更常见的方式是使用预制体作为模板。</p><p>创建的物体将会具有和原物体一样的组件、参数。</p><h2 id="5-2-Destroy销毁物体"><a href="#5-2-Destroy销毁物体" class="headerlink" title="5.2 Destroy销毁物体"></a>5.2 Destroy销毁物体</h2><p>可以用Destroy函数来销毁游戏物体或者组件。</p><p>例如，下面的代码会在导弹产生碰撞时销毁该导弹，第二个参数0.5f表示在0.5秒之后才执行销毁动作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span> (<span class="hljs-params">Collision otherobj</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (other0bj.gameObject.tag == <span class="hljs-string">&quot;Missile&quot;</span>)<br>    &#123;<br>        Destroy (gameObject,<span class="hljs-number">0.5f</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:由于销毁游戏物体和销毁脚本都是使用Destoy函数，所以经常 会出现误删除组件的情况。</p><p>如以下代码：</p><p><code>Destroy (this);</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在脚本中访问其他游戏物体</title>
    <link href="/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在实际的游戏开发中，脚本不仅会对当前挂载的物体进行操作，还可能会引用其他物体。<br>例如，正在追逐玩家角色的敌人角色会-直保留着对玩家角色的引用， 以便随时确定玩家角色的位置。<br>访问其他游戏物体的方法非常多，使用非常灵活，可以根据不同的情况采用不同的方式。</p><h1 id="2-常用的4种访问操作"><a href="#2-常用的4种访问操作" class="headerlink" title="2.常用的4种访问操作"></a>2.常用的4种访问操作</h1><h2 id="2-1-用属性查看器指定参数访问"><a href="#2-1-用属性查看器指定参数访问" class="headerlink" title="2.1 用属性查看器指定参数访问"></a>2.1 用属性查看器指定参数访问</h2><p>Unity中获得其他物体最简单、最直接的方式就是为脚本添加一个<code>publi Gamebiet</code>变量，不需要设置初始值。<br>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>player变量会显示在检视窗口中，默认值为空。</p><p>现在将任何物体或预制体拖曳到player变量的文本框中，就为player变量赋予了初始值。之在脚本中就可以随意使用Player这个游戏物体。<br>如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//读取player的位置并设置本物体的位置在它后方</span><br>        transform.position=player.transform.position-Vector3.forward*<span class="hljs-number">10f</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，上面说的引用其他物体时，变量类型不仅可以是<strong>GameObject</strong>或一个组件，也可以将戏物体拖到这个变量上，只要被拖曳的物体确实具有这个组件就可以。</p><p><code>public Transform playerTransform;</code></p><p>简单地说，可以用何一个组件来指代游戏物体本身。<br>这是因为组件实体具有“被游戏物体挂载”这样的性质，所通过一个游戏物体可以获得它上面的任何一个组件，通过任何一个组件也可以获得挂载该组件游戏物体。这个对应关系是明确的，因此上面的变量类型可以是组件类型，也可以将游戏物体直接拖上去。</p><p>用变量将物体联系起来的做法非常有用，特别是这种联系是持续存在、不易变化的。还可用一个数组或者列表来保存多个游戏物体。</p><blockquote><p>如果被引用的物体是游戏运行时才动态添加的，或者被引用的物体会随着游戏进行而变化事先拖曳的方式就不可行了，需要动态指定物体，下面将详细说明。</p></blockquote><h2 id="2-2-用父子关系查找子物体"><a href="#2-2-用父子关系查找子物体" class="headerlink" title="2.2 用父子关系查找子物体"></a>2.2 用父子关系查找子物体</h2><p>有时需要管理一系列同类型的游戏物体，例如一批敌人、一批寻路点、 多个障碍物等。<br>如果这时候需要对这些物体进行统一的管理或操作，就需要在脚本中用数组或容器来管理它们。</p><p>使用属性查看器指定参数访问的方法，可以将每个物体拖动到检视窗口中，但是这样做不仅低效，而且容易误操作，在物体增加、减少时还需要再次手动操作。</p><p>所以，在这种情况下是不合适的，可以用父子关系查找子物体的方法来遍历所有子物体。<br>在具体实现时，要用父物体的变换组件来查找子物体。</p><blockquote><p>物体的父子关系访问的属性都在变换组件中，而不在GameObject对象中</p></blockquote><p>以下是遍历所有子物体的例子:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WaypointManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br><span class="hljs-keyword">public</span> Transform[] waypoints;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>waypoints = <span class="hljs-keyword">new</span> Transform[transform.childCount];<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">foreach</span> (Transform t <span class="hljs-keyword">in</span> transform)<br>&#123;<br>waypoints[i++] = t;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以使用<strong>transform.Find</strong>方法指定查找某个子物体，代码如下。</p><p><code>transform.Find (&quot;Gun&quot;);</code></p><blockquote><p>由于<strong>Find函数</strong>的效率不好估计，可能会遍历所有物体才能查找到指定物体，所以如果可以在<strong>Start函数</strong>中使用，就不要在<strong>Updata函数</strong>中使用。因为<strong>start函数</strong>只执行一次而<strong>updata函数</strong>每帧都会执行。</p></blockquote><h2 id="2-3-用标签或名称查找物体"><a href="#2-3-用标签或名称查找物体" class="headerlink" title="2.3 用标签或名称查找物体"></a>2.3 用标签或名称查找物体</h2><p>使用<strong>GameObject.Find方法</strong>可以通过名称查找游戏物体。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.Find (<span class="hljs-string">&quot;ObjectName&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要用标签查找物体，那么就要用到<strong>GameObject.FindWithTag方法</strong> 或<strong>GameObject.FindGameObjectWithTag方法</strong>。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br>GameObject[] enemies;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.FindWithTag(<span class="hljs-string">&quot;Player&quot;</span>);<br>    enemies =GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;Enemy&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
      <tag>Unity常用操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL语句大全</title>
    <link href="/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/"/>
    <url>/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MYSQL语句大全"><a href="#MYSQL语句大全" class="headerlink" title="MYSQL语句大全"></a>MYSQL语句大全</h1><h2 id="0-相关知识"><a href="#0-相关知识" class="headerlink" title="0 相关知识"></a>0 相关知识</h2><ul><li><p><a href="https://blog.csdn.net/chaoyue1861/article/details/80468773">MYSQL逻辑架构</a></p></li><li><p><a href="https://blog.csdn.net/GitChat/article/details/78787837?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">MYSQL底层原理</a></p></li><li><p><a href="https://blog.csdn.net/m0_38075425/article/details/82256315?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">MySQL底层架构原理，工作流程和存储引擎的数据结构讲解</a></p></li></ul><h2 id="1-用户管理操作"><a href="#1-用户管理操作" class="headerlink" title="1 用户管理操作"></a>1 用户管理操作</h2><h3 id="1-1-添加用户"><a href="#1-1-添加用户" class="headerlink" title="1.1 添加用户"></a>1.1 添加用户</h3><ul><li><code> create user username identified by &#39;password&#39;;</code></li></ul><p>参数：用户名：username 密码：password</p><blockquote><p>用户数据存储在mysql.user表内</p></blockquote><h3 id="1-2-用户授权"><a href="#1-2-用户授权" class="headerlink" title="1.2 用户授权"></a>1.2 用户授权</h3><ul><li><code>grant privilegesCode on dbName.tableName to username@host identified by &#39;password&#39;;</code></li></ul><p>将Dbname数据库的所有操作权限都授权给了用户username。</p><p>参数：</p><p><strong>privilegesCode</strong> 权限类型<br>常用的权限类型</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>all privileges</td><td>所有权限</td></tr><tr><td>select</td><td>读取权限</td></tr><tr><td>delete</td><td>删除权限</td></tr><tr><td>update</td><td>更新权限</td></tr><tr><td>create</td><td>创建权限</td></tr><tr><td>drop</td><td>删除数据库、数据表权限</td></tr></tbody></table><p><strong>dbName.tableName</strong> 授权的库或特定表</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>授予该数据库服务器所有数据库的权限</td></tr><tr><td>dbName.*</td><td>授予dbName数据库所有表的权限</td></tr><tr><td>dbName.dbTable</td><td>授予数据库dbName中dbTable表的权限</td></tr></tbody></table><p><strong>username@’host’</strong> 授予的用户以及允许该用户登录的IP地址<br>| 参数         | 含义                 |<br>| ————– | ———————- |<br>| localhost | 只允许该用户在本地登录，不能远程登录 |<br>| % | 允许在除本机之外的任何一台机器远程登录 |<br>| 192.168.52.32 | 具体的IP表示只允许该用户从特定IP登录 |</p><ul><li><p><code> flush privileges;</code></p><p>刷新权限变更</p></li><li><p><code> show grants for &#39;username&#39;;</code></p></li></ul><p>查看用户的已有权限</p><blockquote><p>用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush privileges;<br></code></pre></td></tr></table></figure><p>上面的语句将zhangsanDb数据库的所有操作权限都授权给了用户zhangsan</p></blockquote><ul><li><p><code>REVOKE DELETE ON *.* FROM &#39;test&#39;@&#39;localhost&#39;;</code> </p><p>取消该用户的删除权限</p></li></ul><blockquote><p>用户权限数据存储在mysql.db表内</p></blockquote><h3 id="1-3-修改密码"><a href="#1-3-修改密码" class="headerlink" title="1.3 修改密码"></a>1.3 修改密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update mysql.user set password &#x3D; password(&#39;newpassword&#39;) where user &#x3D; &#39;username&#39; and host &#x3D; &#39;%&#39;; <br>flush privileges;<br></code></pre></td></tr></table></figure><h3 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a>1.4 删除用户</h3><ul><li><code>drop user zhangsan@&#39;%&#39;;</code></li></ul><h3 id="1-5-常用命令组"><a href="#1-5-常用命令组" class="headerlink" title="1.5 常用命令组"></a>1.5 常用命令组</h3><p><strong>创建用户并授予指定数据库全部权限：适用于Web应用创建MySQL用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user zhangsan identified by &#39;zhangsan&#39;;<br>grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush  privileges;<br></code></pre></td></tr></table></figure><p>创建了用户zhangsan，并将数据库zhangsanDB的所有权限授予zhangsan。如果要使zhangsan可以从本机登录，那么可以多赋予localhost权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;localhost&#39; identified by &#39;zhangsan&#39;;<br></code></pre></td></tr></table></figure><h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2 数据库操作"></a>2 数据库操作</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code> show database;</code></td><td>查看所有的数据库</td></tr><tr><td><code>create database DBname;</code></td><td>创建该数据库</td></tr><tr><td><code>drop DBname;</code></td><td>删除该数据库</td></tr><tr><td><code>use DBname;</code></td><td>使用调用该数据库</td></tr></tbody></table><h2 id="3-表操作"><a href="#3-表操作" class="headerlink" title="3 表操作"></a>3 表操作</h2><h3 id="3-1-表的基础操作"><a href="#3-1-表的基础操作" class="headerlink" title="3.1 表的基础操作"></a>3.1 表的基础操作</h3><ul><li><p><code>show tables;</code><br>查看所有的表</p></li><li><p><code>SHOW TABLE STATUS;</code><br>查看所有的表信息（包括视图）</p></li><li><p><code> create table TBname(mode);</code></p><p>创建一个表</p><blockquote><p>例如<br><code>create table n(id INT, name VARCHAR(10));</code></p></blockquote></li><li><p><code> create table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的表</p></li><li><p><code>create table TBname like TBname;</code><br>新创建的表与一个存在的表的数据结构类似</p></li><li><p><code>create temporay table TBname(mode);</code><br>创建一个临时表</p><blockquote><p>临时表将在你连接MySQL期间存在。当断开连接时，MySQL将自动删除表并释放所用的空间。也可手动删除。</p></blockquote></li></ul><ul><li><p><code>create temporary table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的临时表</p></li><li><p><code> drop table if exists TBname;</code><br>删除一个存在表</p></li><li><pre><code>alter table TBname rename TBname;或rename TBname to TBname;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  更改存在表的名称<br><br>  <br>  <br>- ``` <br>  <span class="hljs-keyword">desc</span> TBname;<br>  describe TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">in</span> TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> TBname;<br>  <span class="hljs-keyword">explain</span> TBname;<br></code></pre></td></tr></table></figure>查看表的结构(以上五条语句效果相同）</code></pre></li><li><p><code> show create table TBname;</code><br>查看表的创建语句</p><h3 id="3-2-表的结构操作"><a href="#3-2-表的结构操作" class="headerlink" title="3.2 表的结构操作"></a>3.2 表的结构操作</h3></li></ul><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td><code> alter table TBname add Fieldname mode;</code></td><td>添加字段</td></tr><tr><td><code>alter table TBname drop Fieldname;</code></td><td>删除字段</td></tr><tr><td><code>alter table TBname change Fieldname mode;</code></td><td>更改字段属性</td></tr><tr><td><code>alter table TBname change Fieldname Fieldname mode;</code></td><td>更改字段名与属性</td></tr></tbody></table><h3 id="3-3-表的数据操作"><a href="#3-3-表的数据操作" class="headerlink" title="3.3 表的数据操作"></a>3.3 表的数据操作</h3><ul><li><p>增加数据</p><p><code>INSERT INTO n VALUES (1, &#39;tom&#39;, &#39;23&#39;), (2, &#39;john&#39;, &#39;22&#39;);</code></p><p><code>INSERT INTO n SELECT * FROM n;</code>  把数据复制一遍重新插入</p></li><li><p>删除数据</p><p><code>DELETE FROM n WHERE id = 2;</code></p></li><li><p>更改数据</p><p><code>UPDATE n SET name = &#39;tom&#39; WHERE id = 2;</code></p></li><li><p>数据查找</p><p><code>SELECT * FROM n WHERE name LIKE &#39;%h%&#39;;</code></p></li><li><p>数据排序(反序)</p><p><code>SELECT * FROM n ORDER BY name, id DESC ;</code></p></li></ul><blockquote><p>增删改查请看：<a href="https://www.cnblogs.com/heyangblog/p/7624645.html">https://www.cnblogs.com/heyangblog/p/7624645.html</a></p></blockquote><h2 id="4-键"><a href="#4-键" class="headerlink" title="4 键"></a>4 键</h2><h3 id="4-1-添加主键"><a href="#4-1-添加主键" class="headerlink" title="4.1 添加主键"></a>4.1 添加主键</h3><ul><li><p><code>ALTER TABLE TBname ADD PRIMARY KEY (id);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT pk_n PRIMARY KEY (id);</code>  </p><p>添加主键的同时自定义键名</p></li></ul><h3 id="4-2-删除主键"><a href="#4-2-删除主键" class="headerlink" title="4.2 删除主键"></a>4.2 删除主键</h3><ul><li><code> ALTER TABLE TBname DROP PRIMARY KEY ;</code></li></ul><h3 id="4-3-添加外键"><a href="#4-3-添加外键" class="headerlink" title="4.3 添加外键"></a>4.3 添加外键</h3><ul><li><p><code>ALTER TABLE TBname ADD FOREIGN KEY (id) REFERENCES TBname(id);</code>   </p><p>自动生成键名m_ibfk_1</p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES TBname(id); </code>  </p><p>使用定义的键名fk_id</p></li></ul><h3 id="4-4-删除外键"><a href="#4-4-删除外键" class="headerlink" title="4.4 删除外键"></a>4.4 删除外键</h3><ul><li>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</li></ul><h3 id="4-5-修改外键"><a href="#4-5-修改外键" class="headerlink" title="4.5 修改外键"></a>4.5 修改外键</h3><ul><li><p>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</p><p>ADD CONSTRAINT fk_id2 FOREIGN KEY (id) REFERENCES TBname(id); </p><p>删除之后从新建</p></li></ul><h3 id="4-6-添加唯一键"><a href="#4-6-添加唯一键" class="headerlink" title="4.6 添加唯一键"></a>4.6 添加唯一键</h3><ul><li><p><code> ALTER TABLE TBname ADD UNIQUE (name);</code></p></li><li><p><code> ALTER TABLE TBname ADD UNIQUE u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD UNIQUE INDEX u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT u_name UNIQUE (name);</code></p></li><li><p><code>CREATE UNIQUE INDEX u_name ON TBname(name);</code></p></li></ul><h3 id="4-7-添加索引"><a href="#4-7-添加索引" class="headerlink" title="4.7 添加索引"></a>4.7 添加索引</h3><ul><li><p><code>ALTER TABLE TBname ADD INDEX (age);</code></p></li><li><p><code>ALTER TABLE TBname ADD INDEX i_age (age);</code></p></li><li><p><code>CREATE INDEX i_age ON TBname(age);</code></p></li></ul><h3 id="4-8-删除索引或唯一键"><a href="#4-8-删除索引或唯一键" class="headerlink" title="4.8 删除索引或唯一键"></a>4.8 删除索引或唯一键</h3><ul><li><p><code>DROP INDEX u_name ON n;</code></p></li><li><p><code>DROP INDEX i_age ON n;</code></p></li></ul><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5 视图"></a>5 视图</h2><h3 id="5-1-创建视图"><a href="#5-1-创建视图" class="headerlink" title="5.1 创建视图"></a>5.1 创建视图</h3><ul><li><p><code>CREATE VIEW v AS SELECT id, name FROM n;</code></p></li><li><p><code>CREATE VIEW v(id, name) AS SELECT id, name FROM n;</code></p></li></ul><h3 id="5-2查看视图"><a href="#5-2查看视图" class="headerlink" title="5.2查看视图"></a>5.2查看视图</h3><ul><li><p><code>SELECT * FROM v;</code></p></li><li><p><code>DESC v;</code></p></li></ul><blockquote><p>与表操作类似</p></blockquote><h3 id="5-3查看创建视图语句"><a href="#5-3查看创建视图语句" class="headerlink" title="5.3查看创建视图语句"></a>5.3查看创建视图语句</h3><ul><li><code>SHOW CREATE VIEW v;</code></li></ul><h3 id="5-4-更改视图"><a href="#5-4-更改视图" class="headerlink" title="5.4 更改视图"></a>5.4 更改视图</h3><ul><li><p><code>CREATE OR REPLACE VIEW v AS SELECT name, age FROM n;</code></p></li><li><p><code>ALTER VIEW v AS SELECT name FROM n ;</code></p></li></ul><h3 id="5-5-删除视图"><a href="#5-5-删除视图" class="headerlink" title="5.5 删除视图"></a>5.5 删除视图</h3><ul><li><code>DROP VIEW IF EXISTS v;</code></li></ul><h2 id="6-联接"><a href="#6-联接" class="headerlink" title="6 联接"></a>6 联接</h2><h3 id="6-1-内联接"><a href="#6-1-内联接" class="headerlink" title="6.1 内联接"></a>6.1 内联接</h3><ul><li><code>SELECT * FROM m INNER JOIN n ON m.id = n.id;</code></li></ul><h3 id="6-2-外连接"><a href="#6-2-外连接" class="headerlink" title="6.2 外连接"></a>6.2 外连接</h3><ul><li><code>SELECT * FROM m LEFT JOIN n ON m.id = n.id;</code>左外连接</li><li><code>SELECT * FROM m RIGHT JOIN n ON m.id = n.id;</code>右外连接</li></ul><h3 id="6-3-交叉联接"><a href="#6-3-交叉联接" class="headerlink" title="6.3 交叉联接"></a>6.3 交叉联接</h3><ul><li><p><code>SELECT * FROM m CROSS JOIN n;</code>  标准写法</p></li><li><p><code>SELECT * FROM m, n;</code></p></li></ul><h3 id="6-4-类似全连接full-join的联接用法"><a href="#6-4-类似全连接full-join的联接用法" class="headerlink" title="6.4 类似全连接full join的联接用法"></a>6.4 类似全连接full join的联接用法</h3><ul><li><pre><code>SELECT id,name FROM mUNIONSELECT id,name FROM n;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs sql">## <span class="hljs-number">7</span> 函数<br><br>### <span class="hljs-number">7.1</span> 聚合函数<br><br><span class="hljs-operator">|</span> 语句                               <span class="hljs-operator">|</span> 含义   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">---------------------------------- | ------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(id) <span class="hljs-keyword">AS</span> total <span class="hljs-keyword">FROM</span> n;  <span class="hljs-operator">|</span> 总数   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 总和   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 平均值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">max</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最大值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最小值 <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.2</span> 数学函数<br><br><span class="hljs-operator">|</span> 语句                              <span class="hljs-operator">|</span> 含义                                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">--------------------------------- | ------------------------------------------------------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">abs</span>(<span class="hljs-number">-5</span>);                   <span class="hljs-operator">|</span> 绝对值                                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> bin(<span class="hljs-number">15</span>), oct(<span class="hljs-number">15</span>), hex(<span class="hljs-number">15</span>); <span class="hljs-operator">|</span> 二进制，八进制，十六进制                               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> pi();                      <span class="hljs-operator">|</span> 圆周率<span class="hljs-number">3.141593</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">5.5</span>);                 <span class="hljs-operator">|</span> 大于x的最小整数值<span class="hljs-number">6</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">5.5</span>);                <span class="hljs-operator">|</span> 小于x的最大整数值<span class="hljs-number">5</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> greatest(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>); <span class="hljs-operator">|</span> 返回集合中最大的值<span class="hljs-number">9</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> least(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);    <span class="hljs-operator">|</span> 返回集合中最小的值<span class="hljs-number">1</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);                  <span class="hljs-operator">|</span> 余数<span class="hljs-number">2</span>                                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand();                    <span class="hljs-operator">|</span> 返回０到１内的随机值，每次不一样                       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 提供一个参数(种子)使RAND()随机数生成器生成一个指定的值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>);          <span class="hljs-operator">|</span> 四舍五入<span class="hljs-number">1415</span>                                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);       <span class="hljs-operator">|</span> 四舍五入三位数<span class="hljs-number">1415.142</span>                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);      <span class="hljs-operator">|</span> 四舍五入整数位数<span class="hljs-number">1420</span>                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);    <span class="hljs-operator">|</span> 截短为<span class="hljs-number">3</span>位小数<span class="hljs-number">1415.141</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);   <span class="hljs-operator">|</span> 截短为<span class="hljs-number">-1</span>位小数<span class="hljs-number">1410</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">-5</span>);                  <span class="hljs-operator">|</span> 符号的值负数<span class="hljs-number">-1</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 符号的值正数<span class="hljs-number">1</span>                                          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">9</span>);                   <span class="hljs-operator">|</span> 平方根<span class="hljs-number">3</span>                                                <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.3</span> 字符串函数<br><br><span class="hljs-operator">|</span> 语句                                        <span class="hljs-operator">|</span> 含义                                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------- | ------------------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>);         <span class="hljs-operator">|</span> 连接字符串<span class="hljs-operator">-</span>apple                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>); <span class="hljs-operator">|</span> 连接用<span class="hljs-string">&#x27;,&#x27;</span>分割字符串<span class="hljs-operator">-</span>a,p,p,le                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">insert</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;IN&#x27;</span>);       <span class="hljs-operator">|</span> 将字符串<span class="hljs-string">&#x27;chinese&#x27;</span>从<span class="hljs-number">3</span>位置开始的<span class="hljs-number">2</span>个字符替换为<span class="hljs-string">&#x27;IN&#x27;</span><span class="hljs-operator">-</span>chINese <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">left</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">4</span>);                  <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>左边的<span class="hljs-number">4</span>个字符<span class="hljs-operator">-</span>chin                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">right</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);                 <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>右边的<span class="hljs-number">3</span>个字符<span class="hljs-operator">-</span>ese                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);             <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的子字符串<span class="hljs-operator">-</span>inese       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">-3</span>);            <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>倒数第三个字符之后的子字符串<span class="hljs-operator">-</span>ese     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);          <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的两个字符<span class="hljs-operator">-</span><span class="hljs-keyword">in</span>          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27; chinese &#x27;</span>);                   <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese&#x27;</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ltrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese &#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rtrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27; chinese&#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> repeat(<span class="hljs-string">&#x27;boy&#x27;</span>, <span class="hljs-number">3</span>);                    <span class="hljs-operator">|</span> 重复字符<span class="hljs-string">&#x27;boy&#x27;</span>三次<span class="hljs-operator">-</span><span class="hljs-string">&#x27;boyboyboy&#x27;</span>                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> reverse(<span class="hljs-string">&#x27;chinese&#x27;</span>);                  <span class="hljs-operator">|</span> 反向排序<span class="hljs-operator">-</span><span class="hljs-string">&#x27;esenihc&#x27;</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> length(<span class="hljs-string">&#x27;chinese&#x27;</span>);                   <span class="hljs-operator">|</span> 返回字符串的长度<span class="hljs-number">-7</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>), <span class="hljs-built_in">lower</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ucase(<span class="hljs-string">&#x27;chINese&#x27;</span>), lcase(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;i&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-3</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;e&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-5</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abd&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数小于第二个返回负数<span class="hljs-operator">-</span> <span class="hljs-number">-1</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abb&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数大于第二个返回正数<span class="hljs-operator">-</span> <span class="hljs-number">1</span>             <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.4</span> 时间函数<br><br><span class="hljs-operator">|</span> 语句                                                         <span class="hljs-operator">|</span> 含义                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------------------------ | -------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">current_date</span>, <span class="hljs-built_in">current_time</span>, now();                    <span class="hljs-operator">|</span> <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span>   <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span>    <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span> <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">hour</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">minute</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">second</span>(<span class="hljs-built_in">current_time</span>); <span class="hljs-operator">|</span> <span class="hljs-number">12</span>  <span class="hljs-number">31</span>   <span class="hljs-number">34</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">year</span>(<span class="hljs-built_in">current_date</span>), <span class="hljs-keyword">month</span>(<span class="hljs-built_in">current_date</span>), week(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">2018</span>    <span class="hljs-number">1</span>   <span class="hljs-number">1</span>                                <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> quarter(<span class="hljs-built_in">current_date</span>);                                <span class="hljs-operator">|</span> <span class="hljs-number">1</span>                                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> monthname(<span class="hljs-built_in">current_date</span>), dayname(<span class="hljs-built_in">current_date</span>);       <span class="hljs-operator">|</span> January  Saturday                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> dayofweek(<span class="hljs-built_in">current_date</span>), dayofmonth(<span class="hljs-built_in">current_date</span>), dayofyear(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">7</span>   <span class="hljs-number">13</span>  <span class="hljs-number">13</span>                                   <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.5</span> 控制流函数<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> if(<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>), if(<span class="hljs-number">3</span><span class="hljs-operator">&lt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>);`    <br><br>  t f<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> ifnull(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;t&#x27;</span>), ifnull(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>);`    <br><br>  t <span class="hljs-number">2</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> isnull(<span class="hljs-number">1</span>), isnull(<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>);`    <br><br>   <span class="hljs-number">0</span> <span class="hljs-number">1</span> 是<span class="hljs-keyword">null</span>返回<span class="hljs-number">1</span>，不是<span class="hljs-keyword">null</span>返回<span class="hljs-number">0</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);`    <br><br>  <span class="hljs-keyword">null</span> a 参数相同或成立返回<span class="hljs-keyword">null</span>，不同或不成立则返回第一个参数<br><br><span class="hljs-operator">-</span> ```<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-number">2</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;first&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;second&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;third&#x27;</span><br>         <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;other&#x27;</span><br>         <span class="hljs-keyword">END</span> ;     <br></code></pre></td></tr></table></figure>second&gt; 这一块不是完全看不懂吗！</code></pre></li></ul><h1 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h1><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td>SELECT database();</td><td>当前数据库名-test</td></tr><tr><td>SELECT connection_id();</td><td>当前用户id-306</td></tr><tr><td>SELECT user();</td><td>当前用户-root@localhost</td></tr><tr><td>SELECT version();</td><td>当前mysql版本</td></tr><tr><td>SELECT found_rows();</td><td>返回上次查询的检索行数</td></tr></tbody></table><h2 id="8-存储过程"><a href="#8-存储过程" class="headerlink" title="8 存储过程"></a>8 存储过程</h2><h3 id="8-1-创建存储过程"><a href="#8-1-创建存储过程" class="headerlink" title="8.1 创建存储过程"></a>8.1 创建存储过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">DELIMITER <span class="hljs-comment">//    # 无参数</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> ;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_2</span><span class="hljs-params">(<span class="hljs-keyword">IN</span> id INT)</span>    # <span class="hljs-title">in</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> <span class="hljs-title">WHERE</span> <span class="hljs-title">a</span> = <span class="hljs-title">id</span>;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_3</span><span class="hljs-params">(<span class="hljs-keyword">OUT</span> sum INT)</span>    # <span class="hljs-title">out</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">sum</span> = <span class="hljs-params">(<span class="hljs-keyword">SELECT</span> count(*)</span> <span class="hljs-title">FROM</span> <span class="hljs-title">test</span>);</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_4</span><span class="hljs-params">(INOUT i INT)</span>    # <span class="hljs-title">inout</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">i</span> = <span class="hljs-title">i</span> + 1;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="8-2-删除存储过程"><a href="#8-2-删除存储过程" class="headerlink" title="8.2 删除存储过程"></a>8.2 删除存储过程</h3><ul><li><code>DROP PROCEDURE IF EXISTS getDates;</code></li></ul><h3 id="8-3-修改存储过程的特性"><a href="#8-3-修改存储过程的特性" class="headerlink" title="8.3 修改存储过程的特性"></a>8.3 修改存储过程的特性</h3><ul><li><code>ALTER PROCEDURE getDates MODIFIES SQL DATA ;</code></li></ul><h3 id="8-4-查看存储过程"><a href="#8-4-查看存储过程" class="headerlink" title="8.4 查看存储过程"></a>8.4 查看存储过程</h3><ul><li><p><code>SHOW PROCEDURE STATUS LIKE &#39;getDates&#39;;</code>    </p><p> 状态</p></li><li><p><code>SHOW CREATE PROCEDURE getDates_3;</code> </p><p> 语句</p></li></ul><h3 id="8-5-调用存储过程"><a href="#8-5-调用存储过程" class="headerlink" title="8.5 调用存储过程"></a>8.5 调用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> getDates();<br><span class="hljs-keyword">CALL</span> getDates_2(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">CALL</span> getDates_3(<span class="hljs-variable">@s</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@s</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">CALL</span> getDates_4(<span class="hljs-variable">@i</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@i</span>;    # <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="9-数据库安全"><a href="#9-数据库安全" class="headerlink" title="9 数据库安全"></a>9 数据库安全</h2><h3 id="9-1-数据库备份"><a href="#9-1-数据库备份" class="headerlink" title="9.1 数据库备份"></a>9.1 数据库备份</h3><ul><li><pre><code>mysqldump -u root -p db_name &gt; file.sqlmysqldump -u root -p db_name table_name &gt; file.sql</code></pre><h3 id="9-2数据库还原"><a href="#9-2数据库还原" class="headerlink" title="9.2数据库还原"></a>9.2数据库还原</h3></li><li><code>mysql -u root -p &lt; C:\file.sql</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>数据库</tag>
      
      <tag>MYSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量基础知识</title>
    <link href="/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在数学中，几何向量（也称为欧几里得向量，通常简称向量、矢量），指具有大小和方向的量。</p><p>向量可以形象化地表示为带箭头的线段。</p><p>箭头所指：代表向量的方向；线段长度：代表向量的大小。</p><p>标量：只有大小,没有方向。</p><h1 id="2-向量的运算"><a href="#2-向量的运算" class="headerlink" title="2. 向量的运算"></a>2. 向量的运算</h1><h2 id="2-1-基础运算"><a href="#2-1-基础运算" class="headerlink" title="2.1 基础运算"></a>2.1 基础运算</h2><table><thead><tr><th>运算</th><th>描述</th></tr></thead><tbody><tr><td>加减</td><td>各个分量分别相加减</td></tr><tr><td>数乘</td><td>向量与标量的乘数，可以对向量的长度进行缩放，如果标量&gt;0，向量的方向不变，如果&lt;0,向量的方向为反方向</td></tr></tbody></table><h2 id="2-2-点乘（点积）"><a href="#2-2-点乘（点积）" class="headerlink" title="2.2 点乘（点积）"></a>2.2 点乘（点积）</h2><p>两个向量点乘得到一个标量 ，数值等于两个向量长度相乘后再乘以二者夹角的余弦值 。<br>如果两个向量a,b均 为单位 向量 ,那么a.b等于向量b在向量a方向上的投影的长度</p><p>点乘后得到的是一个值</p><ul><li><p>若结果 == 0，则 两向量 互垂直 </p></li><li><p>若结果 &lt; 0 ，则 两向量夹角大于90°</p></li><li><p>若结果 &gt;0 ，则两向量夹角小于 90°</p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E4%B9%98.png" srcset="/img/loading.gif" alt="点乘"></p></li></ul><blockquote><p>两个单位向量的点积得到两个向量的夹角的cos值，通过它可以知道两个向量的相似性。</p></blockquote><blockquote><p>利用点积可判断一个多边形是否面向摄像机还是背向摄像机。</p></blockquote><blockquote><p>如果点积越大，说明夹角越小，则物理离光照的轴线越近，光照越强。</p></blockquote><h2 id="2-3-叉乘"><a href="#2-3-叉乘" class="headerlink" title="2.3 叉乘"></a>2.3 叉乘</h2><p>两个向量的叉乘得到一个新的向量，新向量垂直于原来两个向量，并且长度等于原向量长度相乘后再乘以夹角的正弦值，类似左手坐标系Z。</p><p>在Unity3D里面。两个向量的点乘所得到的是两个向量的余弦值，也就是-1 到1之间，0表示垂直，-1表示相反，1表示相同方向。 </p><p>两个向量的叉乘所得到的是两个向量所组成的面的垂直向量，分两个方向。 </p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8F%89%E4%B9%98.png" srcset="/img/loading.gif" alt="叉乘"></p><blockquote><p>简单的说，点乘判断角度，叉乘判断方向。 </p><p>形象的说当一个敌人在你身后的时候，叉乘可以判断你是往左转还是往右转更好的转向敌人，点乘得到你当前的面朝向的方向和你到敌人的方向的所成的角度大小。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>跨专业知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
      <tag>跨专业知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vector3类</title>
    <link href="/2021/02/21/Vector3%E7%B1%BB/"/>
    <url>/2021/02/21/Vector3%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Vector3是结构体,Vector3类在Unity中一般用于表示3D向量和三维坐标点。</p><h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2. 属性"></a>2. 属性</h1><h2 id="2-1静态成员变量"><a href="#2-1静态成员变量" class="headerlink" title="2.1静态成员变量"></a>2.1静态成员变量</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>right</code>（右）</td><td>代表坐标轴（1,0,0）</td></tr><tr><td><code>left</code> （左）</td><td>代表坐标轴（-1,0,0）</td></tr><tr><td><code>up</code>（上）</td><td>代表坐标轴（0,1,0）</td></tr><tr><td><code>down</code>（下）</td><td>代表坐标轴（0,-1,0）</td></tr><tr><td><code>forward</code>  （前）</td><td>代表坐标轴（0,0,1）</td></tr><tr><td><code>back</code>（后）</td><td>代表坐标轴（0,0,-1）</td></tr><tr><td><code>zero</code>（零）</td><td>代表坐标轴（0,0,0）</td></tr><tr><td><code>one</code>（一）</td><td>代表坐标轴（1,1,1）</td></tr></tbody></table><h2 id="2-2-实例成员变量"><a href="#2-2-实例成员变量" class="headerlink" title="2.2 实例成员变量"></a>2.2 实例成员变量</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Magnitude</code></td><td>返回向量的长度，向量的长度是(x<em>x+y</em>y+z*z)的平方根（只读）</td></tr><tr><td><code>Normalized</code></td><td>返回一个归一化的新向量，原向量长度不变</td></tr><tr><td><code>sqrMagnitude</code></td><td>返回向量的长度的平方（只读）</td></tr></tbody></table><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><h2 id="3-1-静态方法"><a href="#3-1-静态方法" class="headerlink" title="3.1 静态方法"></a>3.1 静态方法</h2><table><thead><tr><th>方法名称</th><th>方法体</th><th>描述</th></tr></thead><tbody><tr><td><code>Angle</code></td><td><code>public static float Angle(Vector3 from, Vector3 to);</code></td><td>此方法用于返回向量from和to的夹角，单位为角度，返回值范围为[0,180]，且当from和to中至少有一个为Vector3.zero时，方法返回值为90</td></tr><tr><td><code>ClampMagnitude</code></td><td><code>public static Vector3 ClampMagnitude(Vector3 vector, float maxLength);</code></td><td>此方法用于返回向量vector的一个同方向向量，模长受maxLength限制</td></tr><tr><td><code>Cross</code></td><td><code>public static Vector3 Cross(Vector3 Ihs,Vecxtor3 rhs);</code></td><td>向量叉乘</td></tr><tr><td><code>Dot</code></td><td><code>public static float Dot(Vector3 Ihs, Vector3 rhs);</code></td><td>向量点乘</td></tr><tr><td><code>Lerp</code></td><td><code>public static Vector3 Lerp(Vector3 from, Vector3 to, float t);</code></td><td>参数from为差值起始点坐标，参数to为插值结束点坐标，参数t为插值系数</td></tr><tr><td><code>MoveTowards</code></td><td><code>public static Vector3 MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta);</code></td><td>此方法用于返回一个从参数current到参数target的差值向量</td></tr><tr><td><code>OrthoNormalize</code></td><td><code>public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent);</code></td><td>此方法用于对向量normal进行单位化处理，并对tangent进行正交化处理。即normal变成单位向量，tangent变成与该单位向量垂直的模长为1的向量，且这些向量处于同一平面</td></tr><tr><td><code>OrthoNormalize</code></td><td><code>public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent, ref Vector3 binormal);</code></td><td>此方法用于对向量normal进行单位化处理，并对向量tangent和binormal进行正交化处理，于上面两个参数的重载相同，binormal垂直于normal和tangent组成的平面</td></tr><tr><td><code>Project</code></td><td><code>public static Vector3 Project(Vector3 vector, Vector3 onNormal);</code></td><td>此方法用于返回向量vector在向量onNormal上的投影向量</td></tr><tr><td><code>Reflect</code></td><td><code>public static Vector3 Reflect(Vector3 inDirection, Vector3 inNormal);</code></td><td>参数inDirection为入射向量，inNormal为镜面向量。参数inNormal向量必须为单位向量，否则入射角和反射角不相等。当inNormal取反时，反射向量不受影响</td></tr><tr><td><code>RotateTowards</code></td><td><code>public static Vector3 RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)</code></td><td>参数current为起始点坐标，参数target为目标点坐标，参数maxRadiansDelta为角度旋转系数，参数maxMagnitudeDelta为模长系数</td></tr><tr><td><code>Scale</code></td><td><code>public static Vector3 Scale(Vector3 a, Vector3 b);</code></td><td>此方法返回向量a和b的乘积</td></tr><tr><td><code>Slerp</code></td><td><code>public static Vector3 Slerp(Vector3 from, Vector3 to, float t);</code></td><td>参数from为插值起始点坐标，参数to为插值结束点坐标，参数t为插值系数。此方法用于返回从参数from点到参数to点的球形差值向量。</td></tr><tr><td><code>SmoothDamp</code></td><td>见下</td><td>见下</td></tr></tbody></table><p> <code>SmoothDamp</code>方法：阻尼运动</p><ul><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime);</code></p></li><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed);</code></p></li><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed, float maxSpeed);</code></p></li><li><p>参数表</p></li></ul><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td><code>current</code></td><td>起点坐标</td></tr><tr><td><code>target</code></td><td>终点坐标</td></tr><tr><td><code>currentVelocity</code></td><td>当前帧移动向量</td></tr><tr><td><code>smoothTime</code></td><td>接近目标时的阻尼强度</td></tr><tr><td><code>maxSpeed</code></td><td>最大移动速度，默认值为无穷大</td></tr><tr><td><code>deltaTime</code></td><td>控制当前帧实际移动的距离，即为maxSpeed*deltaTime，默认值为Time.deltaTime。</td></tr></tbody></table><h2 id="3-2-实例方法"><a href="#3-2-实例方法" class="headerlink" title="3.2 实例方法"></a>3.2 实例方法</h2><p><code>Scale</code>方法：向量放缩</p><p><code>public void Scale(Vector3 scale);</code></p><p>此方法可以对Vector3实例按参考向量scale进行放缩，即分量依次相乘。</p><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h1><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code></td><td>向量相加</td></tr><tr><td><code>-</code></td><td>向量相减</td></tr><tr><td><code>*</code></td><td>向量乘以标量</td></tr><tr><td><code>/ </code></td><td>向量除以标量</td></tr><tr><td><code>==</code></td><td>若向量相等返回true</td></tr><tr><td><code>!=</code></td><td>若向量不等于则返回true</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vector2类</title>
    <link href="/2021/02/21/Vector2%E7%B1%BB/"/>
    <url>/2021/02/21/Vector2%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Vector2类在Unity中一般用于表示2D向量和二维坐标点。</p><p>例如<a href="https://docs.unity3d.com/530/Documentation/ScriptReference/Mesh.html">Mesh</a>（纹理坐标）或<a href="https://docs.unity3d.com/530/Documentation/ScriptReference/Material.html">Material</a>（纹理偏移）。</p><h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h1><h2 id="2-1-静态属性"><a href="#2-1-静态属性" class="headerlink" title="2.1 静态属性"></a>2.1 静态属性</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>down</code></td><td>Vector2（0，-1）的简写</td></tr><tr><td><code>left</code></td><td>Vector2（-1，0）的简写</td></tr><tr><td><code>one</code></td><td>Vector2（1，1）的简写</td></tr><tr><td><code>right</code></td><td>Vector2（1，0）的简写</td></tr><tr><td><code>up</code></td><td>Vector2（0，1）的简写</td></tr><tr><td><code>zero</code></td><td>Vector2（0，0）的简写</td></tr></tbody></table><h2 id="2-2-普通属性"><a href="#2-2-普通属性" class="headerlink" title="2.2 普通属性"></a>2.2 普通属性</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>magnitude</td><td>返回此向量的长度（只读）</td></tr><tr><td>normalized</td><td>返回此向量的归一化（只读）</td></tr><tr><td>sqrMagnitude</td><td>返回此向量的平方长度（只读）</td></tr><tr><td>this[int]</td><td>分别使用[0]或[1]访问x或y分量</td></tr><tr><td><code>x</code></td><td>向量的X分量</td></tr><tr><td><code>y</code></td><td>向量的Y分量</td></tr></tbody></table><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><h2 id="3-1-静态方法"><a href="#3-1-静态方法" class="headerlink" title="3.1 静态方法"></a>3.1 静态方法</h2><table><thead><tr><th>方法名称</th><th>描述</th><th>方法体</th></tr></thead><tbody><tr><td><code>Angle</code></td><td>返回两向量夹角，参数from为起始向量，to为结束向量。此方法用于返回两个Vector2实例的夹角，单位为角度，返回值的取值范围为[0,180]，并且当from和to中至少有一个向量为Vector2.zero的时候返回值为90</td><td><code>public static float Angle(Vector2 from, Vector2 to);</code></td></tr><tr><td><code>ClampMagnitude</code></td><td>此方法用于返回向量的长度，且最大不超过maxLength</td><td><code>public static Vector2 ClampMagnitude(Vector2 vector, float maxLength);</code></td></tr><tr><td><code>Distance</code></td><td>返回两个向量间的距离</td><td></td></tr><tr><td><code>Dot</code></td><td>返回两个向量的点积</td><td></td></tr><tr><td><code>Lerp</code></td><td>向量差值，参数from为插值的起始向量，参数to为插值的结束向量，参数t为插值系数</td><td><code>public static Vector2 Lerp(Vector from, Vector2 to, float t);</code></td></tr><tr><td><code>LerpUnclamped</code></td><td>返回向量在向量a和b之间线性插值t</td><td></td></tr><tr><td><code>Max</code></td><td>返回由两个向量的最大分量组成的向量</td><td></td></tr><tr><td><code>Min</code></td><td>返回由两个向量的最小分量构成的向量</td><td></td></tr><tr><td><code>MoveTowards</code></td><td>向量差值，参数current为移动起始点坐标，参数target为移动目标点，参数maxDistanceDelta为移动的参考系数。</td><td><code>public static Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta);</code></td></tr><tr><td><code>Reflect</code></td><td>返回从法线定义的向量上反射向量</td><td></td></tr><tr><td><code>Scale</code></td><td>向量放缩，此方法用于返回向量a按向量b进行放缩后的值，即向量a，b的乘积</td><td></td></tr><tr><td><code>SmoothDamp</code></td><td>无法理解</td><td></td></tr></tbody></table><blockquote><p><a href="https://blog.csdn.net/andyhebear/article/details/51818534">MoveTowards、Lerp、Slerp三个函数的解析</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/e5b06b7be721">差值函数Lerp和SmoothDamp的解析</a></p></blockquote><h2 id="3-2-公有方法"><a href="#3-2-公有方法" class="headerlink" title="3.2 公有方法"></a>3.2 公有方法</h2><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Normalize</code></td><td>单位化Vector2实例。此方法改变了原始向量，无返回值。实例属性normalized与此方法功能相同，但使用属性normalized来单位化向量时，不改变原始向量值，且有返回值。</td></tr><tr><td><code>Set</code></td><td>设置向量的x,y值</td></tr><tr><td><code>ToString</code></td><td>返回字符串</td></tr></tbody></table><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h1><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>-</code></td><td>向量相减</td></tr><tr><td><code>!=</code></td><td>向量不同，则返回true</td></tr><tr><td><code>*</code></td><td>向量乘以数字</td></tr><tr><td><code>/</code></td><td>向量除以数字</td></tr><tr><td><code>+</code></td><td>向量相加</td></tr><tr><td><code>=</code></td><td>向量相等，则返回true</td></tr><tr><td><code>Vector2</code></td><td>将Vector3转换为Vector2</td></tr><tr><td><code>Vector3</code></td><td>将Vector2转换为Vector3</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transform类</title>
    <link href="/2021/02/19/Transform%E7%B1%BB/"/>
    <url>/2021/02/19/Transform%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><strong>Transform</strong>组件是Unity3D的重点之一，主要用于控制物体的旋转、移动、缩放。</p><p><strong>Unity</strong>规定所有游戏物体都必须<strong>有且只有一个</strong>变换组件(<strong>Transform</strong>)且<strong>不能删除</strong>。</p><p>变换组件(<strong>Transform</strong>)实现了Unity的父子关系功能。</p><p>那么接下来我们将详细学习下<strong>Transform</strong>类所包含的成员变量和成员函数。</p><h1 id="2-父子关系"><a href="#2-父子关系" class="headerlink" title="2. 父子关系"></a>2. 父子关系</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>父子关系是Uniy中重要的基本概念之一。<br>当一个物体是另一个物体的父物体时，子物体会严格地随着父物体起移动、 旋转、缩放。<br>可以将父子关系理解为你的手臂与身体的关系，当身体移动时，手臂也定会跟着一 起移动， 且手臂还可以有自己下一级的子物体，比如手掌就是手名臂的子物体、手指是手掌的子物体等。</p><blockquote><p>在unity中带有local字样的属性也就意味着其数值是相对于父物体的。</p></blockquote><h2 id="2-2-底层原理与规则"><a href="#2-2-底层原理与规则" class="headerlink" title="2.2 底层原理与规则"></a>2.2 底层原理与规则</h2><p>规则：</p><ul><li>任何物体都可以有多个子物体，但是每个物体都只能有一个父物体。</li></ul><p>原理：</p><p>这种父子关系组成一个树状的层级结构，最基层的那个物体是唯一不具有父物体的物体，它被称为根节点。</p><p>由于物体的移动、旋转、缩放与父子关系密切相关，且游戏物体和变换组件是一一对应的。所以在Unity中，游戏物体的层级结构完全可以理解为变换组件的层级结构。父子关系的操作在脚本中确实是在变换组件上进行的。<br>子物体的变换组件的参数其实是相对父物体的值，再次考虑之前身体和手臂的例子，无论身体如何移动，手臂和身体的连接处是固定不变的。</p><h2 id="2-3-关于父子物体的一些现象"><a href="#2-3-关于父子物体的一些现象" class="headerlink" title="2.3 关于父子物体的一些现象"></a>2.3 关于父子物体的一些现象</h2><h3 id="2-3-1-position："><a href="#2-3-1-position：" class="headerlink" title="2.3.1 position："></a>2.3.1 position：</h3><ul><li><p>改变父物体的position，父物体连同子物体一起移动；</p></li><li><p>改变子物体的position，父物体不随子物体移动。</p></li><li><p>当子物体的position设置为（0，0，0）时，子物体与父物体中心点重合。</p></li></ul><h3 id="2-3-2-rotation："><a href="#2-3-2-rotation：" class="headerlink" title="2.3.2 rotation："></a>2.3.2 rotation：</h3><p>介绍两个位于unity快捷工具栏右侧的选项：<strong>Pivot</strong>与<strong>Local</strong></p><ul><li><p><strong>Poivt</strong></p><p>用于调节物体轴心点，有两个子选项</p><ul><li><p>Pivot    父物体的中心点</p></li><li><p>Center 当前父子物体的中心点</p></li></ul></li><li><p><strong>Local</strong><br>用于调节当前被选中物体的坐标轴，有两个子选项</p><ul><li><p>Local    自身坐标系</p></li><li><p>World  世界坐标系</p></li></ul></li></ul><h3 id="2-3-3-Scale"><a href="#2-3-3-Scale" class="headerlink" title="2.3.3 Scale:"></a>2.3.3 Scale:</h3><p><strong>子物体的真实缩放比例Scale=子物体Scale比例×父物体Scale比例</strong></p><p>可以通过下述代码在unity脚本中直接查看：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3 _truthScale = <span class="hljs-keyword">this</span>.transform.LossyScale;<span class="hljs-comment">//此属性为只读属性</span><br></code></pre></td></tr></table></figure><h2 id="2-4-坐标系的选择"><a href="#2-4-坐标系的选择" class="headerlink" title="2.4 坐标系的选择"></a>2.4 坐标系的选择</h2><p>局部坐标与世界坐标各有各的适用情况：</p><ul><li><p>在搭建场景时，我们更喜欢使用局部坐标系<br>比如移动一个房屋时，屋子里所有的东西都会跟着一起移动;</p></li><li><p>而在编写游戏逻辑时，更多的时候需要获得物体在空间中的实际位置。<br>比如我们要将摄像机对准人物的眼睛，这时候眼睛和人物的相对坐标就没有太大价值，而应当让摄像机对准眼睛在世界坐标系中的位置。</p></li></ul><p>所以，在脚本系统中，变换组件的大部分操作都提供了两类操作方式，分别是世界坐标系的和局部坐标系的，我们可以根据需求进行使用。</p><h2 id="2-5-关于父子物体使用的小技巧"><a href="#2-5-关于父子物体使用的小技巧" class="headerlink" title="2.5 关于父子物体使用的小技巧"></a>2.5 关于父子物体使用的小技巧</h2><p>在处理美工交过来的模型时，推荐将模型拉入一个空的gameobject，形成父子物体关系，组件只给空的gameobject上。</p><p>这样就可以防止日后更换模型时需要重新上组件的情况。</p><p>空物体通常用来管理和控制多个相互之间无关联的游戏物体。</p><h1 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3. 成员变量"></a>3. 成员变量</h1><table><thead><tr><th>position</th><th>在世界空间坐标transform的位置。</th></tr></thead><tbody><tr><td>localPosition</td><td>相对于父级的变换的位置。  如果该变换没有父级，那么等同于Transform.position。</td></tr><tr><td>eulerAngles</td><td>世界坐标系中的旋转（欧拉角）。</td></tr><tr><td>localEulerAngles</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>right</td><td>世界坐标系中的右方向。  （世界空间坐标变换的红色轴。也就是x轴。）</td></tr><tr><td>up</td><td>世界坐标系中的上方向。  （在世界空间坐标变换的绿色轴。也就是y轴。）</td></tr><tr><td>forward</td><td>世界坐标系中的前方向。  （在世界空间坐标变换的蓝色轴。也就是z轴。）</td></tr><tr><td>rotation</td><td>世界坐标系中的旋转（四元数）。</td></tr><tr><td>localRotation</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>localScale</td><td>相对于父级的缩放比例。</td></tr><tr><td>parent</td><td>父对象Transform组件。</td></tr><tr><td>worldToLocalMatrix</td><td>矩阵变换的点从世界坐标转为自身坐标（只读）。</td></tr><tr><td>localToWorldMatrix</td><td>矩阵变换的点从自身坐标转为世界坐标（只读）。</td></tr><tr><td>root</td><td>对象层级关系中的根对象的Transform组件。</td></tr><tr><td>childCount</td><td>子对象数量。</td></tr><tr><td>lossyScale</td><td>全局缩放比例（只读）。</td></tr></tbody></table><h1 id="4-成员函数"><a href="#4-成员函数" class="headerlink" title="4. 成员函数"></a>4. 成员函数</h1><h2 id="4-1-LookAt函数"><a href="#4-1-LookAt函数" class="headerlink" title="4.1 LookAt函数"></a>4.1 LookAt函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void LookAt(Transform target);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition, Vector3 worldUp = Vector3.up);</td></tr><tr><td>public void  LookAt(Transform target, Vector3 worldUp = Vector3.up);</td></tr></tbody></table><p>旋转物体，使物体的z轴指向<strong>target/worldPosition</strong>，对于<strong>worldUp</strong>的描述是，在完成上面的旋转之后，继续旋转自身，使得当前对象的正y轴朝向与worldUp所指向的朝向一致。</p><p>这里的朝向一致指的是新旋转后的y轴与<strong>worldUp</strong>在该对象初次旋转后的xy平面上的投影向量一致。之所以取投影是因为第一次旋转使物体的z轴指向<strong>target/worldPosition</strong>后，此时的<strong>worldUp</strong>向量可能不在xy平面上，要在z轴指向<strong>target/worldPosition</strong>前提下是y轴朝向与<strong>worldUp</strong>一致，只能取<strong>worldUp</strong>在xy平面上的投影。</p><blockquote><p>注意：使用<strong>worldPosition向量</strong>时要注意方向，一定是<strong>target-transform.position</strong>，顺序反了会使物体背向目标；若使用<strong>Transform</strong>作为参数，则不必注意。默认情况下，<strong>worldUp</strong>是<strong>Vector3.up</strong>（世界坐标系下的y轴）</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-2-Rotate函数"><a href="#4-2-Rotate函数" class="headerlink" title="4.2 Rotate函数"></a>4.2 Rotate函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 eulerAngles);</td></tr><tr><td>public void  Rotate(Vector3 eulerAngles, Space relativeTo = Space.Self);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo =  Space.Self);</td></tr></tbody></table><p>旋转一个欧拉角度，它按照zxy的顺序进行旋转，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 axis, float angle);</td></tr><tr><td>public void  Rotate(Vector3 axis, float angle,Space relativeTo = Space.Self);</td></tr></tbody></table><p>绕axis轴旋转angle角度，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><p><strong>transform.rotation</strong>和<strong>Rotate</strong>有个区别：</p><ul><li><p>Rotate()方法是： 旋转多少度。</p><p>在原有的基础上累加，即旋转了多少角度。  又旋转了多少角度，是在原有的基础上在旋转</p></li><li><p>rotation属性是：  旋转到某个角度，就是是在update中每帧都执行。 </p><p> 但每次旋转到的角度都是5，所以是旋转到5度。一直都是。 </p></li></ul><p>比如你只想让他旋转到多少, 用rotation; 假如想让他一直转,可以用Rotate</p><p>rotation直接改变了数值, 以达到旋转效果</p><p>Rotate应用一个的旋转角度每秒1度慢慢的旋转物体</p><p>当然:rotation()还可以通过插值旋转</p><h2 id="4-3-RotateAround函数"><a href="#4-3-RotateAround函数" class="headerlink" title="4.3 RotateAround函数"></a>4.3 RotateAround函数</h2><p>让物体以某一点为轴心成圆周运动。</p><p><code>public void RotateAround (point : Vector3, axis : Vector3, angle : float) : void</code></p><p>让物体以<strong>point</strong>为中心，绕<strong>axis</strong>为轴向旋转<strong>angle</strong>度。保持原来与<strong>point</strong>的距离。</p><h2 id="4-4-TransformDirection函数"><a href="#4-4-TransformDirection函数" class="headerlink" title="4.4 TransformDirection函数"></a>4.4 TransformDirection函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public Vector3  TransformDirection(Vector3 direction);</td></tr><tr><td>public Vector3  TransformDirection(float x, float y, float z);</td></tr></tbody></table><p>从自身坐标到世界坐标变换方向（这个强调的是方向）这个操作不会受到变换的缩放和位置的影响。</p><p>返回的向量与<strong>direction</strong>有同样的长度。</p><h2 id="4-5-InverseTransformDirection函数"><a href="#4-5-InverseTransformDirection函数" class="headerlink" title="4.5 InverseTransformDirection函数"></a>4.5 InverseTransformDirection函数</h2><table><thead><tr><th>重载的多种函数</th></tr></thead><tbody><tr><td>public Vector3  InverseTransformDirectionTransformDirection (direction : Vector3)  : Vector3</td></tr><tr><td>public Vector3  InverseTransformDirectionTransformDirection (x : float, y : float,  z : float) : Vector3</td></tr></tbody></table><p>与<strong>TransformDirection</strong>相反，从世界坐标转换到自身相对坐标。</p><h2 id="4-6-TransformPoint函数"><a href="#4-6-TransformPoint函数" class="headerlink" title="4.6 TransformPoint函数"></a>4.6 TransformPoint函数</h2><table><thead><tr><th>public Vector3  TransformPoint(Vector3 position);</th></tr></thead><tbody><tr><td>public Vector3  TransformPoint(float x, float y, float z);</td></tr></tbody></table><p>变换位置从自身坐标到世界坐标。</p><p>注意，返回位置受缩放影响</p><h2 id="4-7-InverseTransformPoint函数"><a href="#4-7-InverseTransformPoint函数" class="headerlink" title="4.7 InverseTransformPoint函数"></a>4.7 InverseTransformPoint函数</h2><table><thead><tr><th>public  Vector3 InverseTransformPoint (position : Vector3)  : Vector3</th></tr></thead><tbody><tr><td>public  Vector3 InverseTransformPoint (x : float, y : float, z  : float) : Vector3</td></tr></tbody></table><p>把一个点从时间坐标转换到自身坐标的位置。</p><h2 id="4-8-TransformVector函数"><a href="#4-8-TransformVector函数" class="headerlink" title="4.8 TransformVector函数"></a>4.8 TransformVector函数</h2><table><thead><tr><th>public Vector3  TransformVector(Vector3 vector);</th></tr></thead><tbody><tr><td>public Vector3  TransformVector(float x, float y, float z);</td></tr></tbody></table><p>变换一个向量从局部坐标空间到世界坐标空间。</p><p>这个操作不受变换位置的影响，但是受缩放的影响</p><h2 id="4-9-Translate函数"><a href="#4-9-Translate函数" class="headerlink" title="4.9 Translate函数"></a>4.9 Translate函数</h2><table><thead><tr><th>public void  Translate(Vector3 translation);</th></tr></thead><tbody><tr><td>public void  Translate(Vector3 translation, Space relativeTo = Space.Self);</td></tr></tbody></table><p>沿着<strong>translation</strong>方向移动<strong>translation</strong>向量长度的距离。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(float x, float y, float z);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Space relativeTo = Space.Self);</td></tr></tbody></table><p>移动变换由x沿着x轴，y沿着y轴，z沿着z轴。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(Vector3 translation, Transform relativeTo);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Transform relativeTo);</td></tr></tbody></table><p>第一个参数的解释跟前面的一样，重点在移动<strong>relativeTo</strong>，解释为被应用相对于（relativeTo :Transform）的自身坐标系统。</p><p>日光相对于为<strong>null</strong>，则移动被应用相对于世界坐标系统</p><p>例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//相对于摄像机每秒1单位向右移动物体</span><br><br>transform.Translate(Vector3.right * Time.deltaTime, Camera.main.transform);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-10-DetachChildren函数"><a href="#4-10-DetachChildren函数" class="headerlink" title="4.10 DetachChildren函数"></a>4.10 DetachChildren函数</h2><p><code>public void DetachChildren () : void</code></p><p>把自身所有的子物体的父物体都设成世界，也就是跟自己的所有子物体接触父子关系。</p><h2 id="4-11-Find-函数"><a href="#4-11-Find-函数" class="headerlink" title="4.11 Find 函数"></a>4.11 <strong>Find</strong> <strong>函数</strong></h2><p><code>public Transform Find (name : string) : Transform</code></p><p>找到一个名字是name的物体并返回</p><p>如果没有找到则返回null。如果字符串被/隔离，函数则会像文件路径一样逐级下查。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// The magical rotating finger</span><br><br><span class="hljs-function">function <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>aFinger = transform.Find(<span class="hljs-string">&quot;LeftShoulder/Arm/Hand/Finger&quot;</span>);<br><br>aFinger.Rotate(Time.deltaTime*<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-12-IsChildOf函数"><a href="#4-12-IsChildOf函数" class="headerlink" title="4.12 IsChildOf函数"></a>4.12 IsChildOf函数</h2><p><code>public bool IsChildOf (parent : Transform) : bool</code></p><p>如果物体是<strong>parent</strong>的父子层级关系下的一员，返回<strong>true</strong>;</p><h1 id="5-组件使用注意事项"><a href="#5-组件使用注意事项" class="headerlink" title="5. 组件使用注意事项"></a>5. 组件使用注意事项</h1><h2 id="5-1-非等比缩放的问题"><a href="#5-1-非等比缩放的问题" class="headerlink" title="5.1 非等比缩放的问题"></a>5.1 非等比缩放的问题</h2><p>某些组件不完全支持非等比缩放，在非等比缩放的情况下可能会出现意想不到的结果。<br>因为当该游戏物体具有一个球体或者胶囊体的外壳，而这些外壳的大小是通过一个半径参数指定的。<br>在物体或者父物体被拉伸或压扁的时候，这些组件的球体范围并不会跟着压扁成椭球体，它们实际上仍然是球体或胶囊体。<br>所以当物体中具有这类组件时，由于组件形状和物体形状不一致，可能会导致穿透模型被意外阻挡等情况发生。</p><p>例如，碰撞体、角色控制器这些组件和灯光、音源。</p><p>这些问题不致命，但是会引起奇怪的bug。</p><h2 id="5-2-其它注意事项"><a href="#5-2-其它注意事项" class="headerlink" title="5.2 其它注意事项"></a>5.2 其它注意事项</h2><ul><li>当为一个物体添加子物体时， 可以考虑先将父物体的位置设置为原点，这样子物体的局部坐标系就和世界坐标系重合，方便我们指定子物体的准确位置。</li><li>粒子系统不会受变换组件的缩放系数的影响。要改变- -个粒子的整体比例，还是需要在粒子系统中适当改变相关参数。</li><li>修改物体缩放比例时不仅会直接影响子物体的比例，还会影响子物体的实际位置(因为要保证相对位置不变)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MonoBehaviour基类</title>
    <link href="/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/"/>
    <url>/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-脚本基类-MonoBehaviour"><a href="#Unity-脚本基类-MonoBehaviour" class="headerlink" title="Unity 脚本基类 MonoBehaviour"></a>Unity 脚本基类 MonoBehaviour</h1><h2 id="1-MonoBehaviour-简介"><a href="#1-MonoBehaviour-简介" class="headerlink" title="1. MonoBehaviour 简介"></a>1. MonoBehaviour 简介</h2><p><strong>MonoBehaviour</strong> 是 <strong>Unity</strong> 中所有脚本的基类。</p><p>如果你使用<strong>JS</strong>的话，脚本会自动继承<strong>MonoBehaviour</strong>。</p><p>如果使用<strong>C#**的话，你需要显式继承</strong>MonoBehaviour**。</p><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><p>下面用一张图来更形象地说明一下这几个类的在<strong>MonoBehaviour</strong>的<em>生命周期</em>中是如何被调用的：<br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125028717" srcset="/img/loading.gif" alt="这里写图片描述"></p><h2 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h2><h3 id="3-1-不可重写函数："><a href="#3-1-不可重写函数：" class="headerlink" title="3.1 不可重写函数："></a>3.1 不可重写函数：</h3><h4 id="3-1-1-Invoke函数"><a href="#3-1-1-Invoke函数" class="headerlink" title="3.1.1 Invoke函数"></a>3.1.1 Invoke函数</h4><p><code>function Invoke (methodName : string, time : float) : void</code><br>在 <strong>time</strong> 秒之后，调用 <strong>methodName</strong> 方法；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">example</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><span class="hljs-keyword">public</span> Rigidbody projectile;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchProjectile</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Rigidbody instance = Instantiate(projectile);<br>    instance.velocity = Random.insideUnitSphere * <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Invoke(<span class="hljs-string">&quot;LaunchProjectile&quot;</span>, <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-InvokeRepeating"><a href="#3-1-2-InvokeRepeating" class="headerlink" title="3.1.2 InvokeRepeating"></a>3.1.2 InvokeRepeating</h4><p><code>function InvokeRepeating (methodName : string, time : float, repeatRate : float) : void</code><br>从第一次调用开始,每隔<strong>repeatRate</strong>时间调用一次.</p><h4 id="3-1-3-CancelInvoke"><a href="#3-1-3-CancelInvoke" class="headerlink" title="3.1.3 CancelInvoke"></a>3.1.3 CancelInvoke</h4><p><code>function CancelInvoke () : void</code><br>取消这个<strong>MonoBehaviour</strong>上的所有调用<strong>Invoke</strong>。</p><h4 id="3-1-4-IsInvoking"><a href="#3-1-4-IsInvoking" class="headerlink" title="3.1.4 IsInvoking"></a>3.1.4 IsInvoking</h4><p><code>function IsInvoking (methodName : string) : bool</code><br>某指定函数是否在等候调用。</p><h4 id="3-1-5-StartCoroutine"><a href="#3-1-5-StartCoroutine" class="headerlink" title="3.1.5 StartCoroutine"></a>3.1.5 StartCoroutine</h4><p><code>function StartCoroutine (routine : IEnumerator) : Coroutine</code><br>一个协同程序在执行过程中,可以在任意位置使用 <strong>yield</strong> 语句。</p><p><strong>yield</strong> 的返回值控制何时恢复协同程序向下执行。</p><p>协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。</p><p><strong>StartCoroutine</strong>函数是立刻返回的,但是<strong>yield</strong>可以延迟结果。直到协同程序执行完毕。</p><h4 id="3-1-6-StopCoroutine-StopAllCoroutines"><a href="#3-1-6-StopCoroutine-StopAllCoroutines" class="headerlink" title="3.1.6 StopCoroutine / StopAllCoroutines"></a>3.1.6 StopCoroutine / StopAllCoroutines</h4><h3 id="3-2-可重写函数："><a href="#3-2-可重写函数：" class="headerlink" title="3.2 可重写函数："></a>3.2 可重写函数：</h3><p>可重写函数会在游戏中发生某些事件的时候被调用。</p><p>我们在<strong>Unity</strong>中最常用到的几个可重写函数是这几个：</p><table><thead><tr><th align="left">可重写函数</th><th>描述</th></tr></thead><tbody><tr><td align="left"><code>Awake</code></td><td>当一个脚本被实例化时，<strong>Awake</strong> 被调用。我们大多在这个类中完成成员变量的初始化。</td></tr><tr><td align="left"><code>Start</code></td><td>仅在 <strong>Update</strong> 函数第一次被调用前调用。因为它是在<strong>Awake</strong> 之后被调用的，我们可以把一些需要依赖 <strong>Awake</strong> 的变量放在<strong>Start</strong>里面初始化。 同时我们还大多在这个类中执行 <strong>StartCoroutine</strong> 进行一些协程的触发。要注意在用C#写脚本时，必须使用 <strong>StartCoroutine</strong> 开始一个协程，但是如果使用的是 <strong>JavaScript</strong>，则不需要这么做。</td></tr><tr><td align="left"><code>Update</code></td><td>当开始播放游戏帧时（此时，<strong>GameObject</strong> 已实例化完毕），其 **Update **在 每一帧 被调用。</td></tr><tr><td align="left"><code>LateUpdate</code></td><td><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。</td></tr><tr><td align="left"><code>FixedUpdate</code></td><td>当 <strong>MonoBehaviour</strong>启用时，其 <strong>FixedUpdate</strong> 在每一固定帧被调用</td></tr><tr><td align="left"><code>OnEnable</code></td><td>当对象变为可用或激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDisable</code></td><td>当对象变为不可用或非激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDestroy</code></td><td>当 <strong>MonoBehaviour</strong> 将被销毁时，这个函数被调用</td></tr></tbody></table><h4 id="3-2-1-Update"><a href="#3-2-1-Update" class="headerlink" title="3.2.1 Update"></a>3.2.1 Update</h4><p>当 <strong>MonoBehaviour</strong> 实例化完成之后，<strong>Update</strong> 在每一帧被调用。</p><p>所以Update函数可以用来实现用户输入、角色移动和角色行动等功能。</p><p>基本上大部分游戏逻辑都离不开Update函数。</p><p>Unity 提供了非常多的基本方法来读取输入、查找某个游戏物体、查找组件、修改组件信息等，这些方法都可以在Update函数中使用，用来完成实际的游戏功能。</p><h4 id="3-2-2-LateUpdate"><a href="#3-2-2-LateUpdate" class="headerlink" title="3.2.2 LateUpdate"></a>3.2.2 LateUpdate</h4><p><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。这可用于调整脚本执行顺序。</p><p>例如:当物体在Update里移动时，跟随物体的相机可以在<strong>LateUpdate</strong>里实现。</p><h4 id="3-2-3-FixedUpdate"><a href="#3-2-3-FixedUpdate" class="headerlink" title="3.2.3 FixedUpdate"></a>3.2.3 FixedUpdate</h4><p>处理 <strong>Rigidbody</strong> 时，需要用<strong>FixedUpdate</strong>代替<strong>Update</strong>。</p><p>例如:给刚体加一个作用力时，你必须应用作用力在<strong>FixedUpdate</strong>里的固定帧，而不是<strong>Update</strong>中的帧。(两者帧长不同)</p><h4 id="3-2-4-Awake"><a href="#3-2-4-Awake" class="headerlink" title="3.2.4 Awake"></a>3.2.4 Awake</h4><p><strong>Awake</strong> 用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次。<strong>Awake</strong> 在所有对象被初始化之后调用，所以你可以安全的与其他对象对话或用诸如 <strong>GameObject.FindWithTag</strong> 这样的函数搜索它们。</p><p>每个游戏物体上的<strong>Awke</strong>以随机的顺序被调用。因此，你应该用<strong>Awake</strong>来设置脚本间的引用，并用<strong>Start</strong>来传递信息<strong>Awake</strong>总是在<strong>Start</strong>之前被调用。它不能用来执行协同程序。</p><p>C#和Boo用户注意：<strong>Awake</strong> 不同于构造函数，物体被构造时并没有定义组件的序列化状态。<strong>Awake</strong>像构造函数一样只被调用一次。</p><h4 id="3-2-5-Start"><a href="#3-2-5-Start" class="headerlink" title="3.2.5 Start"></a>3.2.5 Start</h4><p><strong>Start</strong>在<strong>behaviour</strong>的生命周期中只被调用一次。<br>它和 <strong>Awake</strong> 的不同是，<strong>Start</strong> 只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。<strong>Awake</strong> 总是在<strong>Start</strong>之前执行。</p><p>Start函数适合用来做一些初始化工作。<br>对有经验的程序编写者来说，要注意脚本组件通常不使用构造函数来做初始化，因为构造函数可控制性较差，会导致调用时机和预想的不一致。 所以最好的方式是遵循Unity的设计惯例。</p><h4 id="3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag"><a href="#3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag" class="headerlink" title="3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag"></a>3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag</h4><p>当鼠标进入 ／ 悬浮 ／ 移出 ／ 点击 ／ 释放 ／ 拖拽<strong>GUIElement</strong>(GUI元素)或<strong>Collider</strong>(碰撞体)中时调用<strong>OnMouseEnter</strong>。</p><h4 id="3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay"><a href="#3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay" class="headerlink" title="3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay"></a>3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay</h4><p>当<strong>Collider</strong>(碰撞体)进入 ／ 退出 ／ 停留在 <strong>trigger</strong>(触发器)时调用<strong>OnTriggerEnter</strong>。</p><p><strong>OnTriggerStay</strong> 将会在每一帧被调用。</p><h4 id="3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay"><a href="#3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay" class="headerlink" title="3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay"></a>3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay</h4><p>当此<strong>collider/rigidbody</strong>触发另一个<strong>rigidbody/collider</strong>时，被调用。</p><p><strong>OnCollisionStay</strong> 将会在每一帧被调用。</p><h2 id="4-脚本与GameObject的关系"><a href="#4-脚本与GameObject的关系" class="headerlink" title="4. 脚本与GameObject的关系"></a>4. 脚本与GameObject的关系</h2><p>被显式添加到 <strong>Hierarchy</strong> 中的 <strong>GameObject</strong> 会被最先实例化，<strong>GameObject</strong> 被实例化的顺序是从下往上。<strong>GameObject</strong> 被实例化的同时，加载其组件 <strong>component</strong> 并实例化，如果挂载了脚本组件，则实例化脚本组件时，将调用脚本的 <strong>Awake</strong> 方法，组件的实例化顺序是也是从下往上。在所有显式的 <strong>GameObject</strong> 及其组件被实例化完成之前，游戏不会开始播放帧。</p><p>当 <strong>GameObject</strong> 实例化工作完成之后，将开始播放游戏帧。每个脚本的第一帧都是调用 <strong>Start</strong> 方法，其后每一帧调用 <strong>Update</strong>，而且每个脚本在每一帧中的调用顺序是从下往上。</p><blockquote><p>总结：被挂载到 <strong>GameObject</strong> 下面的脚本会被实例化成 <strong>GameObject</strong> 的一个成员。</p></blockquote><h3 id="4-1-脚本变量的引用"><a href="#4-1-脚本变量的引用" class="headerlink" title="4.1 脚本变量的引用"></a>4.1 脚本变量的引用</h3><p>在脚本中声明另一个脚本的变量。在 <strong>ClassA</strong> 中建立一个 <strong>public</strong> 的变量类型是 <strong>ClassB</strong>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-非同一个-GameObject-的脚本引用"><a href="#4-1-1-非同一个-GameObject-的脚本引用" class="headerlink" title="4.1.1 非同一个 GameObject 的脚本引用"></a>4.1.1 非同一个 GameObject 的脚本引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125148891" srcset="/img/loading.gif" alt="这里写图片描述"><br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125157563" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，如果 <strong>classA</strong> 中的成员 <strong>B</strong> 想要引用由 <strong>GameObjectB</strong> new 出来的 <strong>classB</strong> 对象，只需要将 <strong>GameObjectB</strong> 拖拽到 <strong>GameObjectA</strong> 中 <strong>classA</strong> 脚本即可。</p><h4 id="4-1-2-同一个-GameObject-中互相引用"><a href="#4-1-2-同一个-GameObject-中互相引用" class="headerlink" title="4.1.2 同一个 GameObject 中互相引用"></a>4.1.2 同一个 GameObject 中互相引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125328273" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，发现没法通过拖拽的方式建立 <strong>classA</strong> 和 <strong>classB</strong> 的引用。因为 <strong>Unity</strong> 编辑器里面的拖拽绑定方式是 <strong>GameObject</strong> 级别的。</p><p>那么此时如何解决互相引用的问题呢？此时，需要用到 <strong>gameObject</strong> 这个变量。</p><p>被挂载到 <strong>GameObject</strong> 中的脚本，被实例化时，其内部继承自 <strong>Monobehavior</strong> 的 <strong>gameObject</strong> 成员会绑定所挂载的 <strong>GameObject</strong> 对象。可以注意到，在本例中，<strong>classA</strong> 和 <strong>classB</strong> 都是同一个 <strong>GameObject</strong> 下的组件，所以通过 <strong>GetComponent</strong> 便可以获得另一个脚本变量的引用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>        b = gameObject.GetComponent (<span class="hljs-string">&quot;ClassB&quot;</span>) <span class="hljs-keyword">as</span> ClassB;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>       a = gameObject.GetComponent (<span class="hljs-string">&quot;ClassA&quot;</span>) <span class="hljs-keyword">as</span> ClassA;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-父子关系的-GameObject-中引用"><a href="#4-1-3-父子关系的-GameObject-中引用" class="headerlink" title="4.1.3 父子关系的 GameObject 中引用"></a>4.1.3 父子关系的 GameObject 中引用</h4><p>把问题引申一步,还是那两个脚本<strong>ClassA</strong>,<strong>ClassB</strong>,不过这回不是绑在同一个<strong>GameObject</strong>上面，而是分辨绑定在两个<strong>GameObject</strong>：Parent(ClassA),Child(ClassB)</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125418710" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>首先还是来尝试拖拽，虽然无法在Unity的编辑器中通过拖拽互相引用脚本(Componet),不过绑定 <strong>GameObject</strong> 是可以的。所以只需要建立两个<strong>public</strong>的变量，然后类型都是 <strong>GameObject</strong>，在Unity里面互相拖拽引用,最后在 <strong>Start</strong> 函数时候通过已经绑定好的 <strong>gameObject</strong> 调用其 <strong>GetComponent</strong> 方法即可。</p><p>的确，这个方法是可行，不过有个更好的方法就是使用 <strong>Transform</strong>。<strong>Transform</strong> 是一个很特殊的<strong>Component</strong>，其内部保留着 <strong>GameObject</strong>之间的显示树结构.所以就上面的例子来说，当要从 <strong>Child</strong> 访问到 <strong>Parent</strong>，只需要在 <strong>Child</strong> 对应的脚本里面写 <code>transform.parent.gameObject.GetComponent() </code>即可</p><p>返过来就相对麻烦一点,因为无法保证一个<strong>parent</strong>只有一个<strong>child</strong>，所以无法简单的使用 <strong>transform.child.gameObject</strong>这样访问, 但是Unity给我们提供了一个很方便的函数，那就是<strong>Find</strong>。</p><p>需要注意的是<strong>Find</strong>只能查找其<strong>Child</strong>,举个复杂点的例子</p><p><strong>Parent-&gt;ChildA-&gt;ChildB-&gt;ChildC</strong></p><p>当在 <strong>Patent</strong> 中想要找到 <strong>ChildC</strong>中的一个<strong>Component</strong>时候，调用 <code>transform.Find(“ChildA/ChildB/ChildC”).gameObject;</code></p><h2 id="5-普通类与继承MonoBehaviour类的区别："><a href="#5-普通类与继承MonoBehaviour类的区别：" class="headerlink" title="5. 普通类与继承MonoBehaviour类的区别："></a>5. 普通类与继承MonoBehaviour类的区别：</h2><ul><li><p>1.继承<strong>MonoBehaviour</strong>的类不需要创建它的实例，也不能自己创建(用new)，因为从<strong>MonoBehaviour</strong>继承过来的类Unity会自动创建实例，并且调用被重载的函数(Awake，Start…..)。</p><p>如果用new会出现警告，警告说的很明显，就是如果继承了MonoBehaviour就不允许你用new创建，你可以用添加组件的方式替代，或者根本没有基类(不继承MonoBehaviour的普通类)，但是好像并不影响程序，这点很奇怪。</p></li><li><p>2.不继承MonoBehaviour不能使用Invoke，Coroutine，print以及生命周期函数等。</p></li><li><p>3.不继承MonoBehaviour不能挂在到Inspector上，也就是说不能当组件使用也不能看到一些数据。</p></li></ul><h2 id="6-MonoBehaviour-的那些坑"><a href="#6-MonoBehaviour-的那些坑" class="headerlink" title="6. MonoBehaviour 的那些坑"></a>6. MonoBehaviour 的那些坑</h2><ul><li><strong>私有（private）</strong>和<strong>保护（protected）</strong>变量只能在<strong>专家模式</strong>中显示。属性不被序列化或显示在检视面板。</li><li>不要使用<strong>命名空间（namespace）</strong></li><li>记得使用 缓存组件查找， 即在<strong>MonoBehaviour</strong>的长远方法中经常被访问的组件最好在把它当作一个私有成员变量存储起来。</li><li>在游戏里经常出现需要检测敌人和我方距离的问题，这时如果要寻找所有的敌人，显然要消耗的运算量太大了，所以最好的办法是将攻击范围使用<strong>Collider</strong>表示，然后将<strong>Collider</strong>的<strong>isTrigger</strong>设置为<strong>True</strong>。最后使用<strong>OnTriggerEnter</strong>来做攻击范围内的距离检测，这样会极大提升程序性能。</li></ul><blockquote><p>整理自: <a href="https://blog.csdn.net/hihozoo/article/details/66970467">https://blog.csdn.net/hihozoo/article/details/66970467</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客中添加音乐播放器</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是介绍基于网易云iframe插件在hexo博客中加装音乐播放器的方法，无需安装任何额外插件。</p><h1 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2.安装步骤"></a>2.安装步骤</h1><ol><li><p>在网易云音乐中打开你想要插入的音乐页面，点击 <strong>生成外联播放器</strong>。</p></li><li><p>在网页中调整好播放器插件后，复制下方的HTML代码。</p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">330</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=1488285208&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>打开本地架设hexo博客的文件夹，寻找正在使用主题文件夹下的layout文件夹。</p><p>例如我在使用的fluid主题的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">F:\MyBlog\node_modules\hexo-theme-fluid\layout<br></code></pre></td></tr></table></figure></li><li><p>在layout文件夹下寻找你想要添加音乐播放器位置的ejs文件。</p><p>例如我想放在所有页面的页脚，则ejs文件的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\layout\_partial\footer.ejs<br></code></pre></td></tr></table></figure></li><li><p>打开ejs文件(可以用vscode或者记事本)，找到生成相关位置html文件的代码。</p><p>这些ejs文件相当于是生成html文件的模板。</p></li><li><p>将复制来的HTML代码加上div加进相关的位置</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center mt-5 py-3&quot;</span>&gt;</span>//原本的页脚生成代码<br>--------------------------------------------------------<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;music-player&quot;</span>&gt;</span>//复制来的外链播放器插件代码<br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">530</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=572328440&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;&gt;</span><br>---------------------------------------------------------<br>  //原本的页脚生成代码<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer-content&quot;</span>&gt;</span><br>  &lt;%- theme.footer.content %&gt;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> &lt;%- partial(&#x27;_partial/statistics.ejs&#x27;) %&gt;<br> &lt;%- partial(&#x27;_partial/beian.ejs&#x27;) %&gt;<br> &lt;% if(theme.web_analytics.cnzz) &#123; %&gt;<br>  *<span class="hljs-comment">&lt;!-- cnzz Analytics Icon --&gt;</span>*<br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cnzz_stat_icon_&lt;%- theme.web_analytics.cnzz %&gt;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> &lt;% &#125; %&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>清理服务器缓存后再重新部署，音乐播放器就出现在对应位置了！</p></li></ol><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h1><blockquote><p>音乐不能是网易云里的VIP音乐，它是不会给你播的</p></blockquote><blockquote><p>当页面转换或者刷新时，播放器状态将被重置，目前还没有办法解决</p></blockquote><h1 id="4-其它的实现方法"><a href="#4-其它的实现方法" class="headerlink" title="4.其它的实现方法"></a>4.其它的实现方法</h1><p>在hexo框架的基础下，还可以用音乐播放插件<strong>Aplayer</strong>来实现。</p><p>相关链接：<a href="https://aplayer.js.org/#/zh-Hans/"><strong>Aplayer</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown快速入门</title>
    <link href="/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>.md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言。</p><p>本博客中的所有文章都是用.md文件编写的，而且很多企业也在在鼓励使用这种编辑方式。</p><h1 id="1-基本符号：-gt"><a href="#1-基本符号：-gt" class="headerlink" title="1.基本符号：* - +. &gt;"></a>1.基本符号：* - +. &gt;</h1><p>基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。</p><h1 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h1><p>分别表示h1-h6,只到h6，而且h1下面会有一条横线。</p><p>有两种方法，一种是只在前面加#，另一种是闭合式标签，两者效果相同。</p><p>例如：</p><p>方法一：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 </span><br><span class="hljs-section">## 二级标题 </span><br><span class="hljs-section">### 三级标题 </span><br><span class="hljs-section">#### 四级标题 </span><br><span class="hljs-section">##### 五级标题 </span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 # </span><br><span class="hljs-section">## 二级标题 ## </span><br><span class="hljs-section">### 三级标题 ### </span><br><span class="hljs-section">#### 四级标题 #### </span><br><span class="hljs-section">##### 五级标题 ##### </span><br><span class="hljs-section">###### 六级标题 #####</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h1><h2 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//形式一 <br><span class="hljs-bullet">+</span> a <br><span class="hljs-bullet">+</span> b <br><span class="hljs-bullet">+</span> c <br>//形式二<br><span class="hljs-bullet">-</span> d <br><span class="hljs-bullet">-</span> e <br><span class="hljs-bullet">-</span> f <br>//形式三 <br><span class="hljs-bullet">*</span> g <br><span class="hljs-bullet">*</span> h <br><span class="hljs-bullet">*</span> i<br></code></pre></td></tr></table></figure><p>以上三种形式，效果其实都是一样的：</p><ul><li>a </li><li>b </li><li>c </li></ul><ul><li>d </li><li>e </li><li>f </li></ul><ul><li>g </li><li>h </li><li>i</li></ul><h2 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//正常形式<br><span class="hljs-bullet">1.</span> abc<br><span class="hljs-bullet">2.</span> bcd<br><span class="hljs-bullet">3.</span> cde<br>//错序效果<br><span class="hljs-bullet">2.</span> fgh<br><span class="hljs-bullet">3.</span> ghi<br><span class="hljs-bullet">5.</span> hij<br></code></pre></td></tr></table></figure><p>效果如下：</p><ol><li><p>abc</p></li><li><p>bcd</p></li><li><p>cde</p></li><li><p>fgh</p></li><li><p>ghi</p></li><li><p>hij</p></li></ol><blockquote><p>注意，数字后面的点只能是英文的点，有序列表的序号是根据第一行列表的数字顺序来的，错序列表的序号本来是序号是乱的， 但是还是显示 4 5 6</p></blockquote><h1 id="4-引用说明区块"><a href="#4-引用说明区块" class="headerlink" title="4.引用说明区块"></a>4.引用说明区块</h1><p>对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。</p><h2 id="4-1-正常形式"><a href="#4-1-正常形式" class="headerlink" title="4.1 正常形式"></a>4.1 正常形式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 引用内容、说明内容。</span><br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>引用内容、说明内容。<br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</p></blockquote><h2 id="4-2-嵌套区块"><a href="#4-2-嵌套区块" class="headerlink" title="4.2 嵌套区块"></a>4.2 嵌套区块</h2><p>这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 一级引用 </span><br>&gt;&gt; 二级引用 <br>&gt;&gt;&gt; 三级引用 <br>&gt;&gt;&gt;&gt; 四级引用 <br>&gt;&gt;&gt;&gt;&gt; 五级引用 <br>&gt;&gt;&gt;&gt;&gt;&gt; 六级引用<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>一级引用 </p><blockquote><p>二级引用 </p><blockquote><p>三级引用 </p><blockquote><p>四级引用 </p><blockquote><p>五级引用 </p><blockquote><p>六级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5. 代码块"></a>5. 代码块</h1><p>在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。</p><h2 id="5-1-少量代码，单行使用，直接用-包裹起来就行了"><a href="#5-1-少量代码，单行使用，直接用-包裹起来就行了" class="headerlink" title="5.1 少量代码，单行使用，直接用`包裹起来就行了"></a>5.1 少量代码，单行使用，直接用`包裹起来就行了</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`shaoliangdaima,danhangshiyong`</span> <br></code></pre></td></tr></table></figure><p>效果如下：</p><p><code>shaoliangdaima,danhangshiyong</code></p><h2 id="5-2大量代码，需要多行使用，用-包裹起来"><a href="#5-2大量代码，需要多行使用，用-包裹起来" class="headerlink" title="5.2大量代码，需要多行使用，用```包裹起来"></a>5.2大量代码，需要多行使用，用```包裹起来</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">​<span class="hljs-code">```</span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong    </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong   </span><br><span class="hljs-code">​```</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong    <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong   <br></code></pre></td></tr></table></figure><h1 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h1><h2 id="6-1行内式"><a href="#6-1行内式" class="headerlink" title="6.1行内式"></a>6.1行内式</h2><p>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">烤麸的博客</span>](<span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot;</span>), 是烤麸自己学习用的博客<br></code></pre></td></tr></table></figure><h2 id="6-2参数式"><a href="#6-2参数式" class="headerlink" title="6.2参数式"></a>6.2参数式</h2><p>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot; </span><br>[烤麸的博客]是烤麸自己学习用的博客。 <br>//参数定义的其他写法 <br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ &#x27;烤麸的博客&#x27; </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ (烤麸的博客) </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">&lt;https://mycroftcooper.github.io/&gt; &quot;烤麸的博客&quot;</span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果都是一样的，如下：</p><p><a href="https://mycroftcooper.github.io/%22%E7%83%A4%E9%BA%B8%E7%9A%84%E5%8D%9A%E5%AE%A2%22">烤麸的博客</a>, 是烤麸自己学习用的博客</p><h1 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h1><h2 id="7-1-行内式"><a href="#7-1-行内式" class="headerlink" title="7.1 行内式"></a>7.1 行内式</h2><p>和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）</p><blockquote><p>注意的是[]前要加上!</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">markdown快速入门示例图.png</span>](<span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="7-2-参数式"><a href="#7-2-参数式" class="headerlink" title="7.2 参数式"></a>7.2 参数式</h2><p>图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">markdown快速入门示例图.png</span>]: <span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot; ![markdown快速入门示例图.png] </span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果图都是一样的，如下：</p><p><img src="/images/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="markdown快速入门示例图"></p><h1 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8. 分割线"></a>8. 分割线</h1><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">--- - - - ------ *** * * * ****** ___ _ _ _ ______<br></code></pre></td></tr></table></figure><p>以上代码的效果均为：</p><hr><h1 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h1><h2 id="9-1-强调字体"><a href="#9-1-强调字体" class="headerlink" title="9.1 强调字体"></a>9.1 强调字体</h2><p>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*md*</span>   <span class="hljs-strong">**md**</span> <span class="hljs-emphasis">_md_</span>   <span class="hljs-strong">__md__</span><br></code></pre></td></tr></table></figure><p>效果：<br><em>md</em><br><strong>md</strong><br><em>md</em><br><strong>md</strong></p><h2 id="9-2-转义"><a href="#9-2-转义" class="headerlink" title="9.2 转义"></a>9.2 转义</h2><p>基本上和js转义一样,\加需要转义的字符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\\ <br>\<span class="hljs-emphasis">* </span><br><span class="hljs-emphasis">\+ </span><br><span class="hljs-emphasis">\- </span><br><span class="hljs-emphasis">\` </span><br><span class="hljs-emphasis">\_</span><br></code></pre></td></tr></table></figure><h2 id="9-3-删除线"><a href="#9-3-删除线" class="headerlink" title="9.3 删除线"></a>9.3 删除线</h2><p>用~~把需要显示删除线的字符包裹起来</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">~~删除~~<br></code></pre></td></tr></table></figure><p>效果：</p><p><del>删除</del></p><h1 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//例子一 <br>|123|234|345| <br>|:-|:-:|-:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子二 <br>|123|234|345| <br>|:---|:---:|---:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子三 <br>123|234|345 <br>:-|:-:|-: <br>abc|bcd|cde <br>abc|bcd|cde <br>abc|bcd|cde<br></code></pre></td></tr></table></figure><p>上面三个例子的效果一样，由此可得：</p><ol><li><p>表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的</p></li><li><p>分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中</p></li></ol><p>效果如下：</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table><p>整理自：<a href="https://www.jianshu.com/p/399e5a3c7cc5">https://www.jianshu.com/p/399e5a3c7cc5</a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>博客使用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客使用手册</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是关于hexo框架下博客的使用方法总结，以便更好的学习与使用博客整理笔记。</p><h1 id="2-写作"><a href="#2-写作" class="headerlink" title="2. 写作"></a>2. 写作</h1><p>要创建新帖子或新页面，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>[layout]</code>是可选参数<code>布局</code>，<code>布局</code>分为以下几种：</p><table><thead><tr><th align="left">布局</th><th align="left">保存路径</th><th>用途</th></tr></thead><tbody><tr><td align="left">post</td><td align="left">source/_posts</td><td>创建新文章</td></tr><tr><td align="left">page</td><td align="left">source</td><td>创建新页面</td></tr><tr><td align="left">draft</td><td align="left">source/_drafts</td><td>创建新草稿</td></tr></tbody></table><p>该指令可以增加附加选项：</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--path</code></td><td align="left">发布路径。自定义帖子的路径。</td></tr><tr><td align="left"><code>-r</code>， <code>--replace</code></td><td align="left">替换当前帖子（如果存在）。</td></tr><tr><td align="left"><code>-s</code>， <code>--slug</code></td><td align="left">文章缩略名，自定义帖子的URL。</td></tr></tbody></table><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><h2 id="2-1-文档名称"><a href="#2-1-文档名称" class="headerlink" title="2.1 文档名称"></a>2.1 文档名称</h2><p>默认情况下，Hexo使用帖子标题作为其文件名。您可以在<code>_config.yml</code>中编辑<code>new_post_name</code>设置以更改默认文件名。</p><p>例如，<code>:year-:month-:day-:title.md</code>在文件名前加上创建日期。</p><p>您可以使用以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">帖子标题（小写，空格用连字符代替）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">创建年份，例如 <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">创建的月份（前导零），例如 <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">创建的月份（无前导零），例如 <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">创建日期（前导零），例如 <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">创建日期（无前导零），例如 <code>7</code></td></tr></tbody></table><h2 id="2-2-文档头"><a href="#2-2-文档头" class="headerlink" title="2.2 文档头"></a>2.2 文档头</h2><p>当新建.md文档后，打开文档可以看见如下文件头：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">title: hexo博客使用手册<br>date: 2021-02-18 14:11:04<br>tags: 博客使用手册<br>categories: 博客使用手册<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title:</code></td><td align="left">帖子标题</td></tr><tr><td align="left"><code>date:</code></td><td align="left">创建日期</td></tr><tr><td align="left"><code>tags:</code></td><td align="left">帖子所属标签</td></tr><tr><td align="left"><code>categories:</code></td><td align="left">帖子所属分类(需要手动添加)</td></tr></tbody></table><p>当想要新增标签与分类时，直接创建新的文档后在文件头填写参数即可。</p><p>多个标签时使用：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span>  <br><br>- [tag1]<br><br>- [tag2]<br></code></pre></td></tr></table></figure><p>含父子分类时，将父类写在前，子类写在后:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories: <br><span class="hljs-bullet">-</span> [categorie1]<br><span class="hljs-bullet">-</span> [categorie2]<br></code></pre></td></tr></table></figure><h2 id="2-3-添加图片"><a href="#2-3-添加图片" class="headerlink" title="2.3 添加图片"></a>2.3 添加图片</h2><p>关于图片和图片路径的设置，有以下教程。</p><p>事先声明，所有博客文件均保存在 <code>hexo/_posts/</code>文件夹下</p><p>首先在 <code>hexo &gt; source</code>目录下建一个文件夹叫images，用来保存博客中的图片。</p><p>然后打开Typora的 <code>文件 &gt; 偏好设置</code>，进行如下设置。</p><p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" alt="插入图片设置"></p><p>这样的话所有的博客中的图片都将会保存到 <code>/source/images/该博客md文件名/图片名称</code></p><p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p><p>在typora菜单栏点击 <code>格式-&gt;图像-&gt;设置图片根目录</code>，将<code>hexo/source</code>作为其根目录即可。</p><p><strong>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确喔！</strong></p><h2 id="2-4-草稿"><a href="#2-4-草稿" class="headerlink" title="2.4 草稿"></a>2.4 草稿</h2><p><code>draft</code>布局初始化的帖子将保存到该<code>source/_drafts</code>文件夹中。</p><p>您可以使用<code>publish</code>命令将草稿移至<code>source/_posts</code>文件夹。</p><p><code>publish</code>命令与<code>new</code>命令相似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>默认不显示草稿。</p><p>您可以在运行Hexo时添加选项<code>--draft</code>，也可以在<code>_config.yml</code>中启用<code>render_drafts</code>设置以渲染草稿。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --draft<br></code></pre></td></tr></table></figure><p>显示草稿（存储在<code>source/_drafts</code>文件夹中）。</p><h2 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h2><p>创建帖子时，Hexo将基于文件<code>scaffolds</code>夹中的相应模板文件来构建文件。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new photo <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>当您运行此命令时，Hexo将尝试在<code>scaffolds</code>文件夹中查找<code>photo.md</code>，并基于该文件构建帖子。模板中提供以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件创建日期</td></tr></tbody></table><h2 id="2-6-支持的格式"><a href="#2-6-支持的格式" class="headerlink" title="2.6 支持的格式"></a>2.6 支持的格式</h2><p>只要安装了相应的渲染器插件，Hexo支持帖子就可以以任何格式编写。、</p><p>本博客支持的编写格式：<code>markdown</code>，<code>ejs</code>。</p><h1 id="3-服务器指令"><a href="#3-服务器指令" class="headerlink" title="3. 服务器指令"></a>3. 服务器指令</h1><h2 id="3-1-init-安装指令"><a href="#3-1-init-安装指令" class="headerlink" title="3.1 init 安装指令"></a>3.1 init 安装指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init [folder]<br></code></pre></td></tr></table></figure><p>将hexo框架文件安装到当前/指定文件夹内。</p><h2 id="3-2-server-本地服务器启动指令"><a href="#3-2-server-本地服务器启动指令" class="headerlink" title="3.2 server 本地服务器启动指令"></a>3.2 server 本地服务器启动指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server 或 $ hexo s<br></code></pre></td></tr></table></figure><p>启动本地服务器。默认情况下，该位置为<code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--port</code></td><td align="left">覆盖默认端口</td></tr><tr><td align="left"><code>-s</code>， <code>--static</code></td><td align="left">仅提供静态文件</td></tr><tr><td align="left"><code>-l</code>， <code>--log</code></td><td align="left">启用记录器。覆盖记录器格式。</td></tr></tbody></table><h2 id="3-3-deploy-部署指令"><a href="#3-3-deploy-部署指令" class="headerlink" title="3.3 deploy 部署指令"></a>3.3 deploy 部署指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy 或 $ hexo d<br></code></pre></td></tr></table></figure><p>部署您的网站。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>， <code>--generate</code></td><td align="left">部署前生成</td></tr></tbody></table><h2 id="3-4-clean-清除缓存指令"><a href="#3-4-clean-清除缓存指令" class="headerlink" title="3.4 clean 清除缓存指令"></a>3.4 clean 清除缓存指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean <br></code></pre></td></tr></table></figure><p>清除缓存文件（<code>db.json</code>）和生成的文件（<code>public</code>）。</p><h2 id="3-5-version查看版本指令"><a href="#3-5-version查看版本指令" class="headerlink" title="3.5 version查看版本指令"></a>3.5 version查看版本指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo version 或 $ hexo v<br></code></pre></td></tr></table></figure><p>显示版本信息。</p><h2 id="3-6-选项"><a href="#3-6-选项" class="headerlink" title="3.6 选项"></a>3.6 选项</h2><h3 id="3-6-1-安全模式"><a href="#3-6-1-安全模式" class="headerlink" title="3.6.1 安全模式"></a>3.6.1 安全模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --safe<br></code></pre></td></tr></table></figure><p>禁用加载插件和脚本。如果在安装新插件后遇到问题，请尝试此操作。</p><h3 id="3-6-2-调试模式"><a href="#3-6-2-调试模式" class="headerlink" title="3.6.2 调试模式"></a>3.6.2 调试模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --debug<br></code></pre></td></tr></table></figure><p>将详细消息记录到终端和<code>debug.log</code>。如果遇到Hexo任何问题，请尝试此操作。如果看到错误，请<a href="https://github.com/hexojs/hexo/issues/new">提出GitHub问题</a>。</p><h3 id="3-6-3-静音模式"><a href="#3-6-3-静音模式" class="headerlink" title="3.6.3 静音模式"></a>3.6.3 静音模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --silent<br></code></pre></td></tr></table></figure><p>静音输出到终端。</p><h3 id="3-6-4-自定义配置文件路径"><a href="#3-6-4-自定义配置文件路径" class="headerlink" title="3.6.4 自定义配置文件路径"></a>3.6.4 自定义配置文件路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml<br></code></pre></td></tr></table></figure><p>使用自定义配置文件（而不是<code>_config.yml</code>）。</p><p>还接受以逗号分隔的JSON或YAML配置文件列表，该列表会将文件合并为一个<code>_multiconfig.yml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml，custom2.json<br></code></pre></td></tr></table></figure><h3 id="3-6-5-自定义CWD"><a href="#3-6-5-自定义CWD" class="headerlink" title="3.6.5 自定义CWD"></a>3.6.5 自定义CWD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --cwd / path / to / cwd<br></code></pre></td></tr></table></figure><p>自定义当前工作目录的路径。</p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
