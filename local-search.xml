<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WPF-资源与样式</title>
    <link href="/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/"/>
    <url>/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-资源"><a href="#1-资源" class="headerlink" title="1.资源"></a>1.资源</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>WPF资源系统是一种保管一系列有用对象（如常用的画刷、样式和模板）的简单方法，从而使您可以更容易地重用这些对象。<br>每个元素都有Resources属性，该属性存储了一个资源字典集合（它是ResourceDictionary类的实例）。<br>资源集合可包含任意类型的对象，根据字符串编写索引。</p><h2 id="1-2-写法"><a href="#1-2-写法" class="headerlink" title="1.2 写法"></a>1.2 写法</h2><ul><li><p>Window的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Window&gt;</span><br>   <span class="hljs-section">&lt;Window.Resources&gt;</span><br>   <span class="hljs-section">&lt;/Window.Resources&gt;</span><br><span class="hljs-section">&lt;/Window&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Control的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Control&gt;</span><br>      <span class="hljs-section">&lt;Control.Resources&gt;</span><br>       <span class="hljs-section">&lt;/Control.Resources&gt;</span><br><span class="hljs-section">&lt;/Control&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-样式"><a href="#2-样式" class="headerlink" title="2. 样式"></a>2. 样式</h1></li></ul><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>样式是修改View（窗体、控件）样式的主要手段，主要作用更改控件的外观以及增强用户体验。</p><h2 id="2-2-样式的属性"><a href="#2-2-样式的属性" class="headerlink" title="2.2 样式的属性"></a>2.2 样式的属性</h2><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>Setterts</td><td>设置属性值以及自动关联事件处理程序的Setter对象或EventSetter对象的集合是Style类中最重要的属性，但并非唯一属性。</td></tr><tr><td>Triggers</td><td>继承自TriggerBase类能自动改变样式设置的对象集合。例如，当另一个属性改变时，或者当发生某个时间时，可以修改样式。</td></tr><tr><td>Resources</td><td>希望用于样式的资源集合。</td></tr><tr><td>BasedOn</td><td>通过该属性可创建继承自其它样式设置的更具体的样式</td></tr><tr><td>TargetType</td><td>该属性标识应用样式的元素类型。通过该属性可创建只影响特定类型元素的设置器，还可以创建能够为恰当的元素类型自动起作用的设置器</td></tr></tbody></table><h2 id="2-3-如何关联样式"><a href="#2-3-如何关联样式" class="headerlink" title="2.3 如何关联样式"></a>2.3 如何关联样式</h2><ul><li>DynamicResource（动态资源）<br><code> &lt;Button Style=&quot;&#123;StaticResource BtnStyle&#125;&quot; /&gt;</code></li><li>StaticResource（静态资源）<br><code>&lt;Button Style=&quot;&#123;DynamicResource BtnStyle&#125;&quot; /&gt;</code></li></ul><blockquote><p>二者区别<br>静态资源在第一次编译后即确定其对象或值，之后不能对其进行修改。<br>动态资源在运行时决定，当运行过程中真正需要时，才到资源目标中查找其值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>样式</tag>
      
      <tag>资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataResult与DataTable类</title>
    <link href="/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/"/>
    <url>/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>DataTable和DataSet可以看做是数据容器，比如你查询数据库后得到一些结果，可以放到这种容器里。</p><p>那你可能要问：我不用这种容器，自己读到变量或数组里也一样可以存起来啊，为什么用容器？</p><p>原因是，这种容器的功能比较强大，除了可以存数据，还可以有更大用途。</p><p>举例：<br>在一个c/s结构的桌面数据库系统里，你可以把前面存放查询结果的容器里的数据显示到你客户端界面上，用户在界面上对数据进行添加、删除、修改，你可以把用户的操作更新到容器。<br>等用户操作完毕了，要求更新，然后你才把容器整个的数据变化更新到中心数据库。</p><blockquote><p>这样做的好处是什么？<br>就是减少了数据库操作，客户端速度提高了，数据库压力减小了。</p></blockquote><p> DataSet可以比作一个内存中的数据库，DataTable是一个内存中的数据表，DataSet里可以存储多个DataTable。</p><h1 id="2-DataTable"><a href="#2-DataTable" class="headerlink" title="2. DataTable"></a>2. DataTable</h1><h2 id="2-1-类成员"><a href="#2-1-类成员" class="headerlink" title="2.1 类成员"></a>2.1 类成员</h2><h3 id="2-1-1-构造函数"><a href="#2-1-1-构造函数" class="headerlink" title="2.1.1 构造函数"></a>2.1.1 构造函数</h3><table><thead><tr><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td>DataTable()</td><td>不带参数初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName)</td><td>用指定的表名初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName, string tableNamespace)</td><td>用指定的表名和命名空间初始化DataTable类的新实例</td></tr></tbody></table><h3 id="2-1-2-常用属性"><a href="#2-1-2-常用属性" class="headerlink" title="2.1.2 常用属性"></a>2.1.2 常用属性</h3><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>CaseSensitive</td><td>指示表中的字符串比较是否区分大小写</td></tr><tr><td>ChildRelations</td><td>获取此DataTable 的子关系的集合</td></tr><tr><td>Columns</td><td>获取属于该表的列的集合</td></tr><tr><td>Constraints</td><td>获取由该表维护的约束的集合</td></tr><tr><td>DataSet</td><td>获取此表所属的DataSet</td></tr><tr><td>DefaultView</td><td>获取可能包括筛选视图或游标位置的表的自定义视图</td></tr><tr><td>HasErrors</td><td>获取一个值，该值指示该表所属的DataSet 的任何表的任何行中是否有错误</td></tr><tr><td>MinimumCapacity</td><td>获取或设置该表最初的起始大小。该表中行的最初起始大小。默认值为 50</td></tr><tr><td>Rows</td><td>获取属于该表的行的集合</td></tr><tr><td>TableName</td><td>获取或设置DataTable 的名称</td></tr></tbody></table><h3 id="2-1-3-常用方法"><a href="#2-1-3-常用方法" class="headerlink" title="2.1.3 常用方法"></a>2.1.3 常用方法</h3><table><thead><tr><th>方法名</th><th>含义</th></tr></thead><tbody><tr><td>AcceptChanges()</td><td>提交自上次调用AcceptChanges() 以来对该表进行的所有更改</td></tr><tr><td>BeginInit()</td><td>开始初始化在窗体上使用或由另一个组件使用的DataTable。初始化发生在运行时</td></tr><tr><td>Clear()</td><td>清除所有数据的DataTable</td></tr><tr><td>Clone()</td><td>克隆DataTable 的结构，包括所有DataTable 架构和约束</td></tr><tr><td>EndInit()</td><td>结束在窗体上使用或由另一个组件使用的DataTable 的初始化。初始化发生在运行时</td></tr><tr><td>ImportRow(DataRow row)</td><td>将DataRow 复制到DataTable 中，保留任何属性设置以及初始值和当前值</td></tr><tr><td>Merge(DataTable table)</td><td>将指定的DataTable 与当前的DataTable 合并</td></tr><tr><td>NewRow()</td><td>创建与该表具有相同架构的新DataRow</td></tr></tbody></table><h2 id="2-2-使用技巧"><a href="#2-2-使用技巧" class="headerlink" title="2.2 使用技巧"></a>2.2 使用技巧</h2><h3 id="2-2-1-创建表"><a href="#2-2-1-创建表" class="headerlink" title="2.2.1 创建表"></a>2.2.1 创建表</h3><p><code>DataTable dt = new DataTable(&quot;Table_AX&quot;); </code></p><h3 id="2-2-2-添加列属性"><a href="#2-2-2-添加列属性" class="headerlink" title="2.2.2 添加列属性"></a>2.2.2 添加列属性</h3><p>方法1：<br><code>dt.Columns.Add(&quot;column0&quot;, System.Type.GetType(&quot;System.String&quot;));</code><br>方法2：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataColumn dc = <span class="hljs-keyword">new</span> DataColumn(<span class="hljs-string">&quot;column1&quot;</span>, System.Type.GetType(<span class="hljs-string">&quot;System.Boolean&quot;</span>));<br>dt.Columns.Add(dc); <br></code></pre></td></tr></table></figure><h3 id="2-2-3-添加数据行"><a href="#2-2-3-添加数据行" class="headerlink" title="2.2.3 添加数据行"></a>2.2.3 添加数据行</h3><p>初始化行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr = dt.NewRow();<br>dr[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AX&quot;</span>;<br>dr[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">true</span>;<br>dt.Rows.Add(dr);<br></code></pre></td></tr></table></figure><p>空行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr1 = dt.NewRow();<br>dt.Rows.Add(dr1);    <br></code></pre></td></tr></table></figure><h3 id="2-2-4-选择数据行"><a href="#2-2-4-选择数据行" class="headerlink" title="2.2.4 选择数据行"></a>2.2.4 选择数据行</h3><p>选择表中所有第0列属性为’AX’的数据行<br><code>DataRow[] drss = dt.Select(&quot;column0 = &#39;AX&#39;&quot;);</code></p><blockquote><p>空属性时用<strong>is null</strong><br>例：<code> DataRow[] drs = dt.Select(&quot;column1 is null&quot;);</code></p></blockquote><h3 id="2-2-5-复制表-包括数据"><a href="#2-2-5-复制表-包括数据" class="headerlink" title="2.2.5 复制表(包括数据)"></a>2.2.5 复制表(包括数据)</h3><p><code>DataTable dtNew = dt.Copy();</code></p><h3 id="2-2-6-复制表-仅结构"><a href="#2-2-6-复制表-仅结构" class="headerlink" title="2.2.6 复制表(仅结构)"></a>2.2.6 复制表(仅结构)</h3><p><code>DataTable dtOnlyScheme = dt.Clone(); </code></p><h3 id="2-2-7-数据行操作"><a href="#2-2-7-数据行操作" class="headerlink" title="2.2.7 数据行操作"></a>2.2.7 数据行操作</h3><ul><li><p>方法一</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow drOperate = dt.Rows[<span class="hljs-number">0</span>];<br>drOperate[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">drOperate[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法三</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法四</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; <br></code></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>  <span class="hljs-keyword">foreach</span> (DataColumn column <span class="hljs-keyword">in</span> dt.Columns) <br>  &#123; <br> Console.WriteLine(row[column]); <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>row[column] 中的column是检索出来的表个列名。</p><p>如果想把某列的值拼接字符串，那就去掉内层循环就行了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">StringBuilder mailList = <span class="hljs-keyword">new</span> StringBuilder(); <br><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>   mailList.Append(row[<span class="hljs-string">&quot;Email&quot;</span>]); <br>   mailList.Append(<span class="hljs-string">&quot;;&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-8-复制数据行到当前数据表"><a href="#2-2-8-复制数据行到当前数据表" class="headerlink" title="2.2.8 复制数据行到当前数据表"></a>2.2.8 复制数据行到当前数据表</h3></li></ul><p><code>dtOnlyScheme.Rows.Add(dt.Rows[0].ItemArray); </code></p><h3 id="2-2-9-转换为字符串"><a href="#2-2-9-转换为字符串" class="headerlink" title="2.2.9 转换为字符串"></a>2.2.9 转换为字符串</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">System.IO.StringWriter sw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>System.Xml.XmlTextWriter xw = <span class="hljs-keyword">new</span> System.Xml.XmlTextWriter(sw);<br>dt.WriteXml(xw);<br><span class="hljs-built_in">string</span> s = sw.ToString();<br></code></pre></td></tr></table></figure><h3 id="2-2-10-筛选数据表"><a href="#2-2-10-筛选数据表" class="headerlink" title="2.2.10 筛选数据表"></a>2.2.10 筛选数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 &lt;&gt; true&quot;</span>;<br>dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 = true&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-11-行排序"><a href="#2-2-11-行排序" class="headerlink" title="2.2.11 行排序"></a>2.2.11 行排序</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.Sort = <span class="hljs-string">&quot;ID ,Name ASC&quot;</span>;<br>dt=dt.DefaultView.ToTable();   <br></code></pre></td></tr></table></figure><h3 id="2-2-12-绑定数据表"><a href="#2-2-12-绑定数据表" class="headerlink" title="2.2.12 绑定数据表"></a>2.2.12 绑定数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">gvTestDataTable.DataSource = dt;<br>gvTestDataTable.DataBind();<br></code></pre></td></tr></table></figure><blockquote><p>绑定的其实是DefaultView</p></blockquote><h3 id="2-2-13-判断一个字符串是否为数据表的列名"><a href="#2-2-13-判断一个字符串是否为数据表的列名" class="headerlink" title="2.2.13 判断一个字符串是否为数据表的列名"></a>2.2.13 判断一个字符串是否为数据表的列名</h3><p><code>dtInfo.Columns.Contains(&quot;AX&quot;);</code></p><h3 id="2-2-14-序列化"><a href="#2-2-14-序列化" class="headerlink" title="2.2.14 序列化"></a>2.2.14 序列化</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataTable convert to XML <span class="hljs-keyword">and</span> XML convert to DataTable<br>     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Page_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>     &#123;<br>       DataTable dt_AX = <span class="hljs-keyword">new</span> DataTable();<br>       <span class="hljs-comment">//dt_AX.Columns.Add(&quot;Sex&quot;, typeof(System.Boolean));</span><br>       <span class="hljs-comment">//DataRow dr = dt_AX.NewRow();</span><br>       <span class="hljs-comment">//dr[&quot;Sex&quot;] = true;</span><br>       <span class="hljs-comment">//dt_AX.Rows.Add(dr);</span><br>       <span class="hljs-built_in">string</span> xml=ConvertBetweenDataTableAndXML_AX(dt_AX);<br>       DataTable dt = ConvertBetweenDataTableAndXML_AX(xml);<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params">DataTable dtNeedCoveret</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextWriter tw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>       <span class="hljs-comment">//if TableName is empty, WriteXml() will throw Exception.         </span><br><br>dtNeedCoveret.TableName=dtNeedCoveret.TableName.Length==<span class="hljs-number">0</span>?<span class="hljs-string">&quot;Table_AX&quot;</span>:dtNeedCoveret.TableName;<br>       dtNeedCoveret.WriteXml(tw);<br>       dtNeedCoveret.WriteXmlSchema(tw);<br>       <span class="hljs-keyword">return</span> tw.ToString();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> DataTable <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> xml</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextReader trDataTable = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(<span class="hljs-number">0</span>, xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       System.IO.TextReader trSchema = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       DataTable dtReturn = <span class="hljs-keyword">new</span> DataTable();<br>       dtReturn.ReadXmlSchema(trSchema);<br>       dtReturn.ReadXml(trDataTable);<br>       <span class="hljs-keyword">return</span> dtReturn;<br>    &#125;<br> dt.Compute(<span class="hljs-string">&quot;sum(SaleNum)&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>) ; <br><span class="hljs-comment">// 对列SaleNum 汇总支持所以sql 聚合函数 如：sum(),count(),avg()等等。。。  </span><br><br>linq<br><br><span class="hljs-keyword">var</span> productNames = <span class="hljs-keyword">from</span> products <span class="hljs-keyword">in</span> dt.AsEnumerable() <span class="hljs-keyword">select</span> products.Field&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;ProductName&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>C#常用类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-命令</title>
    <link href="/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>命令有许多可变的部分组成，但它们都具有以下4个重要元素：</p><ul><li>命令<br>命令表示应用程序任务，并且跟踪任务是否能够被执行。<br>然而，命令实际上不包含执行应用程序任务的代码。</li><li>命令绑定<br>每个命令绑定针对用户界面的具体元素，将命令连接到相关的应用程序逻辑。<br>这种分解的设计是非常重要的，因为单个命令可用于应用程序中的多个地方，并且在每个地方具有不同的意义。<br>为处理这一问题，需要将同一命令与不同的命令绑定。</li><li>命令源<br>命令源触发命令。<br>例如，button就是命令源。<br>单击它们都会执行绑定命令。</li><li>命令目标<br>命令目标是在其中执行命令的元素。</li></ul><p><img src="/images/WPF-%E5%91%BD%E4%BB%A4/image-20210424153346796.png" srcset="/img/loading.gif" alt="image-20210424153346796"></p><h1 id="2-如何实现一个命令"><a href="#2-如何实现一个命令" class="headerlink" title="2.如何实现一个命令"></a>2.如何实现一个命令</h1><p>WPF命令的核心是System.Windows.Input.ICommand接口，该接口定义了命令的工作原理。<br>该接口包含两个方法和一个事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICommand</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">CanExecute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-keyword">event</span> EventHandler CanExecuteChanged;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>Execute</td><td>将包含引用程序任务逻辑</td></tr><tr><td>CanExecute</td><td>返回命令的状态。可用为true，不可用为false；</td></tr><tr><td>CanExecuteChanged</td><td>当命令状态改变是引发该事件。对于使用命令的任何控件，这是指示信号，表示他们应当调用</td></tr></tbody></table><blockquote><p>Execute和CanExecute方法都接受一个附加的对象参数，可使用该对象传递所需的任何附加信息。</p></blockquote><blockquote><p>CanExecute方法检查命令的状态。<br>通过使用该事件，当命令可用时，命令源（如button）可自动启用自身；<br>当命令不可用时，禁用自身。</p></blockquote><h1 id="3-如何让控件支持命令"><a href="#3-如何让控件支持命令" class="headerlink" title="3. 如何让控件支持命令"></a>3. 如何让控件支持命令</h1><p>支持命令的实现是在“命令源”这个环节实现ICommandSource。</p><p>ICommandSource接口定义了三个属性:</p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>Command</td><td>指向连接的命令，这是唯一必须的细节</td></tr><tr><td>CommandParameter</td><td>提供其他希望随命令发送的数据</td></tr><tr><td>CommandTarget</td><td>确定将在其中执行命令的元素</td></tr></tbody></table><blockquote><p>不是每个控件都直接支持command绑定的<br>需要将他们关联到实现了ICommandSource接口的控件<br>其中包括继承自ButtonBase类的控件（button和Checkbox等）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-MVVC</title>
    <link href="/2021/04/24/WPF-MVVC/"/>
    <url>/2021/04/24/WPF-MVVC/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MVVM是一种开发模式，是一种开发标准。<br>在WPF中应用到MVVM是非常常见的，MVVM全称为Model、View、ViewModel。</p><p>开发模式有</p><ul><li><p>MVC<br>模型-视图-控制器</p></li><li><p>MVP<br>模型-视图-演示者</p></li><li><p>MVVM<br>模型-视图-视图模型</p></li></ul><p>MVP, MVVM都是由MVC衍生出。<br>所有这些设计模式大体上都有助于开发松散组合、易于测试和维护的应用程序。</p><p><a href="https://www.php.cn/faq/417265.html">开发模式</a></p><p><img src="/images/WPF-MVVC/image-20210424155250844.png" srcset="/img/loading.gif" alt="image-20210424155250844"></p><h1 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h1><ul><li>View<br>代表窗体、控件等可视化资源</li><li>ViewModel<br>代表View的业务处理类，<br>将获取到的数据处理好与View进行关联绑定</li><li>Model<br>通常代表数据模型，它将支持ViewModel中所使用的到的<br>还有一种用法就是在Model里完成业务逻辑的编写ViewModel只需要写出关联逻辑代码，具体的使用方式视情况而定。</li></ul><p><img src="/images/WPF-MVVC/image-20210424154619430.png" srcset="/img/loading.gif" alt="image-20210424154619430"></p><h1 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h1><ul><li>优点<br>前后端逻辑分离，解耦，代码配置灵活，易维护，为数据驱动奠定基础。</li><li>缺点<br>开发耗时较长，对于新手掌握起来略微有难度。<br>基于MVVM再实现绑定难度会有一个小幅度的提升。<br>需多实践积累经验即可。</li></ul><h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4. 文件管理"></a>4. 文件管理</h1><p><img src="/images/WPF-MVVC/image-20210424154830937.png" srcset="/img/loading.gif" alt="image-20210424154830937"></p><p>如图所示</p><ul><li><p>请将与页面可视化相关的xaml文件放于Views文件夹下</p></li><li><p>请将页面逻辑交互相关的cs文件放于ViewModels文件夹下</p></li><li><p>请将数据处理，事务实现相关的cs文件放于Models文件夹下</p></li></ul><blockquote><p>.MainWindow稍微特殊点<br>因为它是主窗体作为整个程序的起始点，它可以单独放在外面</p></blockquote><blockquote><p>App.xaml是程序启动配置文件<br>如果需要更换起始运行窗体则需要修改StartupUri=“xxxView.xaml”即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>MVVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-依赖属性</title>
    <link href="/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>依赖属性就是一种自己可以没有值，并且可以通过绑定从其他数据源获取值。<br>依赖属性可支持WPF中的样式设置、数据绑定、继承、动画及默认值。</p><p>将所有的属性都设置为依赖属性并不总是正确的解决方案，具体取决于其应用场景。<br>有时，使用私有字段实现属性的典型方法便能满足要求。</p><p>MSDN中给出了下面几种应用依赖属性的场景：</p><ol><li><p>希望可在样式中设置属性。</p></li><li><p>希望属性支持数据绑定。</p></li><li><p>希望可使用动态资源引用设置属性。</p></li><li><p>希望从元素树中的父元素自动继承属性值。</p></li><li><p>希望属性可进行动画处理。</p></li><li><p>希望属性系统在属性系统、环境或用户执行的操作或者读取并使用样式更改了属性以前的值时报告。</p></li><li><p>希望使用已建立的、WPF 进程也使用的元数据约定，例如报告更改属性值时是否要求布局系统重新编写元素的可视化对象。</p><blockquote><p>总结自<a href="https://www.cnblogs.com/dotnet261010/p/6286475.html">https://www.cnblogs.com/dotnet261010/p/6286475.html</a></p></blockquote></li></ol><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><h2 id="2-1-属性变更通知"><a href="#2-1-属性变更通知" class="headerlink" title="2.1 属性变更通知"></a>2.1 属性变更通知</h2><p>无论什么时候，只要依赖属性的值发生改变，wpf就会自动根据属性的元数据触发一系列的动作，这些动作可以重新呈现UI元素，也可以更新当前的布局，刷新数据绑定等等。<br>这种变更的通知最有趣的特点之一就是属性触发器，它可以在属性值改变的时候，执行一系列自定义的动作，而不需要更改任何其他的代码来实现。通过下面的示例来演示属性变更通知</p><p>示例：当鼠标移动到Button按钮上面时，文字的前景色变为红色，离开时变为默认颜色黑色，采用传统方式和依赖属性两种方式实现：</p><h3 id="2-1-1-使用传统方式实现"><a href="#2-1-1-使用传统方式实现" class="headerlink" title="2.1.1 使用传统方式实现"></a>2.1.1 使用传统方式实现</h3><p>在Button按钮上定义MouseEnter和MouseLeave两个事件，分别处理鼠标移动到按钮上面和离开，</p><p>XAML界面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span>              <br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">MouseEnter</span>=<span class="hljs-string">&quot;Button_MouseEnter&quot;</span> <span class="hljs-attr">MouseLeave</span>=<span class="hljs-string">&quot;Button_MouseLeave&quot;</span> &gt;</span>鼠标移动到上面，前景色变为红色<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>        <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>C#后台代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Collections.Generic;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Linq;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Text;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Threading.Tasks;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Controls;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Data;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Documents;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.<span class="hljs-keyword">Input</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Navigation;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Shapes;<br> <br>namespace WpfDemo<br>&#123;<br>     // MainWindow.xaml 的交互逻辑<br>     <span class="hljs-built_in">public</span> partial <span class="hljs-keyword">class</span> MainWindow : <span class="hljs-keyword">Window</span><br>     &#123;<br>        <span class="hljs-built_in">public</span> MainWindow()<br>         &#123;<br>             InitializeComponent();<br>         &#125;<br>          // 鼠标移动到按钮上面<br>          // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>          // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseEnter(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Red;<br>             &#125;<br>        &#125;<br>         // 鼠标离开按钮<br>        // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>         // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseLeave(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Black;<br>             &#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-2-使用依赖属性实现"><a href="#2-1-2-使用依赖属性实现" class="headerlink" title="2.1.2 使用依赖属性实现"></a>2.1.2 使用依赖属性实现</h3><p>XAML界面代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">&lt;</span><span class="hljs-variable">Window</span> <span class="hljs-variable">x</span><span class="hljs-operator">:</span><span class="hljs-variable">Class</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">:</span><span class="hljs-variable">x</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br>        <span class="hljs-variable">Title</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;237&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;525&quot;</span> <span class="hljs-variable">WindowStartupLocation</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;CenterScreen&quot;</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Grid</span> <span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;30&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span><span class="hljs-operator">&gt;</span>鼠标移动到上面，前景色变为红色<br>            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span> <span class="hljs-variable">TargetType</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Button&quot;</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Trigger</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;IsMouseOver&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span><span class="hljs-operator">&gt;</span><br>                            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Setter</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Foreground&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Red&quot;</span><span class="hljs-operator">&gt;&lt;/</span><span class="hljs-built_in">Setter</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Trigger</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>           <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Grid</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;/</span><span class="hljs-variable">Window</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>使用上面的两种方式都可以实现Button按钮的前景色改变，效果如下：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230351681-1555534511.png" srcset="/img/loading.gif" alt="img"></p><p>在判断属性IsMouseOver的值为false的时候，自动将Foreground的值改为之前的值，因此就不需要写IsMouseOver的值为false的时候，将Foreground的值改为Black。</p><h2 id="2-2-属性值继承"><a href="#2-2-属性值继承" class="headerlink" title="2.2 属性值继承"></a>2.2 属性值继承</h2><p>是指属性值自顶向下沿着元素树进行传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;依赖属性&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我使用的是继承的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span>我使用的是自己的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>界面运行效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230206494-1555380756.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-3-节省内存空间"><a href="#2-3-节省内存空间" class="headerlink" title="2.3 节省内存空间"></a>2.3 节省内存空间</h2><p>依赖属性和CLR属性在内存的使用上是截然不同的，每个CLR属性都包含一个非static的字段。<br>因此当我们实例化一个类型的时候，就会创建该类型所拥有的所有CLR属性。<br>也就是说一个对象所占用的内存在调用new操作进行实例化的时候就已经决定了。</p><p>而wpf允许对象在创建的时候并不包含用于存储数据的空间，只保留在需要用到数据的时候能够获得该默认值，即用其他对象数据或者实时分配空间的能力。</p><h1 id="３-如何自定义依赖属性"><a href="#３-如何自定义依赖属性" class="headerlink" title="３. 如何自定义依赖属性"></a>３. 如何自定义依赖属性</h1><h2 id="3-1-声明依赖属性变量"><a href="#3-1-声明依赖属性变量" class="headerlink" title="3.1 声明依赖属性变量"></a>3.1 声明依赖属性变量</h2><p>依赖属性的声明都是通过public static来公开一个静态变量，变量的类型必须是DependencyProperty</p><h2 id="3-2-在属性系统中进行注册"><a href="#3-2-在属性系统中进行注册" class="headerlink" title="3.2 在属性系统中进行注册"></a>3.2 在属性系统中进行注册</h2><p>使用DependencyProperty.Register方法来注册依赖属性，或者是使用DependencyProperty.RegisterReadOnly方法来注册</p><h2 id="3-3-使用-NET属性包装依赖属性"><a href="#3-3-使用-NET属性包装依赖属性" class="headerlink" title="3.3 使用.NET属性包装依赖属性"></a>3.3 使用.NET属性包装依赖属性</h2><p>在类上实现属性时，只要该类派生自 DependencyObject，便可以选择使用 DependencyProperty 标识符来标示属性，从而将其设置为依赖属性。</p><p>其语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DependencyProperty TextProperty;<br>        TextProperty =<br>        DependencyProperty.Register(<span class="hljs-string">&quot;Text&quot;</span>, <span class="hljs-comment">//属性名称</span><br>        <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-comment">//属性类型</span><br>        <span class="hljs-keyword">typeof</span>(TestDependencyPropertyWindow), <span class="hljs-comment">//该属性所有者，即将该属性注册到那个类上</span><br>        <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">//属性默认值</span><br>         <br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Text<br> &#123;<br>    <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(TextProperty); &#125;<br>    <span class="hljs-keyword">set</span> &#123; SetValue(TextProperty, <span class="hljs-keyword">value</span>); &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p> 示例：自定义一个依赖属性，界面包括一个TextBox和TextBlock，TextBlock上面字体的前景色随TextBox里面输入的颜色而改变，如果TextBox里面输入的值可以转换成颜色，TextBlock字体的前景色会显示输入的颜色值，如果不能转换，显示默认的前景色。</p><ul><li>1、在当前项目里面添加一个WPF版的用户控件，命名为“MyDependencyProperty”，在MyDependencyProperty.xaml.cs文件里面自定义一个依赖属性：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Windows;<br><span class="hljs-keyword">using</span> System.Windows.Controls;<br><span class="hljs-keyword">using</span> System.Windows.Data;<br><span class="hljs-keyword">using</span> System.Windows.Documents;<br><span class="hljs-keyword">using</span> System.Windows.Input;<br><span class="hljs-keyword">using</span> System.Windows.Media;<br><span class="hljs-keyword">using</span> System.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> System.Windows.Navigation;<br><span class="hljs-keyword">using</span> System.Windows.Shapes;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">WpfDemo</span><br>&#123;<br>    <span class="hljs-comment">// MyDependencyProperty.xaml 的交互逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDependencyProperty</span> : <span class="hljs-title">UserControl</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-comment">//1、声明依赖属性变量</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyColorProperty;<br><br>        <span class="hljs-comment">//2、在属性系统中进行注册</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            MyColorProperty = DependencyProperty.Register(<span class="hljs-string">&quot;MyColor&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-keyword">typeof</span>(MyDependencyProperty),<br>                <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;Red&quot;</span>, (s, e) =&gt; <br>                &#123;<br>                    <span class="hljs-keyword">var</span> mdp = s <span class="hljs-keyword">as</span> MyDependencyProperty;<br>                    <span class="hljs-keyword">if</span> (mdp != <span class="hljs-literal">null</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">try</span><br>                        &#123;<br>                           <span class="hljs-keyword">var</span> color = (Color)ColorConverter.ConvertFromString(e.NewValue.ToString());<br>                            mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(color);<br>                        &#125;<br>                        catch<br>                        &#123;<br>                           mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(Colors.Black);<br>                        &#125;<br>                    &#125;<br>                <br>                &#125;));<br>        &#125;<br><br>        <span class="hljs-comment">//3、使用.NET属性包装依赖属性:属性名称与注册时候的名称必须一致，</span><br>       <span class="hljs-comment">//即属性名MyColor对应注册时的MyColor</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> MyColor <br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>               <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(MyColorProperty);<br>          &#125;<br>           <span class="hljs-keyword">set</span><br>            &#123;<br>               SetValue(MyColorProperty, <span class="hljs-keyword">value</span>);<br>            &#125;<br>        &#125;                    <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速定义依赖属性的快捷方式：</p><p>输入propdp，连续按两下Tab健，自动生成定义依赖属性的语法。</p><p>和输入cw连续按两下Tab健，自动生成Console.Write()一样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty<br>        &#123;<br>            <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)GetValue(MyPropertyProperty); &#125;<br>            <span class="hljs-keyword">set</span> &#123; SetValue(MyPropertyProperty, <span class="hljs-keyword">value</span>); &#125;<br>        &#125;<br><br>       <span class="hljs-comment">// Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc...</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyPropertyProperty =<br>           DependencyProperty.Register(<span class="hljs-string">&quot;MyProperty&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>), <span class="hljs-keyword">typeof</span>(ownerclass), <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><ul><li>2、在MyDependencyProperty.xaml里面添加一个TextBlock</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MyDependencyProperty&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:mc</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:d</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">mc:Ignorable</span>=<span class="hljs-string">&quot;d&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">d:DesignHeight</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">d:DesignWidth</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我是自定义的依赖属性<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>3、在MainWindow.xaml里面引用新创建的用户控件，并添加一个TextBox，用于输入颜色值，并将自定义的依赖属性MyColor绑定到TextBox</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span></span><br><span class="xml">         xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="xml">         xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;       </span><br><span class="xml">        xmlns:p=&quot;clr-namespace:WpfDemo&quot;</span><br><span class="xml">         Title=&quot;依赖属性&quot; Height=&quot;237&quot; Width=&quot;525&quot; WindowStartupLocation=&quot;CenterScreen&quot;&gt;</span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">TextBox</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;tbColor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextBox</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">p:MyDependencyProperty</span> <span class="hljs-attr">MyColor</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;Binding Path=Text,ElementName=tbColor&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p:MyDependencyProperty</span>&gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span>        </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在设计界面显示的效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115122217947-1972572422.png" srcset="/img/loading.gif" alt="img"></p><p>4、程序运行效果：</p><p>在TextBox里面输入正确的颜色值，前景色会显示为当前输入的颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121945931-691430131.png" srcset="/img/loading.gif" alt="img"></p><p>在TextBox里面输入错误的颜色值，前景色会显示为默认颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121956713-612253816.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>依赖属性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-布局</title>
    <link href="/2021/04/24/WPF-%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/24/WPF-%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>又称容器，面板。<br>在WPF中是最基础也是最重要的一环，它直接决定你界面的样子。掌握熟练度决定它的美观度和可交互性。</p><p>WPF与JavaSwing的布局(容器)有相似之处但又不完全相同。</p><p>WPF的面板主要有6个：</p><ul><li><p>Grid（网格面板）</p></li><li><p>StackPanel(栈面板)</p></li><li><p>Canvas（画布）</p></li><li><p>WrapPanel（环绕面板）</p></li><li><p>DockPanel（停靠面板）</p></li><li><p>UniformGrid(均布网格)</p></li></ul><p>其中前三个最为常用。</p><h1 id="2-Gird-布局"><a href="#2-Gird-布局" class="headerlink" title="2. Gird 布局"></a>2. Gird 布局</h1><p>可以理解为一个表格，类似于HTML中的Table标签。</p><p>它是由行和列组成。</p><h2 id="2-1-标签"><a href="#2-1-标签" class="headerlink" title="2.1 标签"></a>2.1 标签</h2><ul><li><p><code>&lt;Grid&gt;&lt;/Grid&gt;</code><br>该标签对内写入表格内容</p></li><li><p><code>&lt;Grid.RowDefinitions&gt;</code><br>该标签内写入<code>&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</code>标签对<br>用于定义Gird布局中有几行</p></li><li><p><code>&lt;Grid.ColumnDefinitions&gt;</code><br>该标签内写入<code>&lt;ColumnDefinition&gt;&lt;/ColumnDefinition&gt;</code>标签对<br>用于定义Gird布局中有几列</p></li></ul><h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><ul><li><p>Grid.Column<br>当前元素在Gird布局中的第几列</p></li><li><p>Grid.Row<br>当前元素在Gird布局中的第几行</p><blockquote><p>都从0开始数，且该属性写在元素标签内</p></blockquote></li></ul><h2 id="2-3-案例"><a href="#2-3-案例" class="headerlink" title="2.3 案例"></a>2.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上代码的效果是：</p><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424125742746.png" srcset="/img/loading.gif" alt="Grid布局"></p><h1 id="3-StackPanel-布局"><a href="#3-StackPanel-布局" class="headerlink" title="3 StackPanel 布局"></a>3 StackPanel 布局</h1><p>是一个可以将自身内容横向或纵向排列的容器。</p><h2 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 标签"></a>3.1 标签</h2><ul><li><code>&lt;StackPanel&gt;&lt;/StackPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p><ul><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul></li></ul><blockquote><p>默认情况下：<br>水平排列时，每个元素都与面板一样高；<br>垂直排列时，每个元素都与面板一样宽。<br>如果包含的元素超过了面板空间，它只会截断多出的内容。<br>元素的Margin属性用于使元素之间产生一定得间隔，当元素空间大于其内容的空间时，剩余空间将由HorizontalAlignment和 VerticalAlignment属性来决定如何分配。</p></blockquote><h2 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h2><p>垂直排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Vertical&quot;</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131943534.png" srcset="/img/loading.gif" alt="竖直排列"></p><p>水平排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Horizontal&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131833665.png" srcset="/img/loading.gif" alt="水平排列"></p><h1 id="4-WrapPanel-布局"><a href="#4-WrapPanel-布局" class="headerlink" title="4. WrapPanel 布局"></a>4. WrapPanel 布局</h1><p>WrapPanel面板以一行或者一列的形式来布置控件，当一行（列）放满之后自动转到下一行（列）。</p><blockquote><p>除了自动换行外，基本与StackPanel相同</p></blockquote><h2 id="4-1-标签"><a href="#4-1-标签" class="headerlink" title="4.1 标签"></a>4.1 标签</h2><ul><li><code>&lt;WrapPanel&gt;&lt;/WrapPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="4-2-属性"><a href="#4-2-属性" class="headerlink" title="4.2 属性"></a>4.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p></li><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul><h1 id="5-Canvas-布局"><a href="#5-Canvas-布局" class="headerlink" title="5 Canvas 布局"></a>5 Canvas 布局</h1><p>它比较特殊。它属于“任意布局”的一种概念，就是你拖控件到UI上的时候你把它放在哪里它就在那里了。</p><h2 id="5-1-标签"><a href="#5-1-标签" class="headerlink" title="5.1 标签"></a>5.1 标签</h2><ul><li><code>&lt;Canvas&gt;&lt;/Canvas&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="5-2-属性"><a href="#5-2-属性" class="headerlink" title="5.2 属性"></a>5.2 属性</h2><ul><li>Canvas.Top<br>设置元素距Canvas顶部的距离</li><li>Canvas.Bottom<br>设置元素距Canvas底部的距离</li><li>Canvas.Left<br>设置元素距Canvas左边界的距离</li><li>Canvas.Right<br>设置元素距Canvas右边界的距离</li></ul><blockquote><p>当同时设置left和right,top和bottom,以left和top为准</p></blockquote><h2 id="5-3-案例"><a href="#5-3-案例" class="headerlink" title="5.3 案例"></a>5.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Canvas</span> <span class="hljs-attr">Background</span>=<span class="hljs-string">&quot;LightBlue&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Top</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Top=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Bottom</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Bottom=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Left</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Left=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Right</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Right=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Canvas</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>WPF</category>
      
      <category>布局</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-控件</title>
    <link href="/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/"/>
    <url>/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul><li>常用控件表</li></ul><table><thead><tr><th>控件名</th><th>作用</th></tr></thead><tbody><tr><td>Label</td><td>一般用户描述性文字显示</td></tr><tr><td>TextBlock</td><td>只读的文本框，无法进行编辑，比较适合显示文本，该文本内容不允许编辑的情况</td></tr><tr><td>TextBox</td><td>支持编辑的基本控件</td></tr><tr><td>PassWordBox</td><td>一般用于用户输入验证或者注册时使用</td></tr><tr><td>DataGrid</td><td>列表数据显示控件</td></tr><tr><td>ListView</td><td>一般ListView都可以用DataGrid替代</td></tr><tr><td>ListBox</td><td>下拉列表级控件</td></tr><tr><td>GroupBox</td><td>用于组织页面相关元素放到一起，方便用户使用等方面提供帮助。</td></tr><tr><td>RichTextBox</td><td>支持富文本和简单文本等，可以实现出类似Word的那样的效果。</td></tr><tr><td>MediaElement</td><td>对媒体文件的操作和访问</td></tr><tr><td>Menu</td><td>菜单栏方式的多级菜单的管理和操作</td></tr><tr><td>TabControl</td><td>分页标签</td></tr></tbody></table><p><img src="/images/WPF-%E6%8E%A7%E4%BB%B6/image-20210424140413545.png" srcset="/img/loading.gif" alt="image-20210424140413545"></p><ul><li>控件的基础属性<br>宽、高、背景色、字体颜色、字体大小、禁用、启用、显示、隐藏等</li><li>控件显示的值内容<br>Content、Text、Value等</li></ul>]]></content>
    
    
    <categories>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>控件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-绑定</title>
    <link href="/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/"/>
    <url>/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p> 绑定顾名思义，是将我们获取到的数据和UI上的控件绑定起来利用数据的变化来更新界面所看到的内容。</p><p>绑定的五个步骤:</p><ul><li>1.绑定目标 </li><li>2.绑定属性 </li><li>3.绑定模式 </li><li>4.绑定数据源 </li><li>5.关联资源</li></ul><h1 id="2-绑定步骤"><a href="#2-绑定步骤" class="headerlink" title="2. 绑定步骤"></a>2. 绑定步骤</h1><h2 id="2-1-绑定目标"><a href="#2-1-绑定目标" class="headerlink" title="2.1 绑定目标"></a>2.1 绑定目标</h2><p>绑定目标很好理解，其实就是你要操作绑定的控件。例如：Button，TextBox。</p><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot;&gt;&lt;/TextBox&gt;</code></p><p><img src="D:\码田\项目\MyBlog\source\images\WPF-绑定\image-20210424143754327.png" srcset="/img/loading.gif" alt="image-20210424143754327"></p><h2 id="2-2绑定属性（依赖项属性）"><a href="#2-2绑定属性（依赖项属性）" class="headerlink" title="2.2绑定属性（依赖项属性）"></a>2.2绑定属性（依赖项属性）</h2><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot; Text=&quot;&#123;Bingding Name&#125;&quot;&gt;&lt;/TextBox&gt;</code></p><ul><li>Text绑定属性</li><li>Bingding 绑定关键字</li><li>Name你要绑定的数据源的变量名</li></ul><h2 id="2-3-绑定模式"><a href="#2-3-绑定模式" class="headerlink" title="2.3 绑定模式"></a>2.3 绑定模式</h2><table><thead><tr><th>模式名称</th><th>含义</th></tr></thead><tbody><tr><td>TwoWay</td><td>无论是目标属性还是源属性，只要发生了更改，就会更新目标属性或源属性</td></tr><tr><td>OneWay</td><td>仅当源属性发生更改时更新目标属性</td></tr><tr><td>OneTime</td><td>仅当应用程序启动时或 DataContext 进行更改时更新目标属性</td></tr><tr><td>OneWayToSource</td><td>在目标属性更改时更新源属性</td></tr><tr><td>Default</td><td>模式根据实际情况来定，如果是可编辑的就是TwoWay,只读的就是OneWay</td></tr></tbody></table><h2 id="2-4-绑定数据源"><a href="#2-4-绑定数据源" class="headerlink" title="2.4 绑定数据源"></a>2.4 绑定数据源</h2><p>一般来说可以是单个变量（int , double,string）、也可以是一个数据集（List）。根据需求和场景去定义。</p><h2 id="2-5-关联资源-DataContext"><a href="#2-5-关联资源-DataContext" class="headerlink" title="2.5 关联资源 DataContext"></a>2.5 关联资源 DataContext</h2><p>在每一个窗体中，都有一个DataContext ，它是一个object类型主要用来存储绑定资源。</p><h1 id="3-绑定和窗体xaml-cs操作的区别"><a href="#3-绑定和窗体xaml-cs操作的区别" class="headerlink" title="3. 绑定和窗体xaml.cs操作的区别"></a>3. 绑定和窗体xaml.cs操作的区别</h1><p>区别在于，窗体后台文件直接访问控件的操作是事件驱动，如果没有事件的存在是改变不了界面的。</p><p>绑定操作，是以数据本身的变化来通知界面显示改变的。</p><p>UI代码和逻辑代码实现前后端分离。</p>]]></content>
    
    
    <categories>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>绑定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF快速入门</title>
    <link href="/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>整理自B站视频教程:<a href="https://www.bilibili.com/video/BV19K411M72o?p=1">https://www.bilibili.com/video/BV19K411M72o?p=1</a></p><h2 id="1-1-什么是WPF"><a href="#1-1-什么是WPF" class="headerlink" title="1.1 什么是WPF"></a>1.1 什么是WPF</h2><p>WPF全称Windows Presentation Foundation，是微软推出的一项基于windows操作系统的.net平台的c/s客户端构建技术。<br>最大的特征就是可以快速构建项目从而达到节约项目成本的目的。<br>在众多中小型企业比较受欢迎。</p><p>该项受欢迎的行业有医疗、工业、金融、硬件、物流、管理系统（ERP）等领域。</p><p>简而言之就是微软基于C#与.NET推出的一个可视化框架。</p><blockquote><p>微软的可视化框架发展路径：<br>MFC-&gt;WinForm-&gt;WPF</p></blockquote><h2 id="1-2-推荐书籍"><a href="#1-2-推荐书籍" class="headerlink" title="1.2 推荐书籍"></a>1.2 推荐书籍</h2><ul><li><p>《WPF编程宝典使用c#2012和.net4.5 第四版》</p></li><li><p>《c#高级编程》</p></li><li><p>《CLR Via C#》</p></li></ul><h2 id="1-3-前置知识体系"><a href="#1-3-前置知识体系" class="headerlink" title="1.3 前置知识体系"></a>1.3 前置知识体系</h2><ul><li><p>C#</p></li><li><p>学习过至少一种可视化框架或web框架</p></li></ul><h1 id="2-学习目录索引"><a href="#2-学习目录索引" class="headerlink" title="2 学习目录索引"></a>2 学习目录索引</h1><ul><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%B8%83%E5%B1%80/">布局(Pannel)</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/">控件</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/">依赖属性</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/">绑定</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/">命令</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-MVVC/">MVVM</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p><p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。<br>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。<br>这种方式简化了在复杂环境下的配置管理。</p><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><ul><li><p>单例类只能有一个实例</p></li><li><p>单例类必须自己创建自己的唯一实例</p></li><li><p>单例类必须给所有其他对象提供这一实例</p></li></ul><h2 id="2-1-优缺点"><a href="#2-1-优缺点" class="headerlink" title="2.1 优缺点"></a>2.1 优缺点</h2><h3 id="2-1-1-优点"><a href="#2-1-1-优点" class="headerlink" title="2.1.1 优点"></a>2.1.1 优点</h3><ul><li><p>在内存中只有一个对象，节省内存空间；</p></li><li><p>避免频繁的创建销毁对象，可以提高性能；</p></li><li><p>避免对共享资源的多重占用，简化访问；</p></li><li><p>为整个系统提供一个全局访问点。</p></li></ul><h3 id="2-1-2-缺点"><a href="#2-1-2-缺点" class="headerlink" title="2.1.2 缺点"></a>2.1.2 缺点</h3><ul><li><p>不适用于变化频繁的对象；</p></li><li><p>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</p></li><li><p>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</p></li></ul><h2 id="2-2-适用场景"><a href="#2-2-适用场景" class="headerlink" title="2.2 适用场景"></a>2.2 适用场景</h2><ul><li>需要生成唯一序列的环境</li><li>需要频繁实例化然后销毁的对象</li><li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象</li><li>方便资源相互通信的环境</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" alt="单例模式"></p><h1 id="4-实现步骤"><a href="#4-实现步骤" class="headerlink" title="4. 实现步骤"></a>4. 实现步骤</h1><ol><li>将该类的构造方法定义为私有方法：<br>这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</li><li>在该类内提供一个静态方法：<br>当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li></ol><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将为一个网站设计一个用于连接数据库的数据库连接池，它基于JDBC，并且要求具有以下几个功能：</p><ul><li>连接池内有数量可定的已连接对象随时供取用</li><li>当连接池内的连接对象不够时可生成新的对象取用</li><li>当连接操作完毕后，可将连接对象放回连接池</li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p>使用单例模式实现连接池：</p><ol><li><p>将该类的构造方法定义为私有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在该类内提供一个静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>   &#125;<br></code></pre></td></tr></table></figure><p>使用线性表存储连接对象，实现对连接对象操作的各个方法。</p></li></ol><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> EXP6;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;<br>    <span class="hljs-comment">//数据库地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String url;<br>    <span class="hljs-comment">//取得用户</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String user;<br>    <span class="hljs-comment">//登录密码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String password;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Connection&gt; connections;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConnectionPool connectionPool;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(String url,String user,String password)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.url=url;<span class="hljs-keyword">this</span>.user=user;<span class="hljs-keyword">this</span>.password=password;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">(String url,String user,String password)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool(url,user,password);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)<br>            &#123;<br>                connections.add(DriverManager.getConnection(url,user,password));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(connections.size()==<span class="hljs-number">0</span>) addConnection(<span class="hljs-number">1</span>);<br>        Connection t=connections.getFirst();<br>        connections.removeFirst();<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseConnection</span><span class="hljs-params">(Connection c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (c.isClosed()) connections.add(c);<br>                <span class="hljs-keyword">else</span> addConnection(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-进阶写法"><a href="#6-进阶写法" class="headerlink" title="6. 进阶写法"></a>6. 进阶写法</h1><h2 id="6-1-懒汉式-线程不安全"><a href="#6-1-懒汉式-线程不安全" class="headerlink" title="6.1 懒汉式(线程不安全)"></a>6.1 懒汉式(线程不安全)</h2><p>懒汉式其实是一种比较形象的称谓。<br>既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作。<br>因此在装载对象的时候不创建对象实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> (<span class="hljs-params"></span>)</span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         instance = <span class="hljs-keyword">new</span> Singleton();<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。<br>当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。<br>也就是说在多线程下不能正常工作。</p><h2 id="6-2-懒汉式-线程安全"><a href="#6-2-懒汉式-线程安全" class="headerlink" title="6.2 懒汉式(线程安全)"></a>6.2 懒汉式(线程安全)</h2><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。<br>因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。<br>这就引出了双重检验锁。</p><h2 id="6-3-双重检验锁"><a href="#6-3-双重检验锁" class="headerlink" title="6.3 双重检验锁"></a>6.3 双重检验锁</h2><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。<br>程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。<br>为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <span class="hljs-comment">//Single Checked</span><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                 <span class="hljs-comment">//Double Checked</span><br>                instance = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很完美，很可惜，它是有问题:<br>主要在于instance = new Singleton()这句，这<strong>并非是一个原子操作</strong>，事实上在 JVM 中这句话大概做了下面 3 件事情:</p><ul><li><p>给 instance 分配内存</p></li><li><p>调用 Singleton 的构造函数来初始化成员变量</p></li><li><p>将instance对象指向分配的内存空间<br>（执行完这步 instance 就为非 null 了）</p></li></ul><p>但是在 JVM 的即时编译器中存在指令重排序的优化。</p><p>也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。<br>如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance; <span class="hljs-comment">//声明成 volatile</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;       <br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。<br>但其实是不对的。</p><p><strong>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。</strong></p><p>也就是说，<strong>在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前</strong>。<br>比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</p><p>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。<br>这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p><h2 id="6-4-饿汉式-static-final-field"><a href="#6-4-饿汉式-static-final-field" class="headerlink" title="6.4 饿汉式 static final field"></a>6.4 饿汉式 static final field</h2><p>饿汉式其实是一种比较形象的称谓。<br>既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。</p><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-comment">//类加载时就初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点是它不是一种懒加载模式（lazy initialization），<strong>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。</strong></p><blockquote><p>饿汉式的创建方式在一些场景中将无法使用：<br>譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p></blockquote><h2 id="6-5-静态内部类-static-nested-class"><a href="#6-5-静态内部类-static-nested-class" class="headerlink" title="6.5 静态内部类 static nested class"></a>6.5 静态内部类 static nested class</h2><p>这种方法也是《Effective Java》上所推荐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE; <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法仍然使用JVM本身机制保证了线程安全问题。<br>由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，**第一次调用getInstance()时将加载内部类SingletonHolder **，在该内部类中定义了一个static类型的变量INSTANCE ，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><h2 id="6-6-枚举-Enum"><a href="#6-6-枚举-Enum" class="headerlink" title="6.6 枚举 Enum"></a>6.6 枚举 Enum</h2><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EasySingleton</span></span>&#123;<br>    <span class="hljs-type">INSTANCE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>我们可以总结出，要想实现效率高的线程安全的单例，我们必须注意以下两点：</p><ul><li><strong>尽量减少同步块的作用域</strong></li><li><strong>尽量使用细粒度的锁</strong></li></ul><p>一般来说，单例模式有五种写法：<br><strong>懒汉、饿汉、双重检验锁、静态内部类、枚举</strong><br>上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。</p><p>一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。<br>如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p><p>参考：<br><a href="https://www.jianshu.com/p/650593e69f59">https://www.jianshu.com/p/650593e69f59</a><br><a href="https://www.cnblogs.com/xuwendong/p/9633985.html">https://www.cnblogs.com/xuwendong/p/9633985.html</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket原理</title>
    <link href="/2021/04/07/Socket%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/07/Socket%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Socket"><a href="#1-什么是Socket" class="headerlink" title="1. 什么是Socket"></a>1. 什么是Socket</h1><h2 id="1-1-网络中进程之间如何通信"><a href="#1-1-网络中进程之间如何通信" class="headerlink" title="1.1 网络中进程之间如何通信"></a>1.1 网络中进程之间如何通信</h2><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信。</p><p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！<br>在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p><p>其实TCP/IP协议族已经帮我们解决了这个问题：<br>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><p>使用TCP/IP协议的应用程序通常采用应用编程接口：<br>UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。</p><p>就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。</p><h2 id="1-2-什么是TCP-IP、UDP"><a href="#1-2-什么是TCP-IP、UDP" class="headerlink" title="1.2 什么是TCP/IP、UDP"></a>1.2 什么是TCP/IP、UDP</h2><ul><li><p>TCP/IP（Transmission Control Protocol/Internet Protocol）<br>即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。</p></li><li><p>UDP（User Data Protocol，用户数据报协议）<br>是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p></li></ul><p>这里有一张图，表明了这些协议的关系。</p><p>​          <img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154451958.png" srcset="/img/loading.gif" alt="img">                              </p><h2 id="1-3-什么是Socket"><a href="#1-3-什么是Socket" class="headerlink" title="1.3 什么是Socket"></a>1.3 什么是Socket</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。<br>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p><blockquote><h3 id="socket一词的起源"><a href="#socket一词的起源" class="headerlink" title="socket一词的起源"></a>socket一词的起源</h3><p>在组网领域的首次使用是在1970年2月12日发布的文献<a href="http://datatracker.ietf.org/doc/rfc33/">IETF RFC33</a>中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p></blockquote><h2 id="1-4-Socket在哪里"><a href="#1-4-Socket在哪里" class="headerlink" title="1.4 Socket在哪里"></a>1.4 Socket在哪里</h2><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154523875.png" srcset="/img/loading.gif" alt="img"></p><h1 id="2-Socket的使用"><a href="#2-Socket的使用" class="headerlink" title="2. Socket的使用"></a>2. Socket的使用</h1><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154556909.png" srcset="/img/loading.gif" alt="img">   </p><ul><li>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。</li><li>在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。</li><li>客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</li></ul><h2 id="2-1-socket的基本操作"><a href="#2-1-socket的基本操作" class="headerlink" title="2.1 socket的基本操作"></a>2.1 socket的基本操作</h2><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。<br>下面以TCP为例，介绍几个基本的socket接口函数。</p><h3 id="2-1-1-socket-函数"><a href="#2-1-1-socket-函数" class="headerlink" title="2.1.1 socket()函数"></a>2.1.1 socket()函数</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> socket(<span class="hljs-type">int</span> <span class="hljs-keyword">domain</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">type</span>, <span class="hljs-type">int</span> protocol);<br></code></pre></td></tr></table></figure><p>socket函数对应于普通文件的打开操作。<br>普通文件的打开操作返回一个文件描述字，而**socket()**用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。<br>这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。<br>创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：<br>即协议域，又称为协议族（family）。<br>常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。<br>协议族决定了socket的地址类型，在通信中必须采用对应的地址。<br>如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：<br>指定socket类型。<br>常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li><li>protocol：<br>故名思意，就是指定协议。<br>常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等<br>它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li></ul><blockquote><p>注意：<br>并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。<br>当protocol为0时，会自动选择type类型对应的默认协议。</p></blockquote><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h3 id="2-1-2-bind-函数"><a href="#2-1-2-bind-函数" class="headerlink" title="2.1.2 bind()函数"></a>2.1.2 bind()函数</h3><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。<br>例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ul><li><p>sockfd：<br>即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。<br>bind()函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：<br>一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。<br>这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-keyword">sa_family_t</span>    sin_family; <br>    <span class="hljs-keyword">in_port_t</span>      sin_port;   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>   <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span>       s_addr;     <br>&#125;;<br></code></pre></td></tr></table></figure><p>ipv6对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span>     sin6_family;    <br>    <span class="hljs-keyword">in_port_t</span>       sin6_port;      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_flowinfo;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span>      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_scope_id;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> &#123;</span> <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   s6_addr[<span class="hljs-number">16</span>];    <br>&#125;;<br></code></pre></td></tr></table></figure><p>Unix域对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_PATH_MAX    108</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span> sun_family;                <br>    <span class="hljs-keyword">char</span>        sun_path[UNIX_PATH_MAX];   <br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>addrlen：对应的是地址的长度。</p></li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务。<br>客户就可以通过它来接连服务器；</p><p>而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。</p><p>这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p><blockquote><h3 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h3><p><strong>主机字节序</strong>就是我们平常说的大端和小端模式：<br>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。<br>引用标准的Big-Endian和Little-Endian的定义如下：</p><p>　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><p>　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p><strong>网络字节序</strong>：<br>4个字节的32 bit值以下面的次序传输：<br>首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。<br>这种传输次序称作大端字节序。<br><strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong><br>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p><p>所以： 在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。<br>由于 这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再 赋给socket。</p></blockquote><h3 id="2-1-3-listen-、connect-函数"><a href="#2-1-3-listen-、connect-函数" class="headerlink" title="2.1.3 listen()、connect()函数"></a>2.1.3 listen()、connect()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。<br>客户端通过调用connect函数来建立与TCP服务器的连接。</p><h3 id="2-1-4-accept-函数"><a href="#2-1-4-accept-函数" class="headerlink" title="2.1.4 accept()函数"></a>2.1.4 accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。<br>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。<br>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。<br>之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><blockquote><p>注意：<br>accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。<br>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。<br>内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p></blockquote><h3 id="2-1-5-read-、write-等函数"><a href="#2-1-5-read-、write-等函数" class="headerlink" title="2.1.5 read()、write()等函数"></a>2.1.5 read()、write()等函数</h3><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。</p><p>可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。</p><p>它们的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">const</span> struct sockaddr *dest_addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">                 struct sockaddr *src_addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>read函数<br>负责从fd中读取内容<br>当读成功时，read返回实际所读的字节数</p><ul><li>返回的值是0表示已经读到文件的结束了</li><li>返回的值小于0表示出现了错误。<ul><li>如果错误为EINTR说明读是由中断引起的</li><li>如果是ECONNREST表示网络连接出了问题。</li></ul></li></ul></li><li><p>write函数<br>将buf中的nbytes字节内容写入文件描述符fd。</p><ul><li><p>成功时返回写的字节数</p></li><li><p>失败时返回-1，并设置errno变量</p></li><li><p>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</p><ul><li><p>1)write的返回值大于0，表示写了部分或者是 全部的数据。</p></li><li><p>2)返回的值小于0，此时出现了错误。</p></li></ul><p>我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。<br>如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。</p></li></ul></li></ul><p>其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。</p><h3 id="2-1-6-close-函数"><a href="#2-1-6-close-函数" class="headerlink" title="2.1.6 close()函数"></a>2.1.6 close()函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。<br>该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><blockquote><p>注意：<br>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p></blockquote><h2 id="2-2-socket中TCP的三次握手建立连接详解"><a href="#2-2-socket中TCP的三次握手建立连接详解" class="headerlink" title="2.2 socket中TCP的三次握手建立连接详解"></a>2.2 socket中TCP的三次握手建立连接详解</h2><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><p>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0NzYyODYucG5n" srcset="/img/loading.gif" alt="image"></p><p>图1、socket中发送的TCP三次握手</p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><blockquote><p>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</p></blockquote><h2 id="2-3-socket中TCP的四次握手释放连接详解"><a href="#2-3-socket中TCP的四次握手释放连接详解" class="headerlink" title="2.3 socket中TCP的四次握手释放连接详解"></a>2.3 socket中TCP的四次握手释放连接详解</h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0OTQ2OTMucG5n" srcset="/img/loading.gif" alt="image"></p><p>图2、socket中发送的TCP四次握手</p><p>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p>这样每个方向上都有一个FIN和ACK。</p><p>6.下面给出实现的一个实例</p><p>首先，先给出实现的截图</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718155008892.png" srcset="/img/loading.gif" alt="img"></p><p>服务器端代码如下：</p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET sListen = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>//用来指定套接字使用的地址格式，通常使用AF_INET</li><li>//指定套接字的类型，若是SOCK_DGRAM，则用的是udp不可靠传输</li><li>//配合type参数使用，指定使用的协议类型（当指定套接字类型后，可以设置为0，因为默认为UDP或TCP）</li><li>if(sListen == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 填充sockaddr_in结构 ,是个结构体</li><li>sockaddr_in sin;</li><li>sin.sin_family = AF_INET;</li><li>sin.sin_port = htons(4567); //1024 ~ 49151：普通用户注册的端口号</li><li>sin.sin_addr.S_un.S_addr = INADDR_ANY;</li><li>// 绑定这个套节字到一个本地地址</li><li>if(::bind(sListen, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed bind() \n”);</li><li>return 0;</li><li>}</li><li>// 进入监听模式</li><li>//2指的是，监听队列中允许保持的尚未处理的最大连接数</li><li>if(::listen(sListen, 2) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed listen() \n”);</li><li>return 0;</li><li>}</li><li>// 循环接受客户的连接请求</li><li>sockaddr_in remoteAddr;</li><li>int nAddrLen = sizeof(remoteAddr);</li><li>SOCKET sClient = 0;</li><li>char szText[] = “ TCP Server Demo! \r\n”;</li><li>while(sClient==0)</li><li>{</li><li>// 接受一个新连接</li><li>//（(SOCKADDR*)&amp;remoteAddr）一个指向sockaddr_in结构的指针，用于获取对方地址</li><li>sClient = ::accept(sListen, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrLen);</li><li>if(sClient == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed accept()”);</li><li>}</li><li>printf(“接受到一个连接：%s \r\n”, inet_ntoa(remoteAddr.sin_addr));</li><li>continue ;</li><li>}</li><li>while(TRUE)</li><li>{</li><li>// 向客户端发送数据</li><li>gets(szText) ;</li><li>::send(sClient, szText, strlen(szText), 0);</li><li>// 从客户端接收数据</li><li>char buff[256] ;</li><li>int nRecv = ::recv(sClient, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“ 接收到数据：%s\n”, buff);</li><li>}</li><li>}</li><li>// 关闭同客户端的连接</li><li>::closesocket(sClient);</li><li>// 关闭监听套节字</li><li>::closesocket(sListen);</li><li>return 0;</li><li>}</li></ol><p>客户端代码：</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET s = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>if(s == INVALID_SOCKET)</li><li>{</li><li>printf(“ Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 也可以在这里调用bind函数绑定一个本地地址</li><li>// 否则系统将会自动安排</li><li>// 填写远程地址信息</li><li>sockaddr_in servAddr;</li><li>servAddr.sin_family = AF_INET;</li><li>servAddr.sin_port = htons(4567);</li><li>// 注意，这里要填写服务器程序（TCPServer程序）所在机器的IP地址</li><li>// 如果你的计算机没有联网，直接使用127.0.0.1即可</li><li>servAddr.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1”);</li><li>if(::connect(s, (sockaddr*)&amp;servAddr, sizeof(servAddr)) == -1)</li><li>{</li><li>printf(“ Failed connect() \n”);</li><li>return 0;</li><li>}</li><li>char buff[256];</li><li>char szText[256] ;</li><li>while(TRUE)</li><li>{</li><li>//从服务器端接收数据</li><li>int nRecv = ::recv(s, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“接收到数据：%s\n”, buff);</li><li>}</li><li>// 向服务器端发送数据</li><li>gets(szText) ;</li><li>szText[255] = ‘\0’;</li><li>::send(s, szText, strlen(szText), 0) ;</li><li>}</li><li>// 关闭套节字</li><li>::closesocket(s);</li><li>return 0;</li><li>}</li></ol><p>封装的InitSock.h</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include</li><li>#include</li><li>#include</li><li>#include</li><li>#pragma comment(lib, “WS2_32”) // 链接到WS2_32.lib</li><li>class CInitSock</li><li>{</li><li>public:</li><li>CInitSock(BYTE minorVer = 2, BYTE majorVer = 2)</li><li>{</li><li>// 初始化WS2_32.dll</li><li>WSADATA wsaData;</li><li>WORD sockVersion = MAKEWORD(minorVer, majorVer);</li><li>if(::WSAStartup(sockVersion, &amp;wsaData) != 0)</li><li>{</li><li>exit(0);</li><li>}</li><li>}</li><li>~CInitSock()</li><li>{</li><li>::WSACleanup();</li><li>}</li><li>};</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2021/03/27/%E6%A0%88/"/>
    <url>/2021/03/27/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>栈是一种应用广泛的数据结构。</p><p>栈最鲜明的特点就是后进先出，一碟盘子就是类似这样的结构，最晚放上去的，可以最先拿出来。本文将介绍的是如何自己实现一个栈结构。</p><h1 id="2-栈的操作"><a href="#2-栈的操作" class="headerlink" title="2. 栈的操作"></a>2. 栈的操作</h1><p>栈的常见操作有：</p><ul><li>出栈(POP)，从栈中弹出一个元素；</li><li>入栈(PUSH)，将一个元素压入栈中；</li><li>访问栈顶元素(TOP)；</li><li>判断栈是否为空；</li></ul><h1 id="3-栈的实现"><a href="#3-栈的实现" class="headerlink" title="3 .栈的实现"></a>3 .栈的实现</h1><p>栈是较容易实现的抽象数据结构之一。</p><p>我们可以选择数组或者链表来实现，它们各有特点：</p><ul><li>前者容量有限且固定，但操作简单。</li><li>后者容量理论上不受限，但是操作并不如数组方便<br>每次入栈要进行内存申请，出栈要释放内存，稍有不慎便造成内存泄露</li></ul><p>用数组实现栈是比较容易的。</p><p>这个时候的栈像是访问受限的数组，数组可以通过下标访问，查找，插入等，但是栈只能从栈顶，或者说数组的末尾进行操作。<br>我们只需要一个指针记录栈顶即可。</p><h2 id="3-1-数组实现栈"><a href="#3-1-数组实现栈" class="headerlink" title="3.1 数组实现栈"></a>3.1 数组实现栈</h2><h3 id="3-1-1-定义栈"><a href="#3-1-1-定义栈" class="headerlink" title="3.1.1 定义栈"></a>3.1.1 定义栈</h3><p>用数组实现栈时是很容易定义的:<br>只要定一个固定长度的数组即可，然后使用一个指针或者数组下标标记栈顶（topOfStack），栈为空时，它是-1。</p><h3 id="3-1-2-入栈"><a href="#3-1-2-入栈" class="headerlink" title="3.1.2 入栈"></a>3.1.2 入栈</h3><p>入栈操作也很简单，只需要先将topOfStack加1，然后将元素放入数组即可。当然特别要注意检查此时栈是否已满。<br>topOfStack = -1</p><p>将1入栈，此时topOfStack = 0，</p><p>topOfStack    </p><p>1    </p><h3 id="3-1-3-出栈"><a href="#3-1-3-出栈" class="headerlink" title="3.1.3 出栈"></a>3.1.3 出栈</h3><p>与入栈相反，先访问元素，然后将topOfStack减1，但是此时要注意检查栈是否已空。访问栈顶元素可直接使用下标访问，而不用将topOfStack减1。</p><h3 id="3-1-4-访问栈顶元素"><a href="#3-1-4-访问栈顶元素" class="headerlink" title="3.1.4 访问栈顶元素"></a>3.1.4 访问栈顶元素</h3><h3 id="3-1-5判断栈空与栈内元素个数"><a href="#3-1-5判断栈空与栈内元素个数" class="headerlink" title="3.1.5判断栈空与栈内元素个数"></a>3.1.5判断栈空与栈内元素个数</h3><h2 id="3-2-链表实现栈"><a href="#3-2-链表实现栈" class="headerlink" title="3.2 链表实现栈"></a>3.2 链表实现栈</h2><p>与数组实现栈不一样的地方是，链式栈可以动态扩容，基本没有长度限制（受限于内存）。另外，它在入栈以及出栈的时候需要申请或者释放内存。</p><h3 id="3-2-1-定义栈"><a href="#3-2-1-定义栈" class="headerlink" title="3.2.1 定义栈"></a>3.2.1 定义栈</h3><h3 id="3-2-2-入栈"><a href="#3-2-2-入栈" class="headerlink" title="3.2.2 入栈"></a>3.2.2 入栈</h3><h3 id="3-2-3-出栈"><a href="#3-2-3-出栈" class="headerlink" title="3.2.3 出栈"></a>3.2.3 出栈</h3><h3 id="3-2-4-访问栈顶元素"><a href="#3-2-4-访问栈顶元素" class="headerlink" title="3.2.4 访问栈顶元素"></a>3.2.4 访问栈顶元素</h3><h3 id="3-2-5判断栈空与栈内元素个数"><a href="#3-2-5判断栈空与栈内元素个数" class="headerlink" title="3.2.5判断栈空与栈内元素个数"></a>3.2.5判断栈空与栈内元素个数</h3>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
      <tag>数据结构</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer大纲</title>
    <link href="/2021/03/27/%E5%89%91%E6%8C%87offer%E5%A4%A7%E7%BA%B2/"/>
    <url>/2021/03/27/%E5%89%91%E6%8C%87offer%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>对在找工作准备笔试面试过程中，应聘者需要具备的知识技能进行提纲式的总结。</p><h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h1><ul><li>栈</li></ul><h1 id="3-算法"><a href="#3-算法" class="headerlink" title="3. 算法"></a>3. 算法</h1><ul><li><a href="https://mycroftcooper.github.io/2021/03/09/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/">排序</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity输入操作</title>
    <link href="/2021/03/25/Unity%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/03/25/Unity%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>输入操作是游戏的基础操作之一。</p><p>Unity支持的操作方式：</p><ul><li>鼠标、键盘，小键盘(PC)</li><li>手柄(主机)</li><li>触屏操作、重力传感器、手势（移动平台）</li><li>VR，AR</li><li>麦克风，摄像头</li></ul><h1 id="2-虚拟输入轴-Virtual-axes"><a href="#2-虚拟输入轴-Virtual-axes" class="headerlink" title="2. 虚拟输入轴(Virtual axes)"></a>2. 虚拟输入轴(Virtual axes)</h1><p>虚拟控制轴将不同的输入设备(比如键盘或摇杆的按键)都归纳到一个统一的虚拟控制系统中。<br>(比如键盘的w、S键以及手柄摇杆的上下运动默认都统一映射到竖直(Verica)输入轴上)<br>这样就屏蔽了不同设备之间的差异，让开发者可以用一套非常简单的输入逻辑，同时兼容多种输入设备。</p><p>使用**输入管理器(Input Manager)**可以查看、修改或增删虚拟轴。</p><p>现代的游戏中往往允许玩家在游戏中自定义按键，所以使用Unity的输入管理器就更为重要要了。<br>通过一层虚拟轴间接操作，可以避免在代码中直接写死操作按钮，而且还能通过动态修改虚拟轴的设置来改变键位的功能。</p><p>关于虚拟输入轴，还有一些需要知道的内容：</p><ol><li><p>脚本可以直接通过虚拟轴的名称读取那个轴的输入状态。</p></li><li><p>创建Unity工程时，默认创建了以下虚拟轴:</p><ul><li><p>横向输入和纵向输入被映射在键盘的W、A、S、 D键以及方向键上</p></li><li><p>Fire1、 Fire2、 Fire3这三个按钮映射到了鼠标的左、中、右键以及键盘的Ctrl. AIt等键位上</p></li><li><p>鼠标移动可以模拟摇杆输入(和鼠标光标在屏幕上的位置无关)，且被映射在专门的鼠标偏移轴上</p></li><li><p>其他常用虚拟轴，例如跳跃(Jump) 、确认(Submit) 和取消(Cancel) </p></li></ul><h2 id="2-1-添加和编辑虚拟输入轴"><a href="#2-1-添加和编辑虚拟输入轴" class="headerlink" title="2.1 添加和编辑虚拟输入轴"></a>2.1 添加和编辑虚拟输入轴</h2></li></ol><p>要添加新的虚拟输入轴，只需要单击主菜单的Edit &gt; Projet Setings &gt; Input 选项，单击路街检视窗口中会显示一个输入管理器，在里面就可以修改或添加虚拟轴了。</p><blockquote><p>注意:<br>虚拟轴具有正、负两个方向。英文记作Positive和Negative.。<br>某些相反的动作可以只用一个轴来表示。<br>比如，如果摇杆向上为正，那么向下就是同一个轴的负方向。</p></blockquote><p>每个虚拟轴可以映射两个按键，第二个按键作为备用，功能一样，备用的英文为Alterative。</p><h2 id="2-2-虚拟输入轴属性表"><a href="#2-2-虚拟输入轴属性表" class="headerlink" title="2.2 虚拟输入轴属性表"></a>2.2 虚拟输入轴属性表</h2><p>下表是虚拟输入轴的属性表：</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>Name</td><td>轴的名字。在脚本中用这个名字来访问这个轴</td></tr><tr><td>Descriptive Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(正方向)</td></tr><tr><td>Descriptive Negative Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(负方向)</td></tr><tr><td>Ncgative Button</td><td>该轴的负方向，用于绑定某个按键</td></tr><tr><td>Positive Button</td><td>该轴的正方向，用于绑定某个按键</td></tr><tr><td>Alt Negative Button</td><td>该轴的负方向，用于绑定某个备用按键</td></tr><tr><td>Alt Positive Button</td><td>该轴的正方向，用于绑定某个备用按键</td></tr><tr><td>Gravity</td><td>轴回中的力度</td></tr><tr><td>Dead</td><td>轴的死区</td></tr><tr><td>Sensitivity</td><td>敏感度</td></tr><tr><td>Snap</td><td>保持式按键。比如按住下方向键，则一直保持下的状态，直到再次按上方向键</td></tr><tr><td>Invert</td><td>如果勾选，则交换正负方向</td></tr><tr><td>Type</td><td>控制该虚拟轴的类型， 比如手柄、键盘是两种不同的类型</td></tr><tr><td>Axis</td><td>很多手柄的输入不是按钮式的，这时就不能配置到Button里面，而是要配置到这里。可以理解为实际的操作轴</td></tr><tr><td>Joy Num</td><td>当有多个控制器时，要填写控制器的编号</td></tr></tbody></table><p>上表中的Gravity、Dead 等属性需要解释一下。</p><h3 id="2-2-1-Gravity"><a href="#2-2-1-Gravity" class="headerlink" title="2.2.1 Gravity"></a>2.2.1 Gravity</h3><p>现代游戏的方向输入和早期游戏的方向输入不太一样。<br>早期游戏中，上、中、下都是离散的状态，可以直接用1、0、-1来表示。<br>而现代游戏输入往往具有中间状态，比如0、0.35、 0.5、0.7、1, 是带有多级梯度的。<br>比如轻推摇杆代表走路，推到底就是跑步。<br>所以现代游戏的输入默认都是采用多梯度的模式。</p><p>虽然键盘没有多级输入的功能，但Unity依然会模拟这个功能，也就是说当你按住W键时，这个轴的值会以很快的速度逐渐从0增加到1。</p><p>所以，上表中Gravity和Sensitivity的含义就不难理解了，它们影响着虚拟轴从1到0、从0到1的速度以及敏感度。</p><blockquote><p>具体调试方法这里不再介绍，建议使用默认值</p></blockquote><h3 id="2-2-2-Dead"><a href="#2-2-2-Dead" class="headerlink" title="2.2.2 Dead"></a>2.2.2 Dead</h3><p>还有死区需要单独说明。</p><p>由于实体手柄、摇杆会有一些误差，比如，手柄放着不动时，某些手柄的输出值可能会在0.05 和0.08之间浮动。这个误差有必要在程序中排除。<br>所以Unity设计了死区的功能，在该值范围内的抖动被忽略为0,这样就可以过滤掉输入设备的误差。</p><h2 id="2-3-在脚本中处理输入"><a href="#2-3-在脚本中处理输入" class="headerlink" title="2.3 在脚本中处理输入"></a>2.3 在脚本中处理输入</h2><p>读取输入轴的方法很简单，代码如下:</p><p><code>float value = Input.GetAxis (&quot;Horizontal&quot;);</code></p><p>得到的值的范围为-1~1,默认位置为0。<br>这个读取虚拟轴的方法与具体控制器是键盘还是手柄无关。</p><blockquote><p>如果用鼠标控制虚拟轴，就有可能由于移动过快导致值超出-1~1的范围。</p></blockquote><blockquote><p>注意:<br>可以创建多个相同名字的虚拟轴。<br>Unity 可以同时管理多个同名的轴，最终结果以变化最大的轴为准。<br>这样做的原因是很多游戏可以同时用多种设备进行操作。<br>比如PC游戏可以用键盘、鼠标或手柄进行操作，手机游戏可以用重力感应器或手柄进行操作。<br>这种设计有助于用户在多种操作设备之间切换，且在脚本中不用去关心这一点。</p></blockquote><h2 id="2-4-按键名称"><a href="#2-4-按键名称" class="headerlink" title="2.4 按键名称"></a>2.4 按键名称</h2><p>要映射按键到轴上，需要在正方向输入框或者负方向输入框中输入正确的按键名称。<br>按键名称的规则和例子如下。</p><ul><li><p>常规按键: A、B、……</p></li><li><p>数字键: 1、2、……</p></li><li><p>方向键: Up、 Down、 Left、 Right…..</p></li><li><p>小键盘键: [1]、 [2]、 [3]、 [+]、 [equals]…..</p></li><li><p>修饰键: Right+Shift、 Lef+Shift、Right+Ctrl、Left+Ctrl、Right+Alt、Left+Alt、Right+Cmd、Left+Cmd….</p></li><li><p>鼠标按钮: mouse 0、mouse 1、mouse2 …..</p></li><li><p>手柄按钮(不指定具体的手柄序号) : joystick button 0、joystick button 1…..</p></li><li><p>手柄按钮(指定具体的手柄序号): joystick 1 button 0、joystick 1 button 1……</p></li><li><p>特殊键: Backspace、 Tab、 Retur、 Escape、 Space、 Delete、 Enter、 Insert、 Home、Page Up…..</p></li><li><p>功能键: FI、F2、…..</p><blockquote><p>可以使用<strong>KeyCode枚举类</strong>型来指定案件，与用字符串的效果一致</p></blockquote></li></ul><h1 id="3-在PC端输入"><a href="#3-在PC端输入" class="headerlink" title="3. 在PC端输入"></a>3. 在PC端输入</h1><p>unity为开发者提供了input库，来支持键盘事件，鼠标事件以及触摸事件。</p><h2 id="3-1-键盘事件"><a href="#3-1-键盘事件" class="headerlink" title="3.1 键盘事件"></a>3.1 键盘事件</h2><p>一般的PC键盘有104个不同的按键，在程序中通过监听这些按键事件，从而进一步执行逻辑操作。<br>如：射击游戏中，W表示前进，S表示后退，A表示左移，D表示右移。</p><h3 id="3-1-1-按下事件"><a href="#3-1-1-按下事件" class="headerlink" title="3.1.1 按下事件"></a>3.1.1 按下事件</h3><p>在脚本中，用<strong>input.GetKeyDown( )方法</strong>将按键值作为参数，监听此按键是否被按下。<br>按下返回true，否者返回false。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了W键&quot;</span>);  <br>            &#125;  <br><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了空格键&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-2-抬起事件"><a href="#3-1-2-抬起事件" class="headerlink" title="3.1.2 抬起事件"></a>3.1.2 抬起事件</h3><p>抬起事件完全依赖于按下事件，因为只有按下才有抬起。</p><p>我们用<strong>Input.GetKeyUp( )方法</strong>监听抬起事件<br>按键抬起后，返回true，否则返回false。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.W))  <br>           &#123;  <br>               Debug.Log(<span class="hljs-string">&quot;您抬起了W键&quot;</span>);  <br>           &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-3-长按事件"><a href="#3-1-3-长按事件" class="headerlink" title="3.1.3 长按事件"></a>3.1.3 长按事件</h3><p>长按事件是监听某一按键是否处于一直按下的状态<br>通过**Input.GetKey( )**来判断键盘中某一按键是否被一直按着。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKey (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//记录按下的帧数  </span><br>                keyFrame++;  <br>                Debug.Log(<span class="hljs-string">&quot;A连按:&quot;</span> + keyFrame+<span class="hljs-string">&quot;帧&quot;</span>);  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//抬起后清空帧数  </span><br>                keyFrame=<span class="hljs-number">0</span>;  <br>                Debug.Log(<span class="hljs-string">&quot;A按键抬起&quot;</span>);  <br>            &#125;     <br></code></pre></td></tr></table></figure><h3 id="3-1-4-任意键事件"><a href="#3-1-4-任意键事件" class="headerlink" title="3.1.4 任意键事件"></a>3.1.4 任意键事件</h3><p>在程序中还可以监听按键中的任意按键是否被按下</p><p>常见于加载完游戏后，按任意键进入。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span>(Input.anyKeyDown)  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;任意键被按下&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-4实例——组合按键"><a href="#3-1-4实例——组合按键" class="headerlink" title="3.1.4实例——组合按键"></a>3.1.4实例——组合按键</h3><p>在经典的格斗游戏中，会有组合键发出牛逼的大招，而这个功能的事件思路其实不难：<br>在玩家按下某一键后，便开始时间记数，在某一时间内按出所需要的键便发出大招。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs c#">    <span class="hljs-keyword">using</span> UnityEngine;  <br>    <span class="hljs-keyword">using</span> System.Collections.Generic;  <br>    <span class="hljs-keyword">using</span> System;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Script_07_05</span> : <span class="hljs-title">MonoBehaviour</span>   <br>    &#123;  <br>        <span class="hljs-comment">//方向键上的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageUp;  <br>        <span class="hljs-comment">//方向键下的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageDown;  <br>        <span class="hljs-comment">//方向键左的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageLeft;  <br>        <span class="hljs-comment">//方向键右的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageRight;  <br>        <span class="hljs-comment">//按键成功的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageSuccess; <br>        <br>        <span class="hljs-comment">//自定义方向键的储存值  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_UP = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_DOWN = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_LEFT = <span class="hljs-number">2</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_RIGHT = <span class="hljs-number">3</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_FIRT = <span class="hljs-number">4</span>;  <br>        <br>        <span class="hljs-comment">//连续按键的事件限制  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> FRAME_COUNT = <span class="hljs-number">100</span>;  <br><br>        <span class="hljs-comment">//仓库中储存技能的数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_SIZE = <span class="hljs-number">3</span>;  <br><br>        <span class="hljs-comment">//每组技能的按键数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_COUNT = <span class="hljs-number">5</span>;  <br><br>        <span class="hljs-comment">//技能仓库  </span><br>        <span class="hljs-built_in">int</span>[,] Sample =   <br>        &#123;  <br>            <span class="hljs-comment">//下 + 前 + 下 + 前 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_RIGHT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 前 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 后 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_LEFT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>        &#125;;  <br>        <span class="hljs-comment">//记录当前按下按键的键值  </span><br>        <span class="hljs-built_in">int</span>  currentkeyCode =<span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//标志是否开启监听按键  </span><br>        <span class="hljs-built_in">bool</span> startFrame = <span class="hljs-literal">false</span>;  <br>        <span class="hljs-comment">//记录当前开启监听到现在的时间  </span><br>        <span class="hljs-built_in">int</span>  currentFrame = <span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//保存一段时间内玩家输入的按键组合  </span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; playerSample;  <br>        <span class="hljs-comment">//标志完成操作  </span><br>        <span class="hljs-built_in">bool</span> isSuccess= <span class="hljs-literal">false</span>;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//初始话按键组合链表  </span><br>            playerSample  = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();  <br>        &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获得按键组合链表中储存按键的数量  </span><br>            <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>            <span class="hljs-comment">//遍历该按键组合链表  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; size; i++)  <br>            &#123;  <br>                <span class="hljs-comment">//将按下按键对应的图片显示在屏幕中  </span><br>                <span class="hljs-built_in">int</span> key = playerSample[i];  <br>                Texture temp = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">switch</span>(key)  <br>                &#123;  <br>                    <span class="hljs-keyword">case</span> KEY_UP:  <br>                        temp = imageUp;  <br>                        <span class="hljs-keyword">break</span>;  <br>                    <span class="hljs-keyword">case</span> KEY_DOWN:<br>                        temp = imageDown;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_LEFT:<br>                        temp = imageLeft;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_RIGHT:<br>                        temp = imageRight;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp != <span class="hljs-literal">null</span>)  <br>                &#123;<br>                    GUILayout.Label(temp);  <br>                &#125;  <br>            &#125;<br>            <span class="hljs-keyword">if</span>(isSuccess)<br>            &#123;<br>                <span class="hljs-comment">//显示成功贴图</span><br>                GUILayout.Label(imageSuccess);<br>            &#125;<br>            <span class="hljs-comment">//默认提示信息</span><br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键1：下、前、下、前、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、前、下、后、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、后、下、后、拳&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//更新按键</span><br>            UpdateKey();<br>            <span class="hljs-keyword">if</span>(Input.anyKeyDown)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(isSuccess)<br>                &#123;<br>                    <span class="hljs-comment">//按键成功后重置</span><br>                    isSuccess = <span class="hljs-literal">false</span>;<br>                    Reset();<br>                &#125;<br>                <span class="hljs-keyword">if</span>(!startFrame)<br>                &#123;<br>                    <span class="hljs-comment">//启动时间计数器</span><br>                    startFrame = <span class="hljs-literal">true</span>;<br>                &#125;  <br>                <span class="hljs-comment">//将按键值添加如链表中  </span><br>                playerSample.Add(currentkeyCode);  <br>                <span class="hljs-comment">//遍历链表  </span><br>                <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>                <span class="hljs-keyword">if</span>(size == SAMPLE_COUNT)  <br>                &#123;  <br>                    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; SAMPLE_SIZE; i++)  <br>                    &#123;  <br>                        <span class="hljs-built_in">int</span> SuccessCount = <span class="hljs-number">0</span>;  <br>                        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j&lt; SAMPLE_COUNT; j++)  <br>                        &#123;  <br>                            <span class="hljs-built_in">int</span> temp = playerSample[j];  <br>                            <span class="hljs-keyword">if</span>(temp== Sample[i,j])<br>                            &#123;  <br>                                SuccessCount++;  <br>                            &#125;  <br>                        &#125;  <br><span class="hljs-comment">//玩家按下的组合按键与仓库中的按键组合相同表示释放技能成功</span><br>                        <span class="hljs-keyword">if</span>(SuccessCount ==SAMPLE_COUNT)  <br>                        &#123;  <br>                            isSuccess = <span class="hljs-literal">true</span>;  <br>                            <span class="hljs-keyword">break</span>;  <br>                        &#125;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(startFrame)  <br>            &#123;  <br>                <span class="hljs-comment">//计数器++  </span><br>                currentFrame++;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(currentFrame &gt;= FRAME_COUNT)  <br>            &#123; <br>                <span class="hljs-comment">//计数器超时  </span><br>                <span class="hljs-keyword">if</span>(!isSuccess)  <br>                &#123;  <br>                    Reset();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>         <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span> (<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>         &#123;  <br>            <span class="hljs-comment">//重置按键相关信息  </span><br>            currentFrame = <span class="hljs-number">0</span>;  <br>            startFrame = <span class="hljs-literal">false</span>;  <br>            playerSample.Clear();  <br>         &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateKey</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获取当前键盘的按键信息  </span><br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                currentkeyCode = KEY_UP;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.S))  <br>            &#123;  <br>                currentkeyCode = KEY_DOWN;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.A))  <br>            &#123;  <br>                currentkeyCode = KEY_LEFT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.D))  <br>            &#123;  <br>                currentkeyCode = KEY_RIGHT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>               currentkeyCode = KEY_FIRT;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>按s,d,s,d,空格：<img src="./images/Unity%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/20160426162352358" srcset="/img/loading.gif" alt="img"></p><h2 id="3-2-鼠标事件"><a href="#3-2-鼠标事件" class="headerlink" title="3.2 鼠标事件"></a>3.2 鼠标事件</h2><p>和键盘事件一样，鼠标一般只有3个按键，左键、右键和中键。</p><p>具体如下：</p><h3 id="3-2-1-按下事件"><a href="#3-2-1-按下事件" class="headerlink" title="3.2.1 按下事件"></a>3.2.1 按下事件</h3><p><code>Input.GetMouseButtonDown()</code><br>来判断鼠标哪个按键被按下：</p><ul><li>返回值为0代表鼠标左键被按下</li><li>返回值为1代表鼠标右键被按下</li><li>返回值为2代表鼠标中键被按下</li></ul><h3 id="3-2-2-抬起事件"><a href="#3-2-2-抬起事件" class="headerlink" title="3.2.2 抬起事件"></a>3.2.2 抬起事件</h3><p><code>Input.GetMouseButtonUp()</code><br>方法监听鼠标按键的抬起事件</p><h3 id="3-2-3-长按事件"><a href="#3-2-3-长按事件" class="headerlink" title="3.2.3 长按事件"></a>3.2.3 长按事件</h3><p><code>Input.GetMouseButton()</code></p><p>监听鼠标某个按键是否一直处于按下状态</p><h1 id="4-在移动端输入"><a href="#4-在移动端输入" class="headerlink" title="4. 在移动端输入"></a>4. 在移动端输入</h1><p>略</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>输入操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>观察者模式是一种对象行为模式。<br>在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。</p><p>它定义对象间的一种一对多的依赖关系：<br>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>主体是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅并接收通知。</p><p>观察者模式（Observer）完美的将观察者和被观察的对象分离开。<br>观察者模式被广泛应用于软件界面元素之间的交互，在业务对象之间的交互、权限管理等方面。</p><blockquote><p>此种模式通常被用来实现事件处理系统</p></blockquote><p>别名：</p><ul><li>发布-订阅(Publish/Subscribe)模式</li><li>模型-视图(Model/View)模式</li><li>源-监听器(Source/Listener)模式</li><li>从属者(Dependents)模式</li></ul><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>交互对象之间尽量采用低耦合设计</li><li>封装代码中经常变化的数据</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/3985563-8f775c097136a39d.png" srcset="/img/loading.gif" alt="img"></p><p>观察者模式所涉及的角色有：</p><ul><li><p><strong>抽象主题(Subject)角色：</strong><br>抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。<br>抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p></li><li><p><strong>具体主题(ConcreteSubject)角色：</strong><br>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。<br>具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p></li><li><p><strong>抽象观察者(Observer)角色：</strong><br>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p></li><li><p><strong>具体观察者(ConcreteObserver)角色：</strong><br>存储与主题的状态自恰的状态。<br>具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。<br>如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p></li></ul><h1 id="4-推模型与拉模型"><a href="#4-推模型与拉模型" class="headerlink" title="4. 推模型与拉模型"></a>4. 推模型与拉模型</h1><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><h2 id="4-1-推模型"><a href="#4-1-推模型" class="headerlink" title="4.1 推模型"></a>4.1 推模型</h2><p>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><h2 id="4-2-拉模型"><a href="#4-2-拉模型" class="headerlink" title="4.2 拉模型"></a>4.2 拉模型</h2><p>主题对象在通知观察者的时候，只传递少量信息。<br>如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。</p><p>一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><h2 id="4-3-二者比较"><a href="#4-3-二者比较" class="headerlink" title="4.3 二者比较"></a>4.3 二者比较</h2><ul><li><ul><li><p>推模型是假定主题对象知道观察者需要的数据</p></li><li><p>拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值</p></li></ul></li><li><ul><li><p>推模型可能会使得观察者对象难以复用<br>因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况<br>这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者</p></li><li><p>拉模型就不会造成这样的情况<br>因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p></li></ul></li></ul><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将设计一个气象监测应用，它要求具备以下几个功能：</p><ul><li><p>可以从气象站更新：温度，湿度，气压三项数据</p></li><li><p>可以给用户用多种视图展示数据：<br>初始三种视图：目前状况，天气统计，天气预报<br>可以随时增加新的视图</p></li><li><p>用户视图更新有两种方式：</p><ul><li><p>系统按事件自动更新数据同时更新视图</p></li><li><p>用户主动请求更新数据与视图</p></li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%A4%A9%E6%B0%94%E7%9B%91%E6%B5%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="天气监测应用设计类图"></p></li></ul><p>从上图可以分析出各个类在观察者模式中他们的角色：</p><ul><li><p>抽象主题(Subject)角色：Subject</p></li><li><p>具体主题(ConcreteSubject)角色：WeatherData</p></li><li><p>抽象观察者(Observer)角色：Observer</p></li><li><p>具体观察者(ConcreteObserver)角色：StatisticsDisplay;ThirdPartDisplay;ForecastDisplay;</p></li></ul><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><h3 id="5-3-1-抽象主题编写"><a href="#5-3-1-抽象主题编写" class="headerlink" title="5.3.1 抽象主题编写"></a>5.3.1 抽象主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//添加观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//移除观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//广播</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-抽象观察者编写"><a href="#5-3-2-抽象观察者编写" class="headerlink" title="5.3.2 抽象观察者编写"></a>5.3.2 抽象观察者编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span>;<span class="hljs-comment">//广播更新的数据(推模型)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//观察者申请数据更新(拉模型)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-具体主题编写"><a href="#5-3-3-具体主题编写" class="headerlink" title="5.3.3 具体主题编写"></a>5.3.3 具体主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherData</span>:<span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Data<br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> temperature;<span class="hljs-comment">//温度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> humidity;<span class="hljs-comment">//湿度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> pressure;<span class="hljs-comment">//气压</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> Data data;<br>    List&lt;Observer&gt; listeners;<span class="hljs-comment">//订阅的观察者名单</span><br>    <span class="hljs-keyword">public</span> Data Datas &#123; <span class="hljs-keyword">get</span> =&gt; data;&#125;<span class="hljs-comment">//用于实现拉模式的get属性</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherData</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123; <br>        listeners = <span class="hljs-keyword">new</span> List&lt;Observer&gt;();<br>        measurementsChanged();<br>        data = <span class="hljs-keyword">new</span> Data();<br>    &#125;<br>    <span class="hljs-comment">//对Subject接口的实现</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Add(a);<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Remove(a);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Observer i <span class="hljs-keyword">in</span> listeners)<br>        &#123;<br>            i.update(data);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//更新天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        getRandomDate();<br>        notifyObserver();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getRandomDate</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//随机产生天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        data.humidity = random.NextDouble();<br>      data.temperature=random.Next(<span class="hljs-number">-40</span>,<span class="hljs-number">40</span>)+random.NextDouble();<br>        data.pressure = random.Next(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)+random.NextDouble();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-4-具体观察者编写"><a href="#5-3-4-具体观察者编写" class="headerlink" title="5.3.4 具体观察者编写"></a>5.3.4 具体观察者编写</h3><p>显示模式的接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">DisplayElement</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>三种显示模式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentConditionsDisplay</span>:<span class="hljs-title">Observer</span>,<span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示当前观测值</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    <span class="hljs-keyword">private</span> Data d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CurrentConditionsDisplay</span>(<span class="hljs-params">Subject x</span>) </span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = x; <br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;---当前天气---&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;当前温度:&quot;</span> + d.temperature.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前气压:&quot;</span> <br>        + d.pressure.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前湿度:&quot;</span>+d.humidity.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StatisticsDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示统计最大最小平均值</span><br>&#123;<br>    Subject weatherData;<br>    <span class="hljs-keyword">private</span> Queue&lt;Data&gt; dates;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StatisticsDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>        dates = <span class="hljs-keyword">new</span> Queue&lt;Data&gt;();<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span>(dates.Count== <span class="hljs-number">3</span>)dates.Dequeue();<br>        dates.Enqueue(x);<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>=&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Double[] average = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">foreach</span> (Data i <span class="hljs-keyword">in</span> dates)<br>        &#123;<br>            average[<span class="hljs-number">0</span>] += i.temperature;<br>            average[<span class="hljs-number">1</span>] += i.pressure;<br>            average[<span class="hljs-number">2</span>] += i.humidity;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;***天气统计***&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;最高温度:&quot;</span> + dates.Max(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低温度:&quot;</span> + dates.Min(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均温度:&quot;</span> +<br>        (average[<span class="hljs-number">0</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高气压:&quot;</span> + dates.Max(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <br>        <span class="hljs-string">&quot;\t最低气压:&quot;</span> + dates.Min(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均气压:&quot;</span> +<br>        (average[<span class="hljs-number">1</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高湿度:&quot;</span> + dates.Max(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低湿度:&quot;</span> + dates.Min(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均湿度:&quot;</span> +<br>        (average[<span class="hljs-number">2</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ForecastDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示天气预报</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    Data d;<br>    String weather;<br>    <span class="hljs-built_in">double</span> t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForecastDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data data</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = data;<br>        <span class="hljs-keyword">if</span> (d.humidity &gt; <span class="hljs-number">0.5</span> &amp;&amp; d.pressure &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(d.temperature&lt;<span class="hljs-number">1</span>) weather = <span class="hljs-string">&quot;雪&quot;</span>;<br>                <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;雨&quot;</span>;<br>            &#125;<br>        <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;晴&quot;</span>;<br>        t = d.temperature;<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;===天气预报===&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;今日天气:&quot;</span> + weather + <span class="hljs-string">&quot;\t 温度:&quot;</span> + t.ToString(<span class="hljs-string">&quot;F2&quot;</span>)+<span class="hljs-string">&quot;\n&quot;</span>); ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-5-测试"><a href="#5-3-5-测试" class="headerlink" title="5.3.5 测试"></a>5.3.5 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    WeatherData weatherData = <span class="hljs-keyword">new</span> WeatherData();<br>    CurrentConditionsDisplay s1 = <span class="hljs-keyword">new</span> CurrentConditionsDisplay(weatherData);<br>    StatisticsDisplay s2 = <span class="hljs-keyword">new</span> StatisticsDisplay(weatherData);<br>    ForecastDisplay s3 = <span class="hljs-keyword">new</span> ForecastDisplay(weatherData);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>    &#123;<br>        weatherData.measurementsChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210325114238949.png" srcset="/img/loading.gif" alt="测试结果"></p><h1 id="6-java中的观察者模式类"><a href="#6-java中的观察者模式类" class="headerlink" title="6. java中的观察者模式类"></a>6. java中的观察者模式类</h1><blockquote><p>略 <a href="https://www.jianshu.com/p/fc4554cda68d">https://www.jianshu.com/p/fc4554cda68d</a></p></blockquote><h1 id="8-C-中实现观察者模式的方法"><a href="#8-C-中实现观察者模式的方法" class="headerlink" title="8. C#中实现观察者模式的方法"></a>8. C#中实现观察者模式的方法</h1><p>整理自：<a href="https://www.jb51.net/article/63077.htm">https://www.jb51.net/article/63077.htm</a></p><h2 id="8-1-利用事件"><a href="#8-1-利用事件" class="headerlink" title="8.1 利用事件"></a>8.1 利用事件</h2><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a></p></blockquote><p>我们将上面讲的天气数据监测应用改成用C#事件实现的观察者模式</p><ol><li><p>在WeatherData类中声明委托与事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WeatherdateUpdate</span>(<span class="hljs-params">Data data</span>)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> WeatherdateUpdate updata;<br></code></pre></td></tr></table></figure></li><li><p>在WeatherData类中编写事件触发函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyByEvent</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span>(updata!=<span class="hljs-literal">null</span>)<br>            &#123;<br>                updata(data);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>在三个具体观察者中编写事件处理函数并在构造函数中订阅到事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//写在构造函数里</span><br>WeatherData.updata += update;<span class="hljs-comment">//事件订阅</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)<span class="hljs-comment">//事件处理</span></span><br><span class="hljs-function"></span>        &#123;<br>            d = x; <br>            display();<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>触发事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            getRandomDate();<br>            <span class="hljs-comment">//notifyObserver();</span><br>            notifyByEvent();<br>        &#125;<br></code></pre></td></tr></table></figure><p>运行输出结果与用接口实现的效果完全相同。</p></li></ol><h2 id="8-2-利用IObservable和IObserver实现"><a href="#8-2-利用IObservable和IObserver实现" class="headerlink" title="8.2 利用IObservable和IObserver实现"></a>8.2 利用IObservable<out T>和IObserver<in T>实现</h2><p>与java中类似，略</p><h2 id="8-3-利用Action函数式"><a href="#8-3-利用Action函数式" class="headerlink" title="8.3 利用Action函数式"></a>8.3 利用Action函数式</h2><p>略</p><h1 id="7-优缺点"><a href="#7-优缺点" class="headerlink" title="7. 优缺点"></a>7. 优缺点</h1><h2 id="7-1-优点"><a href="#7-1-优点" class="headerlink" title="7.1 优点"></a>7.1 优点</h2><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</li><li>目标与观察者之间建立了一套触发机制。</li></ul><h2 id="7-2-缺点"><a href="#7-2-缺点" class="headerlink" title="7.2 缺点"></a>7.2 缺点</h2><ul><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>观察者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>策略模式属于对象的行为模式。<br>其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。<br>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><ul><li><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>找出项目中不稳定的代码（可能需要改动的地方），把它们独立出来，不要把它们和其它稳定的代码混在一起</li><li>针对接口编程而不是针对实现编程</li><li>多用组合少用继承</li></ul></li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p>策略模式是对算法的包装，是把调用算法的责任（行为）和算法本身（行为实现）分割开来，委派给不同的对象管理。</p><p>策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。下面就以一个示意性的实现讲解策略模式实例的结构。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-b97fa59581b3c88c.png" srcset="/img/loading.gif" alt="img"></p><p>这个模式涉及到三个角色：</p><ul><li>环境(Context)角色：<br>持有一个Strategy的引用，即具有复杂多变行为的对象。</li><li>抽象策略(Strategy)角色：<br>这是一个抽象角色，通常由一个接口或抽象类实现。<br>此角色给出所有的具体策略类所需的接口。</li><li>具体策略(ConcreteStrategy)角色：<br>包装了相关的算法或行为。</li></ul><h1 id="4-模式案例"><a href="#4-模式案例" class="headerlink" title="4. 模式案例"></a>4. 模式案例</h1><h2 id="4-1-案例描述"><a href="#4-1-案例描述" class="headerlink" title="4.1 案例描述"></a>4.1 案例描述</h2><p>你将设计一个ARPG文字冒险小游戏，你需要设计以下内容：</p><ul><li>四个角色：<br>女王Queen；国王King；骑士Knight；巨魔Troll；</li><li>四种武器：<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；</li></ul><p>每个角色一次只能使用一种武器，但是在游戏的过程中可以切换武器。</p><p>让他们相互攻击，直到有人胜出。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/423180E36C6DA4925016AA187CA09C05-1616508222683.jpg" srcset="/img/loading.gif" alt="423180E36C6DA4925016AA187CA09C05"></p><p>由上图可以看出类的结构为<br>女王Queen；国王King；骑士Knight；巨魔Troll；继承于Character。<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；实现了WeaponBehavior接口。</p><p>由此可以分析出在策略模式中他们的角色：</p><ul><li>环境(Context)角色：Character</li><li>抽象策略(Strategy)角色：WeaponBehavior</li><li>具体策略(ConcreteStrategy)角色：<br>KnifeBehavior，BowAndArrowBehavior，AxeBehavior，SwordBehavior</li></ul><h2 id="4-3-代码编写"><a href="#4-3-代码编写" class="headerlink" title="4.3 代码编写"></a>4.3 代码编写</h2><h3 id="4-3-1-环境角色编写"><a href="#4-3-1-环境角色编写" class="headerlink" title="4.3.1 环境角色编写"></a>4.3.1 环境角色编写</h3><p>编写所有角色的基类Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> hp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> energy;<br>    WeaponBehavior weapon;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span> =&gt; name; <span class="hljs-keyword">set</span> =&gt; name = <span class="hljs-keyword">value</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Hp &#123; <span class="hljs-keyword">get</span> =&gt; hp; <span class="hljs-keyword">set</span> =&gt; hp = <span class="hljs-keyword">value</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Energy &#123; <span class="hljs-keyword">get</span> =&gt; energy; <span class="hljs-keyword">set</span> =&gt; energy = <span class="hljs-keyword">value</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name,<span class="hljs-built_in">int</span> hp,<span class="hljs-built_in">int</span> energy</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.hp = hp;<br>        <span class="hljs-keyword">this</span>.energy = energy;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeapon</span>(<span class="hljs-params">WeaponBehavior weapon</span>)<span class="hljs-comment">//设置武器</span></span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.weapon = weapon;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">fight</span>(<span class="hljs-params">Character A</span>)<span class="hljs-comment">//攻击！</span></span><br><span class="hljs-function"></span>    &#123;<br>        weapon.useWeapon(<span class="hljs-keyword">this</span>,A);<br>        <span class="hljs-keyword">if</span> (A.Hp &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            Console.WriteLine(A.Name + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;杀死了&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showState</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//显示状态</span></span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(Name+<span class="hljs-string">&quot;:血量 &quot;</span>+ hp+<span class="hljs-string">&quot;精力 &quot;</span>+energy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写四种角色类继承Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Queen</span>:<span class="hljs-title">Character</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Queen</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">10</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> KnifeBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">King</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">King</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">5</span>, <span class="hljs-number">20</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Knight</span> : <span class="hljs-title">Character</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Knight</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">20</span>, <span class="hljs-number">10</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Troll</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Troll</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">15</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> AexBehavior());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-抽象策略角色编写"><a href="#4-3-2-抽象策略角色编写" class="headerlink" title="4.3.2 抽象策略角色编写"></a>4.3.2 抽象策略角色编写</h3><p>编写武器行为接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A,Character B</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-具体策略角色编写"><a href="#4-3-3-具体策略角色编写" class="headerlink" title="4.3.3 具体策略角色编写"></a>4.3.3 具体策略角色编写</h3><p>编写具体的武器行为，实现接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">KnifeBehavior</span>:<span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name+<span class="hljs-string">&quot;对&quot;</span>+B.Name+<span class="hljs-string">&quot;使用了 匕首 刺杀&quot;</span>);<br>        B.Hp--;<br>        A.Energy --;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BowandArrowBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;射了一箭&quot;</span>);<br>        B.Hp--;<br>        A.Energy--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AexBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 斧头 劈砍&quot;</span>);<br>        B.Hp-=<span class="hljs-number">3</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy-=<span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SwordBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 直剑 挥击&quot;</span>);<br>        B.Hp -= <span class="hljs-number">5</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy -= <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-测试"><a href="#4-3-4-测试" class="headerlink" title="4.3.4 测试"></a>4.3.4 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();<br>    List&lt;Character&gt; c = <span class="hljs-keyword">new</span> List&lt;Character&gt;(<span class="hljs-number">4</span>);<span class="hljs-comment">//将各种角色类都装箱成Character</span><br>    c.Add(<span class="hljs-keyword">new</span> King(<span class="hljs-string">&quot;大清皇帝&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Troll(<span class="hljs-string">&quot;林登万&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Knight(<span class="hljs-string">&quot;堂吉诃德&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Queen(<span class="hljs-string">&quot;玛丽&quot;</span>));<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (c.Count != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">int</span> a, b;<br>        a = random.Next(<span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">//随机选取两人PK，直到剩下最后一位角色活着</span><br>        <span class="hljs-keyword">while</span> ((b = random.Next(<span class="hljs-number">0</span>, i)) == a)<br>        &#123;<br>            b = random.Next(<span class="hljs-number">0</span>, i);<br>        &#125;<br>        c[a].showState();<br>        c[b].showState();<br>        <span class="hljs-keyword">if</span> (c[a].fight(c[b]))<br>        &#123;<br>            c.RemoveAt(b);<br>            i--;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//每回合恢复体力</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;c.Count;j++)<br>        &#123;<br>            c[j].Energy++;<br>        &#125;<br>    &#125;<br>    Console.WriteLine(<span class="hljs-string">&quot;胜者是:&quot;</span> + c[<span class="hljs-number">0</span>].Name + <span class="hljs-string">&quot;!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这次中世纪文字吃鸡的结果是：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95.png" srcset="/img/loading.gif" alt="策略模式测试"></p><h1 id="5-对策略模式的深入认识"><a href="#5-对策略模式的深入认识" class="headerlink" title="5.对策略模式的深入认识"></a>5.对策略模式的深入认识</h1><h2 id="5-1-策略模式对多态的使用"><a href="#5-1-策略模式对多态的使用" class="headerlink" title="5.1 策略模式对多态的使用"></a>5.1 策略模式对多态的使用</h2><p> 　通过让环境类持有一个抽象策略类（超类）的引用，在生成环境类实例对象时，让该引用指向具体的策略子类。再对应的方法调用中，就会通过Java的多态，调用对应策略子类的方法。从而可以相互替换，不需要修改环境类内部的实现。同时，在有新的需求的情况下，也只需要修改策略类即可，降低与环境类之间的耦合度。</p><h2 id="5-2-策略模式的重心"><a href="#5-2-策略模式的重心" class="headerlink" title="5.2 策略模式的重心"></a>5.2 策略模式的重心</h2><p>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p><h2 id="5-3算法的平等性"><a href="#5-3算法的平等性" class="headerlink" title="5.3算法的平等性"></a>5.3算法的平等性</h2><p>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p><p>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。</p><h2 id="5-4-运行时策略的唯一性"><a href="#5-4-运行时策略的唯一性" class="headerlink" title="5.4 运行时策略的唯一性"></a>5.4 运行时策略的唯一性</h2><p>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p><h2 id="5-5-公有的行为"><a href="#5-5-公有的行为" class="headerlink" title="5.5 公有的行为"></a>5.5 公有的行为</h2><p>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p><p>这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-398483227b01f042.png" srcset="/img/loading.gif" alt="img"></p><h1 id="6-策略模式的优缺点"><a href="#6-策略模式的优缺点" class="headerlink" title="6. 策略模式的优缺点"></a>6. 策略模式的优缺点</h1><h2 id="6-1-相较于纯继承的优点"><a href="#6-1-相较于纯继承的优点" class="headerlink" title="6.1 相较于纯继承的优点"></a>6.1 相较于纯继承的优点</h2><ul><li><p>代码复用度高，子类中几乎没有重复</p></li><li><p>很容易知道该类的全部策略（算法）</p></li><li><p>在运行时可以更容易的更改策略</p></li><li><p>改动时不会牵一发而动全身，代码耦合度低</p></li></ul><h2 id="6-2-策略模式的优点"><a href="#6-2-策略模式的优点" class="headerlink" title="6.2 策略模式的优点"></a>6.2 策略模式的优点</h2><ul><li>策略模式提供了管理相关的算法族的办法。<br>策略类的等级结构定义了一个算法或行为族。<br>恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。<br>多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li></ul><h2 id="6-3策略模式的缺点"><a href="#6-3策略模式的缺点" class="headerlink" title="6.3策略模式的缺点"></a>6.3策略模式的缺点</h2><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<br>这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p></li><li><p>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p></li></ul><p>总结自：</p><ul><li>《设计模式HeadFirst》</li><li><a href="https://www.jianshu.com/p/7fa8ad000a97">https://www.jianshu.com/p/7fa8ad000a97</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的标签 层级 静态物体 预制体</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-标签"><a href="#1-标签" class="headerlink" title="1. 标签"></a>1. 标签</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>标签(Tag)是一个可以标记在游戏物体上的记号，它一般是一个简单的单词。<br>比如：你可以为游戏人物添加一个Player标签，并为敌人角色添加一个Encemy 标签，还可以为地图上的道具添加一个Collectable标签。</p><p>在脚本中查找和指定物体时，使用标签是一种非常好的方法。<br>这种方法可以避免总是采用某个公开变量的方式来指定游戏物体，那样还需要通过拖曳的操作才能给变量赋初值。通过标签来查找物体可以简化编辑工作。</p><p>标签还特别适合用在处理碰撞的时候，当游戏人物与其他物体发生碰撞时，你可以通过判断碰到的物体是敌人、道具还是其他东西，来进行下一步处理。</p><h2 id="1-2-Unity预制标签"><a href="#1-2-Unity预制标签" class="headerlink" title="1.2. Unity预制标签"></a>1.2. Unity预制标签</h2><p>Uniy预置了一些常用的标签， 在标签管理器中你不能修改下面这些预置的标签：</p><table><thead><tr><th>标签名</th><th>含义</th></tr></thead><tbody><tr><td>Untagged</td><td>没有标签</td></tr><tr><td>Respawn</td><td>出生</td></tr><tr><td>Finish</td><td>完成</td></tr><tr><td>EditorOnly</td><td>编辑器专用</td></tr><tr><td>MainCamera</td><td>主摄像机</td></tr><tr><td>Player</td><td>玩家</td></tr><tr><td>GameController</td><td>游戏控制器</td></tr></tbody></table><h2 id="1-3-创建新标签"><a href="#1-3-创建新标签" class="headerlink" title="1.3. 创建新标签"></a>1.3. 创建新标签</h2><p>要创建一个新的标签，需要在标签下拉菜单中选择Add Tag,之后检视窗口会切换到标签与层级管理器(Tag and Layer Manager)。</p><blockquote><p>注意:标签一旦创建就不可以再被修改，只能删除并重新创建。</p></blockquote><h2 id="1-4-为物体设置标签"><a href="#1-4-为物体设置标签" class="headerlink" title="1.4. 为物体设置标签"></a>1.4. 为物体设置标签</h2><p>检视窗口的上方显示了标签(Tg)和层级(Layer) 的下拉菜单。</p><p>在标装的下技菜单中单击任意.个标签名称，就可以为物体指定该标签了</p><h2 id="1-5-使用标签查找游戏物体"><a href="#1-5-使用标签查找游戏物体" class="headerlink" title="1.5. 使用标签查找游戏物体"></a>1.5. 使用标签查找游戏物体</h2><blockquote><p>略，详见<a href="https://mycroftcooper.github.io/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/">在脚本中访问其他物体2.3</a></p></blockquote><h2 id="1-6-小提示"><a href="#1-6-小提示" class="headerlink" title="1.6. 小提示"></a>1.6. 小提示</h2><ul><li>一个游戏物体只能被指定一个标签</li><li>可以用任意一个单词作为标签的名称<br>甚至可以用一个很长的词组作为名称<br>但是那样非会不太方便，比如在界面中看不到完整的名字</li></ul><h1 id="2-层级"><a href="#2-层级" class="headerlink" title="2. 层级"></a>2. 层级</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>层级最有用、最常用的地方有：</p><ul><li>用来让摄像机仅渲染场景中的一部分物体</li><li>还可以让灯光只照亮一部分物体。</li><li>用来在进行碰撞检测、射线检测时，从而只让某些物体发生碰撞，让另一些物体不发生碰撞。</li></ul><h2 id="2-2-新建层级"><a href="#2-2-新建层级" class="headerlink" title="2.2 新建层级"></a>2.2 新建层级</h2><p>单击主菜单的Edit &gt; Project Settings &gt; Tagsand Layers选项，会在检视窗口中打开层级和标签窗口。<br>这步操作和之前介绍标签时的操作完全一样， 不同的是，在学习标签时我们展开了标签菜单，这里我们要展开层级菜单。<br>将新的层级User Layer8命名为Player,就建立了一个新的Player层级，序号为8.</p><h2 id="2-3-只渲染场景的一部分"><a href="#2-3-只渲染场景的一部分" class="headerlink" title="2.3 只渲染场景的一部分"></a>2.3 只渲染场景的一部分</h2><p>层级配合摄像机的剔除遮眾Culling Mas)使用，就可以有选择性地显示某些层级的物体，而不渲染另一些层级的物体。</p><p>要做到这一点， 只需要在摄像机中选中需要渲染的层级即可。<br>单击摄像机的剔除遮罩下拉菜单，打钩的层就是要显示的层。</p><blockquote><p>注意: Unity 中有很多类似这样的下拉菜单，菜单的最上面两项是特殊的：<br>单击Noting时，所有选项都会被取消勾选，表示全部不选<br>单击Everyhing 时，则所有选项都会被勾选。<br>使用这两个快捷选项有助于快速选中必要的层。<br>比如说，要仅选中Ul层和Player层，就可以先选择Nothing,然后再单独勾选UI层和Player层即可.</p></blockquote><blockquote><p>UI系统如果采用屏幕空间画布，则不会受摄像机别除遮罩的影响。</p></blockquote><h2 id="2-5-选择性的射线检测"><a href="#2-5-选择性的射线检测" class="headerlink" title="2.5 选择性的射线检测"></a>2.5 选择性的射线检测</h2><p>使用层级可以让射线检测忽略某些碰撞体，这种效果也是用“层级”和“遮罩”这两个概念来设置的。</p><p>例如，有时需要发射条射线， 仅和Player 层的物体发生碰撞， 而忽略其他层的物体。<br>Physics.Racast方法用来发射一条射线， 它可以带有一个叫作layerMask 的参数，layerMask是一个利用位标记作为遮罩的参数。</p><blockquote><p>用位(bit)作为标记是二进制相关的一种方法<br>原理是int型的变量由32个位组成，每个位的值只能是0或1<br>因此可以根据某个位是0还是1来选中或者忽略某一层</p></blockquote><ul><li>如果layerMask所有的位都是1,那么就会和所有的层发生碰撞。</li><li>如果layerMask等于0，那么它就不会和任何层、任何物体发生碰撞。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//将1左移8位</span><br><span class="hljs-built_in">int</span> layerMask =<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br><span class="hljs-comment">//将layerMask设置为只有从右数第8位是1,其他位是0，则只会和Layer 8 Player层发生碰撞</span><br><span class="hljs-keyword">if</span> (Physics .Raycast (transform.position, Vector3. forward, Mathf. Infinity, layerMask))<br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;The ray hit the player&quot;</span>) ;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是玩家的游戏人物射击发出的检测射线，就恰恰相反，需要和除玩家的游戏人物以外的所有物体发生碰撞，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//将1左移8位</span><br>    <span class="hljs-built_in">int</span> layerMask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">//按位取反，所有值为0的位变为1,值为1的位变为0</span><br>    layerMask = ~ layerMask;<br>    RaycastHit hit;<br>    <span class="hljs-comment">//发射射线，Debug. DrawRay用于画出辅助框线</span><br>    <span class="hljs-keyword">if</span> (Physics.Raycast(transform.position,traform.TransformDirection(Vector3.forward),<br>                        <span class="hljs-keyword">out</span> hit, Mathf.Infinity,layerMask))<br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<br>                      hit.distance,Color.yellow);<br>        Debug. Log(<span class="hljs-string">&quot;Did Hit&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<span class="hljs-number">1000</span><br>                      Color.white) ;<br>        Debug.Log(<span class="hljs-string">&quot;Did not Hit&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在调用Raycast方法时省略layerMask参数，则默认除了Ignore Raycast这层不会被碰撞，其他层都可能发生碰撞。</p><p>使用lgnore Raycast层可以专门指定某些物体不受射线检测碰撞。</p><blockquote><p>序号为31的最后一层是特别的，编辑器把它作为预览使用，开发者不要使用这一层，会造成冲突</p></blockquote><h1 id="3-静态物体"><a href="#3-静态物体" class="headerlink" title="3. 静态物体"></a>3. 静态物体</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>如果引擎事先知道了某一个物体在游戏进行中是否会移动，那么就可以针对性地应用一系列优化策略。</p><p>如果一个物体是静态的，即不会移动的，那么引擎就可以假定它不会受到任何其他物体或者事件的影响，从而预先计算好物体的信息。<br>比如说，渲染器可以将场景中许多静态物体台并为一个整体，这样就可以通过一次渲染就将它们全部处理完毕，这种做法也被称为批量渲染。</p><p>在检视窗口中，每个游戏物体名称的右侧都有一一个静态(Static) 复选框以及一个菜单，它用来指定物体是否是静态的，且可以进一步指定物体 在某些子系统中是否是静态的，还可以独立地设置游戏物体在每个子系统中是否是静态的，这样就可以对物体进行非常细致的优化。</p><p>下图是静态标记菜单，可以有针对性地设置物体在每个子系统中是否是静态的。</p><h2 id="3-2-子系统的静态特性内容"><a href="#3-2-子系统的静态特性内容" class="headerlink" title="3.2 子系统的静态特性内容"></a>3.2 子系统的静态特性内容</h2><p>静态菜单中的Everyhing和Nothing选项分别用于同时启用或禁用物体在所有子系统中的静态特性以便优化。</p><p>这些子系统包含如下内容：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Lightmap Static</td><td>场景中的高级光照特性</td></tr><tr><td>Occluder Static</td><td>根据物体在特定摄像机下的可见性，进行渲染优化</td></tr><tr><td>Batching Static</td><td>将多个物体合并为一个整体进行渲染</td></tr><tr><td>Navigation Static</td><td>在寻路系统中，将此物体作为静态的障碍物</td></tr><tr><td>Off Mesh Link Generation</td><td>寻路系统中的网格链接</td></tr><tr><td>Reflection Probe Static</td><td>反射探针优化</td></tr></tbody></table><p>某些子系统与内部渲染方式有较大关联，可以在相关文档中阅读它们的细节。</p><h1 id="4-预制体"><a href="#4-预制体" class="headerlink" title="4.预制体"></a>4.预制体</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>在场景中创建物体、添加组件并设置合适参数的操作一开始会令人觉得方便， 但是当场影的用到大量同样的NPC、障碍物或机关时，创建以及设置属性的操作就会带来巨大的麻烦。<br>复制这些物体看似可以解决问题，但是由于这些物体都是独立的，所以还是需要一个一个单独体改它们。</p><p>所以，Unity 提供了预制体这个概念。<br>它允许事先保存一个游戏物体，包括该物体上挂载的组件与设置的参数。<br>这样预制体就可以成为模板，可以用这个模板在场景中创建物体。</p><p>预制体具有以下两个优点</p><ul><li><p>对预制体文件的任何修改可以立即影响所有相关联的物体</p></li><li><p>每个物体还可以重载(override)一些些组件和参数， 以实现与模板有所区别的设置</p></li></ul><blockquote><p>注意:<br>当你拖曳一个资源文件(比如一个模型)到场景中时，Unity 会自动创建一个新的游戏物体，原始资源的修改也会影响到这些相关的游戏物体。<br>这种物体看起来像是预制体，但是和预制体是完全不同的，所以不适用下面介绍的预制体的特性。<br>这种“引用关系”仅仅是与预制体有相似之处。</p></blockquote><h2 id="4-2-使用预制体"><a href="#4-2-使用预制体" class="headerlink" title="4.2 使用预制体"></a>4.2 使用预制体</h2><p>创建预制体有两种常用方法: </p><ul><li>方法一:<br>在工程窗口中的某个文件夹内单击右键，选择Create&gt; Prefab创建一个空白预制体，然后将场景中制作好的某个游戏物体拖曳到空白预制体上。</li><li>方法二:<br>直接将某个游戏物体从场景拖曳到文件夹中。<br>在创建好预制体以后，将另一个游戏物体拖曳到预制体文件上，系统会提示是否替换预制体。</li></ul><blockquote><p>预制体是一个后缀为 .prefab的资源文件。<br>在层级视图中，所有与预制体关联的游戏物体的名称，都会以蓝色显示(普通物体的名称是以黑色显示的)</p></blockquote><blockquote><p>编辑器会用粗体字来显示游戏物体中与预制体不一样的独特属性</p></blockquote><h2 id="4-3-通过游戏物体实例修改预制体"><a href="#4-3-通过游戏物体实例修改预制体" class="headerlink" title="4.3 通过游戏物体实例修改预制体"></a>4.3 通过游戏物体实例修改预制体</h2><p>与预制体关联的游戏物体，会在检视窗口的上方多出三个按钮:</p><ul><li><p>选择( Select)<br>选中与物体相关联的那个预制体，单击后，在工程窗口中会高亮显示该预制体。<br>这有助于迅速找到相关的预制体。</p></li><li><p>回滚(Revert)<br>将游戏物体修改过的组件和属性恢复到和预制体一致。<br>这个功能用于试验性地修改某些参数以后，将物体恢复到原始状态。</p></li><li><p>应用(Apply)<br>将本物体上修改的那些组件和参数写回到原始的预制体中(但是变换组件的位置信息不会写回预制体)。<br>这有助于通过任何一个物体修改预制体，有时会非常方便，特别是在某些预制体只有一个实例的时候。</p></li></ul><h2 id="４-4-预制体实例化"><a href="#４-4-预制体实例化" class="headerlink" title="４.4 预制体实例化"></a>４.4 预制体实例化</h2><p>使用<strong>Instantiate函数</strong></p><p>Instantiate函数实例化是将传入对象的所有子物体和子组件完全复制，成为一个新的对象。<br>这个新的对象拥有与源对象完全一样的东西，包括坐标值等。</p><h3 id="4-4-1-参数"><a href="#4-4-1-参数" class="headerlink" title="4.4.1 参数"></a>4.4.1 参数</h3><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>original</td><td>用来做复制操作的对像物体，源对象</td></tr><tr><td>position</td><td>实例化的对象的位置坐标</td></tr><tr><td>rotation</td><td>实例化的对象的旋转坐标（旋转四元数）</td></tr><tr><td>parent</td><td>实例化对象的父对象，在完成实例化函数处理后，实例化对象将是父对象的子对象</td></tr><tr><td>instantiateWorldSpace</td><td>为TRUE，表示实例化对象相对于世界坐标系的位置（是位置，不是坐标值，比如实例化前在Canvas左上角，实例化后还在左上角）不变，相对于父对象的坐标值变了<br />为false，表示实例化对象相对于父对象的坐标值不变，但在世界坐标系中的位置变了。</td></tr></tbody></table><p><a href="https://blog.csdn.net/qq_29413829/article/details/78934579">https://blog.csdn.net/qq_29413829/article/details/78934579</a></p><h3 id="4-4-2-重载"><a href="#4-4-2-重载" class="headerlink" title="4.4.2 重载"></a>4.4.2 重载</h3><p>![Instantiate函数](./images/Unity中的标签 层级 静态物体/20171229171822891)</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>标签</tag>
      
      <tag>层级</tag>
      
      <tag>静态物体</tag>
      
      <tag>预制体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的事件</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity在C#Event特性的基础上进行了改良，Event只能用于纯代码编程，而UnityEvent可以和UnityEditor配合使用提高效率。</p><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a>！</p></blockquote><h1 id="2-Unity事件的改良"><a href="#2-Unity事件的改良" class="headerlink" title="2. Unity事件的改良"></a>2. Unity事件的改良</h1><p>在C#事件中我们举的例子中，可以看出.Net框架下的事件存在以下几个问题：</p><ul><li>订阅的时机受限<br>你必须在事件触发前完成事件的订阅<br>事件处理程序将收不到订阅前的事件动态</li><li>不方便管理<br>想要查看所有订阅事件的对象，我们就得查找项目中所有对事件的引用，然后再把每个对象的文件打开，可以说是非常麻烦了</li></ul><p>为了避免上述的缺点，Unity使用Serializable（序列化）让用户可以在Editor中直接绑定所有对象的调用，即一目了然又不用担心把握不准订阅的时机，这就是<strong>UnityEvent</strong>。</p><h1 id="3-UnityEvent类"><a href="#3-UnityEvent类" class="headerlink" title="3. UnityEvent类"></a>3. UnityEvent类</h1><p><strong>UnityEvent</strong> 可添加到任何 <strong>MonoBehaviour</strong>，并从标准 .net 委托之类的代码中执行。当 <strong>UnityEvent</strong>添加到 <strong>MonoBehaviour</strong>时，它会出现在 <strong>Inspector</strong> 中，并可添加持久回调。</p><h2 id="3-1-方法"><a href="#3-1-方法" class="headerlink" title="3.1 方法"></a>3.1 方法</h2><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>AddListener</td><td>将一个非持久性侦听器添加到UnityEvent</td></tr><tr><td>Invoke</td><td>调用所有已注册的回调（运行时和持久的）</td></tr><tr><td>RemoveListener</td><td>从UnityEvent中删除一个非持久性侦听器</td></tr></tbody></table><h2 id="3-2-继承的成员"><a href="#3-2-继承的成员" class="headerlink" title="3.2 继承的成员"></a>3.2 继承的成员</h2><p>普通方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetPersistentEventCount</td><td>获取已注册的持久性侦听器的数量</td></tr><tr><td>GetPersistentMethodName</td><td>获取索引为index的侦听器的目标方法名称</td></tr><tr><td>GetPersistentTarget</td><td>在索引index处获取侦听器的目标组件</td></tr><tr><td>RemoveAllListeners</td><td>从事件中删除所有侦听器</td></tr><tr><td>SetPersistentListenerState</td><td>修改持久侦听器的执行状态</td></tr></tbody></table><p>静态方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetValidMethodInfo</td><td>给定对象，函数名称和参数类型列表；找到匹配的方法</td></tr></tbody></table><h2 id="3-3-UnityEvent的使用"><a href="#3-3-UnityEvent的使用" class="headerlink" title="3.3 UnityEvent的使用"></a>3.3 UnityEvent的使用</h2><p>要在 Editor 中配置回调，需执行以下几个步骤：</p><ol><li>确保脚本导入/使用 <code>UnityEngine.Events</code>。</li><li>选择 + 图标为回调添加字段</li><li>选择要接收回调的 UnityEngine.Object（可使用对象选择器进行选择）</li><li>选择要调用的函数</li><li>可为事件添加多个回调</li></ol><p>在 <strong>Inspector</strong> 中配置 <strong>UnityEvent</strong> 时，支持两种类型的函数调用：</p><ul><li>静态。<br>静态调用是预配置的调用，具有在 UI 中设置的预配置值。<br>这意味着，在调用回调时，使用已在 UI 中输入的参数调用目标函数。</li><li>动态。<br>使用从代码发送的参数调用动态调用，并与正在调用的 UnityEvent 类型相关。<br>UI 会过滤回调，仅显示对 UnityEvent 有效的动态调用。</li></ul><h2 id="3-4-UnityEvent的多态（派生自定义事件）"><a href="#3-4-UnityEvent的多态（派生自定义事件）" class="headerlink" title="3.4 UnityEvent的多态（派生自定义事件）"></a>3.4 UnityEvent的多态（派生自定义事件）</h2><p>默认情况下，<strong>Monobehaviour</strong> 中的 UnityEvent 动态绑定到 void 函数。</p><p>但不一定非得如此，<strong>UnityEvent</strong> 的子类支持绑定到最多包含 4 个参数的函数。</p><p>为此，您可以定义一个支持多个参数的自定义 <strong>UnityEvent</strong> 类。</p><p>此定义十分简单：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringEvent</span> : <span class="hljs-title">UnityEvent</span> &lt;<span class="hljs-title">string</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>订阅时订阅此派生类的实例而不是基类 <strong>UnityEvent</strong>，即可回调时传递各种参数。</p><p>然后，可通过调用**Invoke()**函数来对其进行调用。</p><blockquote><p>UnityEvent 可在其通用定义中定义最多 4 个参数。</p></blockquote><h2 id="3-5-使用案例："><a href="#3-5-使用案例：" class="headerlink" title="3.5 使用案例："></a>3.5 使用案例：</h2><p>将C#事件中的用例代码改写成Unity引擎内继承于<strong>UnityEvent</strong>的脚本：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Events;<br><br><span class="hljs-comment">//使用Serializable序列化IdolEvent, 否则无法在Editor中显示</span><br>[<span class="hljs-meta">System.Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IdolEvent</span> : <span class="hljs-title">UnityEvent</span>&lt;<span class="hljs-title">string</span>&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">//public delegate void IdolBehaviour(string behaviour);</span><br>    <span class="hljs-comment">//public event IdolBehaviour IdolDoSomethingHandler;</span><br>    <span class="hljs-keyword">public</span> IdolEvent idolEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (idolEvent == <span class="hljs-literal">null</span>)<br>        &#123;<br>            idolEvent = <span class="hljs-keyword">new</span> IdolEvent();<br>        &#125;<br>        idolEvent.Invoke(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将三个脚本绑定在三个GameObject上，此时两个粉丝还未实现订阅。和Event不同，UnityEvent在序列化后可以在Editor上显示，并且可以在Editor上设置好需要执行的函数</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315164014120.png" srcset="/img/loading.gif" alt="image-20210315164014120"></p><p>运行</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315160434052.png" srcset="/img/loading.gif" alt="image-20210315160434052"></p><p>除此之外，UnityEvent依然提供和C# Event 类似的运行时绑定的功能，不过不同的是，UnityEvent是一个对象，向其绑定函数是通过AddListener()方法实现的。以SubscriberB为例，我们可以在代码中实现同等效果的绑定：</p><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">public</span> Idol myIdol;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        myIdol.idolEvent.AddListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        myIdol.idolEvent.RemoveListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于UnityEvent是一个对象，所以自然可以允许我们通过继承实现自己的Event，实际上Unity中包括Button在内的许多UI组件的点击事件都是通过继承自UnityEvent来复写的。<br>可访问性(public/private)决定了UnityEvent的默认值，当可访问性为public时，默认会为其分配空间(new UnityEvent())；当可访问性为private时，默认UnityEvent为null，需要在Start()中为其分配内存。</p></blockquote><h1 id="4-EventSystem"><a href="#4-EventSystem" class="headerlink" title="4. EventSystem"></a>4. EventSystem</h1><p>EventSystem在Unity中是一个看起来像是专门服务于UGUI系统的组件。<br>每当在场景里创建UGUI对象时，Unity编辑器都会自动产生一个EventSystem对象放在场景中，与之相对应的也有一个Canvas对象，这两个对象就组成了UGUI系统的基础。<br>所有开发人员能看到和能用到的UGUI功能都依附于这两个对象。</p><h2 id="4-1-UGUI中的EventSystem"><a href="#4-1-UGUI中的EventSystem" class="headerlink" title="4.1 UGUI中的EventSystem"></a>4.1 UGUI中的EventSystem</h2><p>使用<strong>UGUI</strong>制作游戏界面时，<strong>EventSystem</strong>的作用就像是一个专为<strong>UGUI</strong>设计好的消息中心，它管理着所有能参与消息处理的<strong>UGUI</strong>组件，包括但不仅限于<strong>Panel</strong>，<strong>Image</strong>，<strong>Button</strong>等。</p><p>如果在<strong>Unity</strong>创建好<strong>EventSystem</strong>之后观察该对象上附带的组件可以看到，至少有两个组件会被自动添加</p><ul><li><p><strong>EventSystem组件</strong>，也就是消息机制的核心；</p></li><li><p><strong>StandaloneInputModule组件</strong>，这个是负责产生输入的组件。<br>StandaloneInputModule本身是个继承自BaseInputModule的实现类，而类似的实现类Unity中还有另外几个，甚至用户也能自定义一个实现类用于事件处理。</p></li></ul><p>看起来这个系统似乎缺少一个部分，就是怎么确定某个事件是发给谁的。<br>因此为了确定操作对象究竟是哪个，一个必不可少的步骤就是检测。</p><p>在GUI之外的游戏场景编辑中，要感知当前鼠标对准的物体是哪个，最常用的方法就是射线检测了：<br>从摄像机对着鼠标指向的方向发出射线，通过碰撞来检测目标。</p><p>这个方案简单实用，可以说在游戏中随处可见，而UGUI所使用的机制也就是这一套射线检测，只不过射线的发射和碰撞处理都被隐藏在了组件之中。</p><p>所以，缺失的部分就是射线检测模块，这个模块不在EventSystem上，而是在Canvas上挂着。<br>这很好理解，Canvas是所有UGUI组件的根对象，所以由他来负责射线处理是相当正常的解决方案，至于射线到底碰到了谁，UGUI组件自然有射线接收反馈来确定。</p><p>Canvas上挂载的组件叫做GraphicRaycaster，它实际上是BaseRaycaster的实现类，专门负责Canvas之下的图形对象的射线检测与计算问题。</p><p>至此，UGUI中的情况就比较清晰了：</p><ul><li><p><strong>EventSystem对象</strong><br>负责管理所有事件相关对象<br>该对象下挂载了EventSystem组件和StandaloneInputModule组件，前者为管理脚本，后者为输入模块</p></li><li><p><strong>Canvas对象</strong><br>下挂载了GraphicRaycaster负责处理射线相关运算<br>用户的操作都会通过射线检测来映射到UGUI组件上，InputModule将用户的操作转化为射线检测，Raycaster则找到目标对象并通知EventSystem，最后EventSystem发送事件让目标对象进行响应</p><p>如下图所示：</p><img src="/images/Unity中的事件/UGUI结构.png" srcset="/img/loading.gif" alt="UGUI结构"  /></li></ul><h3 id="4-1-1-事件响应"><a href="#4-1-1-事件响应" class="headerlink" title="4.1.1 事件响应"></a>4.1.1 事件响应</h3><p>UGUI的事件响应处理有多种方式，这里我们介绍两种常用方法</p><h4 id="4-1-1-1-实现特定接口处理事件响应"><a href="#4-1-1-1-实现特定接口处理事件响应" class="headerlink" title="4.1.1.1 实现特定接口处理事件响应"></a>4.1.1.1 实现特定接口处理事件响应</h4><p>由于Canvas挂载了GraphicRaycaster组件，因此在Canvas对象之下的所有GUI对象都可以通过挂载脚本并且实现一些和事件相关的接口来处理事件，比如常见的IPointerClickHandler接口就是用于处理点击事件的接口。</p><p>可以实现的接口列表大概如下所示：</p><table><thead><tr><th>接口名</th><th>作用</th></tr></thead><tbody><tr><td>IPointerEnterHandler - OnPointerEnter</td><td>当光标进入对象时调用</td></tr><tr><td>IPointerExitHandler - OnPointerExit</td><td>当光标退出对象时调用</td></tr><tr><td>IPointerDownHandler - OnPointerDown</td><td>在对象上按下指针时调用</td></tr><tr><td>IPointerUpHandler - OnPointerUp</td><td>松开鼠标时调用（在指针正在点击的游戏对象上调用）</td></tr><tr><td>IPointerClickHandler - OnPointerClick</td><td>在同一对象上按下再松开指针时调用</td></tr><tr><td>IInitializePotentialDragHandler - OnInitializePotentialDrag</td><td>在找到拖动目标时调用，可用于初始化值</td></tr><tr><td>IBeginDragHandler - OnBeginDrag</td><td>即将开始拖动时在拖动对象上调用</td></tr><tr><td>IDragHandler - OnDrag</td><td>发生拖动时在拖动对象上调用</td></tr><tr><td>IEndDragHandler - OnEndDrag</td><td>拖动完成时在拖动对象上调用</td></tr><tr><td>IDropHandler - OnDrop</td><td>在拖动目标对象上调用</td></tr><tr><td>IScrollHandler - OnScroll</td><td>当鼠标滚轮滚动时调用</td></tr><tr><td>IUpdateSelectedHandler - OnUpdateSelected</td><td>每次勾选时在选定对象上调用</td></tr><tr><td>ISelectHandler - OnSelect</td><td>当对象成为选定对象时调用</td></tr><tr><td>IDeselectHandler - OnDeselect</td><td>取消选择选定对象时调用</td></tr><tr><td>IMoveHandler - OnMove</td><td>发生移动事件（上、下、左、右等）时调用</td></tr><tr><td>ISubmitHandler - OnSubmit</td><td>按下 Submit 按钮时调用</td></tr><tr><td>ICancelHandler - OnCancel</td><td>按下 Cancel 按钮时调用</td></tr></tbody></table><p>只要在挂载的脚本中实现所需要的接口，对应的事件回调也就可以执行了。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EventTest</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerClickHandler</span>, <span class="hljs-title">IDragHandler</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span> <br>&#123;<br>    <span class="hljs-comment">// Execute every update when dragging</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-comment">// quick down and up will perform click</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerClick</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer down</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer up</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Use this for initialization</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Update is called once per frame</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-2-利用EventTrigger组件处理事件响应"><a href="#4-1-1-2-利用EventTrigger组件处理事件响应" class="headerlink" title="4.1.1.2  利用EventTrigger组件处理事件响应"></a>4.1.1.2  利用EventTrigger组件处理事件响应</h4><p>EventTrigger组件是一个通用的事件触发器，它可以用来管理单个组件上的所有可能触发的事件。<br>其使用方法有两种：</p><ul><li><p>编辑器设定方法</p><p>指定组件上添加EventTrigger组件，然后为它添加触发事件类型，再为指定类型添加回调方法。</p></li></ul><p>这种做法的操作很简单，而且灵活性也相当高，想要跨脚本调用方法只需要鼠标拖一拖点一点就好。<br>但是这样在编辑器中设定事件回调会在项目变大时造成比较严重的管理障碍，尤其是当绑定了EventTrigger以及回调指向的物体有修改或者删除情况时，所造成的引用缺失需要花费更多的时间进行处理。</p><blockquote><p>略</p></blockquote><ul><li>动态设定方法</li></ul><p>想要更好地管理大量的事件触发和回调处理，可以尝试采用动态设置的方案。<br>所谓动态设置其实就是在代码中设置EventTrigger来处理事件回调，方法也很简单</p><blockquote><p>略</p></blockquote><h2 id="4-2-场景中的EventSystem"><a href="#4-2-场景中的EventSystem" class="headerlink" title="4.2 场景中的EventSystem"></a>4.2 场景中的EventSystem</h2><p>EventSystem也能在一般的场景中使用。<br>如果没有实现自己的事件系统而又需要一些回调处理的方案的话，可以试着直接将EventSystem应用到一般的游戏场景中。<br>要这样使用EventSystem的话，核心在于前文提到过的事件系统三大部分：</p><ul><li>EventSystem</li><li>InputModule</li><li>Raycaster。</li></ul><p>通过考察三者各自的作用可知，EventSystem和InputModule都和EventSystem对象紧密结合，而唯有Raycaster是孤零零地在Canvas对象上处理所有Canvas内部的射线检测。</p><p>那么想要借助EventSystem的能力来处理场景中的事件传递，肯定不能去动EventSystem对象，毕竟这是建立事件系统时自动创建的对象，不用说一定是要用到的。<br>那么就只剩下Raycaster了，这个组件在Canvas上挂载，用于处理射线检测，那么如果想要在场景里进行射线检测，应该把组件挂到哪里呢？</p><p>一般而言，摄像机是一个不错的选择，因为通常来说游戏大部分时候都只有一个摄像机，而且基本上可以操作的界面也只隶属于一个摄像机，因此将Raycaster挂载到游戏的主摄像机上就是个很自然的考虑了。<br>​ 而Unity编辑器提供的Raycaster一共有三种</p><ul><li>GraphicRaycaster 界面射线处理器，用于Canvas</li><li>Physics2DRaycaster 2D场景射线处理器，用于2D场景</li><li>PhysicsRaycaster 3D场景射线处理器，用于3D场景</li></ul><p>因此要用到的就是后两种了，根据当前场景的特点选择相应的Raycaster并挂载到主摄像机上即可，剩下的就和UGUI中很像了。</p><p>不过需要注意的是，在UGUI中想要让组件可以响应事件必须将组件的RaycasterTarget属性勾选上，而场景中则要在需要响应事件的对象上挂载碰撞器，满足需求的任何碰撞器都可以。<br>然后就和前文讲的一样，实现对应接口或者添加EventTrigger组件来实现各种事件回调。</p><p>使用这样的方案实现的回调，其传递的数据PointerEventData中包含的位置参数还是屏幕位置，而且跟像素相关，以屏幕左下角为原点的坐标。<br>如果希望获取触发事件时的世界坐标，则需要用到PointerEventData类中的pointerCurrentRaycast成员，该成员表示了射线检测的结果，因此其中包含碰撞点的世界坐标。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>底层机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity底层机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#委托</title>
    <link href="/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/"/>
    <url>/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>委托(delegate)是一种存储函数引用的类型。<br>委托是C#的一个语言级特性，而在Java语言中没有直接的对应，但是java利用反射即可实现委托。</p><p>委托最重要的用途在事件和事件处理时才能解释清楚，但这里也将介绍有关委托的许多内容。</p><p>委托是一种数据类型，和类是同级别的，我们可以将delegate与class类比：</p><ul><li>class里存放的是一系列方法，属性，字段，事件，索引。</li><li>delegate里存放的是一系列具有相同类型参数和返回回类型的方法的地址的地址。<br>可以看作为储存方法的载体。</li></ul><p>有了引用函数的变量后，就可以执行无法用其他方式完成的操作。<br>例如，可以把委托变量作为参数传递给-一个函数，这样，该函数就可以使用委托调用它引用的任何函数，而且在运行之前不必知道调用的是哪个函数。下面的示例使用委托访问两个函数中的一个。</p><blockquote><p><a href="https://baike.baidu.com/item/c%23%E5%A7%94%E6%89%98/6916387?fr=aladdin">委托百度百科</a>上看的最明白</p></blockquote><h1 id="2-委托的声明"><a href="#2-委托的声明" class="headerlink" title="2. 委托的声明"></a>2. 委托的声明</h1><p><strong>delegate &lt;函数返回类型&gt; 委托名（函数参数）</strong>   </p><p><strong>例：</strong> <code>public delegate void myDelegate(string name);</code></p><h1 id="3-委托的实例化"><a href="#3-委托的实例化" class="headerlink" title="3. 委托的实例化"></a>3. 委托的实例化</h1><ul><li><strong>&lt;委托名&gt;实例化名= new &lt;委托名&gt;（注册函数）</strong></li></ul><p>例 : <code> myDelegate delegateinstance = new myDelegate(method);</code></p><blockquote><p>注意：注册函数不包含参数，或者可以直接将一个注册函数赋值给委托</p></blockquote><ul><li>匿名方法实例化委托</li></ul><p>​        <strong>&lt;委托类型&gt; &lt;实例化名&gt;=delegate(&lt;函数参数&gt;){函数体}</strong></p><ul><li>使用lamda表达式实例化委托</li></ul><p>实例化例子如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>   <br>&#123;     <br>    <span class="hljs-comment">//声明委托     </span><br>    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)     </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-comment">//实例化委托 </span><br>        <span class="hljs-comment">//1、使用new关键字       </span><br>        MyDelegate _myDelegate = <span class="hljs-keyword">new</span> MyDelegate(GetSum);<br>        <span class="hljs-comment">//2、使用匿名方法       </span><br>        MyDelegate myDelegate = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y)&#123;<span class="hljs-keyword">return</span> x + y;&#125;;<br>        <span class="hljs-comment">//3、使用Lambda表达式       </span><br>        MyDelegate myDelegateLambda = (<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) =&gt; &#123; <span class="hljs-keyword">return</span> x + y; &#125;;  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)     </span><br><span class="hljs-function"></span>    &#123;       <br>        <span class="hljs-keyword">return</span> x + y;     <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-多播委托"><a href="#4-多播委托" class="headerlink" title="4.多播委托"></a>4.多播委托</h1><p>实例化委托时必须将一个匹配函数注册到委托上来实例化一个委托对象，但是一个实例化委托不仅可以注册一个函数还可以注册多个函数。注册多个函数后，在执行委托的时候会根据注册函数的注册先后顺序依次执行每一个注册函数。</p><ul><li><p>多播委托实际上形成委托链 </p><p>函数注册委托的原型：</p><p>​            <strong>&lt;委托类型&gt; &lt;实例化名&gt;+=或者-=new &lt;委托类型&gt;(&lt;注册函数&gt;)</strong><br>如果在委托注册了多个函数后，如果委托有返回值，那么调用委托时，返回的将是最后一个注册函数的返回值。</p><blockquote><p>注意：委托必须先实例化以后，才能使用+=注册其他方法。如果对注册了函数的委托实例从新使用=号赋值，相当于是重新实例化了委托，之前在上面注册的函数和委托实例之间也不再产生任何关系。</p></blockquote></li></ul><blockquote><p>多播委托不支持返回值，也不支持数据引用，是单向广播</p></blockquote><h1 id="5-泛型委托"><a href="#5-泛型委托" class="headerlink" title="5.泛型委托"></a>5.泛型委托</h1><p>委托也支持泛型的使用<br>泛型委托原型：</p><ul><li><strong>delegate <T1> &lt;委托名&gt;&lt;T1,T2,T3…&gt; (T1 t1,T2 t2,T3 t3…)</strong></li></ul><h2 id="5-1-内置泛型委托"><a href="#5-1-内置泛型委托" class="headerlink" title="5.1 内置泛型委托"></a>5.1 内置泛型委托</h2><p>delegate      void   Action&lt;T1，T2，T3&gt;    泛型委托是可以达到16个参数的无返回值委托<br>delegate  Tresult Fun&lt;T1,T2,Tresult&gt;    Fun是内置泛型委托，具有返回值<br>delegate bool Predicate<T>(T obj)    内置泛型委托，返回bool值</p><h1 id="6-委托的清空"><a href="#6-委托的清空" class="headerlink" title="6. 委托的清空"></a>6. 委托的清空</h1><ol><li>在类中申明清空委托方法，依次循环去除委托引用。方法如下：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>&#123;<br>    <span class="hljs-keyword">public</span> DelegateMethod OnDelegate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearDelegate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.OnDelegate != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">this</span>.OnDelegate -= <span class="hljs-keyword">this</span>.OnDelegate;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>如果在类中没有申明清空委托的方法，我们可以利用GetInvocationList查询出委托引用，然后进行去除。</p><p>方法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">TestDelegate test = <span class="hljs-keyword">new</span> TestDelegate();<br><span class="hljs-keyword">if</span> (test.OnDelegate != <span class="hljs-literal">null</span>)<br>&#123;<br>  System.Delegate[] dels = test.OnDelegate.GetInvocationList();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; dels.Length; i++)<br>  &#123;<br>     test.OnDelegate -= dels[i] <span class="hljs-keyword">as</span> DelegateMethod;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-委托的应用"><a href="#7-委托的应用" class="headerlink" title="7.委托的应用"></a>7.委托的应用</h1></li></ol><ul><li>高内聚低耦合</li><li>用于事件系统</li><li>用于设计模式——观察者模式开发</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#事件</title>
    <link href="/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>C#事件的核心思想是基于windows消息处理机制的，只是封装的更好，让开发者无须知道底层的消息处理机制，就可以开发出强大的基于事件的应用程序来。</p><p>关于事件，比较形象的比喻就是广播者和订阅者。事件执行时会广播给订阅他函数，告诉每个函数该运行了，但不管函数的实现细节。</p><p>事件类似于异常，因为它们都由对象引发(抛出)，并且都可以通过我们提供的代码来处理。<br>但它们也有个重要区别：事件并没有与tny. catch类似的结构来处理事件，你必须订阅(Subseribe)它们。</p><p>订阅一个事件的含义是提供代码，在事件发生时执行这些代码，它们称为事件处理程序。</p><p>单个事件可供多个处理程序订阅，在该事件发生时，这些处理程序都会被调用，事件处理程序可以在引发事件的类中，也可以在其他类中。</p><p>事件处理程序本身都是简单方法。对事件处理方法的唯一限制是它必须匹配事件所要求的返回类型和参数，这个限制是事件定义的一部分，由一个委托指定。</p><blockquote><p>学习事件前请先学习<br><a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/">委托</a></p></blockquote><h1 id="2-事件与委托的关系与区别"><a href="#2-事件与委托的关系与区别" class="headerlink" title="2. 事件与委托的关系与区别"></a>2. 事件与委托的关系与区别</h1><p><strong>事件Event</strong>是在<strong>多播委托multicast delegate</strong>的基础上演变而来。</p><ul><li>event是升级版delegate，用event实现的功能用delegate同样可以实现。</li><li>event较之delegate具有继承方面的安全性。<br>用event，别的类只能订阅/取消订阅，如果用一个 public delegate成员变量，别的类可以调用或者覆盖我们的delegate变量。</li><li>一般来说，如果你要创建一个包含多个类的动态体系，使用event而不是delegate。</li></ul><h1 id="3-使用事件的优点"><a href="#3-使用事件的优点" class="headerlink" title="3. 使用事件的优点"></a>3. 使用事件的优点</h1><p>在以往我们编程时，往往采用等待机制，为了等待某件事情的发生，需要不断地检测某些判断变量，而引入事件编程后，大大简化了这种过程：</p><ul><li><p>可以很方便地确定程序执行顺序。</p></li><li><p>当事件驱动程序等待事件时，它不占用很多资源。<br>事件驱动程序与过程式程序最大的不同就在于，程序不再不停地检查输入设备，而是呆着不动，等待消息的到来,每个输入的消息会被排进队列，等待程序处理它。<br>如果没有消息在等待，则程序会把控制交回给操作系统，以运行其他程序。</p></li><li><p>简化了编程。<br>操作系统只是简单地将消息传送给对象，由对象的事件驱动程序确定事件的处理方法。<br>操作系统不必知道程序的内部工作机制，只是需要知道如何与对象进行对话，也就是如何传递消息。</p></li><li><p>在事件源和事件接收器之间启用非常小的耦合。<br>这两个组件可能不会由同一个组织编写，甚至可能会通过完全不同的计划进行更新。</p></li><li><p>订阅事件并从同一事件取消订阅应该非常简单。</p></li><li><p>事件源应支持多个事件订阅服务器。<br>它还应支持不附加任何事件订阅服务器。</p></li></ul><h1 id="4-使用事件需要的步骤"><a href="#4-使用事件需要的步骤" class="headerlink" title="4. 使用事件需要的步骤"></a>4. 使用事件需要的步骤</h1><p>我们编写一个偶像搞事事件来描述使用事件的步骤。</p><p>代码与步骤如下：</p><h2 id="4-1-创建一个委托"><a href="#4-1-创建一个委托" class="headerlink" title="4.1 创建一个委托"></a>4.1 创建一个委托</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像行为委托，参数是行为字符串，返回值为空</p></blockquote><h2 id="4-2-将委托与已有或自定义事件关联"><a href="#4-2-将委托与已有或自定义事件关联" class="headerlink" title="4.2 将委托与已有或自定义事件关联"></a>4.2 将委托与已有或自定义事件关联</h2><p>.Net类库中的很多事件都是已经定制好的，所以他们也就有相应的一个委托，在编写关联事件处理程序——也就是当有事件发生时我们要执行的方法的时候我们需要和这个委托有相同的签名</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像搞事事件，与IdolBehaviour偶像行为委托关联</p></blockquote><h2 id="4-3-编写事件处理程序"><a href="#4-3-编写事件处理程序" class="headerlink" title="4.3 编写事件处理程序"></a>4.3 编写事件处理程序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>&#125;<br><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>的两个事件处理程序函数</p></blockquote><h2 id="4-4-生成委托实例"><a href="#4-4-生成委托实例" class="headerlink" title="4.4 生成委托实例"></a>4.4 生成委托实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br>IdolBehaviour myIdolBehaviour=<span class="hljs-keyword">new</span> IdolBehaviour();<br></code></pre></td></tr></table></figure><blockquote><p>这步可以省略<br>我们在声明event delegate时并没有给它分配内存，使用时直接赋值或添加即可</p></blockquote><h2 id="4-5-订阅事件"><a href="#4-5-订阅事件" class="headerlink" title="4.5 订阅事件"></a>4.5 订阅事件</h2><p>把这个委托实例添加到产生事件对象的事件列表中去，这个过程又叫订阅事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += LikeIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= LikeIdol;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-comment">//OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += HateIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= HateIdol;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>中用于事件订阅</p></blockquote><h2 id="4-6-事件触发"><a href="#4-6-事件触发" class="headerlink" title="4.6 事件触发"></a>4.6 事件触发</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>&#123;<br>    IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>别编写在<strong>Idol.cs</strong>中需要触发事件的地方，Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</p></blockquote><h2 id="4-7-代码汇总"><a href="#4-7-代码汇总" class="headerlink" title="4.7 代码汇总"></a>4.7 代码汇总</h2><p>结果以上6个步骤后，一个自定义事件就完成了，代码汇总如下：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>        &#123;<br>            IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-事件产生和实现的流程"><a href="#5-事件产生和实现的流程" class="headerlink" title="5.事件产生和实现的流程"></a>5.事件产生和实现的流程</h1><ol><li><p>定义A为产生事件的实例，a为A产生的一个事件</p></li><li><p>定义B为接收事件的实例，b为处理事件的方法</p></li><li><p>A由于用户(程序编写者或程序使用者)或者系统产生一个a事件(例如点击一个Button，产生一个Click事件)</p></li><li><p>A通过事件列表中的委托对象将这个事件通知给B</p></li><li><p>B接到一个事件通知(实际是B.b利用委托来实现事件的接收)</p></li><li><p>调用B.b方法完成事件处理</p></li></ol><h1 id="6-参考网站"><a href="#6-参考网站" class="headerlink" title="6. 参考网站"></a>6. 参考网站</h1><ul><li><a href="https://www.jb51.net/article/133032.htm">https://www.jb51.net/article/133032.htm</a></li><li> <a href="https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/">https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yield表达式</title>
    <link href="/2021/03/20/yield%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/03/20/yield%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>unity的协程（Coroutine）认识yield这个关键字的，知道在unity的开发中诸如yield return null、yield return new WaitForSeconds(1.0f)的用法，其实yield是C#的关键字，unity的协程只是在c#的基础上做了一层封装，我们现在来看看yield这个关键字。</p><p>要想整懂yield得先整懂以下几个东西：</p><ul><li><p>设计模式——迭代器模式</p></li><li><p>C#中的IEnumerator、IEnumerable接口</p></li><li><p>Unity的协程（Coroutine）</p><p>目前我还一个不会，先挖个坑吧QAQ</p></li></ul><h1 id="Unity的yield表达式"><a href="#Unity的yield表达式" class="headerlink" title="Unity的yield表达式"></a>Unity的yield表达式</h1><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td>yield return null;</td><td>等1帧执行.暂停协同程序，下一帧再继续往下执行. 通知协程管理器，我到这个点要中断一下，下一帧从这个地方运行而已</td></tr><tr><td>yield return 0;</td><td>同yield return null;,数字改多大没用,都是等一帧</td></tr><tr><td>yield return 666;</td><td>同yield return null;,数字改多大没用,都是等一帧</td></tr><tr><td>yield break;</td><td>不在执行下面的语句,直接rerun</td></tr><tr><td>yield return asynaOperation;</td><td>等待异步操作执行完毕后执行</td></tr><tr><td>yield return StartCoroutine(coroutine);</td><td>等待子协程执行完毕后再执行</td></tr><tr><td>yield return WWW();</td><td>在WWW下载完成之后……waits for a web request to complete (resumes as if WaitForSeconds or null)</td></tr><tr><td>yield return new WaitForEndOfFrame();</td><td>等待帧结束,等待直到所有的摄像机和GUI被渲染完成后，在该帧显示在屏幕之前。用在while循环里减少死机</td></tr><tr><td>yield return new WaitForSeconds(0.3f);</td><td>等待0.3秒 , 一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后注意:受Time.timeScale影响，当Time.timeScale = 0f 时，yield return new WaitForSecond(x) 将不会满足。</td></tr><tr><td>yield return new WaitForFixedUpdate();</td><td>所有脚本上的FixedUpdate函数已经执行调用之后持续</td></tr><tr><td>yield return new WaitUntil</td><td>将协同执行直到 当输入的参数（或者委托）为true的时候…… || yield return new WaitUntil(() =&gt; frame &gt;= 10);</td></tr><tr><td>yield return new WaitWhile</td><td>将协同执行直到 当输入的参数（或者委托）为false的时候…… || yield return new WaitWhile(() =&gt; frame &lt; 10);</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的事件函数</title>
    <link href="/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity中的脚本组织不像传统的游戏循环，有一个持续进行的主循环并在循环体中处理游戏逻辑。</p><p>相对的，Unity 会在特定的事件发生时，调用脚本中特定的函数，然后执行逻辑的任务就交给了该脚本函数，函数执行完毕后，执行的权力重新还给Unty。</p><p>这些特定的函数通常被称为事件函数，因为是在特定事件发生时由引擎层调用的。</p><h1 id="2-必然事件"><a href="#2-必然事件" class="headerlink" title="2.必然事件"></a>2.必然事件</h1><table><thead><tr><th>事件函数</th><th>作用</th></tr></thead><tbody><tr><td>Awake</td><td>脚本实例被创建时调用（用于游戏对象的初始化，注意Awake的执行早于所有脚本的Start函数）</td></tr><tr><td>Start</td><td>Update函数第一次运行之前调用（用于游戏对象的初始化）</td></tr><tr><td>Reset</td><td>用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个最常用的默认值。</td></tr><tr><td>Update</td><td>每帧调用一次（用于更新游戏场景和状态）</td></tr><tr><td>FixedUpdate</td><td>每个固定物理时间间隔调用一次（用于物理引擎的参数更新）</td></tr><tr><td>LateUpdate</td><td>每帧调用一次，在Update之后（用于更新游戏场景和状态，和相机有关的更新一般放在这里）</td></tr></tbody></table><h2 id="2-1-Updata与FixedUpdate的区别"><a href="#2-1-Updata与FixedUpdate的区别" class="headerlink" title="2.1 Updata与FixedUpdate的区别"></a>2.1 Updata与FixedUpdate的区别</h2><ul><li><p>FixedUpdate</p><p>物理更新的事件函数，物理引擎也会按照物理帧更新，机制和<strong>Update函数</strong>类似，但是更新的时机完全不同。</p><p>它在每一次物理更新时被调用。</p></li><li><p>Updata</p><p>帧更新函数，每帧调用一次。</p></li></ul><blockquote><p>要认识到，物理更新的频率和时机与Update函数是相对独立的。尽可能在FixedUpdate函数中进行物理相关的操作，在Update函数中进行其他操作，只有选择正确的函数才能让游戏效果尽可能准确。</p></blockquote><h3 id="2-1-1-帧率"><a href="#2-1-1-帧率" class="headerlink" title="2.1.1 帧率"></a>2.1.1 帧率</h3><p>每一帧所经历的时间并不是一个固定值，所以通过<strong>Updata函数</strong>控制物体移动的速度将不会是稳定的。</p><p>主要是因为硬件负载的原因，引擎默认会按照每秒60帧运行游戏，但是当负载增大时，帧率可能会下降，无法达到60帧，这时可能就只有30帧，帧率降低了一半，每帧的时间增加了一倍。物体的运动由于帧率降低而变慢了。实践中一般不允许这种情况的发生。</p><p>解决方案是将两帧之间的间隔<strong>Time.deltaTime</strong>考虑进去。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleScript</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> distancePerSecond;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        transform.Translate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>，distancePerSecond*Time.deltaTime);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:通过乘以Time.deltaTime的运算，物体的移动不再以“每帧距离”为准，而变成了“每秒距离”。</p><p>物体移动的距离将根据每帧时间的长短而变化，从而在时间上看起来移动是匀速的。</p></blockquote><h3 id="2-1-2-物理帧率"><a href="#2-1-2-物理帧率" class="headerlink" title="2.1.2 物理帧率"></a>2.1.2 物理帧率</h3><p>与主更新函数Update不同，Unity的物理系统必须以固定的时间间隔工作，因为只有固定的时间间隔才能保证物理模拟的准确性。就算当前负载很高、帧率很低，Unity也会尽可能保证物理刷新的频率，因为如果物理刷新帧率无法保证，就可能出现不可预料的计算结果。</p><p>在主菜单的工程选项的TimeManager中可以修改物理更新的时间间隔。<br>在脚本中使用Time. fixedDeltaTime可以获得物理更新间隔。</p><p>较小的物理更新间隔会带来更高的更新频率，更准确、更细腻的运算结果，但是也会极大地增加硬件负担。<br>fixedDeltaTime 的默认值为0.02，当对物理运算的准确性非常在意时，可以考虑适当减小这个值。</p><h1 id="3-事件响应函数"><a href="#3-事件响应函数" class="headerlink" title="3. 事件响应函数"></a>3. 事件响应函数</h1><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>OnMouseEnter</td><td>鼠标移入GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseOver</td><td>鼠标停留在GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseExit</td><td>鼠标移出GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseDown</td><td>鼠标在GUI控件或者碰撞体上按下时调用</td></tr><tr><td>OnMouseUp</td><td>鼠标按键释放时调用</td></tr><tr><td>OnTriggerEnter</td><td>与其他碰撞体进入触发器时调用</td></tr><tr><td>OnTriggerExit</td><td>与其他碰撞体离开触发器时调用</td></tr><tr><td>OnTriggerStay</td><td>当其他碰撞体停留在触发器时调用</td></tr><tr><td>OnCollisionEnter</td><td>当碰撞体或者刚体与其他碰撞体或者刚体接触时调用</td></tr><tr><td>OnCollisionExit</td><td>当碰撞体或者刚体与其他碰撞体或者刚体停止接触时调用</td></tr><tr><td>OnCollisionStay</td><td>当碰撞体或者刚体与其他碰撞体或者刚体保持接触时调用</td></tr><tr><td>OnControllerColliderHit</td><td>当控制器移动时与碰撞体发生碰撞时调用</td></tr><tr><td>OnDestroy</td><td>脚本销毁时调用</td></tr><tr><td>OnGUI</td><td>渲染GUI和处理GUI消息时调用</td></tr><tr><td>OnBecameVisible</td><td>对于任意一个相机可见时调用</td></tr><tr><td>OnBecameInVisible</td><td>对于任意一个相机不可见时调用</td></tr><tr><td>OnEnable</td><td>对象启用或者激活时调用</td></tr><tr><td>OnDisable</td><td>对象禁用或者取消激活时调用</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameObject类</title>
    <link href="/2021/03/20/GameObject%E7%B1%BB/"/>
    <url>/2021/03/20/GameObject%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>GameObject 类是Unity场景中所有实体的基类。</p><p>一个GameObject对象通常由多个组件component组成，且至少含有一个transform组件。</p><p>详细可见<a href="https://blog.csdn.net/a1256242238/article/details/73189101">https://blog.csdn.net/a1256242238/article/details/73189101</a></p><h1 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h1><ul><li><p><code>public GameObject();</code></p></li><li><p><code>public GameObject(string name);</code></p></li><li><p><code>public GameObject(string name,params Type[] components);</code></p></li></ul><h1 id="3-常用成员变量"><a href="#3-常用成员变量" class="headerlink" title="3. 常用成员变量"></a>3. 常用成员变量</h1><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>继承于父类Object，对象的名称</td></tr><tr><td>tag</td><td>游戏对象的标签tag</td></tr><tr><td>layer</td><td>游戏对象所在的层layer，范围为[0…31]</td></tr><tr><td>activeSelf</td><td>游戏对象自身的激活状态</td></tr><tr><td>transform</td><td>游戏对象上的Transform组件，设置对象位置、旋转、缩放</td></tr><tr><td>rigidbody</td><td>游戏对象上的Rigidbody组件，设置物理引擎的刚体属性</td></tr><tr><td>camera</td><td>游戏对象上的Camera组件，设置相机属性</td></tr><tr><td>light</td><td>游戏对象上的Light组件，设置灯光属性</td></tr><tr><td>animation</td><td>游戏对象上的Animation组件，设置动画属性</td></tr><tr><td>renderer</td><td>游戏对象上的Renderer组件，渲染物体模型</td></tr><tr><td>audio</td><td>游戏对象上的AudioSource组件，设置声音属性</td></tr></tbody></table><h1 id="4-常用成员函数"><a href="#4-常用成员函数" class="headerlink" title="4.常用成员函数"></a>4.常用成员函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Find</td><td>静态函数，根据名称查找游戏对象</td></tr><tr><td>FindWithTag</td><td>静态函数，根据标签查找第一个符合条件的游戏对象</td></tr><tr><td>FindGameObjectsWithTag</td><td>静态函数，根据标签查找所有符合条件的游戏对象</td></tr><tr><td>CreatePrimitive</td><td>静态函数，创建一个基本形体的游戏对象（如正方体，球体等）</td></tr><tr><td>SetActive</td><td>激活/取消激活游戏对象</td></tr><tr><td>GetComponent</td><td>获取游戏对象</td></tr><tr><td>GetComponentInChildren</td><td>获取游戏对象或其子对象上指定类型的第一个组件</td></tr><tr><td>GetComponents</td><td>获取游戏对象上指定类型的所有组件</td></tr><tr><td>AddComponent</td><td>为游戏对象添加指定组件</td></tr><tr><td>SendMessage</td><td>调用游戏对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>SendMessageUpwards</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>BroadcastMessage</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>CompareTag</td><td>比较游戏对象的标签</td></tr></tbody></table><h1 id="5-继承自Object类的常用函数"><a href="#5-继承自Object类的常用函数" class="headerlink" title="5. 继承自Object类的常用函数"></a>5. 继承自Object类的常用函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Destroy</td><td>删除一个游戏物体、组件或资源</td></tr><tr><td>DestroyImmediate</td><td>立即销毁物体obj，强烈建议使用Destroy替代</td></tr><tr><td>Instantiate</td><td>克隆原始物体，并返回克隆的物体</td></tr><tr><td>DontDestroyOnLoad</td><td>加载新场景的时候使目标不被自动销毁</td></tr><tr><td>FindObjectOfType</td><td>返回Type类型第一个激活的加载的物体</td></tr></tbody></table><h2 id="5-1-Instantiate创建物体"><a href="#5-1-Instantiate创建物体" class="headerlink" title="5.1 Instantiate创建物体"></a>5.1 Instantiate创建物体</h2><p><strong>Instantiate函数</strong>专门用来创建一个新的物体，但是要提供一个预制体或者已经存在的游戏物体作为模板。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Gameobject enemy;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//以enemy为模板生成5个敌人</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-number">1</span><span class="hljs-number">-0</span>; <span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>; <span class="hljs-number">1</span>++)<br>    &#123;<br>        Instantiate(enemy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用已经存在的物体作为模板，更常见的方式是使用预制体作为模板。</p><p>创建的物体将会具有和原物体一样的组件、参数。</p><h2 id="5-2-Destroy销毁物体"><a href="#5-2-Destroy销毁物体" class="headerlink" title="5.2 Destroy销毁物体"></a>5.2 Destroy销毁物体</h2><p>可以用Destroy函数来销毁游戏物体或者组件。</p><p>例如，下面的代码会在导弹产生碰撞时销毁该导弹，第二个参数0.5f表示在0.5秒之后才执行销毁动作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span> (<span class="hljs-params">Collision otherobj</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (other0bj.gameObject.tag == <span class="hljs-string">&quot;Missile&quot;</span>)<br>    &#123;<br>        Destroy (gameObject,<span class="hljs-number">0.5f</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:由于销毁游戏物体和销毁脚本都是使用Destoy函数，所以经常 会出现误删除组件的情况。</p><p>如以下代码：</p><p><code>Destroy (this);</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在脚本中访问其他游戏物体</title>
    <link href="/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在实际的游戏开发中，脚本不仅会对当前挂载的物体进行操作，还可能会引用其他物体。<br>例如，正在追逐玩家角色的敌人角色会-直保留着对玩家角色的引用， 以便随时确定玩家角色的位置。<br>访问其他游戏物体的方法非常多，使用非常灵活，可以根据不同的情况采用不同的方式。</p><h1 id="2-常用的4种访问操作"><a href="#2-常用的4种访问操作" class="headerlink" title="2.常用的4种访问操作"></a>2.常用的4种访问操作</h1><h2 id="2-1-用属性查看器指定参数访问"><a href="#2-1-用属性查看器指定参数访问" class="headerlink" title="2.1 用属性查看器指定参数访问"></a>2.1 用属性查看器指定参数访问</h2><p>Unity中获得其他物体最简单、最直接的方式就是为脚本添加一个<code>publi Gamebiet</code>变量，不需要设置初始值。<br>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>player变量会显示在检视窗口中，默认值为空。</p><p>现在将任何物体或预制体拖曳到player变量的文本框中，就为player变量赋予了初始值。之在脚本中就可以随意使用Player这个游戏物体。<br>如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//读取player的位置并设置本物体的位置在它后方</span><br>        transform.position=player.transform.position-Vector3.forward*<span class="hljs-number">10f</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，上面说的引用其他物体时，变量类型不仅可以是<strong>GameObject</strong>或一个组件，也可以将戏物体拖到这个变量上，只要被拖曳的物体确实具有这个组件就可以。</p><p><code>public Transform playerTransform;</code></p><p>简单地说，可以用何一个组件来指代游戏物体本身。<br>这是因为组件实体具有“被游戏物体挂载”这样的性质，所通过一个游戏物体可以获得它上面的任何一个组件，通过任何一个组件也可以获得挂载该组件游戏物体。这个对应关系是明确的，因此上面的变量类型可以是组件类型，也可以将游戏物体直接拖上去。</p><p>用变量将物体联系起来的做法非常有用，特别是这种联系是持续存在、不易变化的。还可用一个数组或者列表来保存多个游戏物体。</p><blockquote><p>如果被引用的物体是游戏运行时才动态添加的，或者被引用的物体会随着游戏进行而变化事先拖曳的方式就不可行了，需要动态指定物体，下面将详细说明。</p></blockquote><h2 id="2-2-用父子关系查找子物体"><a href="#2-2-用父子关系查找子物体" class="headerlink" title="2.2 用父子关系查找子物体"></a>2.2 用父子关系查找子物体</h2><p>有时需要管理一系列同类型的游戏物体，例如一批敌人、一批寻路点、 多个障碍物等。<br>如果这时候需要对这些物体进行统一的管理或操作，就需要在脚本中用数组或容器来管理它们。</p><p>使用属性查看器指定参数访问的方法，可以将每个物体拖动到检视窗口中，但是这样做不仅低效，而且容易误操作，在物体增加、减少时还需要再次手动操作。</p><p>所以，在这种情况下是不合适的，可以用父子关系查找子物体的方法来遍历所有子物体。<br>在具体实现时，要用父物体的变换组件来查找子物体。</p><blockquote><p>物体的父子关系访问的属性都在变换组件中，而不在GameObject对象中</p></blockquote><p>以下是遍历所有子物体的例子:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WaypointManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br><span class="hljs-keyword">public</span> Transform[] waypoints;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>waypoints = <span class="hljs-keyword">new</span> Transform[transform.childCount];<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">foreach</span> (Transform t <span class="hljs-keyword">in</span> transform)<br>&#123;<br>waypoints[i++] = t;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以使用<strong>transform.Find</strong>方法指定查找某个子物体，代码如下。</p><p><code>transform.Find (&quot;Gun&quot;);</code></p><blockquote><p>由于<strong>Find函数</strong>的效率不好估计，可能会遍历所有物体才能查找到指定物体，所以如果可以在<strong>Start函数</strong>中使用，就不要在<strong>Updata函数</strong>中使用。因为<strong>start函数</strong>只执行一次而<strong>updata函数</strong>每帧都会执行。</p></blockquote><h2 id="2-3-用标签或名称查找物体"><a href="#2-3-用标签或名称查找物体" class="headerlink" title="2.3 用标签或名称查找物体"></a>2.3 用标签或名称查找物体</h2><p>使用<strong>GameObject.Find方法</strong>可以通过名称查找游戏物体。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.Find (<span class="hljs-string">&quot;ObjectName&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要用标签查找物体，那么就要用到<strong>GameObject.FindWithTag方法</strong> 或<strong>GameObject.FindGameObjectWithTag方法</strong>。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br>GameObject[] enemies;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.FindWithTag(<span class="hljs-string">&quot;Player&quot;</span>);<br>    enemies =GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;Enemy&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity基础</tag>
      
      <tag>Unity常用操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity场景渲染模式</title>
    <link href="/2021/03/20/Unity%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/20/Unity%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>DrawMode，用于绘制渲染场景的四种渲染模式。</p><p>目前还理解不能，先开个坑</p><h1 id="Shading-Mode"><a href="#Shading-Mode" class="headerlink" title="Shading Mode"></a>Shading Mode</h1><h1 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h1><h1 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h1><h1 id="Global-lllumination"><a href="#Global-lllumination" class="headerlink" title="Global lllumination"></a>Global lllumination</h1><p>与全局光照有关</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>渲染</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity基础</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL语句大全</title>
    <link href="/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/"/>
    <url>/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MYSQL语句大全"><a href="#MYSQL语句大全" class="headerlink" title="MYSQL语句大全"></a>MYSQL语句大全</h1><h2 id="0-相关知识"><a href="#0-相关知识" class="headerlink" title="0 相关知识"></a>0 相关知识</h2><ul><li><p><a href="https://blog.csdn.net/chaoyue1861/article/details/80468773">MYSQL逻辑架构</a></p></li><li><p><a href="https://blog.csdn.net/GitChat/article/details/78787837?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">MYSQL底层原理</a></p></li><li><p><a href="https://blog.csdn.net/m0_38075425/article/details/82256315?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">MySQL底层架构原理，工作流程和存储引擎的数据结构讲解</a></p></li></ul><h2 id="1-用户管理操作"><a href="#1-用户管理操作" class="headerlink" title="1 用户管理操作"></a>1 用户管理操作</h2><h3 id="1-1-添加用户"><a href="#1-1-添加用户" class="headerlink" title="1.1 添加用户"></a>1.1 添加用户</h3><ul><li><code> create user username identified by &#39;password&#39;;</code></li></ul><p>参数：用户名：username 密码：password</p><blockquote><p>用户数据存储在mysql.user表内</p></blockquote><h3 id="1-2-用户授权"><a href="#1-2-用户授权" class="headerlink" title="1.2 用户授权"></a>1.2 用户授权</h3><ul><li><code>grant privilegesCode on dbName.tableName to username@host identified by &#39;password&#39;;</code></li></ul><p>将Dbname数据库的所有操作权限都授权给了用户username。</p><p>参数：</p><p><strong>privilegesCode</strong> 权限类型<br>常用的权限类型</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>all privileges</td><td>所有权限</td></tr><tr><td>select</td><td>读取权限</td></tr><tr><td>delete</td><td>删除权限</td></tr><tr><td>update</td><td>更新权限</td></tr><tr><td>create</td><td>创建权限</td></tr><tr><td>drop</td><td>删除数据库、数据表权限</td></tr></tbody></table><p><strong>dbName.tableName</strong> 授权的库或特定表</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>授予该数据库服务器所有数据库的权限</td></tr><tr><td>dbName.*</td><td>授予dbName数据库所有表的权限</td></tr><tr><td>dbName.dbTable</td><td>授予数据库dbName中dbTable表的权限</td></tr></tbody></table><p><strong>username@’host’</strong> 授予的用户以及允许该用户登录的IP地址<br>| 参数         | 含义                 |<br>| ————– | ———————- |<br>| localhost | 只允许该用户在本地登录，不能远程登录 |<br>| % | 允许在除本机之外的任何一台机器远程登录 |<br>| 192.168.52.32 | 具体的IP表示只允许该用户从特定IP登录 |</p><ul><li><p><code> flush privileges;</code></p><p>刷新权限变更</p></li><li><p><code> show grants for &#39;username&#39;;</code></p></li></ul><p>查看用户的已有权限</p><blockquote><p>用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush privileges;<br></code></pre></td></tr></table></figure><p>上面的语句将zhangsanDb数据库的所有操作权限都授权给了用户zhangsan</p></blockquote><ul><li><p><code>REVOKE DELETE ON *.* FROM &#39;test&#39;@&#39;localhost&#39;;</code> </p><p>取消该用户的删除权限</p></li></ul><blockquote><p>用户权限数据存储在mysql.db表内</p></blockquote><h3 id="1-3-修改密码"><a href="#1-3-修改密码" class="headerlink" title="1.3 修改密码"></a>1.3 修改密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update mysql.user set password &#x3D; password(&#39;newpassword&#39;) where user &#x3D; &#39;username&#39; and host &#x3D; &#39;%&#39;; <br>flush privileges;<br></code></pre></td></tr></table></figure><h3 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a>1.4 删除用户</h3><ul><li><code>drop user zhangsan@&#39;%&#39;;</code></li></ul><h3 id="1-5-常用命令组"><a href="#1-5-常用命令组" class="headerlink" title="1.5 常用命令组"></a>1.5 常用命令组</h3><p><strong>创建用户并授予指定数据库全部权限：适用于Web应用创建MySQL用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user zhangsan identified by &#39;zhangsan&#39;;<br>grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush  privileges;<br></code></pre></td></tr></table></figure><p>创建了用户zhangsan，并将数据库zhangsanDB的所有权限授予zhangsan。如果要使zhangsan可以从本机登录，那么可以多赋予localhost权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;localhost&#39; identified by &#39;zhangsan&#39;;<br></code></pre></td></tr></table></figure><h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2 数据库操作"></a>2 数据库操作</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code> show database;</code></td><td>查看所有的数据库</td></tr><tr><td><code>create database DBname;</code></td><td>创建该数据库</td></tr><tr><td><code>drop DBname;</code></td><td>删除该数据库</td></tr><tr><td><code>use DBname;</code></td><td>使用调用该数据库</td></tr></tbody></table><h2 id="3-表操作"><a href="#3-表操作" class="headerlink" title="3 表操作"></a>3 表操作</h2><h3 id="3-1-表的基础操作"><a href="#3-1-表的基础操作" class="headerlink" title="3.1 表的基础操作"></a>3.1 表的基础操作</h3><ul><li><p><code>show tables;</code><br>查看所有的表</p></li><li><p><code>SHOW TABLE STATUS;</code><br>查看所有的表信息（包括视图）</p></li><li><p><code> create table TBname(mode);</code></p><p>创建一个表</p><blockquote><p>例如<br><code>create table n(id INT, name VARCHAR(10));</code></p></blockquote></li><li><p><code> create table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的表</p></li><li><p><code>create table TBname like TBname;</code><br>新创建的表与一个存在的表的数据结构类似</p></li><li><p><code>create temporay table TBname(mode);</code><br>创建一个临时表</p><blockquote><p>临时表将在你连接MySQL期间存在。当断开连接时，MySQL将自动删除表并释放所用的空间。也可手动删除。</p></blockquote></li></ul><ul><li><p><code>create temporary table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的临时表</p></li><li><p><code> drop table if exists TBname;</code><br>删除一个存在表</p></li><li><pre><code>alter table TBname rename TBname;或rename TBname to TBname;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  更改存在表的名称<br><br>  <br>  <br>- ``` <br>  <span class="hljs-keyword">desc</span> TBname;<br>  describe TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">in</span> TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> TBname;<br>  <span class="hljs-keyword">explain</span> TBname;<br></code></pre></td></tr></table></figure>查看表的结构(以上五条语句效果相同）</code></pre></li><li><p><code> show create table TBname;</code><br>查看表的创建语句</p><h3 id="3-2-表的结构操作"><a href="#3-2-表的结构操作" class="headerlink" title="3.2 表的结构操作"></a>3.2 表的结构操作</h3></li></ul><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td><code> alter table TBname add Fieldname mode;</code></td><td>添加字段</td></tr><tr><td><code>alter table TBname drop Fieldname;</code></td><td>删除字段</td></tr><tr><td><code>alter table TBname change Fieldname mode;</code></td><td>更改字段属性</td></tr><tr><td><code>alter table TBname change Fieldname Fieldname mode;</code></td><td>更改字段名与属性</td></tr></tbody></table><h3 id="3-3-表的数据操作"><a href="#3-3-表的数据操作" class="headerlink" title="3.3 表的数据操作"></a>3.3 表的数据操作</h3><ul><li><p>增加数据</p><p><code>INSERT INTO n VALUES (1, &#39;tom&#39;, &#39;23&#39;), (2, &#39;john&#39;, &#39;22&#39;);</code></p><p><code>INSERT INTO n SELECT * FROM n;</code>  把数据复制一遍重新插入</p></li><li><p>删除数据</p><p><code>DELETE FROM n WHERE id = 2;</code></p></li><li><p>更改数据</p><p><code>UPDATE n SET name = &#39;tom&#39; WHERE id = 2;</code></p></li><li><p>数据查找</p><p><code>SELECT * FROM n WHERE name LIKE &#39;%h%&#39;;</code></p></li><li><p>数据排序(反序)</p><p><code>SELECT * FROM n ORDER BY name, id DESC ;</code></p></li></ul><blockquote><p>增删改查请看：<a href="https://www.cnblogs.com/heyangblog/p/7624645.html">https://www.cnblogs.com/heyangblog/p/7624645.html</a></p></blockquote><h2 id="4-键"><a href="#4-键" class="headerlink" title="4 键"></a>4 键</h2><h3 id="4-1-添加主键"><a href="#4-1-添加主键" class="headerlink" title="4.1 添加主键"></a>4.1 添加主键</h3><ul><li><p><code>ALTER TABLE TBname ADD PRIMARY KEY (id);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT pk_n PRIMARY KEY (id);</code>  </p><p>添加主键的同时自定义键名</p></li></ul><h3 id="4-2-删除主键"><a href="#4-2-删除主键" class="headerlink" title="4.2 删除主键"></a>4.2 删除主键</h3><ul><li><code> ALTER TABLE TBname DROP PRIMARY KEY ;</code></li></ul><h3 id="4-3-添加外键"><a href="#4-3-添加外键" class="headerlink" title="4.3 添加外键"></a>4.3 添加外键</h3><ul><li><p><code>ALTER TABLE TBname ADD FOREIGN KEY (id) REFERENCES TBname(id);</code>   </p><p>自动生成键名m_ibfk_1</p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES TBname(id); </code>  </p><p>使用定义的键名fk_id</p></li></ul><h3 id="4-4-删除外键"><a href="#4-4-删除外键" class="headerlink" title="4.4 删除外键"></a>4.4 删除外键</h3><ul><li>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</li></ul><h3 id="4-5-修改外键"><a href="#4-5-修改外键" class="headerlink" title="4.5 修改外键"></a>4.5 修改外键</h3><ul><li><p>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</p><p>ADD CONSTRAINT fk_id2 FOREIGN KEY (id) REFERENCES TBname(id); </p><p>删除之后从新建</p></li></ul><h3 id="4-6-添加唯一键"><a href="#4-6-添加唯一键" class="headerlink" title="4.6 添加唯一键"></a>4.6 添加唯一键</h3><ul><li><p><code> ALTER TABLE TBname ADD UNIQUE (name);</code></p></li><li><p><code> ALTER TABLE TBname ADD UNIQUE u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD UNIQUE INDEX u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT u_name UNIQUE (name);</code></p></li><li><p><code>CREATE UNIQUE INDEX u_name ON TBname(name);</code></p></li></ul><h3 id="4-7-添加索引"><a href="#4-7-添加索引" class="headerlink" title="4.7 添加索引"></a>4.7 添加索引</h3><ul><li><p><code>ALTER TABLE TBname ADD INDEX (age);</code></p></li><li><p><code>ALTER TABLE TBname ADD INDEX i_age (age);</code></p></li><li><p><code>CREATE INDEX i_age ON TBname(age);</code></p></li></ul><h3 id="4-8-删除索引或唯一键"><a href="#4-8-删除索引或唯一键" class="headerlink" title="4.8 删除索引或唯一键"></a>4.8 删除索引或唯一键</h3><ul><li><p><code>DROP INDEX u_name ON n;</code></p></li><li><p><code>DROP INDEX i_age ON n;</code></p></li></ul><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5 视图"></a>5 视图</h2><h3 id="5-1-创建视图"><a href="#5-1-创建视图" class="headerlink" title="5.1 创建视图"></a>5.1 创建视图</h3><ul><li><p><code>CREATE VIEW v AS SELECT id, name FROM n;</code></p></li><li><p><code>CREATE VIEW v(id, name) AS SELECT id, name FROM n;</code></p></li></ul><h3 id="5-2查看视图"><a href="#5-2查看视图" class="headerlink" title="5.2查看视图"></a>5.2查看视图</h3><ul><li><p><code>SELECT * FROM v;</code></p></li><li><p><code>DESC v;</code></p></li></ul><blockquote><p>与表操作类似</p></blockquote><h3 id="5-3查看创建视图语句"><a href="#5-3查看创建视图语句" class="headerlink" title="5.3查看创建视图语句"></a>5.3查看创建视图语句</h3><ul><li><code>SHOW CREATE VIEW v;</code></li></ul><h3 id="5-4-更改视图"><a href="#5-4-更改视图" class="headerlink" title="5.4 更改视图"></a>5.4 更改视图</h3><ul><li><p><code>CREATE OR REPLACE VIEW v AS SELECT name, age FROM n;</code></p></li><li><p><code>ALTER VIEW v AS SELECT name FROM n ;</code></p></li></ul><h3 id="5-5-删除视图"><a href="#5-5-删除视图" class="headerlink" title="5.5 删除视图"></a>5.5 删除视图</h3><ul><li><code>DROP VIEW IF EXISTS v;</code></li></ul><h2 id="6-联接"><a href="#6-联接" class="headerlink" title="6 联接"></a>6 联接</h2><h3 id="6-1-内联接"><a href="#6-1-内联接" class="headerlink" title="6.1 内联接"></a>6.1 内联接</h3><ul><li><code>SELECT * FROM m INNER JOIN n ON m.id = n.id;</code></li></ul><h3 id="6-2-外连接"><a href="#6-2-外连接" class="headerlink" title="6.2 外连接"></a>6.2 外连接</h3><ul><li><code>SELECT * FROM m LEFT JOIN n ON m.id = n.id;</code>左外连接</li><li><code>SELECT * FROM m RIGHT JOIN n ON m.id = n.id;</code>右外连接</li></ul><h3 id="6-3-交叉联接"><a href="#6-3-交叉联接" class="headerlink" title="6.3 交叉联接"></a>6.3 交叉联接</h3><ul><li><p><code>SELECT * FROM m CROSS JOIN n;</code>  标准写法</p></li><li><p><code>SELECT * FROM m, n;</code></p></li></ul><h3 id="6-4-类似全连接full-join的联接用法"><a href="#6-4-类似全连接full-join的联接用法" class="headerlink" title="6.4 类似全连接full join的联接用法"></a>6.4 类似全连接full join的联接用法</h3><ul><li><pre><code>SELECT id,name FROM mUNIONSELECT id,name FROM n;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs sql">## <span class="hljs-number">7</span> 函数<br><br>### <span class="hljs-number">7.1</span> 聚合函数<br><br><span class="hljs-operator">|</span> 语句                               <span class="hljs-operator">|</span> 含义   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">---------------------------------- | ------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(id) <span class="hljs-keyword">AS</span> total <span class="hljs-keyword">FROM</span> n;  <span class="hljs-operator">|</span> 总数   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 总和   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 平均值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">max</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最大值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最小值 <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.2</span> 数学函数<br><br><span class="hljs-operator">|</span> 语句                              <span class="hljs-operator">|</span> 含义                                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">--------------------------------- | ------------------------------------------------------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">abs</span>(<span class="hljs-number">-5</span>);                   <span class="hljs-operator">|</span> 绝对值                                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> bin(<span class="hljs-number">15</span>), oct(<span class="hljs-number">15</span>), hex(<span class="hljs-number">15</span>); <span class="hljs-operator">|</span> 二进制，八进制，十六进制                               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> pi();                      <span class="hljs-operator">|</span> 圆周率<span class="hljs-number">3.141593</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">5.5</span>);                 <span class="hljs-operator">|</span> 大于x的最小整数值<span class="hljs-number">6</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">5.5</span>);                <span class="hljs-operator">|</span> 小于x的最大整数值<span class="hljs-number">5</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> greatest(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>); <span class="hljs-operator">|</span> 返回集合中最大的值<span class="hljs-number">9</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> least(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);    <span class="hljs-operator">|</span> 返回集合中最小的值<span class="hljs-number">1</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);                  <span class="hljs-operator">|</span> 余数<span class="hljs-number">2</span>                                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand();                    <span class="hljs-operator">|</span> 返回０到１内的随机值，每次不一样                       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 提供一个参数(种子)使RAND()随机数生成器生成一个指定的值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>);          <span class="hljs-operator">|</span> 四舍五入<span class="hljs-number">1415</span>                                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);       <span class="hljs-operator">|</span> 四舍五入三位数<span class="hljs-number">1415.142</span>                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);      <span class="hljs-operator">|</span> 四舍五入整数位数<span class="hljs-number">1420</span>                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);    <span class="hljs-operator">|</span> 截短为<span class="hljs-number">3</span>位小数<span class="hljs-number">1415.141</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);   <span class="hljs-operator">|</span> 截短为<span class="hljs-number">-1</span>位小数<span class="hljs-number">1410</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">-5</span>);                  <span class="hljs-operator">|</span> 符号的值负数<span class="hljs-number">-1</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 符号的值正数<span class="hljs-number">1</span>                                          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">9</span>);                   <span class="hljs-operator">|</span> 平方根<span class="hljs-number">3</span>                                                <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.3</span> 字符串函数<br><br><span class="hljs-operator">|</span> 语句                                        <span class="hljs-operator">|</span> 含义                                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------- | ------------------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>);         <span class="hljs-operator">|</span> 连接字符串<span class="hljs-operator">-</span>apple                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>); <span class="hljs-operator">|</span> 连接用<span class="hljs-string">&#x27;,&#x27;</span>分割字符串<span class="hljs-operator">-</span>a,p,p,le                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">insert</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;IN&#x27;</span>);       <span class="hljs-operator">|</span> 将字符串<span class="hljs-string">&#x27;chinese&#x27;</span>从<span class="hljs-number">3</span>位置开始的<span class="hljs-number">2</span>个字符替换为<span class="hljs-string">&#x27;IN&#x27;</span><span class="hljs-operator">-</span>chINese <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">left</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">4</span>);                  <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>左边的<span class="hljs-number">4</span>个字符<span class="hljs-operator">-</span>chin                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">right</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);                 <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>右边的<span class="hljs-number">3</span>个字符<span class="hljs-operator">-</span>ese                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);             <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的子字符串<span class="hljs-operator">-</span>inese       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">-3</span>);            <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>倒数第三个字符之后的子字符串<span class="hljs-operator">-</span>ese     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);          <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的两个字符<span class="hljs-operator">-</span><span class="hljs-keyword">in</span>          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27; chinese &#x27;</span>);                   <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese&#x27;</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ltrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese &#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rtrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27; chinese&#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> repeat(<span class="hljs-string">&#x27;boy&#x27;</span>, <span class="hljs-number">3</span>);                    <span class="hljs-operator">|</span> 重复字符<span class="hljs-string">&#x27;boy&#x27;</span>三次<span class="hljs-operator">-</span><span class="hljs-string">&#x27;boyboyboy&#x27;</span>                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> reverse(<span class="hljs-string">&#x27;chinese&#x27;</span>);                  <span class="hljs-operator">|</span> 反向排序<span class="hljs-operator">-</span><span class="hljs-string">&#x27;esenihc&#x27;</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> length(<span class="hljs-string">&#x27;chinese&#x27;</span>);                   <span class="hljs-operator">|</span> 返回字符串的长度<span class="hljs-number">-7</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>), <span class="hljs-built_in">lower</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ucase(<span class="hljs-string">&#x27;chINese&#x27;</span>), lcase(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;i&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-3</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;e&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-5</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abd&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数小于第二个返回负数<span class="hljs-operator">-</span> <span class="hljs-number">-1</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abb&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数大于第二个返回正数<span class="hljs-operator">-</span> <span class="hljs-number">1</span>             <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.4</span> 时间函数<br><br><span class="hljs-operator">|</span> 语句                                                         <span class="hljs-operator">|</span> 含义                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------------------------ | -------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">current_date</span>, <span class="hljs-built_in">current_time</span>, now();                    <span class="hljs-operator">|</span> <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span>   <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span>    <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span> <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">hour</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">minute</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">second</span>(<span class="hljs-built_in">current_time</span>); <span class="hljs-operator">|</span> <span class="hljs-number">12</span>  <span class="hljs-number">31</span>   <span class="hljs-number">34</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">year</span>(<span class="hljs-built_in">current_date</span>), <span class="hljs-keyword">month</span>(<span class="hljs-built_in">current_date</span>), week(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">2018</span>    <span class="hljs-number">1</span>   <span class="hljs-number">1</span>                                <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> quarter(<span class="hljs-built_in">current_date</span>);                                <span class="hljs-operator">|</span> <span class="hljs-number">1</span>                                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> monthname(<span class="hljs-built_in">current_date</span>), dayname(<span class="hljs-built_in">current_date</span>);       <span class="hljs-operator">|</span> January  Saturday                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> dayofweek(<span class="hljs-built_in">current_date</span>), dayofmonth(<span class="hljs-built_in">current_date</span>), dayofyear(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">7</span>   <span class="hljs-number">13</span>  <span class="hljs-number">13</span>                                   <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.5</span> 控制流函数<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> if(<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>), if(<span class="hljs-number">3</span><span class="hljs-operator">&lt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>);`    <br><br>  t f<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> ifnull(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;t&#x27;</span>), ifnull(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>);`    <br><br>  t <span class="hljs-number">2</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> isnull(<span class="hljs-number">1</span>), isnull(<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>);`    <br><br>   <span class="hljs-number">0</span> <span class="hljs-number">1</span> 是<span class="hljs-keyword">null</span>返回<span class="hljs-number">1</span>，不是<span class="hljs-keyword">null</span>返回<span class="hljs-number">0</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);`    <br><br>  <span class="hljs-keyword">null</span> a 参数相同或成立返回<span class="hljs-keyword">null</span>，不同或不成立则返回第一个参数<br><br><span class="hljs-operator">-</span> ```<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-number">2</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;first&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;second&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;third&#x27;</span><br>         <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;other&#x27;</span><br>         <span class="hljs-keyword">END</span> ;     <br></code></pre></td></tr></table></figure>second&gt; 这一块不是完全看不懂吗！</code></pre></li></ul><h1 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h1><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td>SELECT database();</td><td>当前数据库名-test</td></tr><tr><td>SELECT connection_id();</td><td>当前用户id-306</td></tr><tr><td>SELECT user();</td><td>当前用户-root@localhost</td></tr><tr><td>SELECT version();</td><td>当前mysql版本</td></tr><tr><td>SELECT found_rows();</td><td>返回上次查询的检索行数</td></tr></tbody></table><h2 id="8-存储过程"><a href="#8-存储过程" class="headerlink" title="8 存储过程"></a>8 存储过程</h2><h3 id="8-1-创建存储过程"><a href="#8-1-创建存储过程" class="headerlink" title="8.1 创建存储过程"></a>8.1 创建存储过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">DELIMITER <span class="hljs-comment">//    # 无参数</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> ;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_2</span><span class="hljs-params">(<span class="hljs-keyword">IN</span> id INT)</span>    # <span class="hljs-title">in</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> <span class="hljs-title">WHERE</span> <span class="hljs-title">a</span> = <span class="hljs-title">id</span>;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_3</span><span class="hljs-params">(<span class="hljs-keyword">OUT</span> sum INT)</span>    # <span class="hljs-title">out</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">sum</span> = <span class="hljs-params">(<span class="hljs-keyword">SELECT</span> count(*)</span> <span class="hljs-title">FROM</span> <span class="hljs-title">test</span>);</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_4</span><span class="hljs-params">(INOUT i INT)</span>    # <span class="hljs-title">inout</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">i</span> = <span class="hljs-title">i</span> + 1;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="8-2-删除存储过程"><a href="#8-2-删除存储过程" class="headerlink" title="8.2 删除存储过程"></a>8.2 删除存储过程</h3><ul><li><code>DROP PROCEDURE IF EXISTS getDates;</code></li></ul><h3 id="8-3-修改存储过程的特性"><a href="#8-3-修改存储过程的特性" class="headerlink" title="8.3 修改存储过程的特性"></a>8.3 修改存储过程的特性</h3><ul><li><code>ALTER PROCEDURE getDates MODIFIES SQL DATA ;</code></li></ul><h3 id="8-4-查看存储过程"><a href="#8-4-查看存储过程" class="headerlink" title="8.4 查看存储过程"></a>8.4 查看存储过程</h3><ul><li><p><code>SHOW PROCEDURE STATUS LIKE &#39;getDates&#39;;</code>    </p><p> 状态</p></li><li><p><code>SHOW CREATE PROCEDURE getDates_3;</code> </p><p> 语句</p></li></ul><h3 id="8-5-调用存储过程"><a href="#8-5-调用存储过程" class="headerlink" title="8.5 调用存储过程"></a>8.5 调用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> getDates();<br><span class="hljs-keyword">CALL</span> getDates_2(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">CALL</span> getDates_3(<span class="hljs-variable">@s</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@s</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">CALL</span> getDates_4(<span class="hljs-variable">@i</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@i</span>;    # <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="9-数据库安全"><a href="#9-数据库安全" class="headerlink" title="9 数据库安全"></a>9 数据库安全</h2><h3 id="9-1-数据库备份"><a href="#9-1-数据库备份" class="headerlink" title="9.1 数据库备份"></a>9.1 数据库备份</h3><ul><li><pre><code>mysqldump -u root -p db_name &gt; file.sqlmysqldump -u root -p db_name table_name &gt; file.sql</code></pre><h3 id="9-2数据库还原"><a href="#9-2数据库还原" class="headerlink" title="9.2数据库还原"></a>9.2数据库还原</h3></li><li><code>mysql -u root -p &lt; C:\file.sql</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>数据库</tag>
      
      <tag>MYSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-排序</title>
    <link href="/2021/03/09/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/09/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1.题目要求"></a>1.题目要求</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个无序单链表，实现单链表的排序(按升序排序)。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>说明：本题目包含复杂数据结构ListNode</p><h1 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2.题目分析"></a>2.题目分析</h1><p>该题目主要考察的是排序算法，常用的排序算法可以参考该网站</p><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p><p><img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png" srcset="/img/loading.gif" alt="十种常见排序算法"></p><h1 id="3-解题"><a href="#3-解题" class="headerlink" title="3.解题"></a>3.解题</h1><h2 id="3-1-冒泡排序"><a href="#3-1-冒泡排序" class="headerlink" title="3.1 冒泡排序"></a>3.1 冒泡排序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; head</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; p = head; p.Next != <span class="hljs-literal">null</span>; p = p.Next)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; q = p.Next; q != <span class="hljs-literal">null</span>; q = q.Next)<br>            <span class="hljs-keyword">if</span> (p.Value &gt; p.Next.Value)<br>            &#123;<br>                <span class="hljs-built_in">int</span> t = p.Value;<br>                p.Value = p.Next.Value;<br>                p.Next.Value = t;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-选择排序"><a href="#3-2-选择排序" class="headerlink" title="3.2 选择排序"></a>3.2 选择排序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">selectionSort</span>(<span class="hljs-params">LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; head</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; p = head; p.Next != <span class="hljs-literal">null</span>; p = p.Next)<br>            &#123;<br>                LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; min = <span class="hljs-keyword">new</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">255</span>);<br>                <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; q = p; q.Next != <span class="hljs-literal">null</span>; q = q.Next)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (q.Value &lt; min.Value)<br>                    &#123;<br>                        min = q;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">int</span> t = p.Value;<br>                p.Value = min.Value;<br>                min.Value = t;<br>            &#125;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-插入排序"><a href="#3-3-插入排序" class="headerlink" title="3.3 插入排序"></a>3.3 插入排序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">insertionSort</span>(<span class="hljs-params">LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; head</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; p = head.Next; p.Next != <span class="hljs-literal">null</span>; p = p.Next)<br>            &#123;<br>                <span class="hljs-built_in">int</span> t = p.Value;<br>                LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; q = p.Previous;<br>                <span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(p.Value&gt;q.Value)<br>                    &#123;<br>                        q.Next.Value= t;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    q.Next.Value = q.Value;<br>                    q = q.Previous;<br>                &#125;                <br>            &#125;<br>                <span class="hljs-keyword">return</span> head;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-希尔排序"><a href="#3-4-希尔排序" class="headerlink" title="3.4 希尔排序"></a>3.4 希尔排序</h2>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>剑指offer</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量基础知识</title>
    <link href="/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在数学中，几何向量（也称为欧几里得向量，通常简称向量、矢量），指具有大小和方向的量。</p><p>向量可以形象化地表示为带箭头的线段。</p><p>箭头所指：代表向量的方向；线段长度：代表向量的大小。</p><p>标量：只有大小,没有方向。</p><h1 id="2-向量的运算"><a href="#2-向量的运算" class="headerlink" title="2. 向量的运算"></a>2. 向量的运算</h1><h2 id="2-1-基础运算"><a href="#2-1-基础运算" class="headerlink" title="2.1 基础运算"></a>2.1 基础运算</h2><table><thead><tr><th>运算</th><th>描述</th></tr></thead><tbody><tr><td>加减</td><td>各个分量分别相加减</td></tr><tr><td>数乘</td><td>向量与标量的乘数，可以对向量的长度进行缩放，如果标量&gt;0，向量的方向不变，如果&lt;0,向量的方向为反方向</td></tr></tbody></table><h2 id="2-2-点乘（点积）"><a href="#2-2-点乘（点积）" class="headerlink" title="2.2 点乘（点积）"></a>2.2 点乘（点积）</h2><p>两个向量点乘得到一个标量 ，数值等于两个向量长度相乘后再乘以二者夹角的余弦值 。<br>如果两个向量a,b均 为单位 向量 ,那么a.b等于向量b在向量a方向上的投影的长度</p><p>点乘后得到的是一个值</p><ul><li><p>若结果 == 0，则 两向量 互垂直 </p></li><li><p>若结果 &lt; 0 ，则 两向量夹角大于90°</p></li><li><p>若结果 &gt;0 ，则两向量夹角小于 90°</p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E4%B9%98.png" srcset="/img/loading.gif" alt="点乘"></p></li></ul><blockquote><p>两个单位向量的点积得到两个向量的夹角的cos值，通过它可以知道两个向量的相似性。</p></blockquote><blockquote><p>利用点积可判断一个多边形是否面向摄像机还是背向摄像机。</p></blockquote><blockquote><p>如果点积越大，说明夹角越小，则物理离光照的轴线越近，光照越强。</p></blockquote><h2 id="2-3-叉乘"><a href="#2-3-叉乘" class="headerlink" title="2.3 叉乘"></a>2.3 叉乘</h2><p>两个向量的叉乘得到一个新的向量，新向量垂直于原来两个向量，并且长度等于原向量长度相乘后再乘以夹角的正弦值，类似左手坐标系Z。</p><p>在Unity3D里面。两个向量的点乘所得到的是两个向量的余弦值，也就是-1 到1之间，0表示垂直，-1表示相反，1表示相同方向。 </p><p>两个向量的叉乘所得到的是两个向量所组成的面的垂直向量，分两个方向。 </p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8F%89%E4%B9%98.png" srcset="/img/loading.gif" alt="叉乘"></p><blockquote><p>简单的说，点乘判断角度，叉乘判断方向。 </p><p>形象的说当一个敌人在你身后的时候，叉乘可以判断你是往左转还是往右转更好的转向敌人，点乘得到你当前的面朝向的方向和你到敌人的方向的所成的角度大小。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>跨专业知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity基础</tag>
      
      <tag>跨专业知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vector3类</title>
    <link href="/2021/02/21/Vector3%E7%B1%BB/"/>
    <url>/2021/02/21/Vector3%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Vector3是结构体,Vector3类在Unity中一般用于表示3D向量和三维坐标点。</p><h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2. 属性"></a>2. 属性</h1><h2 id="2-1静态成员变量"><a href="#2-1静态成员变量" class="headerlink" title="2.1静态成员变量"></a>2.1静态成员变量</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>right</code>（右）</td><td>代表坐标轴（1,0,0）</td></tr><tr><td><code>left</code> （左）</td><td>代表坐标轴（-1,0,0）</td></tr><tr><td><code>up</code>（上）</td><td>代表坐标轴（0,1,0）</td></tr><tr><td><code>down</code>（下）</td><td>代表坐标轴（0,-1,0）</td></tr><tr><td><code>forward</code>  （前）</td><td>代表坐标轴（0,0,1）</td></tr><tr><td><code>back</code>（后）</td><td>代表坐标轴（0,0,-1）</td></tr><tr><td><code>zero</code>（零）</td><td>代表坐标轴（0,0,0）</td></tr><tr><td><code>one</code>（一）</td><td>代表坐标轴（1,1,1）</td></tr></tbody></table><h2 id="2-2-实例成员变量"><a href="#2-2-实例成员变量" class="headerlink" title="2.2 实例成员变量"></a>2.2 实例成员变量</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Magnitude</code></td><td>返回向量的长度，向量的长度是(x<em>x+y</em>y+z*z)的平方根（只读）</td></tr><tr><td><code>Normalized</code></td><td>返回一个归一化的新向量，原向量长度不变</td></tr><tr><td><code>sqrMagnitude</code></td><td>返回向量的长度的平方（只读）</td></tr></tbody></table><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><h2 id="3-1-静态方法"><a href="#3-1-静态方法" class="headerlink" title="3.1 静态方法"></a>3.1 静态方法</h2><table><thead><tr><th>方法名称</th><th>方法体</th><th>描述</th></tr></thead><tbody><tr><td><code>Angle</code></td><td><code>public static float Angle(Vector3 from, Vector3 to);</code></td><td>此方法用于返回向量from和to的夹角，单位为角度，返回值范围为[0,180]，且当from和to中至少有一个为Vector3.zero时，方法返回值为90</td></tr><tr><td><code>ClampMagnitude</code></td><td><code>public static Vector3 ClampMagnitude(Vector3 vector, float maxLength);</code></td><td>此方法用于返回向量vector的一个同方向向量，模长受maxLength限制</td></tr><tr><td><code>Cross</code></td><td><code>public static Vector3 Cross(Vector3 Ihs,Vecxtor3 rhs);</code></td><td>向量叉乘</td></tr><tr><td><code>Dot</code></td><td><code>public static float Dot(Vector3 Ihs, Vector3 rhs);</code></td><td>向量点乘</td></tr><tr><td><code>Lerp</code></td><td><code>public static Vector3 Lerp(Vector3 from, Vector3 to, float t);</code></td><td>参数from为差值起始点坐标，参数to为插值结束点坐标，参数t为插值系数</td></tr><tr><td><code>MoveTowards</code></td><td><code>public static Vector3 MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta);</code></td><td>此方法用于返回一个从参数current到参数target的差值向量</td></tr><tr><td><code>OrthoNormalize</code></td><td><code>public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent);</code></td><td>此方法用于对向量normal进行单位化处理，并对tangent进行正交化处理。即normal变成单位向量，tangent变成与该单位向量垂直的模长为1的向量，且这些向量处于同一平面</td></tr><tr><td><code>OrthoNormalize</code></td><td><code>public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent, ref Vector3 binormal);</code></td><td>此方法用于对向量normal进行单位化处理，并对向量tangent和binormal进行正交化处理，于上面两个参数的重载相同，binormal垂直于normal和tangent组成的平面</td></tr><tr><td><code>Project</code></td><td><code>public static Vector3 Project(Vector3 vector, Vector3 onNormal);</code></td><td>此方法用于返回向量vector在向量onNormal上的投影向量</td></tr><tr><td><code>Reflect</code></td><td><code>public static Vector3 Reflect(Vector3 inDirection, Vector3 inNormal);</code></td><td>参数inDirection为入射向量，inNormal为镜面向量。参数inNormal向量必须为单位向量，否则入射角和反射角不相等。当inNormal取反时，反射向量不受影响</td></tr><tr><td><code>RotateTowards</code></td><td><code>public static Vector3 RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)</code></td><td>参数current为起始点坐标，参数target为目标点坐标，参数maxRadiansDelta为角度旋转系数，参数maxMagnitudeDelta为模长系数</td></tr><tr><td><code>Scale</code></td><td><code>public static Vector3 Scale(Vector3 a, Vector3 b);</code></td><td>此方法返回向量a和b的乘积</td></tr><tr><td><code>Slerp</code></td><td><code>public static Vector3 Slerp(Vector3 from, Vector3 to, float t);</code></td><td>参数from为插值起始点坐标，参数to为插值结束点坐标，参数t为插值系数。此方法用于返回从参数from点到参数to点的球形差值向量。</td></tr><tr><td><code>SmoothDamp</code></td><td>见下</td><td>见下</td></tr></tbody></table><p> <code>SmoothDamp</code>方法：阻尼运动</p><ul><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime);</code></p></li><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed);</code></p></li><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed, float maxSpeed);</code></p></li><li><p>参数表</p></li></ul><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td><code>current</code></td><td>起点坐标</td></tr><tr><td><code>target</code></td><td>终点坐标</td></tr><tr><td><code>currentVelocity</code></td><td>当前帧移动向量</td></tr><tr><td><code>smoothTime</code></td><td>接近目标时的阻尼强度</td></tr><tr><td><code>maxSpeed</code></td><td>最大移动速度，默认值为无穷大</td></tr><tr><td><code>deltaTime</code></td><td>控制当前帧实际移动的距离，即为maxSpeed*deltaTime，默认值为Time.deltaTime。</td></tr></tbody></table><h2 id="3-2-实例方法"><a href="#3-2-实例方法" class="headerlink" title="3.2 实例方法"></a>3.2 实例方法</h2><p><code>Scale</code>方法：向量放缩</p><p><code>public void Scale(Vector3 scale);</code></p><p>此方法可以对Vector3实例按参考向量scale进行放缩，即分量依次相乘。</p><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h1><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code></td><td>向量相加</td></tr><tr><td><code>-</code></td><td>向量相减</td></tr><tr><td><code>*</code></td><td>向量乘以标量</td></tr><tr><td><code>/ </code></td><td>向量除以标量</td></tr><tr><td><code>==</code></td><td>若向量相等返回true</td></tr><tr><td><code>!=</code></td><td>若向量不等于则返回true</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vector2类</title>
    <link href="/2021/02/21/Vector2%E7%B1%BB/"/>
    <url>/2021/02/21/Vector2%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Vector2类在Unity中一般用于表示2D向量和二维坐标点。</p><p>例如<a href="https://docs.unity3d.com/530/Documentation/ScriptReference/Mesh.html">Mesh</a>（纹理坐标）或<a href="https://docs.unity3d.com/530/Documentation/ScriptReference/Material.html">Material</a>（纹理偏移）。</p><h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h1><h2 id="2-1-静态属性"><a href="#2-1-静态属性" class="headerlink" title="2.1 静态属性"></a>2.1 静态属性</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>down</code></td><td>Vector2（0，-1）的简写</td></tr><tr><td><code>left</code></td><td>Vector2（-1，0）的简写</td></tr><tr><td><code>one</code></td><td>Vector2（1，1）的简写</td></tr><tr><td><code>right</code></td><td>Vector2（1，0）的简写</td></tr><tr><td><code>up</code></td><td>Vector2（0，1）的简写</td></tr><tr><td><code>zero</code></td><td>Vector2（0，0）的简写</td></tr></tbody></table><h2 id="2-2-普通属性"><a href="#2-2-普通属性" class="headerlink" title="2.2 普通属性"></a>2.2 普通属性</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>magnitude</td><td>返回此向量的长度（只读）</td></tr><tr><td>normalized</td><td>返回此向量的归一化（只读）</td></tr><tr><td>sqrMagnitude</td><td>返回此向量的平方长度（只读）</td></tr><tr><td>this[int]</td><td>分别使用[0]或[1]访问x或y分量</td></tr><tr><td><code>x</code></td><td>向量的X分量</td></tr><tr><td><code>y</code></td><td>向量的Y分量</td></tr></tbody></table><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><h2 id="3-1-静态方法"><a href="#3-1-静态方法" class="headerlink" title="3.1 静态方法"></a>3.1 静态方法</h2><table><thead><tr><th>方法名称</th><th>描述</th><th>方法体</th></tr></thead><tbody><tr><td><code>Angle</code></td><td>返回两向量夹角，参数from为起始向量，to为结束向量。此方法用于返回两个Vector2实例的夹角，单位为角度，返回值的取值范围为[0,180]，并且当from和to中至少有一个向量为Vector2.zero的时候返回值为90</td><td><code>public static float Angle(Vector2 from, Vector2 to);</code></td></tr><tr><td><code>ClampMagnitude</code></td><td>此方法用于返回向量的长度，且最大不超过maxLength</td><td><code>public static Vector2 ClampMagnitude(Vector2 vector, float maxLength);</code></td></tr><tr><td><code>Distance</code></td><td>返回两个向量间的距离</td><td></td></tr><tr><td><code>Dot</code></td><td>返回两个向量的点积</td><td></td></tr><tr><td><code>Lerp</code></td><td>向量差值，参数from为插值的起始向量，参数to为插值的结束向量，参数t为插值系数</td><td><code>public static Vector2 Lerp(Vector from, Vector2 to, float t);</code></td></tr><tr><td><code>LerpUnclamped</code></td><td>返回向量在向量a和b之间线性插值t</td><td></td></tr><tr><td><code>Max</code></td><td>返回由两个向量的最大分量组成的向量</td><td></td></tr><tr><td><code>Min</code></td><td>返回由两个向量的最小分量构成的向量</td><td></td></tr><tr><td><code>MoveTowards</code></td><td>向量差值，参数current为移动起始点坐标，参数target为移动目标点，参数maxDistanceDelta为移动的参考系数。</td><td><code>public static Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta);</code></td></tr><tr><td><code>Reflect</code></td><td>返回从法线定义的向量上反射向量</td><td></td></tr><tr><td><code>Scale</code></td><td>向量放缩，此方法用于返回向量a按向量b进行放缩后的值，即向量a，b的乘积</td><td></td></tr><tr><td><code>SmoothDamp</code></td><td>无法理解</td><td></td></tr></tbody></table><blockquote><p><a href="https://blog.csdn.net/andyhebear/article/details/51818534">MoveTowards、Lerp、Slerp三个函数的解析</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/e5b06b7be721">差值函数Lerp和SmoothDamp的解析</a></p></blockquote><h2 id="3-2-公有方法"><a href="#3-2-公有方法" class="headerlink" title="3.2 公有方法"></a>3.2 公有方法</h2><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Normalize</code></td><td>单位化Vector2实例。此方法改变了原始向量，无返回值。实例属性normalized与此方法功能相同，但使用属性normalized来单位化向量时，不改变原始向量值，且有返回值。</td></tr><tr><td><code>Set</code></td><td>设置向量的x,y值</td></tr><tr><td><code>ToString</code></td><td>返回字符串</td></tr></tbody></table><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h1><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>-</code></td><td>向量相减</td></tr><tr><td><code>!=</code></td><td>向量不同，则返回true</td></tr><tr><td><code>*</code></td><td>向量乘以数字</td></tr><tr><td><code>/</code></td><td>向量除以数字</td></tr><tr><td><code>+</code></td><td>向量相加</td></tr><tr><td><code>=</code></td><td>向量相等，则返回true</td></tr><tr><td><code>Vector2</code></td><td>将Vector3转换为Vector2</td></tr><tr><td><code>Vector3</code></td><td>将Vector2转换为Vector3</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transform类</title>
    <link href="/2021/02/19/Transform%E7%B1%BB/"/>
    <url>/2021/02/19/Transform%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><strong>Transform</strong>组件是Unity3D的重点之一，主要用于控制物体的旋转、移动、缩放。</p><p><strong>Unity</strong>规定所有游戏物体都必须<strong>有且只有一个</strong>变换组件(<strong>Transform</strong>)且<strong>不能删除</strong>。</p><p>变换组件(<strong>Transform</strong>)实现了Unity的父子关系功能。</p><p>那么接下来我们将详细学习下<strong>Transform</strong>类所包含的成员变量和成员函数。</p><h1 id="2-父子关系"><a href="#2-父子关系" class="headerlink" title="2. 父子关系"></a>2. 父子关系</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>父子关系是Uniy中重要的基本概念之一。<br>当一个物体是另一个物体的父物体时，子物体会严格地随着父物体起移动、 旋转、缩放。<br>可以将父子关系理解为你的手臂与身体的关系，当身体移动时，手臂也定会跟着一 起移动， 且手臂还可以有自己下一级的子物体，比如手掌就是手名臂的子物体、手指是手掌的子物体等。</p><blockquote><p>在unity中带有local字样的属性也就意味着其数值是相对于父物体的。</p></blockquote><h2 id="2-2-底层原理与规则"><a href="#2-2-底层原理与规则" class="headerlink" title="2.2 底层原理与规则"></a>2.2 底层原理与规则</h2><p>规则：</p><ul><li>任何物体都可以有多个子物体，但是每个物体都只能有一个父物体。</li></ul><p>原理：</p><p>这种父子关系组成一个树状的层级结构，最基层的那个物体是唯一不具有父物体的物体，它被称为根节点。</p><p>由于物体的移动、旋转、缩放与父子关系密切相关，且游戏物体和变换组件是一一对应的。所以在Unity中，游戏物体的层级结构完全可以理解为变换组件的层级结构。父子关系的操作在脚本中确实是在变换组件上进行的。<br>子物体的变换组件的参数其实是相对父物体的值，再次考虑之前身体和手臂的例子，无论身体如何移动，手臂和身体的连接处是固定不变的。</p><h2 id="2-3-关于父子物体的一些现象"><a href="#2-3-关于父子物体的一些现象" class="headerlink" title="2.3 关于父子物体的一些现象"></a>2.3 关于父子物体的一些现象</h2><h3 id="2-3-1-position："><a href="#2-3-1-position：" class="headerlink" title="2.3.1 position："></a>2.3.1 position：</h3><ul><li><p>改变父物体的position，父物体连同子物体一起移动；</p></li><li><p>改变子物体的position，父物体不随子物体移动。</p></li><li><p>当子物体的position设置为（0，0，0）时，子物体与父物体中心点重合。</p></li></ul><h3 id="2-3-2-rotation："><a href="#2-3-2-rotation：" class="headerlink" title="2.3.2 rotation："></a>2.3.2 rotation：</h3><p>介绍两个位于unity快捷工具栏右侧的选项：<strong>Pivot</strong>与<strong>Local</strong></p><ul><li><p><strong>Poivt</strong></p><p>用于调节物体轴心点，有两个子选项</p><ul><li><p>Pivot    父物体的中心点</p></li><li><p>Center 当前父子物体的中心点</p></li></ul></li><li><p><strong>Local</strong><br>用于调节当前被选中物体的坐标轴，有两个子选项</p><ul><li><p>Local    自身坐标系</p></li><li><p>World  世界坐标系</p></li></ul></li></ul><h3 id="2-3-3-Scale"><a href="#2-3-3-Scale" class="headerlink" title="2.3.3 Scale:"></a>2.3.3 Scale:</h3><p><strong>子物体的真实缩放比例Scale=子物体Scale比例×父物体Scale比例</strong></p><p>可以通过下述代码在unity脚本中直接查看：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3 _truthScale = <span class="hljs-keyword">this</span>.transform.LossyScale;<span class="hljs-comment">//此属性为只读属性</span><br></code></pre></td></tr></table></figure><h2 id="2-4-坐标系的选择"><a href="#2-4-坐标系的选择" class="headerlink" title="2.4 坐标系的选择"></a>2.4 坐标系的选择</h2><p>局部坐标与世界坐标各有各的适用情况：</p><ul><li><p>在搭建场景时，我们更喜欢使用局部坐标系<br>比如移动一个房屋时，屋子里所有的东西都会跟着一起移动;</p></li><li><p>而在编写游戏逻辑时，更多的时候需要获得物体在空间中的实际位置。<br>比如我们要将摄像机对准人物的眼睛，这时候眼睛和人物的相对坐标就没有太大价值，而应当让摄像机对准眼睛在世界坐标系中的位置。</p></li></ul><p>所以，在脚本系统中，变换组件的大部分操作都提供了两类操作方式，分别是世界坐标系的和局部坐标系的，我们可以根据需求进行使用。</p><h2 id="2-5-关于父子物体使用的小技巧"><a href="#2-5-关于父子物体使用的小技巧" class="headerlink" title="2.5 关于父子物体使用的小技巧"></a>2.5 关于父子物体使用的小技巧</h2><p>在处理美工交过来的模型时，推荐将模型拉入一个空的gameobject，形成父子物体关系，组件只给空的gameobject上。</p><p>这样就可以防止日后更换模型时需要重新上组件的情况。</p><p>空物体通常用来管理和控制多个相互之间无关联的游戏物体。</p><h1 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3. 成员变量"></a>3. 成员变量</h1><table><thead><tr><th>position</th><th>在世界空间坐标transform的位置。</th></tr></thead><tbody><tr><td>localPosition</td><td>相对于父级的变换的位置。  如果该变换没有父级，那么等同于Transform.position。</td></tr><tr><td>eulerAngles</td><td>世界坐标系中的旋转（欧拉角）。</td></tr><tr><td>localEulerAngles</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>right</td><td>世界坐标系中的右方向。  （世界空间坐标变换的红色轴。也就是x轴。）</td></tr><tr><td>up</td><td>世界坐标系中的上方向。  （在世界空间坐标变换的绿色轴。也就是y轴。）</td></tr><tr><td>forward</td><td>世界坐标系中的前方向。  （在世界空间坐标变换的蓝色轴。也就是z轴。）</td></tr><tr><td>rotation</td><td>世界坐标系中的旋转（四元数）。</td></tr><tr><td>localRotation</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>localScale</td><td>相对于父级的缩放比例。</td></tr><tr><td>parent</td><td>父对象Transform组件。</td></tr><tr><td>worldToLocalMatrix</td><td>矩阵变换的点从世界坐标转为自身坐标（只读）。</td></tr><tr><td>localToWorldMatrix</td><td>矩阵变换的点从自身坐标转为世界坐标（只读）。</td></tr><tr><td>root</td><td>对象层级关系中的根对象的Transform组件。</td></tr><tr><td>childCount</td><td>子对象数量。</td></tr><tr><td>lossyScale</td><td>全局缩放比例（只读）。</td></tr></tbody></table><h1 id="4-成员函数"><a href="#4-成员函数" class="headerlink" title="4. 成员函数"></a>4. 成员函数</h1><h2 id="4-1-LookAt函数"><a href="#4-1-LookAt函数" class="headerlink" title="4.1 LookAt函数"></a>4.1 LookAt函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void LookAt(Transform target);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition, Vector3 worldUp = Vector3.up);</td></tr><tr><td>public void  LookAt(Transform target, Vector3 worldUp = Vector3.up);</td></tr></tbody></table><p>旋转物体，使物体的z轴指向<strong>target/worldPosition</strong>，对于<strong>worldUp</strong>的描述是，在完成上面的旋转之后，继续旋转自身，使得当前对象的正y轴朝向与worldUp所指向的朝向一致。</p><p>这里的朝向一致指的是新旋转后的y轴与<strong>worldUp</strong>在该对象初次旋转后的xy平面上的投影向量一致。之所以取投影是因为第一次旋转使物体的z轴指向<strong>target/worldPosition</strong>后，此时的<strong>worldUp</strong>向量可能不在xy平面上，要在z轴指向<strong>target/worldPosition</strong>前提下是y轴朝向与<strong>worldUp</strong>一致，只能取<strong>worldUp</strong>在xy平面上的投影。</p><blockquote><p>注意：使用<strong>worldPosition向量</strong>时要注意方向，一定是<strong>target-transform.position</strong>，顺序反了会使物体背向目标；若使用<strong>Transform</strong>作为参数，则不必注意。默认情况下，<strong>worldUp</strong>是<strong>Vector3.up</strong>（世界坐标系下的y轴）</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-2-Rotate函数"><a href="#4-2-Rotate函数" class="headerlink" title="4.2 Rotate函数"></a>4.2 Rotate函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 eulerAngles);</td></tr><tr><td>public void  Rotate(Vector3 eulerAngles, Space relativeTo = Space.Self);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo =  Space.Self);</td></tr></tbody></table><p>旋转一个欧拉角度，它按照zxy的顺序进行旋转，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 axis, float angle);</td></tr><tr><td>public void  Rotate(Vector3 axis, float angle,Space relativeTo = Space.Self);</td></tr></tbody></table><p>绕axis轴旋转angle角度，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><p><strong>transform.rotation</strong>和<strong>Rotate</strong>有个区别：</p><ul><li><p>Rotate()方法是： 旋转多少度。</p><p>在原有的基础上累加，即旋转了多少角度。  又旋转了多少角度，是在原有的基础上在旋转</p></li><li><p>rotation属性是：  旋转到某个角度，就是是在update中每帧都执行。 </p><p> 但每次旋转到的角度都是5，所以是旋转到5度。一直都是。 </p></li></ul><p>比如你只想让他旋转到多少, 用rotation; 假如想让他一直转,可以用Rotate</p><p>rotation直接改变了数值, 以达到旋转效果</p><p>Rotate应用一个的旋转角度每秒1度慢慢的旋转物体</p><p>当然:rotation()还可以通过插值旋转</p><h2 id="4-3-RotateAround函数"><a href="#4-3-RotateAround函数" class="headerlink" title="4.3 RotateAround函数"></a>4.3 RotateAround函数</h2><p>让物体以某一点为轴心成圆周运动。</p><p><code>public void RotateAround (point : Vector3, axis : Vector3, angle : float) : void</code></p><p>让物体以<strong>point</strong>为中心，绕<strong>axis</strong>为轴向旋转<strong>angle</strong>度。保持原来与<strong>point</strong>的距离。</p><h2 id="4-4-TransformDirection函数"><a href="#4-4-TransformDirection函数" class="headerlink" title="4.4 TransformDirection函数"></a>4.4 TransformDirection函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public Vector3  TransformDirection(Vector3 direction);</td></tr><tr><td>public Vector3  TransformDirection(float x, float y, float z);</td></tr></tbody></table><p>从自身坐标到世界坐标变换方向（这个强调的是方向）这个操作不会受到变换的缩放和位置的影响。</p><p>返回的向量与<strong>direction</strong>有同样的长度。</p><h2 id="4-5-InverseTransformDirection函数"><a href="#4-5-InverseTransformDirection函数" class="headerlink" title="4.5 InverseTransformDirection函数"></a>4.5 InverseTransformDirection函数</h2><table><thead><tr><th>重载的多种函数</th></tr></thead><tbody><tr><td>public Vector3  InverseTransformDirectionTransformDirection (direction : Vector3)  : Vector3</td></tr><tr><td>public Vector3  InverseTransformDirectionTransformDirection (x : float, y : float,  z : float) : Vector3</td></tr></tbody></table><p>与<strong>TransformDirection</strong>相反，从世界坐标转换到自身相对坐标。</p><h2 id="4-6-TransformPoint函数"><a href="#4-6-TransformPoint函数" class="headerlink" title="4.6 TransformPoint函数"></a>4.6 TransformPoint函数</h2><table><thead><tr><th>public Vector3  TransformPoint(Vector3 position);</th></tr></thead><tbody><tr><td>public Vector3  TransformPoint(float x, float y, float z);</td></tr></tbody></table><p>变换位置从自身坐标到世界坐标。</p><p>注意，返回位置受缩放影响</p><h2 id="4-7-InverseTransformPoint函数"><a href="#4-7-InverseTransformPoint函数" class="headerlink" title="4.7 InverseTransformPoint函数"></a>4.7 InverseTransformPoint函数</h2><table><thead><tr><th>public  Vector3 InverseTransformPoint (position : Vector3)  : Vector3</th></tr></thead><tbody><tr><td>public  Vector3 InverseTransformPoint (x : float, y : float, z  : float) : Vector3</td></tr></tbody></table><p>把一个点从时间坐标转换到自身坐标的位置。</p><h2 id="4-8-TransformVector函数"><a href="#4-8-TransformVector函数" class="headerlink" title="4.8 TransformVector函数"></a>4.8 TransformVector函数</h2><table><thead><tr><th>public Vector3  TransformVector(Vector3 vector);</th></tr></thead><tbody><tr><td>public Vector3  TransformVector(float x, float y, float z);</td></tr></tbody></table><p>变换一个向量从局部坐标空间到世界坐标空间。</p><p>这个操作不受变换位置的影响，但是受缩放的影响</p><h2 id="4-9-Translate函数"><a href="#4-9-Translate函数" class="headerlink" title="4.9 Translate函数"></a>4.9 Translate函数</h2><table><thead><tr><th>public void  Translate(Vector3 translation);</th></tr></thead><tbody><tr><td>public void  Translate(Vector3 translation, Space relativeTo = Space.Self);</td></tr></tbody></table><p>沿着<strong>translation</strong>方向移动<strong>translation</strong>向量长度的距离。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(float x, float y, float z);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Space relativeTo = Space.Self);</td></tr></tbody></table><p>移动变换由x沿着x轴，y沿着y轴，z沿着z轴。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(Vector3 translation, Transform relativeTo);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Transform relativeTo);</td></tr></tbody></table><p>第一个参数的解释跟前面的一样，重点在移动<strong>relativeTo</strong>，解释为被应用相对于（relativeTo :Transform）的自身坐标系统。</p><p>日光相对于为<strong>null</strong>，则移动被应用相对于世界坐标系统</p><p>例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//相对于摄像机每秒1单位向右移动物体</span><br><br>transform.Translate(Vector3.right * Time.deltaTime, Camera.main.transform);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-10-DetachChildren函数"><a href="#4-10-DetachChildren函数" class="headerlink" title="4.10 DetachChildren函数"></a>4.10 DetachChildren函数</h2><p><code>public void DetachChildren () : void</code></p><p>把自身所有的子物体的父物体都设成世界，也就是跟自己的所有子物体接触父子关系。</p><h2 id="4-11-Find-函数"><a href="#4-11-Find-函数" class="headerlink" title="4.11 Find 函数"></a>4.11 <strong>Find</strong> <strong>函数</strong></h2><p><code>public Transform Find (name : string) : Transform</code></p><p>找到一个名字是name的物体并返回</p><p>如果没有找到则返回null。如果字符串被/隔离，函数则会像文件路径一样逐级下查。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// The magical rotating finger</span><br><br><span class="hljs-function">function <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>aFinger = transform.Find(<span class="hljs-string">&quot;LeftShoulder/Arm/Hand/Finger&quot;</span>);<br><br>aFinger.Rotate(Time.deltaTime*<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-12-IsChildOf函数"><a href="#4-12-IsChildOf函数" class="headerlink" title="4.12 IsChildOf函数"></a>4.12 IsChildOf函数</h2><p><code>public bool IsChildOf (parent : Transform) : bool</code></p><p>如果物体是<strong>parent</strong>的父子层级关系下的一员，返回<strong>true</strong>;</p><h1 id="5-组件使用注意事项"><a href="#5-组件使用注意事项" class="headerlink" title="5. 组件使用注意事项"></a>5. 组件使用注意事项</h1><h2 id="5-1-非等比缩放的问题"><a href="#5-1-非等比缩放的问题" class="headerlink" title="5.1 非等比缩放的问题"></a>5.1 非等比缩放的问题</h2><p>某些组件不完全支持非等比缩放，在非等比缩放的情况下可能会出现意想不到的结果。<br>因为当该游戏物体具有一个球体或者胶囊体的外壳，而这些外壳的大小是通过一个半径参数指定的。<br>在物体或者父物体被拉伸或压扁的时候，这些组件的球体范围并不会跟着压扁成椭球体，它们实际上仍然是球体或胶囊体。<br>所以当物体中具有这类组件时，由于组件形状和物体形状不一致，可能会导致穿透模型被意外阻挡等情况发生。</p><p>例如，碰撞体、角色控制器这些组件和灯光、音源。</p><p>这些问题不致命，但是会引起奇怪的bug。</p><h2 id="5-2-其它注意事项"><a href="#5-2-其它注意事项" class="headerlink" title="5.2 其它注意事项"></a>5.2 其它注意事项</h2><ul><li>当为一个物体添加子物体时， 可以考虑先将父物体的位置设置为原点，这样子物体的局部坐标系就和世界坐标系重合，方便我们指定子物体的准确位置。</li><li>粒子系统不会受变换组件的缩放系数的影响。要改变- -个粒子的整体比例，还是需要在粒子系统中适当改变相关参数。</li><li>修改物体缩放比例时不仅会直接影响子物体的比例，还会影响子物体的实际位置(因为要保证相对位置不变)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MonoBehaviour基类</title>
    <link href="/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/"/>
    <url>/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-脚本基类-MonoBehaviour"><a href="#Unity-脚本基类-MonoBehaviour" class="headerlink" title="Unity 脚本基类 MonoBehaviour"></a>Unity 脚本基类 MonoBehaviour</h1><h2 id="1-MonoBehaviour-简介"><a href="#1-MonoBehaviour-简介" class="headerlink" title="1. MonoBehaviour 简介"></a>1. MonoBehaviour 简介</h2><p><strong>MonoBehaviour</strong> 是 <strong>Unity</strong> 中所有脚本的基类。</p><p>如果你使用<strong>JS</strong>的话，脚本会自动继承<strong>MonoBehaviour</strong>。</p><p>如果使用<strong>C#**的话，你需要显式继承</strong>MonoBehaviour**。</p><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><p>下面用一张图来更形象地说明一下这几个类的在<strong>MonoBehaviour</strong>的<em>生命周期</em>中是如何被调用的：<br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125028717" srcset="/img/loading.gif" alt="这里写图片描述"></p><h2 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h2><h3 id="3-1-不可重写函数："><a href="#3-1-不可重写函数：" class="headerlink" title="3.1 不可重写函数："></a>3.1 不可重写函数：</h3><h4 id="3-1-1-Invoke函数"><a href="#3-1-1-Invoke函数" class="headerlink" title="3.1.1 Invoke函数"></a>3.1.1 Invoke函数</h4><p><code>function Invoke (methodName : string, time : float) : void</code><br>在 <strong>time</strong> 秒之后，调用 <strong>methodName</strong> 方法；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">example</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><span class="hljs-keyword">public</span> Rigidbody projectile;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchProjectile</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Rigidbody instance = Instantiate(projectile);<br>    instance.velocity = Random.insideUnitSphere * <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Invoke(<span class="hljs-string">&quot;LaunchProjectile&quot;</span>, <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-InvokeRepeating"><a href="#3-1-2-InvokeRepeating" class="headerlink" title="3.1.2 InvokeRepeating"></a>3.1.2 InvokeRepeating</h4><p><code>function InvokeRepeating (methodName : string, time : float, repeatRate : float) : void</code><br>从第一次调用开始,每隔<strong>repeatRate</strong>时间调用一次.</p><h4 id="3-1-3-CancelInvoke"><a href="#3-1-3-CancelInvoke" class="headerlink" title="3.1.3 CancelInvoke"></a>3.1.3 CancelInvoke</h4><p><code>function CancelInvoke () : void</code><br>取消这个<strong>MonoBehaviour</strong>上的所有调用<strong>Invoke</strong>。</p><h4 id="3-1-4-IsInvoking"><a href="#3-1-4-IsInvoking" class="headerlink" title="3.1.4 IsInvoking"></a>3.1.4 IsInvoking</h4><p><code>function IsInvoking (methodName : string) : bool</code><br>某指定函数是否在等候调用。</p><h4 id="3-1-5-StartCoroutine"><a href="#3-1-5-StartCoroutine" class="headerlink" title="3.1.5 StartCoroutine"></a>3.1.5 StartCoroutine</h4><p><code>function StartCoroutine (routine : IEnumerator) : Coroutine</code><br>一个协同程序在执行过程中,可以在任意位置使用 <strong>yield</strong> 语句。</p><p><strong>yield</strong> 的返回值控制何时恢复协同程序向下执行。</p><p>协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。</p><p><strong>StartCoroutine</strong>函数是立刻返回的,但是<strong>yield</strong>可以延迟结果。直到协同程序执行完毕。</p><h4 id="3-1-6-StopCoroutine-StopAllCoroutines"><a href="#3-1-6-StopCoroutine-StopAllCoroutines" class="headerlink" title="3.1.6 StopCoroutine / StopAllCoroutines"></a>3.1.6 StopCoroutine / StopAllCoroutines</h4><h3 id="3-2-可重写函数："><a href="#3-2-可重写函数：" class="headerlink" title="3.2 可重写函数："></a>3.2 可重写函数：</h3><p>可重写函数会在游戏中发生某些事件的时候被调用。</p><p>我们在<strong>Unity</strong>中最常用到的几个可重写函数是这几个：</p><table><thead><tr><th align="left">可重写函数</th><th>描述</th></tr></thead><tbody><tr><td align="left"><code>Awake</code></td><td>当一个脚本被实例化时，<strong>Awake</strong> 被调用。我们大多在这个类中完成成员变量的初始化。</td></tr><tr><td align="left"><code>Start</code></td><td>仅在 <strong>Update</strong> 函数第一次被调用前调用。因为它是在<strong>Awake</strong> 之后被调用的，我们可以把一些需要依赖 <strong>Awake</strong> 的变量放在<strong>Start</strong>里面初始化。 同时我们还大多在这个类中执行 <strong>StartCoroutine</strong> 进行一些协程的触发。要注意在用C#写脚本时，必须使用 <strong>StartCoroutine</strong> 开始一个协程，但是如果使用的是 <strong>JavaScript</strong>，则不需要这么做。</td></tr><tr><td align="left"><code>Update</code></td><td>当开始播放游戏帧时（此时，<strong>GameObject</strong> 已实例化完毕），其 **Update **在 每一帧 被调用。</td></tr><tr><td align="left"><code>LateUpdate</code></td><td><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。</td></tr><tr><td align="left"><code>FixedUpdate</code></td><td>当 <strong>MonoBehaviour</strong>启用时，其 <strong>FixedUpdate</strong> 在每一固定帧被调用</td></tr><tr><td align="left"><code>OnEnable</code></td><td>当对象变为可用或激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDisable</code></td><td>当对象变为不可用或非激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDestroy</code></td><td>当 <strong>MonoBehaviour</strong> 将被销毁时，这个函数被调用</td></tr></tbody></table><h4 id="3-2-1-Update"><a href="#3-2-1-Update" class="headerlink" title="3.2.1 Update"></a>3.2.1 Update</h4><p>当 <strong>MonoBehaviour</strong> 实例化完成之后，<strong>Update</strong> 在每一帧被调用。</p><p>所以Update函数可以用来实现用户输入、角色移动和角色行动等功能。</p><p>基本上大部分游戏逻辑都离不开Update函数。</p><p>Unity 提供了非常多的基本方法来读取输入、查找某个游戏物体、查找组件、修改组件信息等，这些方法都可以在Update函数中使用，用来完成实际的游戏功能。</p><h4 id="3-2-2-LateUpdate"><a href="#3-2-2-LateUpdate" class="headerlink" title="3.2.2 LateUpdate"></a>3.2.2 LateUpdate</h4><p><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。这可用于调整脚本执行顺序。</p><p>例如:当物体在Update里移动时，跟随物体的相机可以在<strong>LateUpdate</strong>里实现。</p><h4 id="3-2-3-FixedUpdate"><a href="#3-2-3-FixedUpdate" class="headerlink" title="3.2.3 FixedUpdate"></a>3.2.3 FixedUpdate</h4><p>处理 <strong>Rigidbody</strong> 时，需要用<strong>FixedUpdate</strong>代替<strong>Update</strong>。</p><p>例如:给刚体加一个作用力时，你必须应用作用力在<strong>FixedUpdate</strong>里的固定帧，而不是<strong>Update</strong>中的帧。(两者帧长不同)</p><h4 id="3-2-4-Awake"><a href="#3-2-4-Awake" class="headerlink" title="3.2.4 Awake"></a>3.2.4 Awake</h4><p><strong>Awake</strong> 用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次。<strong>Awake</strong> 在所有对象被初始化之后调用，所以你可以安全的与其他对象对话或用诸如 <strong>GameObject.FindWithTag</strong> 这样的函数搜索它们。</p><p>每个游戏物体上的<strong>Awke</strong>以随机的顺序被调用。因此，你应该用<strong>Awake</strong>来设置脚本间的引用，并用<strong>Start</strong>来传递信息<strong>Awake</strong>总是在<strong>Start</strong>之前被调用。它不能用来执行协同程序。</p><p>C#和Boo用户注意：<strong>Awake</strong> 不同于构造函数，物体被构造时并没有定义组件的序列化状态。<strong>Awake</strong>像构造函数一样只被调用一次。</p><h4 id="3-2-5-Start"><a href="#3-2-5-Start" class="headerlink" title="3.2.5 Start"></a>3.2.5 Start</h4><p><strong>Start</strong>在<strong>behaviour</strong>的生命周期中只被调用一次。<br>它和 <strong>Awake</strong> 的不同是，<strong>Start</strong> 只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。<strong>Awake</strong> 总是在<strong>Start</strong>之前执行。</p><p>Start函数适合用来做一些初始化工作。<br>对有经验的程序编写者来说，要注意脚本组件通常不使用构造函数来做初始化，因为构造函数可控制性较差，会导致调用时机和预想的不一致。 所以最好的方式是遵循Unity的设计惯例。</p><h4 id="3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag"><a href="#3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag" class="headerlink" title="3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag"></a>3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag</h4><p>当鼠标进入 ／ 悬浮 ／ 移出 ／ 点击 ／ 释放 ／ 拖拽<strong>GUIElement</strong>(GUI元素)或<strong>Collider</strong>(碰撞体)中时调用<strong>OnMouseEnter</strong>。</p><h4 id="3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay"><a href="#3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay" class="headerlink" title="3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay"></a>3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay</h4><p>当<strong>Collider</strong>(碰撞体)进入 ／ 退出 ／ 停留在 <strong>trigger</strong>(触发器)时调用<strong>OnTriggerEnter</strong>。</p><p><strong>OnTriggerStay</strong> 将会在每一帧被调用。</p><h4 id="3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay"><a href="#3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay" class="headerlink" title="3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay"></a>3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay</h4><p>当此<strong>collider/rigidbody</strong>触发另一个<strong>rigidbody/collider</strong>时，被调用。</p><p><strong>OnCollisionStay</strong> 将会在每一帧被调用。</p><h2 id="4-脚本与GameObject的关系"><a href="#4-脚本与GameObject的关系" class="headerlink" title="4. 脚本与GameObject的关系"></a>4. 脚本与GameObject的关系</h2><p>被显式添加到 <strong>Hierarchy</strong> 中的 <strong>GameObject</strong> 会被最先实例化，<strong>GameObject</strong> 被实例化的顺序是从下往上。<strong>GameObject</strong> 被实例化的同时，加载其组件 <strong>component</strong> 并实例化，如果挂载了脚本组件，则实例化脚本组件时，将调用脚本的 <strong>Awake</strong> 方法，组件的实例化顺序是也是从下往上。在所有显式的 <strong>GameObject</strong> 及其组件被实例化完成之前，游戏不会开始播放帧。</p><p>当 <strong>GameObject</strong> 实例化工作完成之后，将开始播放游戏帧。每个脚本的第一帧都是调用 <strong>Start</strong> 方法，其后每一帧调用 <strong>Update</strong>，而且每个脚本在每一帧中的调用顺序是从下往上。</p><blockquote><p>总结：被挂载到 <strong>GameObject</strong> 下面的脚本会被实例化成 <strong>GameObject</strong> 的一个成员。</p></blockquote><h3 id="4-1-脚本变量的引用"><a href="#4-1-脚本变量的引用" class="headerlink" title="4.1 脚本变量的引用"></a>4.1 脚本变量的引用</h3><p>在脚本中声明另一个脚本的变量。在 <strong>ClassA</strong> 中建立一个 <strong>public</strong> 的变量类型是 <strong>ClassB</strong>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-非同一个-GameObject-的脚本引用"><a href="#4-1-1-非同一个-GameObject-的脚本引用" class="headerlink" title="4.1.1 非同一个 GameObject 的脚本引用"></a>4.1.1 非同一个 GameObject 的脚本引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125148891" srcset="/img/loading.gif" alt="这里写图片描述"><br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125157563" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，如果 <strong>classA</strong> 中的成员 <strong>B</strong> 想要引用由 <strong>GameObjectB</strong> new 出来的 <strong>classB</strong> 对象，只需要将 <strong>GameObjectB</strong> 拖拽到 <strong>GameObjectA</strong> 中 <strong>classA</strong> 脚本即可。</p><h4 id="4-1-2-同一个-GameObject-中互相引用"><a href="#4-1-2-同一个-GameObject-中互相引用" class="headerlink" title="4.1.2 同一个 GameObject 中互相引用"></a>4.1.2 同一个 GameObject 中互相引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125328273" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，发现没法通过拖拽的方式建立 <strong>classA</strong> 和 <strong>classB</strong> 的引用。因为 <strong>Unity</strong> 编辑器里面的拖拽绑定方式是 <strong>GameObject</strong> 级别的。</p><p>那么此时如何解决互相引用的问题呢？此时，需要用到 <strong>gameObject</strong> 这个变量。</p><p>被挂载到 <strong>GameObject</strong> 中的脚本，被实例化时，其内部继承自 <strong>Monobehavior</strong> 的 <strong>gameObject</strong> 成员会绑定所挂载的 <strong>GameObject</strong> 对象。可以注意到，在本例中，<strong>classA</strong> 和 <strong>classB</strong> 都是同一个 <strong>GameObject</strong> 下的组件，所以通过 <strong>GetComponent</strong> 便可以获得另一个脚本变量的引用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>        b = gameObject.GetComponent (<span class="hljs-string">&quot;ClassB&quot;</span>) <span class="hljs-keyword">as</span> ClassB;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>       a = gameObject.GetComponent (<span class="hljs-string">&quot;ClassA&quot;</span>) <span class="hljs-keyword">as</span> ClassA;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-父子关系的-GameObject-中引用"><a href="#4-1-3-父子关系的-GameObject-中引用" class="headerlink" title="4.1.3 父子关系的 GameObject 中引用"></a>4.1.3 父子关系的 GameObject 中引用</h4><p>把问题引申一步,还是那两个脚本<strong>ClassA</strong>,<strong>ClassB</strong>,不过这回不是绑在同一个<strong>GameObject</strong>上面，而是分辨绑定在两个<strong>GameObject</strong>：Parent(ClassA),Child(ClassB)</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125418710" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>首先还是来尝试拖拽，虽然无法在Unity的编辑器中通过拖拽互相引用脚本(Componet),不过绑定 <strong>GameObject</strong> 是可以的。所以只需要建立两个<strong>public</strong>的变量，然后类型都是 <strong>GameObject</strong>，在Unity里面互相拖拽引用,最后在 <strong>Start</strong> 函数时候通过已经绑定好的 <strong>gameObject</strong> 调用其 <strong>GetComponent</strong> 方法即可。</p><p>的确，这个方法是可行，不过有个更好的方法就是使用 <strong>Transform</strong>。<strong>Transform</strong> 是一个很特殊的<strong>Component</strong>，其内部保留着 <strong>GameObject</strong>之间的显示树结构.所以就上面的例子来说，当要从 <strong>Child</strong> 访问到 <strong>Parent</strong>，只需要在 <strong>Child</strong> 对应的脚本里面写 <code>transform.parent.gameObject.GetComponent() </code>即可</p><p>返过来就相对麻烦一点,因为无法保证一个<strong>parent</strong>只有一个<strong>child</strong>，所以无法简单的使用 <strong>transform.child.gameObject</strong>这样访问, 但是Unity给我们提供了一个很方便的函数，那就是<strong>Find</strong>。</p><p>需要注意的是<strong>Find</strong>只能查找其<strong>Child</strong>,举个复杂点的例子</p><p><strong>Parent-&gt;ChildA-&gt;ChildB-&gt;ChildC</strong></p><p>当在 <strong>Patent</strong> 中想要找到 <strong>ChildC</strong>中的一个<strong>Component</strong>时候，调用 <code>transform.Find(“ChildA/ChildB/ChildC”).gameObject;</code></p><h2 id="5-普通类与继承MonoBehaviour类的区别："><a href="#5-普通类与继承MonoBehaviour类的区别：" class="headerlink" title="5. 普通类与继承MonoBehaviour类的区别："></a>5. 普通类与继承MonoBehaviour类的区别：</h2><ul><li><p>1.继承<strong>MonoBehaviour</strong>的类不需要创建它的实例，也不能自己创建(用new)，因为从<strong>MonoBehaviour</strong>继承过来的类Unity会自动创建实例，并且调用被重载的函数(Awake，Start…..)。</p><p>如果用new会出现警告，警告说的很明显，就是如果继承了MonoBehaviour就不允许你用new创建，你可以用添加组件的方式替代，或者根本没有基类(不继承MonoBehaviour的普通类)，但是好像并不影响程序，这点很奇怪。</p></li><li><p>2.不继承MonoBehaviour不能使用Invoke，Coroutine，print以及生命周期函数等。</p></li><li><p>3.不继承MonoBehaviour不能挂在到Inspector上，也就是说不能当组件使用也不能看到一些数据。</p></li></ul><h2 id="6-MonoBehaviour-的那些坑"><a href="#6-MonoBehaviour-的那些坑" class="headerlink" title="6. MonoBehaviour 的那些坑"></a>6. MonoBehaviour 的那些坑</h2><ul><li><strong>私有（private）</strong>和<strong>保护（protected）</strong>变量只能在<strong>专家模式</strong>中显示。属性不被序列化或显示在检视面板。</li><li>不要使用<strong>命名空间（namespace）</strong></li><li>记得使用 缓存组件查找， 即在<strong>MonoBehaviour</strong>的长远方法中经常被访问的组件最好在把它当作一个私有成员变量存储起来。</li><li>在游戏里经常出现需要检测敌人和我方距离的问题，这时如果要寻找所有的敌人，显然要消耗的运算量太大了，所以最好的办法是将攻击范围使用<strong>Collider</strong>表示，然后将<strong>Collider</strong>的<strong>isTrigger</strong>设置为<strong>True</strong>。最后使用<strong>OnTriggerEnter</strong>来做攻击范围内的距离检测，这样会极大提升程序性能。</li></ul><blockquote><p>整理自: <a href="https://blog.csdn.net/hihozoo/article/details/66970467">https://blog.csdn.net/hihozoo/article/details/66970467</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客中添加音乐播放器</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是介绍基于网易云iframe插件在hexo博客中加装音乐播放器的方法，无需安装任何额外插件。</p><h1 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2.安装步骤"></a>2.安装步骤</h1><ol><li><p>在网易云音乐中打开你想要插入的音乐页面，点击 <strong>生成外联播放器</strong>。</p></li><li><p>在网页中调整好播放器插件后，复制下方的HTML代码。</p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">330</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=1488285208&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>打开本地架设hexo博客的文件夹，寻找正在使用主题文件夹下的layout文件夹。</p><p>例如我在使用的fluid主题的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">F:\MyBlog\node_modules\hexo-theme-fluid\layout<br></code></pre></td></tr></table></figure></li><li><p>在layout文件夹下寻找你想要添加音乐播放器位置的ejs文件。</p><p>例如我想放在所有页面的页脚，则ejs文件的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\layout\_partial\footer.ejs<br></code></pre></td></tr></table></figure></li><li><p>打开ejs文件(可以用vscode或者记事本)，找到生成相关位置html文件的代码。</p><p>这些ejs文件相当于是生成html文件的模板。</p></li><li><p>将复制来的HTML代码加上div加进相关的位置</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center mt-5 py-3&quot;</span>&gt;</span>//原本的页脚生成代码<br>--------------------------------------------------------<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;music-player&quot;</span>&gt;</span>//复制来的外链播放器插件代码<br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">530</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=572328440&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;&gt;</span><br>---------------------------------------------------------<br>  //原本的页脚生成代码<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer-content&quot;</span>&gt;</span><br>  &lt;%- theme.footer.content %&gt;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> &lt;%- partial(&#x27;_partial/statistics.ejs&#x27;) %&gt;<br> &lt;%- partial(&#x27;_partial/beian.ejs&#x27;) %&gt;<br> &lt;% if(theme.web_analytics.cnzz) &#123; %&gt;<br>  *<span class="hljs-comment">&lt;!-- cnzz Analytics Icon --&gt;</span>*<br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cnzz_stat_icon_&lt;%- theme.web_analytics.cnzz %&gt;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> &lt;% &#125; %&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>清理服务器缓存后再重新部署，音乐播放器就出现在对应位置了！</p></li></ol><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h1><blockquote><p>音乐不能是网易云里的VIP音乐，它是不会给你播的</p></blockquote><blockquote><p>当页面转换或者刷新时，播放器状态将被重置，目前还没有办法解决</p></blockquote><h1 id="4-其它的实现方法"><a href="#4-其它的实现方法" class="headerlink" title="4.其它的实现方法"></a>4.其它的实现方法</h1><p>在hexo框架的基础下，还可以用音乐播放插件<strong>Aplayer</strong>来实现。</p><p>相关链接：<a href="https://aplayer.js.org/#/zh-Hans/"><strong>Aplayer</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown快速入门</title>
    <link href="/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>.md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言。</p><p>本博客中的所有文章都是用.md文件编写的，而且很多企业也在在鼓励使用这种编辑方式。</p><h1 id="1-基本符号：-gt"><a href="#1-基本符号：-gt" class="headerlink" title="1.基本符号：* - +. &gt;"></a>1.基本符号：* - +. &gt;</h1><p>基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。</p><h1 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h1><p>分别表示h1-h6,只到h6，而且h1下面会有一条横线。</p><p>有两种方法，一种是只在前面加#，另一种是闭合式标签，两者效果相同。</p><p>例如：</p><p>方法一：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 </span><br><span class="hljs-section">## 二级标题 </span><br><span class="hljs-section">### 三级标题 </span><br><span class="hljs-section">#### 四级标题 </span><br><span class="hljs-section">##### 五级标题 </span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 # </span><br><span class="hljs-section">## 二级标题 ## </span><br><span class="hljs-section">### 三级标题 ### </span><br><span class="hljs-section">#### 四级标题 #### </span><br><span class="hljs-section">##### 五级标题 ##### </span><br><span class="hljs-section">###### 六级标题 #####</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h1><h2 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//形式一 <br><span class="hljs-bullet">+</span> a <br><span class="hljs-bullet">+</span> b <br><span class="hljs-bullet">+</span> c <br>//形式二<br><span class="hljs-bullet">-</span> d <br><span class="hljs-bullet">-</span> e <br><span class="hljs-bullet">-</span> f <br>//形式三 <br><span class="hljs-bullet">*</span> g <br><span class="hljs-bullet">*</span> h <br><span class="hljs-bullet">*</span> i<br></code></pre></td></tr></table></figure><p>以上三种形式，效果其实都是一样的：</p><ul><li>a </li><li>b </li><li>c </li></ul><ul><li>d </li><li>e </li><li>f </li></ul><ul><li>g </li><li>h </li><li>i</li></ul><h2 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//正常形式<br><span class="hljs-bullet">1.</span> abc<br><span class="hljs-bullet">2.</span> bcd<br><span class="hljs-bullet">3.</span> cde<br>//错序效果<br><span class="hljs-bullet">2.</span> fgh<br><span class="hljs-bullet">3.</span> ghi<br><span class="hljs-bullet">5.</span> hij<br></code></pre></td></tr></table></figure><p>效果如下：</p><ol><li><p>abc</p></li><li><p>bcd</p></li><li><p>cde</p></li><li><p>fgh</p></li><li><p>ghi</p></li><li><p>hij</p></li></ol><blockquote><p>注意，数字后面的点只能是英文的点，有序列表的序号是根据第一行列表的数字顺序来的，错序列表的序号本来是序号是乱的， 但是还是显示 4 5 6</p></blockquote><h1 id="4-引用说明区块"><a href="#4-引用说明区块" class="headerlink" title="4.引用说明区块"></a>4.引用说明区块</h1><p>对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。</p><h2 id="4-1-正常形式"><a href="#4-1-正常形式" class="headerlink" title="4.1 正常形式"></a>4.1 正常形式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 引用内容、说明内容。</span><br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>引用内容、说明内容。<br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</p></blockquote><h2 id="4-2-嵌套区块"><a href="#4-2-嵌套区块" class="headerlink" title="4.2 嵌套区块"></a>4.2 嵌套区块</h2><p>这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 一级引用 </span><br>&gt;&gt; 二级引用 <br>&gt;&gt;&gt; 三级引用 <br>&gt;&gt;&gt;&gt; 四级引用 <br>&gt;&gt;&gt;&gt;&gt; 五级引用 <br>&gt;&gt;&gt;&gt;&gt;&gt; 六级引用<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>一级引用 </p><blockquote><p>二级引用 </p><blockquote><p>三级引用 </p><blockquote><p>四级引用 </p><blockquote><p>五级引用 </p><blockquote><p>六级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5. 代码块"></a>5. 代码块</h1><p>在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。</p><h2 id="5-1-少量代码，单行使用，直接用-包裹起来就行了"><a href="#5-1-少量代码，单行使用，直接用-包裹起来就行了" class="headerlink" title="5.1 少量代码，单行使用，直接用`包裹起来就行了"></a>5.1 少量代码，单行使用，直接用`包裹起来就行了</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`shaoliangdaima,danhangshiyong`</span> <br></code></pre></td></tr></table></figure><p>效果如下：</p><p><code>shaoliangdaima,danhangshiyong</code></p><h2 id="5-2大量代码，需要多行使用，用-包裹起来"><a href="#5-2大量代码，需要多行使用，用-包裹起来" class="headerlink" title="5.2大量代码，需要多行使用，用```包裹起来"></a>5.2大量代码，需要多行使用，用```包裹起来</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">​<span class="hljs-code">```</span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong    </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong   </span><br><span class="hljs-code">​```</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong    <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong   <br></code></pre></td></tr></table></figure><h1 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h1><h2 id="6-1行内式"><a href="#6-1行内式" class="headerlink" title="6.1行内式"></a>6.1行内式</h2><p>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">烤麸的博客</span>](<span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot;</span>), 是烤麸自己学习用的博客<br></code></pre></td></tr></table></figure><h2 id="6-2参数式"><a href="#6-2参数式" class="headerlink" title="6.2参数式"></a>6.2参数式</h2><p>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot; </span><br>[烤麸的博客]是烤麸自己学习用的博客。 <br>//参数定义的其他写法 <br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ &#x27;烤麸的博客&#x27; </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ (烤麸的博客) </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">&lt;https://mycroftcooper.github.io/&gt; &quot;烤麸的博客&quot;</span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果都是一样的，如下：</p><p><a href="https://mycroftcooper.github.io/%22%E7%83%A4%E9%BA%B8%E7%9A%84%E5%8D%9A%E5%AE%A2%22">烤麸的博客</a>, 是烤麸自己学习用的博客</p><h1 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h1><h2 id="7-1-行内式"><a href="#7-1-行内式" class="headerlink" title="7.1 行内式"></a>7.1 行内式</h2><p>和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）</p><blockquote><p>注意的是[]前要加上!</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">markdown快速入门示例图.png</span>](<span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="7-2-参数式"><a href="#7-2-参数式" class="headerlink" title="7.2 参数式"></a>7.2 参数式</h2><p>图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">markdown快速入门示例图.png</span>]: <span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot; ![markdown快速入门示例图.png] </span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果图都是一样的，如下：</p><p><img src="/images/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="markdown快速入门示例图"></p><h1 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8. 分割线"></a>8. 分割线</h1><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">--- - - - ------ *** * * * ****** ___ _ _ _ ______<br></code></pre></td></tr></table></figure><p>以上代码的效果均为：</p><hr><h1 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h1><h2 id="9-1-强调字体"><a href="#9-1-强调字体" class="headerlink" title="9.1 强调字体"></a>9.1 强调字体</h2><p>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*md*</span>   <span class="hljs-strong">**md**</span> <span class="hljs-emphasis">_md_</span>   <span class="hljs-strong">__md__</span><br></code></pre></td></tr></table></figure><p>效果：<br><em>md</em><br><strong>md</strong><br><em>md</em><br><strong>md</strong></p><h2 id="9-2-转义"><a href="#9-2-转义" class="headerlink" title="9.2 转义"></a>9.2 转义</h2><p>基本上和js转义一样,\加需要转义的字符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\\ <br>\<span class="hljs-emphasis">* </span><br><span class="hljs-emphasis">\+ </span><br><span class="hljs-emphasis">\- </span><br><span class="hljs-emphasis">\` </span><br><span class="hljs-emphasis">\_</span><br></code></pre></td></tr></table></figure><h2 id="9-3-删除线"><a href="#9-3-删除线" class="headerlink" title="9.3 删除线"></a>9.3 删除线</h2><p>用~~把需要显示删除线的字符包裹起来</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">~~删除~~<br></code></pre></td></tr></table></figure><p>效果：</p><p><del>删除</del></p><h1 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//例子一 <br>|123|234|345| <br>|:-|:-:|-:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子二 <br>|123|234|345| <br>|:---|:---:|---:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子三 <br>123|234|345 <br>:-|:-:|-: <br>abc|bcd|cde <br>abc|bcd|cde <br>abc|bcd|cde<br></code></pre></td></tr></table></figure><p>上面三个例子的效果一样，由此可得：</p><ol><li><p>表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的</p></li><li><p>分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中</p></li></ol><p>效果如下：</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table><p>整理自：<a href="https://www.jianshu.com/p/399e5a3c7cc5">https://www.jianshu.com/p/399e5a3c7cc5</a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客使用手册</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是关于hexo框架下博客的使用方法总结，以便更好的学习与使用博客整理笔记。</p><h1 id="2-写作"><a href="#2-写作" class="headerlink" title="2. 写作"></a>2. 写作</h1><p>要创建新帖子或新页面，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>[layout]</code>是可选参数<code>布局</code>，<code>布局</code>分为以下几种：</p><table><thead><tr><th align="left">布局</th><th align="left">保存路径</th><th>用途</th></tr></thead><tbody><tr><td align="left">post</td><td align="left">source/_posts</td><td>创建新文章</td></tr><tr><td align="left">page</td><td align="left">source</td><td>创建新页面</td></tr><tr><td align="left">draft</td><td align="left">source/_drafts</td><td>创建新草稿</td></tr></tbody></table><p>该指令可以增加附加选项：</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--path</code></td><td align="left">发布路径。自定义帖子的路径。</td></tr><tr><td align="left"><code>-r</code>， <code>--replace</code></td><td align="left">替换当前帖子（如果存在）。</td></tr><tr><td align="left"><code>-s</code>， <code>--slug</code></td><td align="left">文章缩略名，自定义帖子的URL。</td></tr></tbody></table><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><h2 id="2-1-文档名称"><a href="#2-1-文档名称" class="headerlink" title="2.1 文档名称"></a>2.1 文档名称</h2><p>默认情况下，Hexo使用帖子标题作为其文件名。您可以在<code>_config.yml</code>中编辑<code>new_post_name</code>设置以更改默认文件名。</p><p>例如，<code>:year-:month-:day-:title.md</code>在文件名前加上创建日期。</p><p>您可以使用以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">帖子标题（小写，空格用连字符代替）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">创建年份，例如 <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">创建的月份（前导零），例如 <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">创建的月份（无前导零），例如 <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">创建日期（前导零），例如 <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">创建日期（无前导零），例如 <code>7</code></td></tr></tbody></table><h2 id="2-2-文档头"><a href="#2-2-文档头" class="headerlink" title="2.2 文档头"></a>2.2 文档头</h2><p>当新建.md文档后，打开文档可以看见如下文件头：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">title: hexo博客使用手册<br>date: 2021-02-18 14:11:04<br>tags: 博客使用手册<br>categories: 博客使用手册<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title:</code></td><td align="left">帖子标题</td></tr><tr><td align="left"><code>date:</code></td><td align="left">创建日期</td></tr><tr><td align="left"><code>tags:</code></td><td align="left">帖子所属标签</td></tr><tr><td align="left"><code>categories:</code></td><td align="left">帖子所属分类(需要手动添加)</td></tr></tbody></table><p>当想要新增标签与分类时，直接创建新的文档后在文件头填写参数即可。</p><p>多个标签时使用：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span>  <br><br>- [tag1]<br><br>- [tag2]<br></code></pre></td></tr></table></figure><p>含父子分类时，将父类写在前，子类写在后:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories: <br><span class="hljs-bullet">-</span> [categorie1]<br><span class="hljs-bullet">-</span> [categorie2]<br></code></pre></td></tr></table></figure><h2 id="2-3-添加图片"><a href="#2-3-添加图片" class="headerlink" title="2.3 添加图片"></a>2.3 添加图片</h2><p>关于图片和图片路径的设置，有以下教程。</p><p>事先声明，所有博客文件均保存在 <code>hexo/_posts/</code>文件夹下</p><p>首先在 <code>hexo &gt; source</code>目录下建一个文件夹叫images，用来保存博客中的图片。</p><p>然后打开Typora的 <code>文件 &gt; 偏好设置</code>，进行如下设置。</p><p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" alt="插入图片设置"></p><p>这样的话所有的博客中的图片都将会保存到 <code>/source/images/该博客md文件名/图片名称</code></p><p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p><p>在typora菜单栏点击 <code>格式-&gt;图像-&gt;设置图片根目录</code>，将<code>hexo/source</code>作为其根目录即可。</p><p><strong>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确喔！</strong></p><h2 id="2-4-草稿"><a href="#2-4-草稿" class="headerlink" title="2.4 草稿"></a>2.4 草稿</h2><p><code>draft</code>布局初始化的帖子将保存到该<code>source/_drafts</code>文件夹中。</p><p>您可以使用<code>publish</code>命令将草稿移至<code>source/_posts</code>文件夹。</p><p><code>publish</code>命令与<code>new</code>命令相似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>默认不显示草稿。</p><p>您可以在运行Hexo时添加选项<code>--draft</code>，也可以在<code>_config.yml</code>中启用<code>render_drafts</code>设置以渲染草稿。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --draft<br></code></pre></td></tr></table></figure><p>显示草稿（存储在<code>source/_drafts</code>文件夹中）。</p><h2 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h2><p>创建帖子时，Hexo将基于文件<code>scaffolds</code>夹中的相应模板文件来构建文件。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new photo <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>当您运行此命令时，Hexo将尝试在<code>scaffolds</code>文件夹中查找<code>photo.md</code>，并基于该文件构建帖子。模板中提供以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件创建日期</td></tr></tbody></table><h2 id="2-6-支持的格式"><a href="#2-6-支持的格式" class="headerlink" title="2.6 支持的格式"></a>2.6 支持的格式</h2><p>只要安装了相应的渲染器插件，Hexo支持帖子就可以以任何格式编写。、</p><p>本博客支持的编写格式：<code>markdown</code>，<code>ejs</code>。</p><h1 id="3-服务器指令"><a href="#3-服务器指令" class="headerlink" title="3. 服务器指令"></a>3. 服务器指令</h1><h2 id="3-1-init-安装指令"><a href="#3-1-init-安装指令" class="headerlink" title="3.1 init 安装指令"></a>3.1 init 安装指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init [folder]<br></code></pre></td></tr></table></figure><p>将hexo框架文件安装到当前/指定文件夹内。</p><h2 id="3-2-server-本地服务器启动指令"><a href="#3-2-server-本地服务器启动指令" class="headerlink" title="3.2 server 本地服务器启动指令"></a>3.2 server 本地服务器启动指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server 或 $ hexo s<br></code></pre></td></tr></table></figure><p>启动本地服务器。默认情况下，该位置为<code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--port</code></td><td align="left">覆盖默认端口</td></tr><tr><td align="left"><code>-s</code>， <code>--static</code></td><td align="left">仅提供静态文件</td></tr><tr><td align="left"><code>-l</code>， <code>--log</code></td><td align="left">启用记录器。覆盖记录器格式。</td></tr></tbody></table><h2 id="3-3-deploy-部署指令"><a href="#3-3-deploy-部署指令" class="headerlink" title="3.3 deploy 部署指令"></a>3.3 deploy 部署指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy 或 $ hexo d<br></code></pre></td></tr></table></figure><p>部署您的网站。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>， <code>--generate</code></td><td align="left">部署前生成</td></tr></tbody></table><h2 id="3-4-clean-清除缓存指令"><a href="#3-4-clean-清除缓存指令" class="headerlink" title="3.4 clean 清除缓存指令"></a>3.4 clean 清除缓存指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean <br></code></pre></td></tr></table></figure><p>清除缓存文件（<code>db.json</code>）和生成的文件（<code>public</code>）。</p><h2 id="3-5-version查看版本指令"><a href="#3-5-version查看版本指令" class="headerlink" title="3.5 version查看版本指令"></a>3.5 version查看版本指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo version 或 $ hexo v<br></code></pre></td></tr></table></figure><p>显示版本信息。</p><h2 id="3-6-选项"><a href="#3-6-选项" class="headerlink" title="3.6 选项"></a>3.6 选项</h2><h3 id="3-6-1-安全模式"><a href="#3-6-1-安全模式" class="headerlink" title="3.6.1 安全模式"></a>3.6.1 安全模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --safe<br></code></pre></td></tr></table></figure><p>禁用加载插件和脚本。如果在安装新插件后遇到问题，请尝试此操作。</p><h3 id="3-6-2-调试模式"><a href="#3-6-2-调试模式" class="headerlink" title="3.6.2 调试模式"></a>3.6.2 调试模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --debug<br></code></pre></td></tr></table></figure><p>将详细消息记录到终端和<code>debug.log</code>。如果遇到Hexo任何问题，请尝试此操作。如果看到错误，请<a href="https://github.com/hexojs/hexo/issues/new">提出GitHub问题</a>。</p><h3 id="3-6-3-静音模式"><a href="#3-6-3-静音模式" class="headerlink" title="3.6.3 静音模式"></a>3.6.3 静音模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --silent<br></code></pre></td></tr></table></figure><p>静音输出到终端。</p><h3 id="3-6-4-自定义配置文件路径"><a href="#3-6-4-自定义配置文件路径" class="headerlink" title="3.6.4 自定义配置文件路径"></a>3.6.4 自定义配置文件路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml<br></code></pre></td></tr></table></figure><p>使用自定义配置文件（而不是<code>_config.yml</code>）。</p><p>还接受以逗号分隔的JSON或YAML配置文件列表，该列表会将文件合并为一个<code>_multiconfig.yml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml，custom2.json<br></code></pre></td></tr></table></figure><h3 id="3-6-5-自定义CWD"><a href="#3-6-5-自定义CWD" class="headerlink" title="3.6.5 自定义CWD"></a>3.6.5 自定义CWD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --cwd / path / to / cwd<br></code></pre></td></tr></table></figure><p>自定义当前工作目录的路径。</p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
