<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线程基本知识</title>
    <link href="/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1进程-线程"><a href="#1-1进程-线程" class="headerlink" title="1.1进程/线程"></a>1.1进程/线程</h2><h3 id="1-1-1-进程"><a href="#1-1-1-进程" class="headerlink" title="1.1.1 进程"></a>1.1.1 进程</h3><p>进程指一个应用程序所运行的操作系统单元，它是操作系统环境中的基本成分、是系统进行资源分配的基本单位。</p><p>进程是执行程序的实例。<br>当运行一个应用程序后，就生成了一个进程，这个进程拥有自己的独立内存空间。<br>每一个进程对应一个活动的程序，当进程激活时，操作系统就将系统的资源包括内存、I/O和CPU等分配给它，使它执行。</p><ul><li><p>进程在运行时创建的资源随着进程的终止而死亡。</p></li><li><p>进程间获得专用数据或内存的唯一途径就是通过协议来共享内存块，这是一种协作策略。</p></li><li><p>一个进程可以创建多个线程及子进程（启动外部程序）。</p></li><li><p>一个进程内部的线程可以共享该进程所分配的资源。</p></li></ul><p>由于进程之间的切换非常消耗资源和时间，为了提高操作系统的并发性，提高CPU的利用率，在进程下面又加入了线程的概念。<br>线程的创建与撤销、线程之间的切换所占用的资源比进程少很多。</p><h3 id="1-1-2-线程"><a href="#1-1-2-线程" class="headerlink" title="1.1.2 线程"></a>1.1.2 线程</h3><p>进程可以分为若干个独立执行流（路径），这些执行流被称为线程。</p><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>线程是进程的一个实体，是CPU调度和分配时间的基本单位。</p><p>线程基本不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同一进程的其它线程共享进程所拥有的全部资源。<br>所以线程间共享内存空间很容易做到，多线程协作也很容易和便捷。</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程间可以并发执行。</p><p>线程提供了多任务处理的能力。</p><h3 id="1-1-3-线程与进程的异同"><a href="#1-1-3-线程与进程的异同" class="headerlink" title="1.1.3  线程与进程的异同"></a>1.1.3  线程与进程的异同</h3><ul><li><p>地址空间：</p><ul><li><p>进程拥有自己独立的内存地址空间；</p></li><li><p>线程共享进程的地址空间；</p><blockquote><p>换句话说就是进程间彼此是完全隔绝的，同一进程的所有线程共享(堆heap)内存；</p></blockquote></li></ul></li><li><p>资源拥有：</p><ul><li>进程是资源分配和拥有的单位</li><li>同一进程内的线程共享进程的资源；</li></ul></li><li><p>系统粒度：</p><ul><li>进程是分配资源的基本单位</li><li>线程则是系统（处理器）调度的基本单位；</li></ul></li><li><p>执行过程：</p><ul><li>每个独立的进程都有一个程序运行的入口、顺序执行序列和程序的出口；</li><li>线程不能独立执行，必须依存于进程中；</li></ul></li><li><p>系统开销：</p><p>创建或撤销进程时，系统都要为之分配或回收资源（如内存空间、IO设备）<br>进程间的切换也要消耗远大于线程切换的开销。</p></li></ul><p>二者均可并发执行。</p><p>一个程序至少有一个进程，一个进程至少有一个线程（主线程）。<br>主线程以函数地址的形式，如Main或WinMain函数，提供程序的启动点，当主线程终止时，进程也随之终止。<br>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</p><h2 id="1-2-并发-并行"><a href="#1-2-并发-并行" class="headerlink" title="1.2 并发/并行"></a>1.2 并发/并行</h2><p>在单CPU系统中，系统调度在某一刻只能让一个线程运行，虽然这种调度机制有多种形式（时分/频分），但无论如何，要通过不断切换需要运行的线程，这种运行模式称为并发（Concurrent）。</p><p>而在多CPU系统中，可以让两个以上的线程同时运行，这种运行模式称为并行（Parallel）。</p><h2 id="1-3-同步-异步操作"><a href="#1-3-同步-异步操作" class="headerlink" title="1.3 同步/异步操作"></a>1.3 同步/异步操作</h2><h3 id="1-3-1-同步与异步的定义"><a href="#1-3-1-同步与异步的定义" class="headerlink" title="1.3.1 同步与异步的定义"></a>1.3.1 同步与异步的定义</h3><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p><ul><li><p>同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。</p></li><li><p>异步，和同步相反 调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回掉函数来处理这个调用。</p></li></ul><p>所有的程序最终都会由计算机硬件来执行，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。<br>这些无须消耗CPU时间的I/O操作是异步操作的硬件基础。<br>硬盘、光驱、网卡、声卡、显卡都具有DMA功能。</p><p>DMA（DirectMemory Access）是直接内存访问的意思，它是不经过CPU而直接进行内存数据存储的数据交换模式。</p><p>I/O操作包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。</p><p>异步操作可达到避免调用线程堵塞的目的，从而提高软件的可响应性。</p><h3 id="1-3-2-同步与异步的对比"><a href="#1-3-2-同步与异步的对比" class="headerlink" title="1.3.2 同步与异步的对比"></a>1.3.2 同步与异步的对比</h3><p>线程不是一个计算机的硬件功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。</p><p>异步模式无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必共享变量，减少了死锁的可能。</p><p>不过，编写异步操作的复杂程度比较高，程序主要使用回调方式进行处理，与人的思维方式有出入，而且难以调试。</p><p>计算密集型工作使用多线程（如图形处理、算法）；IO密集型工作使用异步机制。</p><h2 id="1-4-任务管理器"><a href="#1-4-任务管理器" class="headerlink" title="1.4 任务管理器"></a>1.4 任务管理器</h2><p>映射名称列：<br>进程并不拥有独立于其所属实例的映射名称；</p><blockquote><p>如果运行5个Notepad拷贝，你会看到5个称为Notepad.exe的进程；</p></blockquote><p>它们是根据进程ID进行区分的，该进程ID是由系统维护，并可以循环使用。</p><p>CPU列：<br>它是进程中线程所占用的CPU时间百分比</p><p>每个任务管理器中的进程，其实内部都包含若干个线程，每个时间点都是某个程序进程中的某个线程在运行。</p><h2 id="1-5-线程是如何工作的"><a href="#1-5-线程是如何工作的" class="headerlink" title="1.5 线程是如何工作的"></a>1.5 线程是如何工作的</h2><p>线程被一个线程协调程序管理着——一个CLR委托给操作系统的函数。<br>线程协调程序确保将所有活动的线程被分配适当的执行时间；<br>并且那些等待或阻止的线程——比如说在排它锁中、或在用户输入——都是不消耗CPU时间的。</p><p>在单核处理器的电脑中，线程协调程序完成一个时间片之后迅速地在活动的线程之间进行切换执行。<br>这就导致“波涛汹涌”的行为，例如在第一个例子，每次重复的X 或 Y 块相当于分给线程的时间片。<br>在Windows XP中时间片通常在10毫秒内选择要比CPU开销在处理线程切换的时候的消耗大的多。(即通常在几微秒区间)</p><p>在多核的电脑中，多线程被实现成混合时间片和真实的并发——不同的线程在不同的CPU上运行。<br>但这仍然会出现一些时间切片,因为操作系统的服务线程、以及一些其他的应用程序都会争夺对CPU的使用权。</p><p>线程由于外部因素（比如时间片）被中断被称为被抢占，在大多数情况下,一个线程在被抢占的那一刻就失去了对它的控制权。</p><h2 id="1-6-线程安全"><a href="#1-6-线程安全" class="headerlink" title="1.6 线程安全"></a>1.6 线程安全</h2><p>当使用线程（Thread）时，程序员必须注意同步处理的问题</p><p>理论上每个Thread都是独立运行的个体，由CLR来主导排程，视Thread的优先权的设置，每个Thread会分到特定的运行时间，当某个Thread的运行时间用完时，CLR就会强制将运行权由该Thread取回，转交给下个Thread<br>这也就意味着Thread本身无法得知自己何时会丧失运行权，所以会发生所谓的race condition（竞速状态）。</p><p>当两个线程争夺一个锁的时候（在这个例子里是locker），一个线程等待，或者说被阻止到那个锁变的可用。<br>在这种情况下，就确保了在同一时刻只有一个线程能进入临界区，所以”Done”只被打印了1次。代码以如此方式在不确定的多线程环境中被叫做线程安全。</p><p>临时暂停，或阻止是多线程的协同工作，同步活动的本质特征。<br>等待一个排它锁被释放是一个线程被阻止的原因，另一个原因是线程想要暂停或Sleep一段时间：</p><p>Thread.Sleep (TimeSpan.FromSeconds (30));  // 阻止30秒</p><p>一个线程也可以使用它的Join方法来等待另一个线程结束：</p><p>Threadt = new Thread(Go);  // 假设Go是某个静态方法</p><p>t.Start();</p><p>t.Join();  // 等待（阻止）直到线程t结束</p><h1 id="2-使用多线程的情况分析"><a href="#2-使用多线程的情况分析" class="headerlink" title="2. 使用多线程的情况分析"></a>2. 使用多线程的情况分析</h1><h2 id="2-1-为什么要使用多线程"><a href="#2-1-为什么要使用多线程" class="headerlink" title="2.1 为什么要使用多线程"></a>2.1 为什么要使用多线程</h2><ul><li>并发需要<br>在C/S或B/S模式下的服务端需要处理来自不同终端的并发请求，使用单线程是不可思议的。</li><li>提高应用程序的响应速度<br>当一个耗时的操作进行时，当前程序都会等待这个操作结束<br>此时程序不会响应键盘、鼠标、菜单等操作，程序处于假死状态；<br>使用多线程可将耗时长的操作（Time Consuming）置于一个新的线程，此时程序仍能响应用户的其它操作</li><li>提高CPU利用率<br>在多CPU体系中，操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li><li>改善程序结构<br>一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分<br>这样的程序会利于理解和修改。</li><li>花销小、切换快<br>线程间的切换时间很小，可以忽略不计</li><li>方便的通信机制<br>线程间共享内存，互相间交换数据很简单。</li></ul><p>多线程的意义在于<br>一个应用程序中，有多个执行部分可以同时执行：<br>一个线程可以在后台读取数据，而另一个线程可以在前台展现已读取的数据。</p><p>C#支持通过多线程并行地执行代码，一个线程有它独立的执行路径，能够与其它的线程同时地运行。<br>一个C#程序开始于一个单线程，这个单线程是被CLR和操作系统（也称为“主线程”）自动创建的，并具有多线程创建额外的线程。</p><h2 id="2-2-何时使用多线程"><a href="#2-2-何时使用多线程" class="headerlink" title="2.2 何时使用多线程"></a>2.2 何时使用多线程</h2><p>多线程程序一般被用来在后台执行耗时的任务：主线程保持运行，而工作线程执行后台工作。</p><ul><li><p>对于Windows Forms程序来说，如果主线程执行了一个冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应，进入假死的状态，可能导致用户强制结束程序进程而出现错误。<br>有鉴于此，应该在主线程运行一个耗时任务时另外添加一个工作线程，同时在主线程上有一个友好的提示“处理中…”，允许继续接收事件（比如响应鼠标、键盘操作）。<br>同时程序还应该实现“取消”功能，允许取消/结束当前工作线程。<br>BackgroundWorker类就提供这一功能。</p></li><li><p>在没有用户界面的程序里，比如说WindowsService中使用多线程特别的有意义。<br>当一个任务有潜在的耗时（在等待被请求方的响应——比如应用服务器，数据库服务器），用工作线程完成任务意味着主线程可以在发送请求后立即做其它的事情。</p></li><li><p>另一个多线程的用途是在需要完成一个复杂的计算工作时,它会在多核的电脑上运行得更快，如果工作量被多个线程分开的话（C#中可使用Environment.ProcessorCount属性来侦测处理芯片的数量）。</p></li></ul><p>远程服务器，或WebServices或ASP.NET程序将别无选择，必须使用多线程；<br>一个单线程的ASP.NET Web Service是不可想象的；<br>幸运的是，应用服务器中多线程是相当普遍的；<br>唯一值得关心的是提供适当锁机制的静态变量问题。</p><h2 id="2-3-何时不用多线程"><a href="#2-3-何时不用多线程" class="headerlink" title="2.3 何时不用多线程"></a>2.3 何时不用多线程</h2><p>多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂<br>拥有多线程本身并不复杂，复杂是的线程的交互作用<br>无论交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的Bugs。<br>因此，要么多线程的交互设计简单一些，要么就根本不使用多线程，除非你有强烈的重写和调试欲望。</p><p>当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。<br>在某些情况下，太多的I/O操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务快的多。</p><h1 id="3-C-中的线程"><a href="#3-C-中的线程" class="headerlink" title="3. C#中的线程"></a>3. C#中的线程</h1><h2 id="3-1-程序域"><a href="#3-1-程序域" class="headerlink" title="3.1 程序域"></a>3.1 程序域</h2><p>在.Net中Process由AppDomain对象所取代。</p><p>虽然AppDomain在CLR中被视为Process的替代品，但实际上AppDomain跟Process是属于主从关系的，AppDomain被放置在一个Process中，<br>每个Process可以拥有多个AppDomain，<br>每个AppDomain又可拥有多个Thread对象。</p><p>Process、AppDomain、Thread的关系如下图所示：</p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/image-20210528201620106.png" srcset="/img/loading.gif" alt="进程、域、线程关系图"></p><p>AppDomain定义了一些事件供程序员使用。</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>AssemblyLoad</td><td>触发于AppDomain载入一个Assembly时</td></tr><tr><td>DomainUnLoad</td><td>触发于AppDomain卸载时，也就是Unload函数被调用或是该AppDomain被消灭前</td></tr><tr><td>ProcessExit</td><td>当默认的AppDomain被卸载时触发，多半是应用程序退出时</td></tr></tbody></table><p>各AppDomain间互不影响。</p><h2 id="3-2-C-中实现线程的方法"><a href="#3-2-C-中实现线程的方法" class="headerlink" title="3.2 C#中实现线程的方法"></a>3.2 C#中实现线程的方法</h2><p>一个C#程序成为多线程可以通过2种方式来实现：</p><ul><li><p>明确地创建和运行多线程</p></li><li><p>使用.NET Framework中封装了多线程的类<br>比如:</p><ul><li><p>BackgroundWorker类</p></li><li><p>线程池</p></li><li><p>Threading Timer</p></li></ul></li></ul><p>更多C#中实现线程的方法请看<br><a href="https://mycroftcooper.github.io/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/">C#中实现线程的方法</a></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>计算机基本知识</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#多线程</title>
    <link href="/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在学习本篇文章前你需要学习的相关知识：<br><a href="https://mycroftcooper.github.io/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">线程基本知识</a></p><p>此篇文章简单总结了C#中主要的多线程实现方法，包括：</p><ul><li>Thread<br>线程</li><li>ThreadPool<br>线程池</li><li>Parallel</li><li>Task<br>任务</li><li>BackgroundWorker组件</li></ul><h1 id="2-Thread类"><a href="#2-Thread类" class="headerlink" title="2. Thread类"></a>2. Thread类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li><p>使用Thread类通过ThreadStart（无参数）或ParameterizedThreadStart（一个输入参数）类型的委托创建一个Thread对象，开启一个新线程，执行该委托传递的任务，此时线程尚未处于运行状态。</p></li><li><p>调用Start()函数启动线程，当前线程继续执行。</p></li><li><p>调用Join()函数可以阻塞当前线程，直到调用Join()的线程终止。</p></li><li><p>调用Abort()方法，如需中止线程，在调用该方法的线程上抛出ThreadAbortException异常，以结束该线程</p></li><li><p>可以通过Thread.ResetAbort()方法阻止线程的中止。</p></li></ul><h2 id="2-1-属性表"><a href="#2-1-属性表" class="headerlink" title="2.1 属性表"></a>2.1 属性表</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Name</td><td>属性，获取或设置线程的名称</td></tr><tr><td>Priority</td><td>属性，获取或设置线程的优先级</td></tr><tr><td>ThreadState</td><td>属性，获取线程当前的状态</td></tr><tr><td>IsAlive</td><td>属性，获取当前线程是否处于启动状态</td></tr><tr><td>IsBackground</td><td>属性，获取或设置值，表示该线程是否为后台线程</td></tr><tr><td>CurrentThread</td><td>属性，获取当前正在运行的线程</td></tr></tbody></table><h2 id="2-2-方法表"><a href="#2-2-方法表" class="headerlink" title="2.2 方法表"></a>2.2 方法表</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Start()</td><td>方法，启动线程</td></tr><tr><td>Sleep(int millisecondsTimout)</td><td>方法，将当前线程暂停指定的毫秒数</td></tr><tr><td>Suspend()</td><td>方法，挂起当前线程（已经被弃用）</td></tr><tr><td>Join()</td><td>方法，阻塞调用线程，直到某个线程终止为止</td></tr><tr><td>Interrupt()</td><td>方法，中断当前线程</td></tr><tr><td>Resume()</td><td>方法，继续已经挂起的线程（已经被弃用）</td></tr><tr><td>Abort()</td><td>方法，终止线程（已经被弃用）</td></tr></tbody></table><h2 id="2-3-开启线程"><a href="#2-3-开启线程" class="headerlink" title="2.3 开启线程"></a>2.3 开启线程</h2><p>首先用new申请Thread对象，然后对象调用Start()方法启用线程。</p><p>代码如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Thread.CurrentThread.ManagedThreadId获取当前线程的ID，便于管理。</p></blockquote><p>用Lambda表达式代替函数调用，也能达到相同的效果</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>        &#125;);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-传递参数"><a href="#2-4-传递参数" class="headerlink" title="2.4 传递参数"></a>2.4 传递参数</h2><p>有两种为线程传递参数的方法：</p><ul><li><p>Start()函数传参法</p></li><li><p>对象成员方法传参法</p></li><li><p>匿名方法传参法</p><h3 id="2-4-1-Start-函数传参"><a href="#2-4-1-Start-函数传参" class="headerlink" title="2.4.1 Start()函数传参"></a>2.4.1 Start()函数传参</h3></li></ul><p>为某方法创建新线程后，在使用Start()方法启动线程时传递该方法需要的参数。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> name</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + name);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start(<span class="hljs-string">&quot;April&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-1-对象传递"><a href="#2-4-1-对象传递" class="headerlink" title="2.4.1 对象传递"></a>2.4.1 对象传递</h3><p>初始化一个对象，然后用对象的方法初始化Thread，这样该线程就可以使用这个对象的所有成员。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Download</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> Id;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> Name;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Download</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, <span class="hljs-built_in">string</span> name</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Id = id;<br>            Name = name;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownloadFile</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + <span class="hljs-string">&quot;ID: &quot;</span> + Id + <span class="hljs-string">&quot; Name: &quot;</span> + Name);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);              <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Download download = <span class="hljs-keyword">new</span> Download(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;人民日报&quot;</span>);<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(download.DownloadFile);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-5-匿名方法"><a href="#2-4-5-匿名方法" class="headerlink" title="2.4.5 匿名方法"></a>2.4.5 匿名方法</h3><p>需要接收多个参数的解决方案是使用一个匿名方法调用，方法如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (<span class="hljs-string">&quot;Hello&quot;</span>); &#125;);<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure><p>它的优点是目标方法（这里是WriteText），可以接收任意数量的参数，并且没有装箱操作。</p><p>不过这需要将一个外部变量放入到匿名方法中，如下示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">voidMain</span>(<span class="hljs-params"></span>)</span> &#123;<br>stringtext = <span class="hljs-string">&quot;Before&quot;</span>;<br><br>Threadt = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (text); &#125;);<br><br>text = <span class="hljs-string">&quot;After&quot;</span>;<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是:<br>当外部变量的值被修改，匿名方法可能进行无意的互动，导致一些古怪的现象。<br>一旦线程开始运行，外部变量最好被处理成只读的——除非有人愿意使用适当的锁。</p></blockquote><h2 id="2-5-线程命名"><a href="#2-5-线程命名" class="headerlink" title="2.5 线程命名"></a>2.5 线程命名</h2><p>线程可以通过它的Name属性进行命名，这非常有利于调试：<br>可以用Console.WriteLine打印出线程的名字<br>Microsoft Visual Studio可以将线程的名字显示在调试工具栏的位置上。</p><p>线程的名字可以在被任何时间设置——但只能设置一次，重命名会引发异常。</p><p>程序的主线程也可以被命名，下面例子里主线程通过CurrentThread命名：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#">Class ThreadNaming &#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread.CurrentThread.Name= <span class="hljs-string">&quot;main&quot;</span>;<br><br>Thread worker = <span class="hljs-keyword">new</span> Thread(Go);<br><br>worker.Name= <span class="hljs-string">&quot;worker&quot;</span>;<br><br>worker.Start();<br><br>Go();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Go</span>(<span class="hljs-params"></span>)</span> &#123;<br>Console.WriteLine (<span class="hljs-string">&quot;Hello from &quot;</span>+ Thread.CurrentThread.Name);<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><p>Hellofrom main</p><p>Hellofrom worker</p><h2 id="2-6-前台线程和后台线程"><a href="#2-6-前台线程和后台线程" class="headerlink" title="2.6 前台线程和后台线程"></a>2.6 前台线程和后台线程</h2><ul><li>前台线程(用户界面线程)<br>只要存在有一个前台线程在运行，应用程序就在运行<br>通常用来处理用户的输入并响应各种事件和消息</li><li>后台线程(工作线程)<br>应用程序关闭时，如果后台线程没有执行完，会被强制性的关闭<br>用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等</li></ul><p>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-built_in">string</span>[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//设为后台线程</span><br>        thread.IsBackground = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上例中，thread被设置为后台线程。<br>Main执行完后，没有前台线程了，应用程序就结束，虽然后台线程thread此时尚未执行完，也被终止。</p><blockquote><p>改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。</p></blockquote><p>拥有一个后台工作线程是有益的，<br>最直接的理由是当提到结束程序它总是可能有最后的发言权。<br>交织以不会消亡的前台线程，保证程序的正常退出。</p><p>抛弃一个前台工作线程是尤为险恶的，尤其对Windows Forms程序，<br>因为程序直到主线程结束时才退出（至少对用户来说），但是它的进程仍然运行着。<br>在Windows任务管理器它将从应用程序栏消失不见，但却可以在进程栏找到它。<br>除非用户找到并结束它，它将继续消耗资源，并可能阻止一个新的实例的运行从开始或影响它的特性。</p><p>对于程序失败退出的普遍原因就是存在“被忘记”的前台线程。</p><table><thead><tr><th>线程类型</th><th>动作</th><th>结束</th><th>后续处理</th></tr></thead><tbody><tr><td>前台线程</td><td>主程序关闭</td><td>否</td><td>显示关闭线程/杀掉当前进程</td></tr><tr><td>后台线程</td><td>主程序关闭</td><td>是</td><td>无</td></tr></tbody></table><h2 id="2-7-注意事项"><a href="#2-7-注意事项" class="headerlink" title="2.7 注意事项"></a>2.7 注意事项</h2><ul><li><p>Thread类创建的线程默认为前台线程，可以通过IsBackground属性设置其为前台或后台线程。</p><blockquote><p>用Thread类创建的线程是前台线程，线程池中的线程总是后台线程</p></blockquote></li><li><p>可以通过Priority属性设置线程的优先级。</p></li><li><p>线程内部可以通过try catch捕获该异常，在catch模块中进行一些必要的处理<br>如释放持有的锁和文件资源等</p></li><li><p>慎重使用Abort()方法<br>如果在当前线程中抛出该异常，其结果是可预测的<br>但是对于其他线程，它会中断任何正在执行的代码，有可能中断静态对象的生成，造成不可预测的结果。</p></li></ul><h1 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>ThreadPool类维护一个线程的列表，提供给用户以执行不同的小任务，减少频繁创建线程的开销。<br>该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</p><p>线程池其实就是一个存放线程对象的“池子(pool)”，他提供了一些基本方法，如：设置pool中最小/最大线程数量、把要执行的方法排入队列等等。ThreadPool是一个静态类，因此可以直接使用，不用创建对象。</p><h2 id="3-2-线程池的优点"><a href="#3-2-线程池的优点" class="headerlink" title="3.2 线程池的优点"></a>3.2 线程池的优点</h2><p>每新建一个线程都需要占用内存空间和其他资源<br>而新建了那么多线程，有很多在休眠，或者在等待资源释放；<br>又有许多线程只是周期性的做一些小工作，如刷新数据等等，太浪费了，划不来。<br>实际编程中大量线程突发，然后在短时间内结束的情况很少见。</p><p>于是，就提出了线程池的概念。</p><p>线程池中的线程执行完指定的方法后并不会自动消除，而是以挂起状态返回线程池，如果应用程序再次向线程池发出请求，那么处以挂起状态的线程就会被激活并执行任务，而不会创建新线程，这就节约了很多开销。<br>只有当线程数达到最大线程数量，系统才会自动销毁线程。</p><p>因此，使用线程池可以避免大量的创建和销毁的开支，具有更好的性能和稳定性，其次，开发人员把线程交给系统管理，可以集中精力处理其他任务。</p><h2 id="3-3-线程池的使用"><a href="#3-3-线程池的使用" class="headerlink" title="3.3 线程池的使用"></a>3.3 线程池的使用</h2><ul><li><p>设置线程池最大最小：<br><strong>ThreadPool.SetMaxThreads (int workerThreads,int completionPortThreads)</strong><br>设置可以同时处于活动状态的线程池的请求数目。<br>所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。<br>还可以设置最小线程数。</p></li><li><p>将任务添加进线程池:<br><strong>ThreadPool.QueueUserWorkItem(new WaitCallback(方法名));**或<br>**ThreadPool.QueueUserWorkItem(new WaitCallback(方法名), 参数);</strong></p></li></ul><p>但是线程池的使用也有一些限制：</p><ul><li>线程池中的线程均为后台线程，并且不能修改为前台线程</li><li>不能给入池的线程设置优先级或名称</li><li>对于COM对象，入池的所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA）  线程</li><li>入池的线程只适合时间较短的任务，如果线程需要长时间运行，应使用Thread类创建线程或使用Task的LongRunning选项</li><li>.Net下线程池最小默认允许4个工作线程，最大允许2048个工作线程。<br>并发线程启动后，瞬间会启动4个线程。<br>而剩下的会依据环境每0.5秒或者1秒启动一个。<br>如果同时运行的线程达到Max工作线程，那么剩下的就会挂起<br>直到线程池中的线程有空闲得了，才会去执行。</li></ul><h1 id="4-Parallel类"><a href="#4-Parallel类" class="headerlink" title="4.  Parallel类"></a>4.  Parallel类</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>整理自<a href="https://blog.csdn.net/honantic/article/details/46876871">https://blog.csdn.net/honantic/article/details/46876871</a></p><p>Parallel和Task类都位于System.Threading.Task命名空间中，是对Thread和ThreadPool类更高级的抽象。</p><p>Parrallel类有For()、ForEach()、Invoke()三个方法</p><ul><li><p>Invoke()<br>实现任务并行性<br>允许同时调用不同的方法，</p></li><li><p>Parallel.For()和 Parallel.ForEach()<br>实现数据并行性<br>在每次迭代中调用相同的代码</p></li></ul><h2 id="4-2-常用方法"><a href="#4-2-常用方法" class="headerlink" title="4.2 常用方法"></a>4.2 常用方法</h2><h3 id="4-2-1-Parallel-For"><a href="#4-2-1-Parallel-For" class="headerlink" title="4.2.1 Parallel.For()"></a>4.2.1 Parallel.For()</h3><p>Parallel.For()方法类似于 C#的 for循环语旬,也是多次执行一个任务。<br>使用Parallel.For()方法,可以并行运行迭代。 </p><p>迭代的顺序没有定义，不能保证。</p><p>在For()方法中：</p><ul><li>前两个参数定义了循环的开头和结束。示例从0迭代到 9。</li><li>第 3个参数是一个Action<int>委托<br>是要并行运行迭代的方法</li><li>整数参数是循环的迭代次数,该参数被传递给Action<int>委托引用的方法。</li><li>Parallel.For()方法的返回类型是ParalleLoopResult结构,它提供了循环是否结束的信息。</li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    ParallelLoopResult result = Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, i =&gt;<br>    &#123;<br>        Console.WriteLine<br>        (<span class="hljs-string">&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;</span>, i, Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Console.WriteLine(<span class="hljs-string">&quot;Is completed: &#123;0&#125;&quot;</span>, result.IsCompleted);<br><br>    <span class="hljs-comment">//i: 0, thread id: 9</span><br>    <span class="hljs-comment">//i: 2, thread id: 10</span><br>    <span class="hljs-comment">//i: 1, thread id: 9</span><br>    <span class="hljs-comment">//i: 3, thread id: 10</span><br>    <span class="hljs-comment">//i: 4, thread id: 9</span><br>    <span class="hljs-comment">//i: 6, thread id: 11</span><br>    <span class="hljs-comment">//i: 7, thread id: 10</span><br>    <span class="hljs-comment">//i: 5, thread id: 9</span><br>    <span class="hljs-comment">//i: 8, thread id: 12</span><br>    <span class="hljs-comment">//i: 9, thread id: 11</span><br>    <span class="hljs-comment">//Is completed: True</span><br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><p>同For()循环类似，Parallel.For()方法也可以中断循环的执行。</p><p>Parallel.For()方法的一个重载版本接受第3个Action&lt;int, ParallelLoopState&gt;类型的参数。<br>使用这些参数定义一个方法,就可以调用ParalleLoopState的Break()或Stop()方法,以影响循环的结果。</p><blockquote><p>注意,迭代的顺序没有定义</p></blockquote><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tsx">public static void Main()<br>&#123;<br>    ParallelLoopResult result &#x3D; Parallel.For(0, 100, (i, state) &#x3D;&gt;<br>    &#123;<br>        Console.WriteLine(&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;, i, Thread.CurrentThread.ManagedThreadId);<br><br>        if (i &gt; 10)<br>            state.Break();<br><br>        Thread.Sleep(10);<br>    &#125;);<br><br>    Console.WriteLine(&quot;Is completed: &#123;0&#125;&quot;, result.IsCompleted);<br>    Console.WriteLine(&quot;Lowest break iteration: &#123;0&#125;&quot;, result.LowestBreakIteration);<br><br>    &#x2F;&#x2F;i: 0, thread id: 10<br>    &#x2F;&#x2F;i: 25, thread id: 6<br>    &#x2F;&#x2F;i: 1, thread id: 10<br>    &#x2F;&#x2F;i: 2, thread id: 10<br>    &#x2F;&#x2F;i: 3, thread id: 10<br>    &#x2F;&#x2F;i: 4, thread id: 10<br>    &#x2F;&#x2F;i: 5, thread id: 10<br>    &#x2F;&#x2F;i: 6, thread id: 10<br>    &#x2F;&#x2F;i: 7, thread id: 10<br>    &#x2F;&#x2F;i: 8, thread id: 10<br>    &#x2F;&#x2F;i: 9, thread id: 10<br>    &#x2F;&#x2F;i: 10, thread id: 10<br>    &#x2F;&#x2F;i: 11, thread id: 10<br>    &#x2F;&#x2F;Is completed: False<br>    &#x2F;&#x2F;Lowest break iteration: 11<br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-Parallel-For-lt-TLocal-gt"><a href="#4-2-2-Parallel-For-lt-TLocal-gt" class="headerlink" title="4.2.2 Parallel.For &lt; TLocal &gt;"></a>4.2.2 Parallel.For &lt; TLocal &gt;</h3><p>Parallel.For()方法可能使用几个线程来执行循环 。</p><p>如果需要对每个线程进行初始化,就可以使用Parallel.For<TLocal>方法。<br>除了from和to对应的值之外,For()方法的泛型版本还接受3个委托参数:</p><ul><li><p>第一个参数的类型是Func&lt; TLocal &gt;<br>因为这里的例子对于TLocal使用字符串,所以该方法需要定义为Func&lt; string &gt;,即返回string的方法。<br>这个方法仅对于用于执行迭代的每个线程调用一次</p></li><li><p>第二个委托参数为循环体定义了委托<br>在示例中,该参数的类型是Func&lt;int, ParallelLoopState, string, string&gt;。<br>其中第一个参数是循环迭代,第二个参数 ParallelLoopstate允许停止循环,如前所述 。<br>循环体方法通过第3个参数接收从init方法返回的值,循环体方法还需要返回一个值,其类型是用泛型for参数定义的。</p></li><li><p>For()方法的最后一个参数指定一个委托Action&lt; TLocal &gt;;在该示例中,接收一个字符串。<br>这个方法仅对于每个线程调用一次,这是一个线程退出方法。</p></li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">Parallel.For&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>,() =&gt;<br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;init thread &#123;0&#125;,\t task &#123;1&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;t&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);<br>                &#125;,<br>            (i, pls, str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;body i &#123;0&#125; \t str &#123;1&#125; \t thread &#123;2&#125; \t task &#123;3&#125;&quot;</span>, i, str, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                Thread.Sleep(<span class="hljs-number">10</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;i \t&#123;0&#125;&quot;</span>, i);<br>            &#125;,<br>            (str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;finally\t &#123;0&#125;&quot;</span>, str);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><p><strong>Parallel.For<TLocal> 方法 (Int32, Int32, Func<TLocal>, Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;, Action<TLocal>)</strong></p><p>参数表：</p><table><thead><tr><th>参数名</th><th>数据类型</th><th>作用</th></tr></thead><tbody><tr><td></td><td>TLoca</td><td>线程本地数据的类型</td></tr><tr><td>fromInclusive</td><td>System.Int32</td><td>开始索引（含）</td></tr><tr><td>toExclusive</td><td>System.Int32</td><td>结束索引（不含）</td></tr><tr><td>localInit</td><td>System.Func<TLocal></td><td>用于返回每个任务的本地数据的初始状态的函数委托</td></tr><tr><td>body</td><td>System.Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;</td><td>将为每个迭代调用一次的委托</td></tr><tr><td>localFinally</td><td>System.Action<TLocal></td><td>用于对每个任务的本地状态执行一个最终操作的委托</td></tr><tr><td>返回值</td><td>System.Threading.Tasks.ParallelLoopResult</td><td></td></tr></tbody></table><p>在迭代范围 (fromInclusive，toExclusive) ，为每个值调用一次body 委托。<br>为它提供以下参数：</p><ul><li>迭代次数 (Int32)</li><li>可用来提前退出循环的ParallelLoopState实例</li><li>可以在同一线程上执行的迭代之间共享的某些本地状态。</li></ul><p>对于参与循环执行的每个任务调用 localInit 委托一次，并返回每个任务的初始本地状态。<br>这些初始状态传递给第一个在该任务上 调用的 body。<br>然后，每个后续正文调用返回可能修改过的状态值，传递到下一个正文调用。<br>最后，每个任务上的最后正文调用返回传递给 localFinally 委托的状态值。<br>每个任务调用 localFinally 委托一次，以对每个任务的本地状态执行最终操作。<br>此委托可以被多个任务同步调用；<br>因此您必须同步对任何共享变量的访问。</p><p>Parallel.For方法比在它执行生存期的线程可能使用更多任务，作为现有的任务完成并被新任务替换。<br>这使基础 TaskScheduler 对象有机会添加、更改或移除服务循环的线程。</p><p>如果 fromInclusive 大于或等于 toExclusive，则该方法立即返回，而无需执行任何迭代。</p><h3 id="4-2-3-Parallel-ForEach"><a href="#4-2-3-Parallel-ForEach" class="headerlink" title="4.2.3 Parallel.ForEach()"></a>4.2.3 Parallel.ForEach()</h3><p>Parallel.ForEach()方法遍历实现了IEnumerable的集合,其方式类似于foreach语句,但以异步方式遍历。<br>这里也没有确定遍历顺序。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s) =&gt;<br>            &#123;<br>                Console.WriteLine(s);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><p>中断循环<br>如果需要中断循环,就可以使用ForEach()方法的重载版本和ParallelLoopState参数。其方式与前面的For()方法相同。<br>ForEach()方法的一个重载版本也可以用于访问索引器,从而获得迭代次数<br>如下所示:　</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s, pls, l) =&gt;<br>             &#123;<br>                 Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;\t&#123;1&#125;&quot;</span>, s, l);<br>                 <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">10</span>)<br>                 &#123;<br>                     pls.Break();<br>                 &#125;<br>             &#125;);<br>            Console.WriteLine(<span class="hljs-string">&quot;Lowest break iteration: &#123;0&#125;&quot;</span>, result.LowestBreakIteration);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><h3 id="4-2-4-Parallel-Invoke"><a href="#4-2-4-Parallel-Invoke" class="headerlink" title="4.2.4 Parallel.Invoke()"></a>4.2.4 Parallel.Invoke()</h3><p>如果多个任务应并行运行,就可以使用Parallel.Invoke()方法。<br>Parallel.Invoke()方法允许传递一个Action委托数组,在其中可以指定应运行的方法。<br>示例代码传递了要并行调用的Foo()和Bar()方法:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Foo, Bar);<br>    Console.ReadKey();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Foo&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Bar&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如需同时执行多个不同的任务，可以使用Parallel.Invoke()方法，它允许传递一个Action委托数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Func1, Func2, Func3);<br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Task类"><a href="#5-Task类" class="headerlink" title="5. Task类"></a>5. Task类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>相比于Thread类，Task类为控制线程提供了更大的灵活性。</p><ul><li><p>Task类可以获取线程的返回值</p></li><li><p>可以定义连续的任务：在一个任务结束结束后开启下一个任务</p></li><li><p>可以在层次结构中安排任务，在父任务中可以创建子任务<br>这样就创建了一种依赖关系，如果父任务被取消，子任务也随之取消</p></li></ul><blockquote><p>注意：<br>Task类默认使用线程池中的线程，如果该任务需长期运行，应使用TaskCreationOptions.LongRunning属性告诉任务管理器创建一个新的线程，而不是使用线程池中的线程。</p></blockquote><h2 id="5-2-任务Task和线程Thread的区别："><a href="#5-2-任务Task和线程Thread的区别：" class="headerlink" title="5.2 任务Task和线程Thread的区别："></a>5.2 任务Task和线程Thread的区别：</h2><ul><li>任务是架构在线程之上的<br>也就是说任务最终还是要<strong>抛给线程</strong>去执行。</li><li><strong>任务跟线程不是一对一的关系</strong><br>比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。</li><li>Task和Thread一样，位于System.Threading命名空间下!</li></ul><h2 id="5-3-Task的生存周期与状态"><a href="#5-3-Task的生存周期与状态" class="headerlink" title="5.3 Task的生存周期与状态"></a>5.3 Task的生存周期与状态</h2><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Created</td><td>表示默认初始化任务，但是“工厂创建的”实例直接跳过。</td></tr><tr><td>WaitingToRun</td><td>这种状态表示等待任务调度器分配线程给任务执行。</td></tr><tr><td>RanToCompletion</td><td>任务执行完毕。</td></tr></tbody></table><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//查看Task中的状态</span><br>   <span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>         &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Begin&quot;</span>);<br>            System.Threading.Thread.Sleep(<span class="hljs-number">2000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;Finish&quot;</span>);<br>         &#125;);<br>         Console.WriteLine(<span class="hljs-string">&quot;Before start:&quot;</span> + task1.Status);<br>         task1.Start();<br>         Console.WriteLine(<span class="hljs-string">&quot;After start:&quot;</span> + task1.Status);<br>         task1.Wait();<br>         Console.WriteLine(<span class="hljs-string">&quot;After Finish:&quot;</span> + task1.Status);<br></code></pre></td></tr></table></figure><h2 id="5-4-Task的使用方法"><a href="#5-4-Task的使用方法" class="headerlink" title="5.4 Task的使用方法"></a>5.4 Task的使用方法</h2><h3 id="5-4-1-启动任务"><a href="#5-4-1-启动任务" class="headerlink" title="5.4.1 启动任务"></a>5.4.1 启动任务</h3><p>以下程序演示了几种通过Task类启动任务的方式：</p><ul><li><p>实例化后手动start()</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>    &#123;<br>       <span class="hljs-comment">//TODO you code</span><br>    &#125;);<br>   task1.Start();<br></code></pre></td></tr></table></figure></li><li><p>使用Task工厂对象创建新任务并执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>工厂创建，直接执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadExample</span><br> &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>     &#123;<br>         TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>         Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br><br>         Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br><br>         Task t3 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task constructor and start&quot;</span>);<br>         t3.Start();<br><br>         <span class="hljs-comment">//需要.NetFramework 4.5以上</span><br>         <span class="hljs-keyword">var</span> t4 = Task.Run(() =&gt; TaskMethod.DoTask(<span class="hljs-string">&quot;using Run method&quot;</span>));<br><br>         Console.ReadKey();<br>     &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">TaskMethod</span><br> &#123;<br>     <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> taskLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> msg</span>)</span><br><span class="hljs-function"></span>     &#123;<br>         <span class="hljs-keyword">lock</span> (taskLock)<br>         &#123;<br>             Console.WriteLine(msg);<br>             Console.WriteLine(<span class="hljs-string">&quot;Task id:&#123;0&#125;, Thread id :&#123;1&#125;&quot;</span>,<br>                            Task.CurrentId == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;no task&quot;</span> : Task.CurrentId.ToString(),<br>                            Thread.CurrentThread.ManagedThreadId);<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-2-任务控制"><a href="#5-4-2-任务控制" class="headerlink" title="5.4.2 任务控制"></a>5.4.2 任务控制</h3><h4 id="5-4-2-1-Task-Wait"><a href="#5-4-2-1-Task-Wait" class="headerlink" title="5.4.2.1 Task.Wait()"></a>5.4.2.1 Task.Wait()</h4><p>就是等待任务执行（task1）完成，task1的状态变为Completed。</p><h4 id="5-4-2-2-Task-WaitAll"><a href="#5-4-2-2-Task-WaitAll" class="headerlink" title="5.4.2.2 Task.WaitAll()"></a>5.4.2.2 Task.WaitAll()</h4><p>等待所有的任务都执行完成：<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAll(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;All task finished!&quot;</span>);<br></code></pre></td></tr></table></figure><p>即当task,task2,task3…N全部任务都执行完成之后才会往下执行代码（打印出：“All task finished!”）</p><h4 id="5-4-2-3-Task-WaitAny"><a href="#5-4-2-3-Task-WaitAny" class="headerlink" title="5.4.2.3 Task.WaitAny()"></a>5.4.2.3 Task.WaitAny()</h4><p>同Task.WaitAll，等待任何一个任务完成就继续向下执行，将上面的代码WaitAll替换为WaitAny</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAny(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;Any task finished!&quot;</span>);<br></code></pre></td></tr></table></figure><p> 即当task,task2,task3…N任意一个任务都执行完成之后就会往下执行代码（打印出：” Any task finished!”）</p><h4 id="5-4-2-4-Task-ContinueWith"><a href="#5-4-2-4-Task-ContinueWith" class="headerlink" title="5.4.2.4 Task.ContinueWith()"></a>5.4.2.4 Task.ContinueWith()</h4><p>在第一个Task完成后自动启动下一个Task，实现Task的延续，编写如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>    Task t1 = tf.StartNew(()=&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务1\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t2 = t1.ContinueWith((t) =&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务2\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t3 = t2.ContinueWith(<span class="hljs-built_in">delegate</span>(Task t) <br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务3\r\n&quot;</span>);<br>    &#125;, TaskContinuationOptions.OnlyOnRanToCompletion);<br><br>    Console.ReadKey(); <br>&#125;<br>    <span class="hljs-comment">//执行结果</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//Current Task id = 1</span><br>    <span class="hljs-comment">//执行任务1</span><br><br>    <span class="hljs-comment">//Last Task id = 1</span><br>    <span class="hljs-comment">//Current Task id = 2</span><br>    <span class="hljs-comment">//执行任务2</span><br><br>    <span class="hljs-comment">//Last Task id = 2</span><br>    <span class="hljs-comment">//Current Task id = 3</span><br>    <span class="hljs-comment">//执行任务3</span><br></code></pre></td></tr></table></figure><p>从执行结果可以看出，任务1，2，3被顺序执行，同时通过 TaskContinuationOptions 还可以指定何种情况下继续执行该任务，常用的值包括OnlyOnFaulted, OnlyOnCanceled, NotOnFaulted, NotOnCanceled等。如将上例中的OnlyOnRanToCompletion改为OnlyOnFaulted，任务2结束之后，任务3将不被执行。</p><p>对于ContinueWith()的使用，MSDN演示了更加优雅的“流式”调用方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)  </span><br><span class="hljs-function"></span>&#123;  <br>   <span class="hljs-keyword">var</span> backgroundScheduler = TaskScheduler.Default;  <br>   <span class="hljs-keyword">var</span> uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  <br>   Task.Factory.StartNew(<span class="hljs-built_in">delegate</span> &#123; DoBackgroundComputation(); &#125;,  <br>                         backgroundScheduler).  <br>   ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUI(); &#125;, uiScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; DoAnotherBackgroundComputation(); &#125;,  <br>                             backgroundScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUIAgain(); &#125;, uiScheduler);  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="5-4-2-5-RunSynchronously"><a href="#5-4-2-5-RunSynchronously" class="headerlink" title="5.4.2.5 RunSynchronously()"></a>5.4.2.5 RunSynchronously()</h4><p>用于实现同步调用，直接在当前线程上调用该任务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskMethod.DoTask(<span class="hljs-string">&quot;Just Main thread&quot;</span>);<br>    Task t1 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using Run Sync&quot;</span>);<br>    t1.RunSynchronously();<br>    <span class="hljs-comment">//输出结果</span><br>    <span class="hljs-comment">//Just Main thread</span><br>    <span class="hljs-comment">//Task id: no task, Thread id: 9</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//using Run Sync</span><br>    <span class="hljs-comment">//Task id:1, Thread id :9</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-3-任务取消"><a href="#5-4-3-任务取消" class="headerlink" title="5.4.3 任务取消"></a>5.4.3 任务取消</h3><p>当我们启动了一个task,出现异常或者用户点击取消等等，我们可以取消这个任务。</p><p>我们通过cancellation的tokens来取消一个Task。<br>在很多Task的Body里面包含循环，我们可以在轮询的时候判断IsCancellationRequested属性是否为True<br>如果是True的话就return或者抛出异常，抛出异常后面再说，因为还没有说异常处理的东西。</p><p>下面在代码中看下如何实现任务的取消，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#">　　　　<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br><span class="hljs-keyword">var</span> token = tokenSource.Token;<br><span class="hljs-keyword">var</span> task = Task.Factory.StartNew(() =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>    &#123;<br>        System.Threading.Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">if</span> (token.IsCancellationRequested)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Abort mission success!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;, token);<br>token.Register(() =&gt;<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>&#125;);<br>Console.WriteLine(<span class="hljs-string">&quot;Press enter to cancel task...&quot;</span>);<br>Console.ReadKey();<br>tokenSource.Cancel();<span class="hljs-number">123456789101112131415161718192021</span><br></code></pre></td></tr></table></figure><p>这里开启了一个Task,并给token注册了一个方法，输出一条信息，然后执行ReadKey开始等待用户输入，用户点击回车后，执行tokenSource.Cancel方法，取消任务。</p><blockquote><p>注意：<br>因为任务通常运行以异步方式在线程池线程上，创建并启动任务的线程将继续执行，一旦该任务已实例化。<br>在某些情况下，当调用线程的主应用程序线程，该应用程序可能会终止之前任何任务实际开始执行。<br>其他情况下，应用程序的逻辑可能需要调用线程继续执行，仅当一个或多个任务执行完毕。<br>您可以同步调用线程的执行，以及异步任务它启动通过调用 Wait 方法来等待要完成的一个或多个任务。<br>若要等待完成一项任务，可以调用其 Task.Wait 方法。<br>调用 Wait 方法将一直阻塞调用线程直到单一类实例都已完成执行。</p></blockquote><h3 id="5-4-4-接收任务的返回值"><a href="#5-4-4-接收任务的返回值" class="headerlink" title="5.4.4 接收任务的返回值"></a>5.4.4 接收任务的返回值</h3><p>对于任务有返回值的情况，可使用Task<TResult>泛型类，TResult定义了返回值的类型，以下代码演示了调用返回int值的任务的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">var</span> t5 = <span class="hljs-keyword">new</span> Task&lt;<span class="hljs-built_in">int</span>&gt;(TaskWithResult, Tuple.Create&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    t5.Start();<br>    t5.Wait();<br>    Console.WriteLine(<span class="hljs-string">&quot;adder results: &#123;0&#125;&quot;</span>, t5.Result);<br><br>    Console.ReadKey(); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">TaskWithResult</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> o</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; adder = (Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;)o;<br>    <span class="hljs-keyword">return</span> adder.Item1 + adder.Item2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-任务的层次结构"><a href="#5-5-任务的层次结构" class="headerlink" title="5.5 任务的层次结构"></a>5.5 任务的层次结构</h2><p>如果在一个Task内部创建了另一个任务，这两者间就存在父/子的层次结构，当父任务被取消时，子任务也会被取消。</p><p>如果不希望使用该层次结构，可在创建子任务时选择TaskCreationOptions.DetachedFromParent。</p><h1 id="6-BackgroundWorker控件"><a href="#6-BackgroundWorker控件" class="headerlink" title="6. BackgroundWorker控件"></a>6. BackgroundWorker控件</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>C#提供了BackgroundWorker控件帮助用户更简单、安全地实现多线程运算。</p><p>该控件提供了DoWork, ProgressChanged 和 RunWorkerCompleted事件<br>为DoWork添加事件处理函数，再调用RunWorkerAsync()方法，即可创建一个新的线程执行DoWork任务</p><p>ProgressChanged和RunWorkerCompleted事件均在UI线程中执行，添加相应的处理函数，即可完成任务线程与UI线程间的交互，可用于显示任务的执行状态（完成百分比）、执行结果等。</p><p>同时，该控件还提供了CancleAsync()方法，以中断线程的执行<br>需注意的是，调用该方法后，只是将控件的CancellationPending属性置True，用户需在程序执行过程中查询该属性以判定是否应中断线程。</p><p>具体用法可参考MSDN：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker?view=netframework-4.7.2">BackgroundWorker用法范例</a><br>可以看的出来，BackgroundWorker组件提供了一种执行异步操作（后台线程）的同时，并且还能妥妥的显示操作进度的解决方案。</p><h2 id="6-2-属性表"><a href="#6-2-属性表" class="headerlink" title="6.2 属性表"></a>6.2 属性表</h2><h3 id="6-2-1-WorkerReportsProgress"><a href="#6-2-1-WorkerReportsProgress" class="headerlink" title="6.2.1 WorkerReportsProgress"></a>6.2.1 WorkerReportsProgress</h3><p>bool类型，指示BackgroundWorker是否可以报告进度更新。</p><ul><li>True时，可以成功调用ReportProgress方法</li><li>否则将引发InvalidOperationException异常</li></ul><p>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> BackgroundWorker bgWorker = <span class="hljs-keyword">new</span> BackgroundWorker();<br>bgWorker.WorkerReportsProgress = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-2-WorkerSupportsCancellation"><a href="#6-2-2-WorkerSupportsCancellation" class="headerlink" title="6.2.2 WorkerSupportsCancellation"></a>6.2.2 WorkerSupportsCancellation</h3><p>bool类型，指示BackgroundWorker是否支持异步取消操作</p><ul><li><p>True时，将可以成功调用CancelAsync方法</p></li><li><p>否则将引发InvalidOperationException异<br>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">bgWorker.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-3-CancellationPending"><a href="#6-2-3-CancellationPending" class="headerlink" title="6.2.3 CancellationPending"></a>6.2.3 CancellationPending</h3><p>bool类型，指示应用程序是否已请求取消后台操作。<br>此属性通常放在用户执行的异步操作内部，用来判断用户是否取消执行异步操作。<br>当执行BackgroundWorker.CancelAsync()方法时，该属性值将变为True。<br>用法：</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在DoWork中键入如下代码</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (bgWorker.CancellationPending)<br>      &#123;<br>          e.Cancel = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>          bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>          System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>      &#125;<br>  &#125;   <br></code></pre></td></tr></table></figure><h3 id="6-2-4-IsBusy"><a href="#6-2-4-IsBusy" class="headerlink" title="6.2.4 IsBusy"></a>6.2.4 IsBusy</h3><p>bool类型，指示BackgroundWorker是否正在执行一个异步操作。<br>此属性通常放在BackgroundWorker.RunWorkerAsync()方法之前，避免多次调用RunWorkerAsync()方法引发异常。<br>当执行BackgroundWorker.RunWorkerAsync()方法是，该属性值将变为True。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//防止重复执行异步操作引发错误</span><br> <span class="hljs-keyword">if</span> (bgWorker.IsBusy)<br>     <span class="hljs-keyword">return</span>;<br> bgWorker.RunWorkerAsync();<br></code></pre></td></tr></table></figure><h2 id="6-3-方法表"><a href="#6-3-方法表" class="headerlink" title="6.3 方法表"></a>6.3 方法表</h2><h3 id="6-3-1-RunWorkerAsync"><a href="#6-3-1-RunWorkerAsync" class="headerlink" title="6.3.1 RunWorkerAsync()"></a>6.3.1 RunWorkerAsync()</h3><p>开始执行一个后台操作。</p><p>调用该方法后，将触发BackgroundWorker.DoWork事件，并以异步的方式执行DoWork事件中的代码。<br>该方法还有一个带参数的重载方法：RunWorkerAsync(Object)。<br>该方法允许传递一个Object类型的参数到后台操作中，并且可以通过DoWork事件的DoWorkEventArgs.Argument属性将该参数提取出来。</p><blockquote><p>注：当BackgroundWorker的IsBusy属性为True时，调用该方法将引发InvalidOperationException异常。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在启动异步操作的地方键入代码</span><br>bgWorker.RunWorkerAsync(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="6-3-2-ReportProgress-Int-percentProgress"><a href="#6-3-2-ReportProgress-Int-percentProgress" class="headerlink" title="6.3.2 ReportProgress(Int percentProgress)"></a>6.3.2 ReportProgress(Int percentProgress)</h3><p>报告操作进度。</p><p>调用该方法后，将触发BackgroundWorker. ProgressChanged事件。<br>另外，该方法包含了一个int类型的参数percentProgress，用来表示当前异步操作所执行的进度百分比。</p><p>该方法还有一个重载方法：ReportProgress(Int percentProgress, Object userState)。<br>允许传递一个Object类型的状态对象到 ProgressChanged事件中<br>并且可以通过ProgressChanged事件的ProgressChangedEventArgs.UserState属性取得参数值。</p><blockquote><p>注：调用该方法之前需确保WorkerReportsProgress属性值为True，否则将引发InvalidOperationException异常。</p></blockquote><p>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>&#123;c<br>    <span class="hljs-comment">//向ProgressChanged报告进度</span><br>    bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>    System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-3-CancelAsync"><a href="#6-3-3-CancelAsync" class="headerlink" title="6.3.3 CancelAsync()"></a>6.3.3 CancelAsync()</h3><p>请求取消当前正在执行的异步操作。</p><p>调用该方法将使BackgroundWorker.CancellationPending属性设置为True。<br>但需要注意的是，并非每次调用CancelAsync()都能确保异步操作，CancelAsync()通常不适用于取消一个紧密执行的操作，更适用于在循环体中执行。<br>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在需要执行取消操作的地方键入以下代码</span><br>bgWorker.CancelAsync();<br></code></pre></td></tr></table></figure><h2 id="6-4-事件表"><a href="#6-4-事件表" class="headerlink" title="6.4 事件表"></a>6.4 事件表</h2><h3 id="6-4-1-DoWork"><a href="#6-4-1-DoWork" class="headerlink" title="6.4.1 DoWork"></a>6.4.1 DoWork</h3><p>用于承载异步操作。当调用BackgroundWorker.RunWorkerAsync()时触发。</p><p>需要注意的是：<br>由于DoWork事件内部的代码运行在非UI线程之上，所以在DoWork事件内部应避免于用户界面交互，<br>而于用户界面交互的操作应放置在ProgressChanged和RunWorkerCompleted事件中。</p><h3 id="6-4-2-ProgressChanged"><a href="#6-4-2-ProgressChanged" class="headerlink" title="6.4.2 ProgressChanged"></a>6.4.2 ProgressChanged</h3><p>当调用BackgroundWorker.ReportProgress(int percentProgress)方式时触发该事件。<br>该事件的ProgressChangedEventArgs.ProgressPercentage属性可以接收来自ReportProgress方法传递的percentProgress参数值,ProgressChangedEventArgs.UserState属性可以接收来自ReportProgress方法传递的userState参数。</p><h3 id="6-4-3-RunWorkerCompleted"><a href="#6-4-3-RunWorkerCompleted" class="headerlink" title="6.4.3 RunWorkerCompleted"></a>6.4.3 RunWorkerCompleted</h3><p>异步操作完成或取消时执行的操作，当调用DoWork事件执行完成时触发。</p><p>该事件的RunWorkerCompletedEventArgs参数包含三个常用的属性Error,Cancelled,Result。其中，Error表示在执行异步操作期间发生的错误；Cancelled用于判断用户是否取消了异步操作；Result属性接收来自DoWork事件的DoWorkEventArgs参数的Result属性值，可用于传递异步操作的执行结果。</p><h2 id="6-3-案例"><a href="#6-3-案例" class="headerlink" title="6.3 案例"></a>6.3 案例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.ComponentModel;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br> <br><span class="hljs-keyword">namespace</span> <span class="hljs-title">bcworker</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br>        <span class="hljs-comment">//后台工作</span><br>        <span class="hljs-keyword">private</span> BackgroundWorker bw = <span class="hljs-keyword">new</span> BackgroundWorker();<br> <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>            <span class="hljs-comment">//后台工作初始化</span><br>            bw.WorkerReportsProgress = <span class="hljs-literal">true</span>;<span class="hljs-comment">//报告进度</span><br>            bw.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<span class="hljs-comment">//支持取消</span><br>            bw.DoWork += <span class="hljs-keyword">new</span> DoWorkEventHandler(bgWorker_DoWork);<span class="hljs-comment">//开始工作</span><br>            bw.ProgressChanged += <span class="hljs-keyword">new</span> ProgressChangedEventHandler(bgWorker_ProgessChanged);<span class="hljs-comment">//进度改变事件</span><br>            bw.RunWorkerCompleted += <span class="hljs-keyword">new</span> RunWorkerCompletedEventHandler(bgWorker_WorkerCompleted);<span class="hljs-comment">//进度完成事件</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnStart_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//后台工作运行中，避免重入</span><br>            <span class="hljs-keyword">if</span> (bw.IsBusy) <span class="hljs-keyword">return</span>;<br>            bw.RunWorkerAsync(<span class="hljs-string">&quot;参数&quot;</span>);<span class="hljs-comment">//触发DoWork事件并异步执行，IsBusy置为True</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作将异步执行</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_DoWork</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, DoWorkEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.Argument == &quot;参数&quot;;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>            &#123;<br> <br>                <span class="hljs-keyword">if</span> (bw.CancellationPending)<br>                &#123;<span class="hljs-comment">//用户取消了工作</span><br>                    e.Cancel = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    bw.ReportProgress(i, <span class="hljs-string">&quot;Working&quot;</span>);<span class="hljs-comment">//报告进度，触发ProgressChanged事件</span><br>                    Thread.Sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//模拟工作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//进度改变事件</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_ProgessChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, ProgressChangedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.UserState==&quot;Working&quot;</span><br>            progressBar1.Value = e.ProgressPercentage;<span class="hljs-comment">//取得进度更新控件，不用Invoke了</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作执行完毕,IsBusy置为False</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_WorkerCompleted</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//e.Error == null 是否发生错误</span><br>            <span class="hljs-comment">//e.Cancelled 完成是由于取消还是正常完成</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span> (bw.IsBusy) bw.CancelAsync();<span class="hljs-comment">//设置CancellationPending属性为True</span><br>        &#125;<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InvalidOperationException</title>
    <link href="/2021/05/23/InvalidOperationException/"/>
    <url>/2021/05/23/InvalidOperationException/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是InvalidOperationException"><a href="#1-什么是InvalidOperationException" class="headerlink" title="1. 什么是InvalidOperationException"></a>1. 什么是InvalidOperationException</h1><p>操作无效异常。当方法调用对对象的当前状态无效时引发的异常。</p><h1 id="2-继承树"><a href="#2-继承树" class="headerlink" title="2. 继承树"></a>2. 继承树</h1><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netframework-4.8">Object</a></p><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.exception?view=netframework-4.8">Exception</a></p><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.systemexception?view=netframework-4.8">SystemException</a></p><p>InvalidOperationException</p><h1 id="3-详细说明"><a href="#3-详细说明" class="headerlink" title="3. 详细说明"></a>3. 详细说明</h1><p>如果调用方法失败是由无效参数以外的其他原因导致的,则使用该异常。<br>通常, 当对象的状态不支持方法调用时, 将引发此异常。<br>例如, 以下方法或原因会引发异常nvalidOperationException:</p><ul><li>IEnumerator.MoveNext如果在创建枚举器后修改集合的对象,。</li><li>ResourceSet.GetString如果在执行方法调用前关闭资源集,。</li><li>XContainer.Add如果要添加的对象将导致结构不正确的 XML 文档,。</li><li>尝试从非主线程或 UI 线程的线程操作 UI 的方法。</li><li>从非 UI 线程更新 UI 线程</li><li>在循环访问集合时更改集合</li><li>对其对象无法进行比较的数组或集合进行排序</li><li>将为 null <T>转换为其基础类型</li><li>对空集合调用 system.exception 方法</li><li>对没有一个元素的序列调用 SingleOrDefault 或可枚举的。</li><li>动态跨应用程序域字段访问</li></ul><p>由于InvalidOperationException异常可以在多种情况下引发，因此读取由message属性返回的异常消息非常重要。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#BUG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>C#BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#序列化</title>
    <link href="/2021/05/23/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2021/05/23/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是序列化"><a href="#1-1-什么是序列化" class="headerlink" title="1.1 什么是序列化"></a>1.1 什么是序列化</h2><p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。<br>在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p><h2 id="1-2-序列化的目的"><a href="#1-2-序列化的目的" class="headerlink" title="1.2 序列化的目的"></a>1.2 序列化的目的</h2><p>1、方便对象长久存储</p><p>2、方便对象传输</p><p>3、使程序更具维护性</p><h2 id="1-3-序列化操作"><a href="#1-3-序列化操作" class="headerlink" title="1.3 序列化操作"></a>1.3 序列化操作</h2><ul><li><p>序列化<br>将对象转换为字符串或二进制数据，以便存储或传输</p></li><li><p>反序列化<br>将字符串或二进制数据还原成对象</p></li><li><p>无序列化<br>标明对象的属性中哪些属性不需要序列化<br><img src="../images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523182615355.png" srcset="/img/loading.gif" alt="image-20210523182615355"></p></li></ul><h2 id="1-4-常用的序列化格式"><a href="#1-4-常用的序列化格式" class="headerlink" title="1.4 常用的序列化格式"></a>1.4 常用的序列化格式</h2><ul><li><p>Binary(二进制)</p><ul><li>protocol buffer</li></ul></li><li><p>XML</p></li><li><p>JSON(最先进，最推荐)</p><blockquote><p><a href="https://www.bejson.com/">在线JSON格式化校验</a></p></blockquote></li></ul><p>性能指标：Binary&gt;JSON&gt;XML</p><h1 id="2-Binary序列化"><a href="#2-Binary序列化" class="headerlink" title="2. Binary序列化"></a>2. Binary序列化</h1><p>略，求求你，用json吧！</p><p><strong>protocol buffer</strong>是Google的一种<strong>独立和轻量级</strong>的数据交换格式。以<strong>二进制结构</strong>进行存储。</p><h1 id="3-XML序列化"><a href="#3-XML序列化" class="headerlink" title="3. XML序列化"></a>3. XML序列化</h1><p>略，求求你，用json吧！</p><p><strong>XML</strong> 指可扩展标记语言（e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage）。是一种<strong>通用和重量级</strong>的数据交换格式。以<strong>文本结构</strong>存储。</p><p>格式很像HTML</p><h1 id="4-JSON序列化"><a href="#4-JSON序列化" class="headerlink" title="4. JSON序列化"></a>4. JSON序列化</h1><h2 id="4-1-JSON简介"><a href="#4-1-JSON简介" class="headerlink" title="4.1 JSON简介"></a>4.1 JSON简介</h2><p><strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JSON">JSON</a></strong>(<strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">J</a></strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">ava</a><strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">S</a></strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">cript</a> <strong>O</strong>bject <strong>N</strong>otation, JS 对象简谱) 是一种<strong>通用和轻量级</strong>的数据交换格式。以<strong>文本结构</strong>存储，它是完全独立于语言的。</p><h3 id="4-1-1-支持的数据结构"><a href="#4-1-1-支持的数据结构" class="headerlink" title="4.1.1 支持的数据结构"></a>4.1.1 支持的数据结构</h3><p>Json支持下面两种数据结构：</p><ul><li>键值对的集合–各种不同的编程语言，都支持这种数据结构；</li><li>有序的列表类型值的集合–这其中包含数组，集合，矢量，或者序列，等等。</li></ul><h3 id="4-1-2-表现形式"><a href="#4-1-2-表现形式" class="headerlink" title="4.1.2 表现形式"></a>4.1.2 表现形式</h3><h4 id="4-1-2-1-对象"><a href="#4-1-2-1-对象" class="headerlink" title="4.1.2.1 对象"></a>4.1.2.1 对象</h4><p>一个没有顺序的“键/值”,一个对象以花括号“{”开始，并以花括号”}”结束，在每一个“键”的后面，有一个冒号，并且使用逗号来分隔多个键值对。</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var user =  &#123;``&quot;name&quot;``:``&quot;Manas&quot;``,``&quot;gender&quot;``:``&quot;Male&quot;``,``&quot;birthday&quot;``:``&quot;1987-8-8&quot;``&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-2-数组"><a href="#4-1-1-2-数组" class="headerlink" title="4.1.1.2 数组"></a>4.1.1.2 数组</h4><p>设置值的顺序，一个数组以中括号”[“开始,并以中括号”]”结束，并且所有的值使用逗号分隔</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var userlist = [&#123;``&quot;user&quot;``:&#123;``&quot;name&quot;``:``&quot;Manas&quot;``,``&quot;gender&quot;``:``&quot;Male&quot;``,``&quot;birthday&quot;``:``&quot;1987-8-8&quot;``&#125;&#125;, ``&#123;``&quot;user&quot;``:&#123;``&quot;name&quot;``:``&quot;Mohapatra&quot;``,``&quot;Male&quot;``:``&quot;Female&quot;``,``&quot;birthday&quot;``:``&quot;1987-7-7&quot;``&#125;&#125;]<br></code></pre></td></tr></table></figure><h4 id="4-1-1-3-字符串"><a href="#4-1-1-3-字符串" class="headerlink" title="4.1.1.3 字符串"></a>4.1.1.3 字符串</h4><p>任意数量的Unicode字符，使用引号做标记，并使用反斜杠来分隔。</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var userlist = ``&quot;&#123;\&quot;ID\&quot;:1,\&quot;Name\&quot;:\&quot;Manas\&quot;,\&quot;Address\&quot;:\&quot;India\&quot;&#125;&quot;<br></code></pre></td></tr></table></figure><h2 id="4-2-C-使用JSON序列化"><a href="#4-2-C-使用JSON序列化" class="headerlink" title="4.2 C#使用JSON序列化"></a>4.2 C#使用JSON序列化</h2><p><strong>序列化和反序列化有三种方式：</strong></p><ol><li><p>使用<code>JavaScriptSerializer</code>类</p></li><li><p>使用<code>DataContractJsonSerializer</code>类</p></li><li><p>使用JSON.NET类库</p></li></ol><blockquote><p>第三种最好，求求你直接看第三种吧</p></blockquote><h3 id="4-2-1-使用JavaScriptSerializer类"><a href="#4-2-1-使用JavaScriptSerializer类" class="headerlink" title="4.2.1 使用JavaScriptSerializer类"></a>4.2.1 使用JavaScriptSerializer类</h3><p><code>DataContractJsonSerializer</code>类帮助我们序列化和反序列化Json，他在程序集<code> System.Runtime.Serialization.dll</code>下的<code>System.Runtime.Serialization.Json</code>命名空间里。</p><p><strong>首先，这里，我新建一个控制台的程序，新建一个类Student</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Runtime.Serialization;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">JsonSerializerAndDeSerializer</span><br>&#123;<br> [<span class="hljs-meta">DataContract</span>]<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br> &#123;<br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Sex &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>上面的Student实体中的契约 [DataMember]，[DataContract]，是使用<code>DataContractJsonSerializer</code>序列化和反序列化必须要加的，对于其他两种方式不必加，也可以的。</p><p><strong>我们程序的代码：</strong></p><p>要先引用程序集，在引入这个命名空间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//使用DataContractJsonSerializer方式需要引入的命名空间，在System.Runtime.Serialization.dll.中</span><br><span class="hljs-keyword">using</span> System.Runtime.Serialization.Json;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 1.DataContractJsonSerializer方式序列化和反序列化</span><br>   Student stu = <span class="hljs-keyword">new</span> Student()<br>    &#123;<br>     ID = <span class="hljs-number">1</span>,<br>     Name = <span class="hljs-string">&quot;曹操&quot;</span>,<br>     Sex = <span class="hljs-string">&quot;男&quot;</span>,<br>     Age = <span class="hljs-number">1000</span><br>    &#125;;<br>   <span class="hljs-comment">//序列化</span><br>   DataContractJsonSerializer js = <span class="hljs-keyword">new</span> DataContractJsonSerializer(<span class="hljs-keyword">typeof</span>(Student));<br>   MemoryStream msObj = <span class="hljs-keyword">new</span> MemoryStream();<br>   <span class="hljs-comment">//将序列化之后的Json格式数据写入流中</span><br>   js.WriteObject(msObj, stu);<br>   msObj.Position = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">//从0这个位置开始读取流中的数据</span><br>   StreamReader sr = <span class="hljs-keyword">new</span> StreamReader(msObj, Encoding.UTF8);<br>   <span class="hljs-built_in">string</span> json = sr.ReadToEnd();<br>   sr.Close();<br>   msObj.Close();<br>   Console.WriteLine(json);<br><br>   <span class="hljs-comment">//反序列化</span><br>   <span class="hljs-built_in">string</span> toDes = json;<br>   <span class="hljs-comment">//string to = &quot;&#123;\&quot;ID\&quot;:\&quot;1\&quot;,\&quot;Name\&quot;:\&quot;曹操\&quot;,\&quot;Sex\&quot;:\&quot;男\&quot;,\&quot;Age\&quot;:\&quot;1230\&quot;&#125;&quot;;</span><br>   <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> ms = <span class="hljs-keyword">new</span> MemoryStream(Encoding.Unicode.GetBytes(toDes)))<br>   &#123;<br>    DataContractJsonSerializer deseralizer = <span class="hljs-keyword">new</span> DataContractJsonSerializer(<span class="hljs-keyword">typeof</span>(Student));<br>    Student model = (Student)deseralizer.ReadObject(ms);<span class="hljs-comment">// //反序列化ReadObject</span><br>    Console.WriteLine(<span class="hljs-string">&quot;ID=&quot;</span> + model.ID);<br>    Console.WriteLine(<span class="hljs-string">&quot;Name=&quot;</span> + model.Name);<br>    Console.WriteLine(<span class="hljs-string">&quot;Age=&quot;</span> + model.Age);<br>    Console.WriteLine(<span class="hljs-string">&quot;Sex=&quot;</span> + model.Sex);<br>   &#125;<br>   Console.ReadKey(); <br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><p>运行之后结果是：</p><p><img src="/images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181440077.png" srcset="/img/loading.gif" alt="image-20210523181440077"></p><h3 id="4-2-2-使用JavaScriptJsonSerializer类"><a href="#4-2-2-使用JavaScriptJsonSerializer类" class="headerlink" title="4.2.2 使用JavaScriptJsonSerializer类"></a>4.2.2 使用JavaScriptJsonSerializer类</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-comment">//使用JavaScriptSerializer方式需要引入的命名空间，这个在程序集System.Web.Extensions.dll.中</span><br><span class="hljs-keyword">using</span> System.Web.Script.Serialization;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 2.JavaScriptSerializer方式实现序列化和反序列化</span><br>   Student stu = <span class="hljs-keyword">new</span> Student()<br>    &#123;<br>     ID = <span class="hljs-number">1</span>,<br>     Name = <span class="hljs-string">&quot;关羽&quot;</span>,<br>     Age = <span class="hljs-number">2000</span>,<br>     Sex = <span class="hljs-string">&quot;男&quot;</span><br>    &#125;;<br><br>   JavaScriptSerializer js = <span class="hljs-keyword">new</span> JavaScriptSerializer();<br>   <span class="hljs-built_in">string</span> jsonData = js.Serialize(stu);<span class="hljs-comment">//序列化</span><br>   Console.WriteLine(jsonData);<br><br><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span>/反序列化方式一：</span><br>   <span class="hljs-built_in">string</span> desJson = jsonData;<br>   <span class="hljs-comment">//Student model = js.Deserialize&lt;Student&gt;(desJson);// //反序列化</span><br>   <span class="hljs-comment">//string message = string.Format(&quot;ID=&#123;0&#125;,Name=&#123;1&#125;,Age=&#123;2&#125;,Sex=&#123;3&#125;&quot;, model.ID, model.Name, model.Age, model.Sex);</span><br>   <span class="hljs-comment">//Console.WriteLine(message);</span><br>   <span class="hljs-comment">//Console.ReadKey(); </span><br><br><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span>/反序列化方式2</span><br>   <span class="hljs-built_in">dynamic</span> modelDy = js.Deserialize&lt;<span class="hljs-built_in">dynamic</span>&gt;(desJson); <span class="hljs-comment">//反序列化</span><br>   <span class="hljs-built_in">string</span> messageDy = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;动态的反序列化,ID=&#123;0&#125;,Name=&#123;1&#125;,Age=&#123;2&#125;,Sex=&#123;3&#125;&quot;</span>,<br>    modelDy[<span class="hljs-string">&quot;ID&quot;</span>], modelDy[<span class="hljs-string">&quot;Name&quot;</span>], modelDy[<span class="hljs-string">&quot;Age&quot;</span>], modelDy[<span class="hljs-string">&quot;Sex&quot;</span>]);<span class="hljs-comment">//这里要使用索引取值，不能使用对象.属性</span><br>   Console.WriteLine(messageDy);<br>   Console.ReadKey(); <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span> </span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181633952.png" srcset="/img/loading.gif" alt="image-20210523181633952"></p><h3 id="4-2-3-使用JSON-NET类库-推荐"><a href="#4-2-3-使用JSON-NET类库-推荐" class="headerlink" title="4.2.3 使用JSON.NET类库(推荐)"></a>4.2.3 使用JSON.NET类库(推荐)</h3><p>首先在NuGet上下载Json.NET类库。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//使用Json.NET类库需要引入的命名空间</span><br><span class="hljs-keyword">using</span> Newtonsoft.Json;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 3.Json.NET序列化</span><br>   List&lt;Student&gt; lstStuModel = <span class="hljs-keyword">new</span> List&lt;Student&gt;() <br>   &#123;<br>   <br>   <span class="hljs-keyword">new</span> Student()&#123;ID=<span class="hljs-number">1</span>,Name=<span class="hljs-string">&quot;张飞&quot;</span>,Age=<span class="hljs-number">250</span>,Sex=<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>   <span class="hljs-keyword">new</span> Student()&#123;ID=<span class="hljs-number">2</span>,Name=<span class="hljs-string">&quot;潘金莲&quot;</span>,Age=<span class="hljs-number">300</span>,Sex=<span class="hljs-string">&quot;女&quot;</span>&#125;<br>   &#125;;<br><br>   <span class="hljs-comment">//Json.NET序列化</span><br>   <span class="hljs-built_in">string</span> jsonData = JsonConvert.SerializeObject(lstStuModel);<br><br>   Console.WriteLine(jsonData);<br>   Console.ReadKey();<br><br><br>   <span class="hljs-comment">//Json.NET反序列化</span><br>   <span class="hljs-built_in">string</span> json = <span class="hljs-string">@&quot;&#123; &#x27;Name&#x27;:&#x27;C#&#x27;,&#x27;Age&#x27;:&#x27;3000&#x27;,&#x27;ID&#x27;:&#x27;1&#x27;,&#x27;Sex&#x27;:&#x27;女&#x27;&#125;&quot;</span>;<br>   Student descJsonStu = JsonConvert.DeserializeObject&lt;Student&gt;(json);<span class="hljs-comment">//反序列化</span><br>   Console.WriteLine(<span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;反序列化： ID=&#123;0&#125;,Name=&#123;1&#125;,Sex=&#123;2&#125;,Sex=&#123;3&#125;&quot;</span>, descJsonStu.ID, descJsonStu.Name, descJsonStu.Age, descJsonStu.Sex));<br>   Console.ReadKey(); <br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181908106.png" srcset="/img/loading.gif" alt="image-20210523181908106"></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader的形式</title>
    <link href="/2021/05/23/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/"/>
    <url>/2021/05/23/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>UnityShader最重要的任务是：指定各种着色器所需的代码</p><p>而代码的编写形式有以下三种</p><h1 id="2-长子：顶点-片元着色器"><a href="#2-长子：顶点-片元着色器" class="headerlink" title="2. 长子：顶点/片元着色器"></a>2. 长子：顶点/片元着色器</h1><p>在Unity中我们可以使用<strong>CG/HLSL语言</strong>来编写**顶点/片元着色器(Vertex/Fragment Shader)**。<br>它更复杂也更灵活。</p><p>它写在Pass语句块内，格式如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">Shader <span class="hljs-string">&quot;Unlit/MyFirstShader&quot;</span><br>&#123;<br>Properties<br>&#123;<br>_Color(<span class="hljs-string">&quot;Color&quot;</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>&#125;<br><br>SubShader<br>&#123;<br>Pass<br>&#123;<br><span class="hljs-built_in">CGPROGRAM</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span><br><br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>#pragma是Unity内置的编绎指令用的命令<br>在Pass中我们就利用此命令来声明所需要的顶点着色器与片元着色器。</p><ul><li><p>#pragma vertexName<br>定义顶点着色器为*name,*通常情况下会起名为vert。</p></li><li><p>#pragma fragmentName<br>定义片元着色器为*name,*通常情况下会起名为frag。</p></li></ul><h2 id="2-1-顶点着色器"><a href="#2-1-顶点着色器" class="headerlink" title="2.1 顶点着色器"></a>2.1 顶点着色器</h2><p>顶点着色器就是处理顶点的着色器，每个顶点都会执行一次顶点着色器。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">float4 <span class="hljs-title">vert</span><span class="hljs-params">(float4 vertex:POSITION)</span>:SV_POSITION</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> UnityObjectToClipPos(vertex);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/image-20210523163930947.png" srcset="/img/loading.gif" alt="image-20210523163930947"></p><p>首先呢，我们先来解释下顶点这个函数的结构。</p><ol><li>顶点着色器函数的名称，在上面我们已经指定了顶点着色器的名称就是vert，所以这里我们必须要用vert作为名称。</li><li>其中float4 vertex是我们自己定义的一个四维向量，名字叫vertex（名字我们可以随便起），仅仅定义一个四维向量并不能使它拥有我们模型的顶点信息，所以这里我们需要为它指定一个语义——POSITION，POSITION就是代表着模型的顶点位置信息。此时变量vertex就表示着我们模型的顶点位置。</li><li>在顶色着色器中最主要的事情就是将顶点从模型坐标转换到裁剪坐标（将模型显示在二维显示器上时需要做的一些矩阵转换）。<br>不会矩阵转换怎么办，没关系，Unity已经为我们准备好现成的命令了，只需调用UnityObjectToClipPos即可，后面括号中加上我们的顶点位置变量就可以了。</li><li>在后面片断着色器中我们需要顶点着色器中的输出结果，所以3中需要加上return来将转换后的顶点返回，float4就是用来定义我们返回的是四维向量。</li><li>经过变换后返回的顶点位置，我们也需要利用语义来标记一下，以便片元着色器可以知道哪个是从顶点着色器输出过来的顶点位置信息。所以我们在函数的后面加上: SV_POSITION。</li></ol><blockquote><p>简单地说：<br>POSITION语义是用于顶点着色器，用来指定模型的顶点位置，是在变换前的顶点的本地空间坐标。<br>SV_POSITION语义则用于像素着色器，用来标识经过顶点着色器变换之后的顶点坐标。</p><p>在顶点着色器中处理顶点时，我们首先需要获取到模型的顶点数据（比如顶点位置、法线信息、顶点颜色等等），那么这些数据都是直接存储在模型中的，我们在Shader中只需要通过标识语义就可以自动获得。</p></blockquote><p>此时我们的Shader还不能正常编译，因为了除了顶点着色器外，还们需要一个片断着色器。</p><h2 id="2-2-片元着色器"><a href="#2-2-片元着色器" class="headerlink" title="2.2 片元着色器"></a>2.2 片元着色器</h2><p>片元着色器也被称作像素着色器，主要是处理最终显示在屏幕上的像素结果。</p><p>经过顶点着色器的处理，我们已经得到了最终显示在屏幕上的顶点矩阵，内部会自动进行插值计算，以获得当前模型的所有片元像素，然后每个像素都会执行一次片元着色器，得到最终每个像素的颜色值。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">fixed4 _Color;<br><span class="hljs-function">fixed4 <span class="hljs-title">frag</span> <span class="hljs-params">()</span> : SV_Target</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _Color;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/image-20210523164629339.png" srcset="/img/loading.gif" alt="image-20210523164629339"></p><ol><li><p>片断着色器的函数名，其中()中是空的，因为在这个简单的示例中我们并不需要额外的数据传过来，所以暂时为空。</p></li><li><p>在Cg/HLSL中使用Properties中的变量前还需要在Cg/HLSL中再重新声明一次，名称要求一致。<br>这是死规则，我们只能按照要求来执行。<br>float、half、fixed，这三都是浮点数的表示，只是分别对应的精度不一样，主要用此可以进行更进一步的优化。</p></li><li><p>直接返回_Color,也就是直接返回我们在材质面板中定义的颜色，这也是我们这个小例子想要的效果。</p></li><li><p>返回的值是个四维向量，我们用float4来表示，如果想优化的话就用fixed4来表示，精度问题，这里不是重点。</p></li><li><p>SV_TARGET是系统值，表示该函数返回的是用于下一个阶段输出的颜色值，也就是我们最终输出到显示器上的值。</p></li></ol><h2 id="2-3-最终代码"><a href="#2-3-最终代码" class="headerlink" title="2.3 最终代码"></a>2.3 最终代码</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs text">Shader &quot;Unlit/MyFirstShader&quot;<br>&#123;<br>Properties<br>&#123;<br>_Color(&quot;Color&quot;, Color) = (1,1,1,1)<br>&#125;<br><br>SubShader<br>&#123;<br>Pass<br>&#123;<br>CGPROGRAM<br>#pragma vertex vert<br>#pragma fragment frag<br><br>fixed4 _Color;<br><br>float4 vert ( float4 vertex : POSITION ) : SV_POSITION<br>&#123;<br>return UnityObjectToClipPos(vertex);<br>&#125;<br><br>fixed4 frag () : SV_Target<br>&#123;<br>return _Color;<br>&#125;<br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们已经可以正常编译并实时更换颜色得到反馈了。</p><h2 id="2-4-注意"><a href="#2-4-注意" class="headerlink" title="2.4 注意"></a>2.4 注意</h2><p>顶点着色器与片断着色器的执行并不是1:1的</p><p>例如:<br>一个三角面片，只有三个顶点，顶点着色器只需执行3次，而片断着色器由最终的像素数来决定，执行几百上千都是很正常的。</p><p>所以从性能的角度来考虑，我们要尽量把计算放在顶点着色器中去执行。<br>其次在片断着色器中也要尽量的简化算法，节省开支。</p><h1 id="3-宠儿：表面着色器"><a href="#3-宠儿：表面着色器" class="headerlink" title="3. 宠儿：表面着色器"></a>3. 宠儿：表面着色器</h1><p>表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型。</p><p>特点是：</p><ul><li><p>代码量少，使用方便简单</p></li><li><p>渲染代价大</p></li></ul><p>实际上，表面着色器在运行时会被Unity编译成对应的顶点/片元着色器。<br>我们可以理解为表面着色器是Unity对顶点/片元着色器的封装抽象。</p><p>一个非常简单的表面着色器示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Custom/simple surface Shader&quot;</span> <br>&#123;<br>SubShader<br>&#123;<br>Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span> = <span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>CGPROGRAM<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> surface surf Lambert</span><br>struct Input <br>&#123;<br>float4 color : COLOR;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> </span><br><span class="hljs-function"></span>&#123;<br>o.Albedo = <span class="hljs-number">1</span>;<br>&#125;<br>ENDCG<br>&#125;<br>Fallback <span class="hljs-string">&quot;Di ffuse&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>从上述程序中可以看出，表面着色器被定义在SubShader语义块(而非Pass语义块)中的CGPROGRAM和ENDCG之间。<br>因为表面着色器不需要开发者关心使用多少个Pass每个如何渲染等问题，Unity 会在背后为我们做好这些事情。</p><blockquote><p>注意：<br>这里的Cg/HLSL是Unity经封装后提供的，它的语法和标准的CgHLSL语法几乎一样， 但还是有细微的不同<br>例如有些原生的函数和用法Unity并没有提供支持。</p></blockquote><h1 id="4-孤儿：固定函数着色器"><a href="#4-孤儿：固定函数着色器" class="headerlink" title="4. 孤儿：固定函数着色器"></a>4. 孤儿：固定函数着色器</h1><p>上述两种UnityShader形式都使用了可编程管线，而对于一些不支持可编程管线的旧设备，就需要用**固定函数着色器(Fixed Function Shader)**。</p><p>这种着色器往往只能完成非常简单的效果。</p><p>固定函数着色器的代码被定义在Pass语句块中，且只是用ShaderLab的语法，不支持Cg/HLSL。</p><p>因为时代变了，现在大多数GPU都支持可编程管线，所以固定函数着色器成了孤儿。<br>实际上，固定函数着色器在运行时会被Unity编译成对应的顶点/片元着色器，因此真正的固定函数着色器已经不存在了。</p><blockquote><p>所以就略过吧，别学，没用的。</p></blockquote><h1 id="5-着色器的选择"><a href="#5-着色器的选择" class="headerlink" title="5. 着色器的选择"></a>5. 着色器的选择</h1><ul><li>除非你有非常明确的需求必须要使用固定函数着色器<br>例如需要在非常旧的设备上运行你的游戏(这些设备非常少见)<br>否则<strong>不要使用固定函数着色器</strong></li><li>如果你想和<strong>各种光源</strong>打交道<br>使用表面着色器<br>但需要小心它在<strong>移动平台的性能表现</strong></li><li>如果你使用的<strong>光照数目非常少</strong><br>使用顶点/片元着色器</li><li>如果你有<strong>很多自定义的渲染效果</strong><br>请选择顶点/片元着色器</li></ul><blockquote><p>其它两种着色器在编译时都会编译成顶点/片选着色器<br>因此从本质上来讲，Unity中只存在顶点/片选着色器</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader的结构</title>
    <link href="/2021/05/23/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <url>/2021/05/23/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是shader"><a href="#1-1-什么是shader" class="headerlink" title="1.1 什么是shader"></a>1.1 什么是shader</h2><p>Shader的中文翻译是着色器，是一类面对GPU编程语言的总称。<br>Shader其实就是一段代码，这段代码的作用是告诉GPU具体怎样去绘制模型的每一个顶点的颜色以及最终每一个像素点的颜色。</p><p>更具体的讲：</p><ul><li>GPU流水线上–些可高度编程的阶段,而由着色器编译出来的最终代码是会在GPU.上运行的(对于固定管线的渲染来说，着色器有时等同于–些特定的渲染设置);</li><li>有一些特定类型的着色器，如顶点着色器、片元着色器等;</li><li>依靠着色器我们可以控制流水线中的渲染细节,例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</li></ul><h2 id="1-2-shader语言有哪些"><a href="#1-2-shader语言有哪些" class="headerlink" title="1.2 shader语言有哪些"></a>1.2 shader语言有哪些</h2><p>既然Shader是一段代码，那必然要用一种语言来书写它，目前主流的有三种语言：</p><ul><li>基于OpenGL<br>OpenGL Shading Language，简称GLSL。</li><li>基于DirectX<br>High Level Shading Language,简称HLSL。</li><li>基于NVIDIA<br>C for Graphic，简称Cg语言。</li></ul><p>GLSL与HLSL分别是基于OpenGL和Direct3D的接口，两者不能混用。</p><p>而Cg语言是用于图形的C语言。<br>这其实说明了当时设计人员的一个初衷，就是<strong>让基于图形硬件的编程变得和C语言编程一样方便，自由</strong>。<br>正如C++和 Java的语法是基于C的，Cg语言本身也是基于C语言的。<br>如果您使用过C、C++、Java其中任意一个，那么Cg的语法也是比较容易掌握的。<br>Cg语言极力保留了C语言的大部分语义，力图让开发人员从硬件细节中解脱出来，Cg同时拥有高级语言的好处，如代码的易重用性，可读性高等。</p><blockquote><p>Cg语言是Microsoft和NVIDIA相互协作在标准硬件光照语言的语法和语义上达成了一致。<br>所以，HLSL和Cg其实是同一种语言。</p></blockquote><h2 id="1-3-什么是UnityShader"><a href="#1-3-什么是UnityShader" class="headerlink" title="1.3 什么是UnityShader"></a>1.3 什么是UnityShader</h2><p>Unity Shader严格来说并不是传统上的Shader,而是Unity自身封装后的一种便于书写的Shader，又称为ShaderLab。</p><p><img src="/images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/image-20210523140053736.png" srcset="/img/loading.gif" alt="UnityShader是封装"></p><p>其实在Unity中反而一切变的简单起来了，我们只需关心如何去这实现我们想要的效果就好了，其余的事情全部交给Unity来自动处理。<br>因为我们在Unity中编写的Shader最终会根据不同的平台来编绎成不同的着色器语言。</p><p>官方建议使用Cg/HLSL来编写ShaderLab，因为Cg/HLSL有更好的跨平台性。</p><h1 id="2-UnityShader的结构"><a href="#2-UnityShader的结构" class="headerlink" title="2. UnityShader的结构"></a>2. UnityShader的结构</h1><p>一段完整UnityShader代码的结构应该如下面的例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Shader">Shader &quot;Path&#x2F;ShaderName&quot;<br>&#123;<br>Properties<br>&#123;<br><br>&#125;<br>SubShader<br>&#123;<br>Pass<br>&#123;<br><br>&#125;<br>&#125;<br>FallBack &quot;Diffuse&quot;<br>CustomEditor &quot;EditorName&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>从整体来看的话，大致是这样的一个框架结构：</p><p><strong>Shader “name” { [Properties] SubShaders [FallBack] [CustomEditor] }</strong></p><blockquote><p>[]方括号表示可选</p></blockquote><p>可以拆分成以下几个大部分：</p><ul><li>Shader “name”</li><li>Properties</li><li>SubShaders</li><li>FallBack</li><li>CustomEditor</li></ul><h2 id="2-1-Shader-“name”-路径名称"><a href="#2-1-Shader-“name”-路径名称" class="headerlink" title="2.1 Shader “name”-路径名称"></a>2.1 Shader “name”-路径名称</h2><p>每个Unity Shader文件的第一行都需要通过Shader语句来指定该Unity Shader 的名字。<br>当为材质选择使用的UnityShader时,这些名称就会出现在材质面板的下拉列表里。</p><p>通过在字符串中添加斜杠(“/”)， 可以控制UnityShader在材质面板中出现的位置<br>例如:<code>Shader &quot;Custom/ MyShader&quot; &#123;...&#125;</code><br>那么这个UnityShader在材质面板中的位置就是:Shader -&gt; Custom -&gt; MyShader</p><blockquote><p>如果我们把路径名称放在Hidden下面的话<br>比如：<code>Shader &quot;Hidden/TA/MyFirstShader&quot;</code><br>则表示在材质面板中隐藏此Shader,你将无法通过材质下拉列表中找到它。<br>这在做一些不需暴露的Shader时很有用处，可以使Shader下拉列表更精简整洁。</p></blockquote><blockquote><p>而Shader文件的名称，也就是我们在Project面板中的资源文件的名称，是可以与Shader内部的路径名称不一样的，这点与C#是不同的。<br>在定义内部路径名称时，建议统一规划下，不要Shader过多后导致很混乱，不便于美术去使用。</p></blockquote><h2 id="2-2-Properties-属性"><a href="#2-2-Properties-属性" class="headerlink" title="2.2 Properties-属性"></a>2.2 Properties-属性</h2><p>Properties是UnityShader与材质的桥梁，语句块中的属性会出现在材质面板。</p><p>格式如下：<br><code>[Attribute]_Name (&quot;Display Name&quot;,Type) = Default Value</code></p><h3 id="2-2-1-Attribute"><a href="#2-2-1-Attribute" class="headerlink" title="2.2.1 Attribute"></a>2.2.1 Attribute</h3><p>属性标记，说白了就是Unity内置的几个属性标记关键字，用于对当前这条属性进行一些特殊的处理，在下面会进行详细介绍。</p><blockquote><p>此标记不是必选项，可以不添加，同时一条属性上也可以有多条属性标记。</p></blockquote><h3 id="2-2-2-Name"><a href="#2-2-2-Name" class="headerlink" title="2.2.2 _Name"></a>2.2.2 _Name</h3><p>属性的名称，也就是变量名。<br>在Shader的CG代码中就是通过这个名称来调用此属性内容的，在外部利用脚本调用时也是这个名称，所以一定要用英文。</p><p><strong>在名称前一定要加上下划线，否则会出现编绎错误！</strong></p><blockquote><p>关于此变量名，有一点很重要！<br>如果此Shader有FallBack的话，一定要将此Shader中的变量名与FallBack中的变量名保持一致，否则会出现FallBack后原有的属性值获取不到的情况<br>切记！</p></blockquote><h3 id="2-2-3-Display-Name"><a href="#2-2-3-Display-Name" class="headerlink" title="2.2.3 Display Name"></a>2.2.3 Display Name</h3><p>显示在材质面板上的名称，主要起到说明解释的作用，可用中文</p><blockquote><p>（正式项目中建议最好还是用英文）</p></blockquote><h3 id="2-2-4-Type"><a href="#2-2-4-Type" class="headerlink" title="2.2.4 Type"></a>2.2.4 Type</h3><p>属性的类型，常用的有以下几种：</p><table><thead><tr><th>属性类型</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>Int</td><td>整数</td><td>_Int(“我是Int”, Int) = 1</td></tr><tr><td>Float</td><td>浮点数(小数)</td><td>_Float(“我是Float”, Float) = 0.5</td></tr><tr><td>Range</td><td>有范围的浮点数(使用滑块)</td><td>_Float(“我是Float”, Range( 0 , 1)) = 0.5</td></tr><tr><td>PowerSlider</td><td>有曲度变化的Range(非线性滑块)</td><td>[PowerSlider(3)]_Float(“我是Float”, Range( 0 , 1)) = 0.5</td></tr><tr><td>IntRange</td><td>向下取整(使用滑块)</td><td>[IntRange]_Float(“我是Float”, Range( 0 , 1)) = 1</td></tr><tr><td>Toggle</td><td>一个checkbook，选中为1，不选为0</td><td>[Toggle]_Float(“我是Float”, Range( 0 , 1)) = 1</td></tr><tr><td>Enum</td><td>枚举(下拉列表)</td><td>[Enum(UnityEngine.Rendering.CullMode)]_Float(“我是Float”, Float) = 1</td></tr><tr><td>Color</td><td>RGBA颜色</td><td>_Color(“我是Color”, Color) = (1,1,1,1)</td></tr><tr><td>HDR</td><td>带亮度的颜色</td><td>[HDR]_Color(“Color”, Color) = (1,1,0,1)</td></tr><tr><td>Vector</td><td>四维向量</td><td>_Vector(“我是Vector”, Vector) = (0,0,0,0)</td></tr><tr><td>2D</td><td>2D纹理</td><td>_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>NoScaleOffset</td><td>没有Tiling (贴图重复度)与Offset (贴图偏移值)的2D纹理</td><td>[NoScaleOffset]_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>Normal</td><td>法线贴图</td><td>[Normal]_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>3D</td><td>3D纹理</td><td>_MainTex(“我是3D纹理”, 3d) = “” {}</td></tr><tr><td>Cube</td><td>立方体纹理</td><td>_MainTex(“我是Cube纹理”, CUBE) = “” {}</td></tr></tbody></table><blockquote><p>其他属性类型</p><p><strong>[Header]</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">Properties<br>&#123;<br>[Header(This is Header )]_Int(&quot;我是Int&quot;, Int) = 1<br>_Float(&quot;我是Float&quot;, Range( 0 , 1)) = 1<br>&#125;<br></code></pre></td></tr></table></figure><p>在材质面板上进行标注，通常用作分类组别用，注意只支持英文、数字、空格以及下划线。</p><p><strong>[HideInInspector]</strong><br>在材质面板中隐藏此条属性，在不希望暴露某条属性时可以快速将其隐藏。</p></blockquote><h3 id="2-2-5-Default-Value"><a href="#2-2-5-Default-Value" class="headerlink" title="2.2.5 Default Value"></a>2.2.5 Default Value</h3><p>默认值。<br>当第一次指定此Shader时，或者在材质面板上执行Reset时，属性的值会自动恢复到默认值。</p><ul><li><p>Int、 Float、 Range<br>其默认值就是一个单独的数字;</p></li><li><p>Color和Vector<br>默认值是用圆括号包围的一个四维向量;</p></li><li><p>2D、Cube、 3D这3种纹理类型<br>默认值的定义稍微复杂，它们的默认值是通过一个字符串 后跟一个花括号来指定的。</p><ul><li>字符串要么是空的，要么是内置的纹理名称<br>如“white”“black” “gray”或者“bump”。 </li></ul></li></ul><blockquote><p>花括号的用处原本是用于指定一些纹理属性的。<br>例如在Unity 5.0以前的版本中，我们可以通过TexGenCubeReflect、TexGen CubeNormal等选项来控制固定管线的纹理坐标的生成。<br>但在Unity 5.0以后的版本中，这些选项被移除了，如果我们需要类似的功能，就需要自己在顶点着色器中编写计算相应纹理坐标的代码。</p></blockquote><h3 id="2-2-6-案例"><a href="#2-2-6-案例" class="headerlink" title="2.2.6 案例"></a>2.2.6 案例</h3><p>下面的代码给出了一个展示所有属性类型的例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php">Properties<br>&#123;<br><span class="hljs-comment">//Numbers and Sliders</span><br>_Int (<span class="hljs-string">&quot;Int&quot;</span>， <span class="hljs-keyword">Int</span>) = <span class="hljs-number">2</span><br><span class="hljs-keyword">Float</span> (<span class="hljs-string">&quot;Float&quot;</span>, <span class="hljs-keyword">Float</span>) = <span class="hljs-number">1.5</span><br>_Range (<span class="hljs-string">&quot;Range&quot;</span> ,Range(<span class="hljs-number">0.0</span>, <span class="hljs-number">5.0</span>)) = <span class="hljs-number">3.0</span><br><br>   <span class="hljs-comment">// Colors and Vectors .</span><br>Color (<span class="hljs-string">&quot;Color&quot;</span>, color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>_Vector (<span class="hljs-string">&quot;Vector&quot;</span>, Vector) = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// Textures</span><br><span class="hljs-number">2</span>D (<span class="hljs-string">&quot;2D&quot;</span>， <span class="hljs-number">2</span>D) =”<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">Cube (&quot;</span>Cube<span class="hljs-string">&quot;, Cube) = &quot;</span>white<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">_3D (&quot;</span><span class="hljs-number">3</span>D<span class="hljs-string">&quot;, 3D) = &quot;</span>black<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>下图是该案例在属性面板中的显示：</p><p><img src="/images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/03B62754D758D194E8F6A1E8F9704AD1.jpg" srcset="/img/loading.gif" alt="属性面板"></p><h2 id="2-3-SubShaders-子着色器"><a href="#2-3-SubShaders-子着色器" class="headerlink" title="2.3 SubShaders-子着色器"></a>2.3 SubShaders-子着色器</h2><p>每个Shader中都可以包含多个SubShader，不可以没有，必须至少有一个。</p><p>Shader的核心算法实现就是在SubShader中来实现的。</p><p>在加载Shader时，Unity将遍历所有SubShader列表，并最终选择用户机器支持的第一个。</p><p>作用：<br>我们都知道不同的硬件性能是不一样的，游戏内通常把机器配置分为高中低三种，假如我们做了一个效果很好的Shader，但只能在高配机上有较好的性能表现，中低端就显的太费性能，SubShader在这时就可以派上用场了，我们可以在这个Shader内做三个SubShader，分别对应于高中低不同的配置。</p><p>SubShaders语句块中包含的定义通常如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">SubShader<br>&#123;<br>[Tags]<span class="hljs-regexp">//</span>可选的<br>[RenderSetup]<span class="hljs-regexp">//</span>可选的<br>Pass<br>&#123;<br>...<br>&#125;<br><span class="hljs-regexp">//</span>可有多个Pass<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可见，SubShader语句块由以下三个部分组成</p><ul><li><p>Tags 标签</p></li><li><p>RenderSetup状态</p></li><li><p>Pass</p></li></ul><h3 id="2-3-1-Tags-标签"><a href="#2-3-1-Tags-标签" class="headerlink" title="2.3.1 Tags 标签"></a>2.3.1 Tags 标签</h3><p>标签(Tags) 是一个键值对(Key/Value Pair),它的键和值都是字符串类型。<br>这些键值对是SubShader和渲染引擎之间的沟通桥梁。<br>它们用来告诉Unity的渲染引擎:我希望怎样以及何时渲染这个对象。</p><p>标签的结构如下:<br><code>Tags &#123;&quot;TagNamo1&quot;=&quot;Value1&quot; &quot;TagNamo2&quot;=&quot;Value2&quot;&#125;</code></p><p><img src="images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/image-20210523155428768.png" srcset="/img/loading.gif" alt="标签"></p><blockquote><p>注意:<br>上述标签仅可以在SubShader中声明，而不可以在Pass块中声明。<br>Pass块虽然也可以定义标签，但这些标签是不同于SubShader的标签类型。这是我们下面将要讲到的。</p></blockquote><h3 id="2-3-2-RenderSetup-状态"><a href="#2-3-2-RenderSetup-状态" class="headerlink" title="2.3.2 RenderSetup 状态"></a>2.3.2 RenderSetup 状态</h3><p>ShaderLab提供了一系列渲染状态的设置指令， 这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等。</p><p>下表给出了ShaderLab中常见的渲染状态设置选项。</p><table><thead><tr><th>状态名称</th><th>设置指令</th><th>解释</th></tr></thead><tbody><tr><td>Cull</td><td>Cull Back |Front |Off</td><td>设置剔除模式:剔除背面/正面/关闭剔除</td></tr><tr><td>ZTest</td><td>ZTest Less Greater |LEqual |GEqual I Equal |NotEqual |Always</td><td>设置深度测试时使用的函数</td></tr><tr><td>ZWrite</td><td>ZWrite On |Off</td><td>开启/关闭深度写入</td></tr><tr><td>Blend</td><td>Blend SrcFactor DstFactor</td><td>开启并设置混合模式</td></tr></tbody></table><p>当在SubShader块中设置了上述渲染状态时，将会应用到所有的Pass。<br>如果我们不想这样，可以在Pass语义块中单独进行上面的设置。</p><h3 id="2-3-3-Pass语句块"><a href="#2-3-3-Pass语句块" class="headerlink" title="2.3.3 Pass语句块"></a>2.3.3 Pass语句块</h3><h4 id="2-3-3-1-Pass的结构"><a href="#2-3-3-1-Pass的结构" class="headerlink" title="2.3.3.1 Pass的结构"></a>2.3.3.1 Pass的结构</h4><p>Pass语句块的格式如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Pass<br>&#123;<br><span class="hljs-string">[Name]</span><br><span class="hljs-string">[Tags]</span><br><span class="hljs-string">[RenderSetup]</span><br><br><span class="hljs-comment">//code</span><br>CGPROGRAM<br>...<br>ENDCG<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>[Name]<br>规定该Pass的名称，如<code>Name &quot;MyPassName&quot;</code><br>通过名称可以使用UsePass直接调用其它UnityShader中的Pass，如：<code>UsePase &quot;MyShader/MYPASSNAME&quot;</code></p><blockquote><p>使用UsePage指令时必须使用大写形式的名字</p></blockquote></li><li><p>[Tags]标签</p><p>用于告诉渲染引擎如何渲染物体<br>暂略，没看懂</p></li><li><p>[RenderSetup] 状态<br>与SubShader中的相同</p></li><li><p>CGPROGRAM-ENDCG<br>CG代码段</p></li></ul><h4 id="2-3-3-2-Pass的分类"><a href="#2-3-3-2-Pass的分类" class="headerlink" title="2.3.3.2 Pass的分类"></a>2.3.3.2 Pass的分类</h4><ul><li>Pass<br>普通的Pass</li><li>UsePass<br>复用其它UnityShader中的Pass</li><li>GrabPass<br>抓取屏幕，将结果存在一张纹理中以便后续的Pass处理</li></ul><h2 id="2-4-FallBack指令"><a href="#2-4-FallBack指令" class="headerlink" title="2.4 FallBack指令"></a>2.4 FallBack指令</h2><p>当我们写的Shader在一些机器上不支持时（最终显示成粉红色），只要添加了FallBack，并在双引号内写上了其它Shader的有效路径名称，那么在碰到不支持的硬件时这个Shader就会自动切换成FallBack内的Shader。</p><p>如果FallBack内的Shader也不支持呢，那就继续从FallBack内的Shader中再找FallBack……</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">FallBack <span class="hljs-string">&quot;name&quot;</span><br><span class="hljs-regexp">//</span>或者<br>FallBack Off<span class="hljs-regexp">//</span>关闭fallback功能<br></code></pre></td></tr></table></figure><blockquote><p>FallBack会影响阴影的投射<br>在渲染阴影纹理时，Unity 会在每个Unity Shader中寻找一个阴影投射的Pass。<br>通常情况下，我们不需要自己专门实现一个Pass。<br>这是因为Fallback使用的内置Shader中包含了这样一个通用的Pass。<br>因此，为每个Unity Shader正确设置Fallback是非常重要的。</p></blockquote><h2 id="2-5-CustomEditor-自定义面板编辑器"><a href="#2-5-CustomEditor-自定义面板编辑器" class="headerlink" title="2.5 CustomEditor-自定义面板编辑器"></a>2.5 CustomEditor-自定义面板编辑器</h2><p>自定义界面，也就是说我们可以通过这个功能来自由定义材质面板的显示结果，它可以改写Properties中定义的显示方式。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#is与as</title>
    <link href="/2021/05/16/is%E4%B8%8Eas/"/>
    <url>/2021/05/16/is%E4%B8%8Eas/</url>
    
    <content type="html"><![CDATA[<h1 id="1-C-类型的转换"><a href="#1-C-类型的转换" class="headerlink" title="1. C#类型的转换"></a>1. C#类型的转换</h1><p>在c#中类型的转换分两种：显式和隐式，基本的规则如下：</p><ul><li>基类对象转化为子类对象，必须显式转换，规则：(类型名) 对象。</li><li>值类型和引用类型的转换采用装箱(boxing)或拆箱(unboxing).</li><li>子类转化为基类对象。</li><li>基本类型互相之间转化可以用Covent类来实现。</li><li>字符串类型转换为对应的基本类型用Parse方法，除了String类型外其他的类型都可以用Parse方法。</li><li>用GetType可以取得对象的精确类型。</li><li>子类转化为基类，采用隐式转换。</li></ul><h1 id="2-C-中的is"><a href="#2-C-中的is" class="headerlink" title="2. C#中的is"></a>2. C#中的is</h1><p>检查一个对象是否兼容于其他指定的类型,并返回一个Bool值,如果一个对象是某个类型或是其父类型的话就返回为true，否则的话就会返回为false。永远不会抛出异常<br>如果对象引用为null，那么is操作符总是返回为false，因为没有对象可以检查其类型。</p><p>　　代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>　　<span class="hljs-keyword">if</span> (o <span class="hljs-keyword">is</span> Label)<br>　　&#123;<br>  　 Label lb = (Label)o;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换成功&quot;</span>);<br>　　&#125;<br>　　<span class="hljs-keyword">else</span><br>　　&#123;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换失败&quot;</span>);  <br>　　&#125;<br></code></pre></td></tr></table></figure><h1 id="3-C-中as的转换规则"><a href="#3-C-中as的转换规则" class="headerlink" title="3. C#中as的转换规则"></a>3. C#中as的转换规则</h1><ul><li>检查对象类型的兼容性，并返回转换结果，如果不兼容则返回null；</li><li>不会抛出异常；</li><li>如果结果判断为空，则强制执行类型转换将抛出NullReferenceException异常；</li><li>用as来进行类型转换的时候，所要转换的对象类型必须是目标类型或者转换目标类型的派生类型</li></ul><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();  <br>　　Label lb = o <span class="hljs-keyword">as</span> Label;  <br>　　<span class="hljs-keyword">if</span> (lb == <span class="hljs-literal">null</span>)<br>　　&#123;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换失败&quot;</span>);<br>　　&#125;<br>　　<span class="hljs-keyword">else</span><br>　　&#123;   <br>  　 Response.Write(<span class="hljs-string">&quot;类型转换成功&quot;</span>); <br>　　&#125;<br></code></pre></td></tr></table></figure><p>使用as操作符有如下几点限制</p><p>第一个就是，不用在类型之间进行类型转化，即如下编写就会出现编译错误。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">NewType newValue = <span class="hljs-keyword">new</span> NewType();<br>NewType1 newValue = newValue <span class="hljs-keyword">as</span> NewType1;<br></code></pre></td></tr></table></figure><p>第二个就是，不能应用在值类型数据，即不能如下写（也会出现编译错误）。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> objTest = <span class="hljs-number">11</span>;<br><span class="hljs-built_in">int</span> nValue = objTest <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>;<br></code></pre></td></tr></table></figure><h1 id="4-as与is的区别"><a href="#4-as与is的区别" class="headerlink" title="4. as与is的区别"></a>4. as与is的区别</h1><ul><li><p>AS在转换的同事兼判断兼容性<br>如果无法进行转换，则 as 返回 null（没有产生新的对象）而不是引发异常。<br>有了AS我想以后就不要再用try-catch来做类型转换的判断了。<br>因此as转换成功要判断是否为null。</p></li><li><p>AS是引用类型类型的转换或者装箱转换，不能用与值类型的转换<br>如果是值类型只能结合is来强制转换</p></li><li><p>IS只是做类型兼容判断，并不执行真正的类型转换<br>返回true或false，不会返回null，对象为null也会返回false。</p></li><li><p>AS模式的效率要比IS模式的高<br>因为借助IS进行类型转换的化，需要执行两次类型兼容检查。<br>而AS只需要做一次类型兼容，一次null检查，null检查要比类型兼容检查快。</p></li></ul><h1 id="5-int-，Int32-Parse-，Convert-ToInt32-的区别"><a href="#5-int-，Int32-Parse-，Convert-ToInt32-的区别" class="headerlink" title="5. (int)，Int32.Parse()，Convert.ToInt32()的区别"></a>5. (int)，Int32.Parse()，Convert.ToInt32()的区别</h1><ul><li>(int)转换：<br>用在数值范围大的类型转换成数值范围小的类型时使用<br>但是如果被转换的数值大于或者小于数值范围，则得到一个错误的结果<br>利用这种转换方式不能将string转换成int，会报错。</li><li>Int32.Parse()转换：<br>在符合数字格式的string到int类型转换过程中使用，并可以对错误的string数字格式的抛出相应的异常。</li><li>Convert.ToInt32()转换：<br>使用这种转换，所提供的字符串必须是数值的有效表达方式，该数还必须不是溢出的数。否则抛出异常。</li></ul><h1 id="6-常用类型转换"><a href="#6-常用类型转换" class="headerlink" title="6. 常用类型转换"></a>6. 常用类型转换</h1><ul><li><p>Object =&gt; 已知引用类型<br>使用as操作符来完成</p></li><li><p>Object =&gt; 已知值类型<br>先使用is操作符来进行判断，再用类型强转方式进行转换</p></li><li><p>已知引用类型之间转换<br>首先需要相应类型提供转换函数，再用类型强转方式进行转换</p></li><li><p>已知值类型之间转换<br>最好使用系统提供的Convert类所涉及的静态方法</p></li></ul><p>希望本文所述对大家的C#程序设计有所帮助。</p><p>转载自：<a href="http://www.jb51.net/article/56657.htm%E3%80%82">http://www.jb51.net/article/56657.htm。</a></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-资源与样式</title>
    <link href="/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/"/>
    <url>/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-资源"><a href="#1-资源" class="headerlink" title="1.资源"></a>1.资源</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>WPF资源系统是一种保管一系列有用对象（如常用的画刷、样式和模板）的简单方法，从而使您可以更容易地重用这些对象。<br>每个元素都有Resources属性，该属性存储了一个资源字典集合（它是ResourceDictionary类的实例）。<br>资源集合可包含任意类型的对象，根据字符串编写索引。</p><h2 id="1-2-写法"><a href="#1-2-写法" class="headerlink" title="1.2 写法"></a>1.2 写法</h2><ul><li><p>Window的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Window&gt;</span><br>   <span class="hljs-section">&lt;Window.Resources&gt;</span><br>   <span class="hljs-section">&lt;/Window.Resources&gt;</span><br><span class="hljs-section">&lt;/Window&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Control的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Control&gt;</span><br>      <span class="hljs-section">&lt;Control.Resources&gt;</span><br>       <span class="hljs-section">&lt;/Control.Resources&gt;</span><br><span class="hljs-section">&lt;/Control&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-样式"><a href="#2-样式" class="headerlink" title="2. 样式"></a>2. 样式</h1></li></ul><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>样式是修改View（窗体、控件）样式的主要手段，主要作用更改控件的外观以及增强用户体验。</p><h2 id="2-2-样式的属性"><a href="#2-2-样式的属性" class="headerlink" title="2.2 样式的属性"></a>2.2 样式的属性</h2><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>Setterts</td><td>设置属性值以及自动关联事件处理程序的Setter对象或EventSetter对象的集合是Style类中最重要的属性，但并非唯一属性。</td></tr><tr><td>Triggers</td><td>继承自TriggerBase类能自动改变样式设置的对象集合。例如，当另一个属性改变时，或者当发生某个时间时，可以修改样式。</td></tr><tr><td>Resources</td><td>希望用于样式的资源集合。</td></tr><tr><td>BasedOn</td><td>通过该属性可创建继承自其它样式设置的更具体的样式</td></tr><tr><td>TargetType</td><td>该属性标识应用样式的元素类型。通过该属性可创建只影响特定类型元素的设置器，还可以创建能够为恰当的元素类型自动起作用的设置器</td></tr></tbody></table><h2 id="2-3-如何关联样式"><a href="#2-3-如何关联样式" class="headerlink" title="2.3 如何关联样式"></a>2.3 如何关联样式</h2><ul><li>DynamicResource（动态资源）<br><code> &lt;Button Style=&quot;&#123;StaticResource BtnStyle&#125;&quot; /&gt;</code></li><li>StaticResource（静态资源）<br><code>&lt;Button Style=&quot;&#123;DynamicResource BtnStyle&#125;&quot; /&gt;</code></li></ul><blockquote><p>二者区别<br>静态资源在第一次编译后即确定其对象或值，之后不能对其进行修改。<br>动态资源在运行时决定，当运行过程中真正需要时，才到资源目标中查找其值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>样式</tag>
      
      <tag>资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataResult与DataTable类</title>
    <link href="/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/"/>
    <url>/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>DataTable和DataSet可以看做是数据容器，比如你查询数据库后得到一些结果，可以放到这种容器里。</p><p>那你可能要问：我不用这种容器，自己读到变量或数组里也一样可以存起来啊，为什么用容器？</p><p>原因是，这种容器的功能比较强大，除了可以存数据，还可以有更大用途。</p><p>举例：<br>在一个c/s结构的桌面数据库系统里，你可以把前面存放查询结果的容器里的数据显示到你客户端界面上，用户在界面上对数据进行添加、删除、修改，你可以把用户的操作更新到容器。<br>等用户操作完毕了，要求更新，然后你才把容器整个的数据变化更新到中心数据库。</p><blockquote><p>这样做的好处是什么？<br>就是减少了数据库操作，客户端速度提高了，数据库压力减小了。</p></blockquote><p> DataSet可以比作一个内存中的数据库，DataTable是一个内存中的数据表，DataSet里可以存储多个DataTable。</p><h1 id="2-DataTable"><a href="#2-DataTable" class="headerlink" title="2. DataTable"></a>2. DataTable</h1><h2 id="2-1-类成员"><a href="#2-1-类成员" class="headerlink" title="2.1 类成员"></a>2.1 类成员</h2><h3 id="2-1-1-构造函数"><a href="#2-1-1-构造函数" class="headerlink" title="2.1.1 构造函数"></a>2.1.1 构造函数</h3><table><thead><tr><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td>DataTable()</td><td>不带参数初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName)</td><td>用指定的表名初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName, string tableNamespace)</td><td>用指定的表名和命名空间初始化DataTable类的新实例</td></tr></tbody></table><h3 id="2-1-2-常用属性"><a href="#2-1-2-常用属性" class="headerlink" title="2.1.2 常用属性"></a>2.1.2 常用属性</h3><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>CaseSensitive</td><td>指示表中的字符串比较是否区分大小写</td></tr><tr><td>ChildRelations</td><td>获取此DataTable 的子关系的集合</td></tr><tr><td>Columns</td><td>获取属于该表的列的集合</td></tr><tr><td>Constraints</td><td>获取由该表维护的约束的集合</td></tr><tr><td>DataSet</td><td>获取此表所属的DataSet</td></tr><tr><td>DefaultView</td><td>获取可能包括筛选视图或游标位置的表的自定义视图</td></tr><tr><td>HasErrors</td><td>获取一个值，该值指示该表所属的DataSet 的任何表的任何行中是否有错误</td></tr><tr><td>MinimumCapacity</td><td>获取或设置该表最初的起始大小。该表中行的最初起始大小。默认值为 50</td></tr><tr><td>Rows</td><td>获取属于该表的行的集合</td></tr><tr><td>TableName</td><td>获取或设置DataTable 的名称</td></tr></tbody></table><h3 id="2-1-3-常用方法"><a href="#2-1-3-常用方法" class="headerlink" title="2.1.3 常用方法"></a>2.1.3 常用方法</h3><table><thead><tr><th>方法名</th><th>含义</th></tr></thead><tbody><tr><td>AcceptChanges()</td><td>提交自上次调用AcceptChanges() 以来对该表进行的所有更改</td></tr><tr><td>BeginInit()</td><td>开始初始化在窗体上使用或由另一个组件使用的DataTable。初始化发生在运行时</td></tr><tr><td>Clear()</td><td>清除所有数据的DataTable</td></tr><tr><td>Clone()</td><td>克隆DataTable 的结构，包括所有DataTable 架构和约束</td></tr><tr><td>EndInit()</td><td>结束在窗体上使用或由另一个组件使用的DataTable 的初始化。初始化发生在运行时</td></tr><tr><td>ImportRow(DataRow row)</td><td>将DataRow 复制到DataTable 中，保留任何属性设置以及初始值和当前值</td></tr><tr><td>Merge(DataTable table)</td><td>将指定的DataTable 与当前的DataTable 合并</td></tr><tr><td>NewRow()</td><td>创建与该表具有相同架构的新DataRow</td></tr></tbody></table><h2 id="2-2-使用技巧"><a href="#2-2-使用技巧" class="headerlink" title="2.2 使用技巧"></a>2.2 使用技巧</h2><h3 id="2-2-1-创建表"><a href="#2-2-1-创建表" class="headerlink" title="2.2.1 创建表"></a>2.2.1 创建表</h3><p><code>DataTable dt = new DataTable(&quot;Table_AX&quot;); </code></p><h3 id="2-2-2-添加列属性"><a href="#2-2-2-添加列属性" class="headerlink" title="2.2.2 添加列属性"></a>2.2.2 添加列属性</h3><p>方法1：<br><code>dt.Columns.Add(&quot;column0&quot;, System.Type.GetType(&quot;System.String&quot;));</code><br>方法2：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataColumn dc = <span class="hljs-keyword">new</span> DataColumn(<span class="hljs-string">&quot;column1&quot;</span>, System.Type.GetType(<span class="hljs-string">&quot;System.Boolean&quot;</span>));<br>dt.Columns.Add(dc); <br></code></pre></td></tr></table></figure><h3 id="2-2-3-添加数据行"><a href="#2-2-3-添加数据行" class="headerlink" title="2.2.3 添加数据行"></a>2.2.3 添加数据行</h3><p>初始化行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr = dt.NewRow();<br>dr[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AX&quot;</span>;<br>dr[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">true</span>;<br>dt.Rows.Add(dr);<br></code></pre></td></tr></table></figure><p>空行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr1 = dt.NewRow();<br>dt.Rows.Add(dr1);    <br></code></pre></td></tr></table></figure><h3 id="2-2-4-选择数据行"><a href="#2-2-4-选择数据行" class="headerlink" title="2.2.4 选择数据行"></a>2.2.4 选择数据行</h3><p>选择表中所有第0列属性为’AX’的数据行<br><code>DataRow[] drss = dt.Select(&quot;column0 = &#39;AX&#39;&quot;);</code></p><blockquote><p>空属性时用<strong>is null</strong><br>例：<code> DataRow[] drs = dt.Select(&quot;column1 is null&quot;);</code></p></blockquote><h3 id="2-2-5-复制表-包括数据"><a href="#2-2-5-复制表-包括数据" class="headerlink" title="2.2.5 复制表(包括数据)"></a>2.2.5 复制表(包括数据)</h3><p><code>DataTable dtNew = dt.Copy();</code></p><h3 id="2-2-6-复制表-仅结构"><a href="#2-2-6-复制表-仅结构" class="headerlink" title="2.2.6 复制表(仅结构)"></a>2.2.6 复制表(仅结构)</h3><p><code>DataTable dtOnlyScheme = dt.Clone(); </code></p><h3 id="2-2-7-数据行操作"><a href="#2-2-7-数据行操作" class="headerlink" title="2.2.7 数据行操作"></a>2.2.7 数据行操作</h3><ul><li><p>方法一</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow drOperate = dt.Rows[<span class="hljs-number">0</span>];<br>drOperate[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">drOperate[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法三</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法四</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; <br></code></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>  <span class="hljs-keyword">foreach</span> (DataColumn column <span class="hljs-keyword">in</span> dt.Columns) <br>  &#123; <br> Console.WriteLine(row[column]); <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>row[column] 中的column是检索出来的表个列名。</p><p>如果想把某列的值拼接字符串，那就去掉内层循环就行了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">StringBuilder mailList = <span class="hljs-keyword">new</span> StringBuilder(); <br><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>   mailList.Append(row[<span class="hljs-string">&quot;Email&quot;</span>]); <br>   mailList.Append(<span class="hljs-string">&quot;;&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-8-复制数据行到当前数据表"><a href="#2-2-8-复制数据行到当前数据表" class="headerlink" title="2.2.8 复制数据行到当前数据表"></a>2.2.8 复制数据行到当前数据表</h3></li></ul><p><code>dtOnlyScheme.Rows.Add(dt.Rows[0].ItemArray); </code></p><h3 id="2-2-9-转换为字符串"><a href="#2-2-9-转换为字符串" class="headerlink" title="2.2.9 转换为字符串"></a>2.2.9 转换为字符串</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">System.IO.StringWriter sw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>System.Xml.XmlTextWriter xw = <span class="hljs-keyword">new</span> System.Xml.XmlTextWriter(sw);<br>dt.WriteXml(xw);<br><span class="hljs-built_in">string</span> s = sw.ToString();<br></code></pre></td></tr></table></figure><h3 id="2-2-10-筛选数据表"><a href="#2-2-10-筛选数据表" class="headerlink" title="2.2.10 筛选数据表"></a>2.2.10 筛选数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 &lt;&gt; true&quot;</span>;<br>dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 = true&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-11-行排序"><a href="#2-2-11-行排序" class="headerlink" title="2.2.11 行排序"></a>2.2.11 行排序</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.Sort = <span class="hljs-string">&quot;ID ,Name ASC&quot;</span>;<br>dt=dt.DefaultView.ToTable();   <br></code></pre></td></tr></table></figure><h3 id="2-2-12-绑定数据表"><a href="#2-2-12-绑定数据表" class="headerlink" title="2.2.12 绑定数据表"></a>2.2.12 绑定数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">gvTestDataTable.DataSource = dt;<br>gvTestDataTable.DataBind();<br></code></pre></td></tr></table></figure><blockquote><p>绑定的其实是DefaultView</p></blockquote><h3 id="2-2-13-判断一个字符串是否为数据表的列名"><a href="#2-2-13-判断一个字符串是否为数据表的列名" class="headerlink" title="2.2.13 判断一个字符串是否为数据表的列名"></a>2.2.13 判断一个字符串是否为数据表的列名</h3><p><code>dtInfo.Columns.Contains(&quot;AX&quot;);</code></p><h3 id="2-2-14-序列化"><a href="#2-2-14-序列化" class="headerlink" title="2.2.14 序列化"></a>2.2.14 序列化</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataTable convert to XML <span class="hljs-keyword">and</span> XML convert to DataTable<br>     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Page_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>     &#123;<br>       DataTable dt_AX = <span class="hljs-keyword">new</span> DataTable();<br>       <span class="hljs-comment">//dt_AX.Columns.Add(&quot;Sex&quot;, typeof(System.Boolean));</span><br>       <span class="hljs-comment">//DataRow dr = dt_AX.NewRow();</span><br>       <span class="hljs-comment">//dr[&quot;Sex&quot;] = true;</span><br>       <span class="hljs-comment">//dt_AX.Rows.Add(dr);</span><br>       <span class="hljs-built_in">string</span> xml=ConvertBetweenDataTableAndXML_AX(dt_AX);<br>       DataTable dt = ConvertBetweenDataTableAndXML_AX(xml);<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params">DataTable dtNeedCoveret</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextWriter tw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>       <span class="hljs-comment">//if TableName is empty, WriteXml() will throw Exception.         </span><br><br>dtNeedCoveret.TableName=dtNeedCoveret.TableName.Length==<span class="hljs-number">0</span>?<span class="hljs-string">&quot;Table_AX&quot;</span>:dtNeedCoveret.TableName;<br>       dtNeedCoveret.WriteXml(tw);<br>       dtNeedCoveret.WriteXmlSchema(tw);<br>       <span class="hljs-keyword">return</span> tw.ToString();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> DataTable <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> xml</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextReader trDataTable = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(<span class="hljs-number">0</span>, xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       System.IO.TextReader trSchema = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       DataTable dtReturn = <span class="hljs-keyword">new</span> DataTable();<br>       dtReturn.ReadXmlSchema(trSchema);<br>       dtReturn.ReadXml(trDataTable);<br>       <span class="hljs-keyword">return</span> dtReturn;<br>    &#125;<br> dt.Compute(<span class="hljs-string">&quot;sum(SaleNum)&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>) ; <br><span class="hljs-comment">// 对列SaleNum 汇总支持所以sql 聚合函数 如：sum(),count(),avg()等等。。。  </span><br><br>linq<br><br><span class="hljs-keyword">var</span> productNames = <span class="hljs-keyword">from</span> products <span class="hljs-keyword">in</span> dt.AsEnumerable() <span class="hljs-keyword">select</span> products.Field&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;ProductName&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>C#常用类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-MVVC</title>
    <link href="/2021/04/24/WPF-MVVC/"/>
    <url>/2021/04/24/WPF-MVVC/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MVVM是一种开发模式，是一种开发标准。<br>在WPF中应用到MVVM是非常常见的，MVVM全称为Model、View、ViewModel。</p><p>开发模式有</p><ul><li><p>MVC<br>模型-视图-控制器</p></li><li><p>MVP<br>模型-视图-演示者</p></li><li><p>MVVM<br>模型-视图-视图模型</p></li></ul><p>MVP, MVVM都是由MVC衍生出。<br>所有这些设计模式大体上都有助于开发松散组合、易于测试和维护的应用程序。</p><p><a href="https://www.php.cn/faq/417265.html">开发模式</a></p><p><img src="/images/WPF-MVVC/image-20210424155250844.png" srcset="/img/loading.gif" alt="image-20210424155250844"></p><h1 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h1><ul><li>View<br>代表窗体、控件等可视化资源</li><li>ViewModel<br>代表View的业务处理类，<br>将获取到的数据处理好与View进行关联绑定</li><li>Model<br>通常代表数据模型，它将支持ViewModel中所使用的到的<br>还有一种用法就是在Model里完成业务逻辑的编写ViewModel只需要写出关联逻辑代码，具体的使用方式视情况而定。</li></ul><p><img src="/images/WPF-MVVC/image-20210424154619430.png" srcset="/img/loading.gif" alt="image-20210424154619430"></p><h1 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h1><ul><li>优点<br>前后端逻辑分离，解耦，代码配置灵活，易维护，为数据驱动奠定基础。</li><li>缺点<br>开发耗时较长，对于新手掌握起来略微有难度。<br>基于MVVM再实现绑定难度会有一个小幅度的提升。<br>需多实践积累经验即可。</li></ul><h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4. 文件管理"></a>4. 文件管理</h1><p><img src="/images/WPF-MVVC/image-20210424154830937.png" srcset="/img/loading.gif" alt="image-20210424154830937"></p><p>如图所示</p><ul><li><p>请将与页面可视化相关的xaml文件放于Views文件夹下</p></li><li><p>请将页面逻辑交互相关的cs文件放于ViewModels文件夹下</p></li><li><p>请将数据处理，事务实现相关的cs文件放于Models文件夹下</p></li></ul><blockquote><p>.MainWindow稍微特殊点<br>因为它是主窗体作为整个程序的起始点，它可以单独放在外面</p></blockquote><blockquote><p>App.xaml是程序启动配置文件<br>如果需要更换起始运行窗体则需要修改StartupUri=“xxxView.xaml”即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>MVVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-依赖属性</title>
    <link href="/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>依赖属性就是一种自己可以没有值，并且可以通过绑定从其他数据源获取值。<br>依赖属性可支持WPF中的样式设置、数据绑定、继承、动画及默认值。</p><p>将所有的属性都设置为依赖属性并不总是正确的解决方案，具体取决于其应用场景。<br>有时，使用私有字段实现属性的典型方法便能满足要求。</p><p>MSDN中给出了下面几种应用依赖属性的场景：</p><ol><li><p>希望可在样式中设置属性。</p></li><li><p>希望属性支持数据绑定。</p></li><li><p>希望可使用动态资源引用设置属性。</p></li><li><p>希望从元素树中的父元素自动继承属性值。</p></li><li><p>希望属性可进行动画处理。</p></li><li><p>希望属性系统在属性系统、环境或用户执行的操作或者读取并使用样式更改了属性以前的值时报告。</p></li><li><p>希望使用已建立的、WPF 进程也使用的元数据约定，例如报告更改属性值时是否要求布局系统重新编写元素的可视化对象。</p><blockquote><p>总结自<a href="https://www.cnblogs.com/dotnet261010/p/6286475.html">https://www.cnblogs.com/dotnet261010/p/6286475.html</a></p></blockquote></li></ol><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><h2 id="2-1-属性变更通知"><a href="#2-1-属性变更通知" class="headerlink" title="2.1 属性变更通知"></a>2.1 属性变更通知</h2><p>无论什么时候，只要依赖属性的值发生改变，wpf就会自动根据属性的元数据触发一系列的动作，这些动作可以重新呈现UI元素，也可以更新当前的布局，刷新数据绑定等等。<br>这种变更的通知最有趣的特点之一就是属性触发器，它可以在属性值改变的时候，执行一系列自定义的动作，而不需要更改任何其他的代码来实现。通过下面的示例来演示属性变更通知</p><p>示例：当鼠标移动到Button按钮上面时，文字的前景色变为红色，离开时变为默认颜色黑色，采用传统方式和依赖属性两种方式实现：</p><h3 id="2-1-1-使用传统方式实现"><a href="#2-1-1-使用传统方式实现" class="headerlink" title="2.1.1 使用传统方式实现"></a>2.1.1 使用传统方式实现</h3><p>在Button按钮上定义MouseEnter和MouseLeave两个事件，分别处理鼠标移动到按钮上面和离开，</p><p>XAML界面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span>              <br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">MouseEnter</span>=<span class="hljs-string">&quot;Button_MouseEnter&quot;</span> <span class="hljs-attr">MouseLeave</span>=<span class="hljs-string">&quot;Button_MouseLeave&quot;</span> &gt;</span>鼠标移动到上面，前景色变为红色<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>        <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>C#后台代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Collections.Generic;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Linq;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Text;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Threading.Tasks;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Controls;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Data;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Documents;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.<span class="hljs-keyword">Input</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Navigation;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Shapes;<br> <br>namespace WpfDemo<br>&#123;<br>     // MainWindow.xaml 的交互逻辑<br>     <span class="hljs-built_in">public</span> partial <span class="hljs-keyword">class</span> MainWindow : <span class="hljs-keyword">Window</span><br>     &#123;<br>        <span class="hljs-built_in">public</span> MainWindow()<br>         &#123;<br>             InitializeComponent();<br>         &#125;<br>          // 鼠标移动到按钮上面<br>          // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>          // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseEnter(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Red;<br>             &#125;<br>        &#125;<br>         // 鼠标离开按钮<br>        // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>         // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseLeave(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Black;<br>             &#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-2-使用依赖属性实现"><a href="#2-1-2-使用依赖属性实现" class="headerlink" title="2.1.2 使用依赖属性实现"></a>2.1.2 使用依赖属性实现</h3><p>XAML界面代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">&lt;</span><span class="hljs-variable">Window</span> <span class="hljs-variable">x</span><span class="hljs-operator">:</span><span class="hljs-variable">Class</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">:</span><span class="hljs-variable">x</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br>        <span class="hljs-variable">Title</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;237&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;525&quot;</span> <span class="hljs-variable">WindowStartupLocation</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;CenterScreen&quot;</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Grid</span> <span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;30&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span><span class="hljs-operator">&gt;</span>鼠标移动到上面，前景色变为红色<br>            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span> <span class="hljs-variable">TargetType</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Button&quot;</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Trigger</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;IsMouseOver&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span><span class="hljs-operator">&gt;</span><br>                            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Setter</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Foreground&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Red&quot;</span><span class="hljs-operator">&gt;&lt;/</span><span class="hljs-built_in">Setter</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Trigger</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>           <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Grid</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;/</span><span class="hljs-variable">Window</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>使用上面的两种方式都可以实现Button按钮的前景色改变，效果如下：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230351681-1555534511.png" srcset="/img/loading.gif" alt="img"></p><p>在判断属性IsMouseOver的值为false的时候，自动将Foreground的值改为之前的值，因此就不需要写IsMouseOver的值为false的时候，将Foreground的值改为Black。</p><h2 id="2-2-属性值继承"><a href="#2-2-属性值继承" class="headerlink" title="2.2 属性值继承"></a>2.2 属性值继承</h2><p>是指属性值自顶向下沿着元素树进行传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;依赖属性&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我使用的是继承的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span>我使用的是自己的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>界面运行效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230206494-1555380756.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-3-节省内存空间"><a href="#2-3-节省内存空间" class="headerlink" title="2.3 节省内存空间"></a>2.3 节省内存空间</h2><p>依赖属性和CLR属性在内存的使用上是截然不同的，每个CLR属性都包含一个非static的字段。<br>因此当我们实例化一个类型的时候，就会创建该类型所拥有的所有CLR属性。<br>也就是说一个对象所占用的内存在调用new操作进行实例化的时候就已经决定了。</p><p>而wpf允许对象在创建的时候并不包含用于存储数据的空间，只保留在需要用到数据的时候能够获得该默认值，即用其他对象数据或者实时分配空间的能力。</p><h1 id="３-如何自定义依赖属性"><a href="#３-如何自定义依赖属性" class="headerlink" title="３. 如何自定义依赖属性"></a>３. 如何自定义依赖属性</h1><h2 id="3-1-声明依赖属性变量"><a href="#3-1-声明依赖属性变量" class="headerlink" title="3.1 声明依赖属性变量"></a>3.1 声明依赖属性变量</h2><p>依赖属性的声明都是通过public static来公开一个静态变量，变量的类型必须是DependencyProperty</p><h2 id="3-2-在属性系统中进行注册"><a href="#3-2-在属性系统中进行注册" class="headerlink" title="3.2 在属性系统中进行注册"></a>3.2 在属性系统中进行注册</h2><p>使用DependencyProperty.Register方法来注册依赖属性，或者是使用DependencyProperty.RegisterReadOnly方法来注册</p><h2 id="3-3-使用-NET属性包装依赖属性"><a href="#3-3-使用-NET属性包装依赖属性" class="headerlink" title="3.3 使用.NET属性包装依赖属性"></a>3.3 使用.NET属性包装依赖属性</h2><p>在类上实现属性时，只要该类派生自 DependencyObject，便可以选择使用 DependencyProperty 标识符来标示属性，从而将其设置为依赖属性。</p><p>其语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DependencyProperty TextProperty;<br>        TextProperty =<br>        DependencyProperty.Register(<span class="hljs-string">&quot;Text&quot;</span>, <span class="hljs-comment">//属性名称</span><br>        <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-comment">//属性类型</span><br>        <span class="hljs-keyword">typeof</span>(TestDependencyPropertyWindow), <span class="hljs-comment">//该属性所有者，即将该属性注册到那个类上</span><br>        <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">//属性默认值</span><br>         <br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Text<br> &#123;<br>    <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(TextProperty); &#125;<br>    <span class="hljs-keyword">set</span> &#123; SetValue(TextProperty, <span class="hljs-keyword">value</span>); &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p> 示例：自定义一个依赖属性，界面包括一个TextBox和TextBlock，TextBlock上面字体的前景色随TextBox里面输入的颜色而改变，如果TextBox里面输入的值可以转换成颜色，TextBlock字体的前景色会显示输入的颜色值，如果不能转换，显示默认的前景色。</p><ul><li>1、在当前项目里面添加一个WPF版的用户控件，命名为“MyDependencyProperty”，在MyDependencyProperty.xaml.cs文件里面自定义一个依赖属性：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Windows;<br><span class="hljs-keyword">using</span> System.Windows.Controls;<br><span class="hljs-keyword">using</span> System.Windows.Data;<br><span class="hljs-keyword">using</span> System.Windows.Documents;<br><span class="hljs-keyword">using</span> System.Windows.Input;<br><span class="hljs-keyword">using</span> System.Windows.Media;<br><span class="hljs-keyword">using</span> System.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> System.Windows.Navigation;<br><span class="hljs-keyword">using</span> System.Windows.Shapes;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">WpfDemo</span><br>&#123;<br>    <span class="hljs-comment">// MyDependencyProperty.xaml 的交互逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDependencyProperty</span> : <span class="hljs-title">UserControl</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-comment">//1、声明依赖属性变量</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyColorProperty;<br><br>        <span class="hljs-comment">//2、在属性系统中进行注册</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            MyColorProperty = DependencyProperty.Register(<span class="hljs-string">&quot;MyColor&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-keyword">typeof</span>(MyDependencyProperty),<br>                <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;Red&quot;</span>, (s, e) =&gt; <br>                &#123;<br>                    <span class="hljs-keyword">var</span> mdp = s <span class="hljs-keyword">as</span> MyDependencyProperty;<br>                    <span class="hljs-keyword">if</span> (mdp != <span class="hljs-literal">null</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">try</span><br>                        &#123;<br>                           <span class="hljs-keyword">var</span> color = (Color)ColorConverter.ConvertFromString(e.NewValue.ToString());<br>                            mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(color);<br>                        &#125;<br>                        catch<br>                        &#123;<br>                           mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(Colors.Black);<br>                        &#125;<br>                    &#125;<br>                <br>                &#125;));<br>        &#125;<br><br>        <span class="hljs-comment">//3、使用.NET属性包装依赖属性:属性名称与注册时候的名称必须一致，</span><br>       <span class="hljs-comment">//即属性名MyColor对应注册时的MyColor</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> MyColor <br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>               <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(MyColorProperty);<br>          &#125;<br>           <span class="hljs-keyword">set</span><br>            &#123;<br>               SetValue(MyColorProperty, <span class="hljs-keyword">value</span>);<br>            &#125;<br>        &#125;                    <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速定义依赖属性的快捷方式：</p><p>输入propdp，连续按两下Tab健，自动生成定义依赖属性的语法。</p><p>和输入cw连续按两下Tab健，自动生成Console.Write()一样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty<br>        &#123;<br>            <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)GetValue(MyPropertyProperty); &#125;<br>            <span class="hljs-keyword">set</span> &#123; SetValue(MyPropertyProperty, <span class="hljs-keyword">value</span>); &#125;<br>        &#125;<br><br>       <span class="hljs-comment">// Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc...</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyPropertyProperty =<br>           DependencyProperty.Register(<span class="hljs-string">&quot;MyProperty&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>), <span class="hljs-keyword">typeof</span>(ownerclass), <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><ul><li>2、在MyDependencyProperty.xaml里面添加一个TextBlock</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MyDependencyProperty&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:mc</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:d</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">mc:Ignorable</span>=<span class="hljs-string">&quot;d&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">d:DesignHeight</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">d:DesignWidth</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我是自定义的依赖属性<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>3、在MainWindow.xaml里面引用新创建的用户控件，并添加一个TextBox，用于输入颜色值，并将自定义的依赖属性MyColor绑定到TextBox</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span></span><br><span class="xml">         xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="xml">         xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;       </span><br><span class="xml">        xmlns:p=&quot;clr-namespace:WpfDemo&quot;</span><br><span class="xml">         Title=&quot;依赖属性&quot; Height=&quot;237&quot; Width=&quot;525&quot; WindowStartupLocation=&quot;CenterScreen&quot;&gt;</span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">TextBox</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;tbColor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextBox</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">p:MyDependencyProperty</span> <span class="hljs-attr">MyColor</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;Binding Path=Text,ElementName=tbColor&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p:MyDependencyProperty</span>&gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span>        </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在设计界面显示的效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115122217947-1972572422.png" srcset="/img/loading.gif" alt="img"></p><p>4、程序运行效果：</p><p>在TextBox里面输入正确的颜色值，前景色会显示为当前输入的颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121945931-691430131.png" srcset="/img/loading.gif" alt="img"></p><p>在TextBox里面输入错误的颜色值，前景色会显示为默认颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121956713-612253816.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>依赖属性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-命令</title>
    <link href="/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>命令有许多可变的部分组成，但它们都具有以下4个重要元素：</p><ul><li>命令<br>命令表示应用程序任务，并且跟踪任务是否能够被执行。<br>然而，命令实际上不包含执行应用程序任务的代码。</li><li>命令绑定<br>每个命令绑定针对用户界面的具体元素，将命令连接到相关的应用程序逻辑。<br>这种分解的设计是非常重要的，因为单个命令可用于应用程序中的多个地方，并且在每个地方具有不同的意义。<br>为处理这一问题，需要将同一命令与不同的命令绑定。</li><li>命令源<br>命令源触发命令。<br>例如，button就是命令源。<br>单击它们都会执行绑定命令。</li><li>命令目标<br>命令目标是在其中执行命令的元素。</li></ul><p><img src="/images/WPF-%E5%91%BD%E4%BB%A4/image-20210424153346796.png" srcset="/img/loading.gif" alt="image-20210424153346796"></p><h1 id="2-如何实现一个命令"><a href="#2-如何实现一个命令" class="headerlink" title="2.如何实现一个命令"></a>2.如何实现一个命令</h1><p>WPF命令的核心是System.Windows.Input.ICommand接口，该接口定义了命令的工作原理。<br>该接口包含两个方法和一个事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICommand</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">CanExecute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-keyword">event</span> EventHandler CanExecuteChanged;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>Execute</td><td>将包含引用程序任务逻辑</td></tr><tr><td>CanExecute</td><td>返回命令的状态。可用为true，不可用为false；</td></tr><tr><td>CanExecuteChanged</td><td>当命令状态改变是引发该事件。对于使用命令的任何控件，这是指示信号，表示他们应当调用</td></tr></tbody></table><blockquote><p>Execute和CanExecute方法都接受一个附加的对象参数，可使用该对象传递所需的任何附加信息。</p></blockquote><blockquote><p>CanExecute方法检查命令的状态。<br>通过使用该事件，当命令可用时，命令源（如button）可自动启用自身；<br>当命令不可用时，禁用自身。</p></blockquote><h1 id="3-如何让控件支持命令"><a href="#3-如何让控件支持命令" class="headerlink" title="3. 如何让控件支持命令"></a>3. 如何让控件支持命令</h1><p>支持命令的实现是在“命令源”这个环节实现ICommandSource。</p><p>ICommandSource接口定义了三个属性:</p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>Command</td><td>指向连接的命令，这是唯一必须的细节</td></tr><tr><td>CommandParameter</td><td>提供其他希望随命令发送的数据</td></tr><tr><td>CommandTarget</td><td>确定将在其中执行命令的元素</td></tr></tbody></table><blockquote><p>不是每个控件都直接支持command绑定的<br>需要将他们关联到实现了ICommandSource接口的控件<br>其中包括继承自ButtonBase类的控件（button和Checkbox等）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-控件</title>
    <link href="/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/"/>
    <url>/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul><li>常用控件表</li></ul><table><thead><tr><th>控件名</th><th>作用</th></tr></thead><tbody><tr><td>Label</td><td>一般用户描述性文字显示</td></tr><tr><td>TextBlock</td><td>只读的文本框，无法进行编辑，比较适合显示文本，该文本内容不允许编辑的情况</td></tr><tr><td>TextBox</td><td>支持编辑的基本控件</td></tr><tr><td>PassWordBox</td><td>一般用于用户输入验证或者注册时使用</td></tr><tr><td>DataGrid</td><td>列表数据显示控件</td></tr><tr><td>ListView</td><td>一般ListView都可以用DataGrid替代</td></tr><tr><td>ListBox</td><td>下拉列表级控件</td></tr><tr><td>GroupBox</td><td>用于组织页面相关元素放到一起，方便用户使用等方面提供帮助。</td></tr><tr><td>RichTextBox</td><td>支持富文本和简单文本等，可以实现出类似Word的那样的效果。</td></tr><tr><td>MediaElement</td><td>对媒体文件的操作和访问</td></tr><tr><td>Menu</td><td>菜单栏方式的多级菜单的管理和操作</td></tr><tr><td>TabControl</td><td>分页标签</td></tr></tbody></table><p><img src="/images/WPF-%E6%8E%A7%E4%BB%B6/image-20210424140413545.png" srcset="/img/loading.gif" alt="image-20210424140413545"></p><ul><li>控件的基础属性<br>宽、高、背景色、字体颜色、字体大小、禁用、启用、显示、隐藏等</li><li>控件显示的值内容<br>Content、Text、Value等</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>控件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-布局</title>
    <link href="/2021/04/24/WPF-%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/24/WPF-%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>又称容器，面板。<br>在WPF中是最基础也是最重要的一环，它直接决定你界面的样子。掌握熟练度决定它的美观度和可交互性。</p><p>WPF与JavaSwing的布局(容器)有相似之处但又不完全相同。</p><p>WPF的面板主要有6个：</p><ul><li><p>Grid（网格面板）</p></li><li><p>StackPanel(栈面板)</p></li><li><p>Canvas（画布）</p></li><li><p>WrapPanel（环绕面板）</p></li><li><p>DockPanel（停靠面板）</p></li><li><p>UniformGrid(均布网格)</p></li></ul><p>其中前三个最为常用。</p><h1 id="2-Gird-布局"><a href="#2-Gird-布局" class="headerlink" title="2. Gird 布局"></a>2. Gird 布局</h1><p>可以理解为一个表格，类似于HTML中的Table标签。</p><p>它是由行和列组成。</p><h2 id="2-1-标签"><a href="#2-1-标签" class="headerlink" title="2.1 标签"></a>2.1 标签</h2><ul><li><p><code>&lt;Grid&gt;&lt;/Grid&gt;</code><br>该标签对内写入表格内容</p></li><li><p><code>&lt;Grid.RowDefinitions&gt;</code><br>该标签内写入<code>&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</code>标签对<br>用于定义Gird布局中有几行</p></li><li><p><code>&lt;Grid.ColumnDefinitions&gt;</code><br>该标签内写入<code>&lt;ColumnDefinition&gt;&lt;/ColumnDefinition&gt;</code>标签对<br>用于定义Gird布局中有几列</p></li></ul><h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><ul><li><p>Grid.Column<br>当前元素在Gird布局中的第几列</p></li><li><p>Grid.Row<br>当前元素在Gird布局中的第几行</p><blockquote><p>都从0开始数，且该属性写在元素标签内</p></blockquote></li></ul><h2 id="2-3-案例"><a href="#2-3-案例" class="headerlink" title="2.3 案例"></a>2.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上代码的效果是：</p><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424125742746.png" srcset="/img/loading.gif" alt="Grid布局"></p><h1 id="3-StackPanel-布局"><a href="#3-StackPanel-布局" class="headerlink" title="3 StackPanel 布局"></a>3 StackPanel 布局</h1><p>是一个可以将自身内容横向或纵向排列的容器。</p><h2 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 标签"></a>3.1 标签</h2><ul><li><code>&lt;StackPanel&gt;&lt;/StackPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p><ul><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul></li></ul><blockquote><p>默认情况下：<br>水平排列时，每个元素都与面板一样高；<br>垂直排列时，每个元素都与面板一样宽。<br>如果包含的元素超过了面板空间，它只会截断多出的内容。<br>元素的Margin属性用于使元素之间产生一定得间隔，当元素空间大于其内容的空间时，剩余空间将由HorizontalAlignment和 VerticalAlignment属性来决定如何分配。</p></blockquote><h2 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h2><p>垂直排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Vertical&quot;</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131943534.png" srcset="/img/loading.gif" alt="竖直排列"></p><p>水平排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Horizontal&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131833665.png" srcset="/img/loading.gif" alt="水平排列"></p><h1 id="4-WrapPanel-布局"><a href="#4-WrapPanel-布局" class="headerlink" title="4. WrapPanel 布局"></a>4. WrapPanel 布局</h1><p>WrapPanel面板以一行或者一列的形式来布置控件，当一行（列）放满之后自动转到下一行（列）。</p><blockquote><p>除了自动换行外，基本与StackPanel相同</p></blockquote><h2 id="4-1-标签"><a href="#4-1-标签" class="headerlink" title="4.1 标签"></a>4.1 标签</h2><ul><li><code>&lt;WrapPanel&gt;&lt;/WrapPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="4-2-属性"><a href="#4-2-属性" class="headerlink" title="4.2 属性"></a>4.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p></li><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul><h1 id="5-Canvas-布局"><a href="#5-Canvas-布局" class="headerlink" title="5 Canvas 布局"></a>5 Canvas 布局</h1><p>它比较特殊。它属于“任意布局”的一种概念，就是你拖控件到UI上的时候你把它放在哪里它就在那里了。</p><h2 id="5-1-标签"><a href="#5-1-标签" class="headerlink" title="5.1 标签"></a>5.1 标签</h2><ul><li><code>&lt;Canvas&gt;&lt;/Canvas&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="5-2-属性"><a href="#5-2-属性" class="headerlink" title="5.2 属性"></a>5.2 属性</h2><ul><li>Canvas.Top<br>设置元素距Canvas顶部的距离</li><li>Canvas.Bottom<br>设置元素距Canvas底部的距离</li><li>Canvas.Left<br>设置元素距Canvas左边界的距离</li><li>Canvas.Right<br>设置元素距Canvas右边界的距离</li></ul><blockquote><p>当同时设置left和right,top和bottom,以left和top为准</p></blockquote><h2 id="5-3-案例"><a href="#5-3-案例" class="headerlink" title="5.3 案例"></a>5.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Canvas</span> <span class="hljs-attr">Background</span>=<span class="hljs-string">&quot;LightBlue&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Top</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Top=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Bottom</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Bottom=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Left</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Left=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Right</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Right=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Canvas</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-绑定</title>
    <link href="/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/"/>
    <url>/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p> 绑定顾名思义，是将我们获取到的数据和UI上的控件绑定起来利用数据的变化来更新界面所看到的内容。</p><p>绑定的五个步骤:</p><ul><li>1.绑定目标 </li><li>2.绑定属性 </li><li>3.绑定模式 </li><li>4.绑定数据源 </li><li>5.关联资源</li></ul><h1 id="2-绑定步骤"><a href="#2-绑定步骤" class="headerlink" title="2. 绑定步骤"></a>2. 绑定步骤</h1><h2 id="2-1-绑定目标"><a href="#2-1-绑定目标" class="headerlink" title="2.1 绑定目标"></a>2.1 绑定目标</h2><p>绑定目标很好理解，其实就是你要操作绑定的控件。例如：Button，TextBox。</p><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot;&gt;&lt;/TextBox&gt;</code></p><p><img src="D:\码田\项目\MyBlog\source\images\WPF-绑定\image-20210424143754327.png" srcset="/img/loading.gif" alt="image-20210424143754327"></p><h2 id="2-2绑定属性（依赖项属性）"><a href="#2-2绑定属性（依赖项属性）" class="headerlink" title="2.2绑定属性（依赖项属性）"></a>2.2绑定属性（依赖项属性）</h2><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot; Text=&quot;&#123;Bingding Name&#125;&quot;&gt;&lt;/TextBox&gt;</code></p><ul><li>Text绑定属性</li><li>Bingding 绑定关键字</li><li>Name你要绑定的数据源的变量名</li></ul><h2 id="2-3-绑定模式"><a href="#2-3-绑定模式" class="headerlink" title="2.3 绑定模式"></a>2.3 绑定模式</h2><table><thead><tr><th>模式名称</th><th>含义</th></tr></thead><tbody><tr><td>TwoWay</td><td>无论是目标属性还是源属性，只要发生了更改，就会更新目标属性或源属性</td></tr><tr><td>OneWay</td><td>仅当源属性发生更改时更新目标属性</td></tr><tr><td>OneTime</td><td>仅当应用程序启动时或 DataContext 进行更改时更新目标属性</td></tr><tr><td>OneWayToSource</td><td>在目标属性更改时更新源属性</td></tr><tr><td>Default</td><td>模式根据实际情况来定，如果是可编辑的就是TwoWay,只读的就是OneWay</td></tr></tbody></table><h2 id="2-4-绑定数据源"><a href="#2-4-绑定数据源" class="headerlink" title="2.4 绑定数据源"></a>2.4 绑定数据源</h2><p>一般来说可以是单个变量（int , double,string）、也可以是一个数据集（List）。根据需求和场景去定义。</p><h2 id="2-5-关联资源-DataContext"><a href="#2-5-关联资源-DataContext" class="headerlink" title="2.5 关联资源 DataContext"></a>2.5 关联资源 DataContext</h2><p>在每一个窗体中，都有一个DataContext ，它是一个object类型主要用来存储绑定资源。</p><h1 id="3-绑定和窗体xaml-cs操作的区别"><a href="#3-绑定和窗体xaml-cs操作的区别" class="headerlink" title="3. 绑定和窗体xaml.cs操作的区别"></a>3. 绑定和窗体xaml.cs操作的区别</h1><p>区别在于，窗体后台文件直接访问控件的操作是事件驱动，如果没有事件的存在是改变不了界面的。</p><p>绑定操作，是以数据本身的变化来通知界面显示改变的。</p><p>UI代码和逻辑代码实现前后端分离。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>绑定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF快速入门</title>
    <link href="/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>整理自B站视频教程:<a href="https://www.bilibili.com/video/BV19K411M72o?p=1">https://www.bilibili.com/video/BV19K411M72o?p=1</a></p><h2 id="1-1-什么是WPF"><a href="#1-1-什么是WPF" class="headerlink" title="1.1 什么是WPF"></a>1.1 什么是WPF</h2><p>WPF全称Windows Presentation Foundation，是微软推出的一项基于windows操作系统的.net平台的c/s客户端构建技术。<br>最大的特征就是可以快速构建项目从而达到节约项目成本的目的。<br>在众多中小型企业比较受欢迎。</p><p>该项受欢迎的行业有医疗、工业、金融、硬件、物流、管理系统（ERP）等领域。</p><p>简而言之就是微软基于C#与.NET推出的一个可视化框架。</p><blockquote><p>微软的可视化框架发展路径：<br>MFC-&gt;WinForm-&gt;WPF</p></blockquote><h2 id="1-2-推荐书籍"><a href="#1-2-推荐书籍" class="headerlink" title="1.2 推荐书籍"></a>1.2 推荐书籍</h2><ul><li><p>《WPF编程宝典使用c#2012和.net4.5 第四版》</p></li><li><p>《c#高级编程》</p></li><li><p>《CLR Via C#》</p></li></ul><h2 id="1-3-前置知识体系"><a href="#1-3-前置知识体系" class="headerlink" title="1.3 前置知识体系"></a>1.3 前置知识体系</h2><ul><li><p>C#</p></li><li><p>学习过至少一种可视化框架或web框架</p></li></ul><h1 id="2-学习目录索引"><a href="#2-学习目录索引" class="headerlink" title="2 学习目录索引"></a>2 学习目录索引</h1><ul><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%B8%83%E5%B1%80/">布局(Pannel)</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/">控件</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/">依赖属性</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/">绑定</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/">命令</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-MVVC/">MVVM</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p><p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。<br>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。<br>这种方式简化了在复杂环境下的配置管理。</p><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><ul><li><p>单例类只能有一个实例</p></li><li><p>单例类必须自己创建自己的唯一实例</p></li><li><p>单例类必须给所有其他对象提供这一实例</p></li></ul><h2 id="2-1-优缺点"><a href="#2-1-优缺点" class="headerlink" title="2.1 优缺点"></a>2.1 优缺点</h2><h3 id="2-1-1-优点"><a href="#2-1-1-优点" class="headerlink" title="2.1.1 优点"></a>2.1.1 优点</h3><ul><li><p>在内存中只有一个对象，节省内存空间；</p></li><li><p>避免频繁的创建销毁对象，可以提高性能；</p></li><li><p>避免对共享资源的多重占用，简化访问；</p></li><li><p>为整个系统提供一个全局访问点。</p></li></ul><h3 id="2-1-2-缺点"><a href="#2-1-2-缺点" class="headerlink" title="2.1.2 缺点"></a>2.1.2 缺点</h3><ul><li><p>不适用于变化频繁的对象；</p></li><li><p>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</p></li><li><p>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</p></li></ul><h2 id="2-2-适用场景"><a href="#2-2-适用场景" class="headerlink" title="2.2 适用场景"></a>2.2 适用场景</h2><ul><li>需要生成唯一序列的环境</li><li>需要频繁实例化然后销毁的对象</li><li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象</li><li>方便资源相互通信的环境</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" alt="单例模式"></p><h1 id="4-实现步骤"><a href="#4-实现步骤" class="headerlink" title="4. 实现步骤"></a>4. 实现步骤</h1><ol><li>将该类的构造方法定义为私有方法：<br>这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</li><li>在该类内提供一个静态方法：<br>当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li></ol><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将为一个网站设计一个用于连接数据库的数据库连接池，它基于JDBC，并且要求具有以下几个功能：</p><ul><li>连接池内有数量可定的已连接对象随时供取用</li><li>当连接池内的连接对象不够时可生成新的对象取用</li><li>当连接操作完毕后，可将连接对象放回连接池</li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p>使用单例模式实现连接池：</p><ol><li><p>将该类的构造方法定义为私有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在该类内提供一个静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>   &#125;<br></code></pre></td></tr></table></figure><p>使用线性表存储连接对象，实现对连接对象操作的各个方法。</p></li></ol><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> EXP6;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;<br>    <span class="hljs-comment">//数据库地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String url;<br>    <span class="hljs-comment">//取得用户</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String user;<br>    <span class="hljs-comment">//登录密码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String password;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Connection&gt; connections;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConnectionPool connectionPool;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(String url,String user,String password)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.url=url;<span class="hljs-keyword">this</span>.user=user;<span class="hljs-keyword">this</span>.password=password;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">(String url,String user,String password)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool(url,user,password);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)<br>            &#123;<br>                connections.add(DriverManager.getConnection(url,user,password));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(connections.size()==<span class="hljs-number">0</span>) addConnection(<span class="hljs-number">1</span>);<br>        Connection t=connections.getFirst();<br>        connections.removeFirst();<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseConnection</span><span class="hljs-params">(Connection c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (c.isClosed()) connections.add(c);<br>                <span class="hljs-keyword">else</span> addConnection(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-进阶写法"><a href="#6-进阶写法" class="headerlink" title="6. 进阶写法"></a>6. 进阶写法</h1><h2 id="6-1-懒汉式-线程不安全"><a href="#6-1-懒汉式-线程不安全" class="headerlink" title="6.1 懒汉式(线程不安全)"></a>6.1 懒汉式(线程不安全)</h2><p>懒汉式其实是一种比较形象的称谓。<br>既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作。<br>因此在装载对象的时候不创建对象实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> (<span class="hljs-params"></span>)</span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         instance = <span class="hljs-keyword">new</span> Singleton();<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。<br>当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。<br>也就是说在多线程下不能正常工作。</p><h2 id="6-2-懒汉式-线程安全"><a href="#6-2-懒汉式-线程安全" class="headerlink" title="6.2 懒汉式(线程安全)"></a>6.2 懒汉式(线程安全)</h2><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。<br>因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。<br>这就引出了双重检验锁。</p><h2 id="6-3-双重检验锁"><a href="#6-3-双重检验锁" class="headerlink" title="6.3 双重检验锁"></a>6.3 双重检验锁</h2><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。<br>程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。<br>为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <span class="hljs-comment">//Single Checked</span><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                 <span class="hljs-comment">//Double Checked</span><br>                instance = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很完美，很可惜，它是有问题:<br>主要在于instance = new Singleton()这句，这<strong>并非是一个原子操作</strong>，事实上在 JVM 中这句话大概做了下面 3 件事情:</p><ul><li><p>给 instance 分配内存</p></li><li><p>调用 Singleton 的构造函数来初始化成员变量</p></li><li><p>将instance对象指向分配的内存空间<br>（执行完这步 instance 就为非 null 了）</p></li></ul><p>但是在 JVM 的即时编译器中存在指令重排序的优化。</p><p>也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。<br>如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance; <span class="hljs-comment">//声明成 volatile</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;       <br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。<br>但其实是不对的。</p><p><strong>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。</strong></p><p>也就是说，<strong>在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前</strong>。<br>比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</p><p>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。<br>这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p><h2 id="6-4-饿汉式-static-final-field"><a href="#6-4-饿汉式-static-final-field" class="headerlink" title="6.4 饿汉式 static final field"></a>6.4 饿汉式 static final field</h2><p>饿汉式其实是一种比较形象的称谓。<br>既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。</p><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-comment">//类加载时就初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点是它不是一种懒加载模式（lazy initialization），<strong>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。</strong></p><blockquote><p>饿汉式的创建方式在一些场景中将无法使用：<br>譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p></blockquote><h2 id="6-5-静态内部类-static-nested-class"><a href="#6-5-静态内部类-static-nested-class" class="headerlink" title="6.5 静态内部类 static nested class"></a>6.5 静态内部类 static nested class</h2><p>这种方法也是《Effective Java》上所推荐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE; <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法仍然使用JVM本身机制保证了线程安全问题。<br>由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，**第一次调用getInstance()时将加载内部类SingletonHolder **，在该内部类中定义了一个static类型的变量INSTANCE ，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><h2 id="6-6-枚举-Enum"><a href="#6-6-枚举-Enum" class="headerlink" title="6.6 枚举 Enum"></a>6.6 枚举 Enum</h2><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EasySingleton</span></span>&#123;<br>    <span class="hljs-type">INSTANCE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>我们可以总结出，要想实现效率高的线程安全的单例，我们必须注意以下两点：</p><ul><li><strong>尽量减少同步块的作用域</strong></li><li><strong>尽量使用细粒度的锁</strong></li></ul><p>一般来说，单例模式有五种写法：<br><strong>懒汉、饿汉、双重检验锁、静态内部类、枚举</strong><br>上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。</p><p>一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。<br>如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p><p>参考：<br><a href="https://www.jianshu.com/p/650593e69f59">https://www.jianshu.com/p/650593e69f59</a><br><a href="https://www.cnblogs.com/xuwendong/p/9633985.html">https://www.cnblogs.com/xuwendong/p/9633985.html</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket原理</title>
    <link href="/2021/04/07/Socket%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/07/Socket%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Socket"><a href="#1-什么是Socket" class="headerlink" title="1. 什么是Socket"></a>1. 什么是Socket</h1><h2 id="1-1-网络中进程之间如何通信"><a href="#1-1-网络中进程之间如何通信" class="headerlink" title="1.1 网络中进程之间如何通信"></a>1.1 网络中进程之间如何通信</h2><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信。</p><p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！<br>在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p><p>其实TCP/IP协议族已经帮我们解决了这个问题：<br>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><p>使用TCP/IP协议的应用程序通常采用应用编程接口：<br>UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。</p><p>就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。</p><h2 id="1-2-什么是TCP-IP、UDP"><a href="#1-2-什么是TCP-IP、UDP" class="headerlink" title="1.2 什么是TCP/IP、UDP"></a>1.2 什么是TCP/IP、UDP</h2><ul><li><p>TCP/IP（Transmission Control Protocol/Internet Protocol）<br>即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。</p></li><li><p>UDP（User Data Protocol，用户数据报协议）<br>是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p></li></ul><p>这里有一张图，表明了这些协议的关系。</p><p>​          <img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154451958.png" srcset="/img/loading.gif" alt="img">                              </p><h2 id="1-3-什么是Socket"><a href="#1-3-什么是Socket" class="headerlink" title="1.3 什么是Socket"></a>1.3 什么是Socket</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。<br>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p><blockquote><h3 id="socket一词的起源"><a href="#socket一词的起源" class="headerlink" title="socket一词的起源"></a>socket一词的起源</h3><p>在组网领域的首次使用是在1970年2月12日发布的文献<a href="http://datatracker.ietf.org/doc/rfc33/">IETF RFC33</a>中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p></blockquote><h2 id="1-4-Socket在哪里"><a href="#1-4-Socket在哪里" class="headerlink" title="1.4 Socket在哪里"></a>1.4 Socket在哪里</h2><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154523875.png" srcset="/img/loading.gif" alt="img"></p><h1 id="2-Socket的使用"><a href="#2-Socket的使用" class="headerlink" title="2. Socket的使用"></a>2. Socket的使用</h1><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154556909.png" srcset="/img/loading.gif" alt="img">   </p><ul><li>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。</li><li>在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。</li><li>客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</li></ul><h2 id="2-1-socket的基本操作"><a href="#2-1-socket的基本操作" class="headerlink" title="2.1 socket的基本操作"></a>2.1 socket的基本操作</h2><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。<br>下面以TCP为例，介绍几个基本的socket接口函数。</p><h3 id="2-1-1-socket-函数"><a href="#2-1-1-socket-函数" class="headerlink" title="2.1.1 socket()函数"></a>2.1.1 socket()函数</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> socket(<span class="hljs-type">int</span> <span class="hljs-keyword">domain</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">type</span>, <span class="hljs-type">int</span> protocol);<br></code></pre></td></tr></table></figure><p>socket函数对应于普通文件的打开操作。<br>普通文件的打开操作返回一个文件描述字，而**socket()**用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。<br>这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。<br>创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：<br>即协议域，又称为协议族（family）。<br>常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。<br>协议族决定了socket的地址类型，在通信中必须采用对应的地址。<br>如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：<br>指定socket类型。<br>常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li><li>protocol：<br>故名思意，就是指定协议。<br>常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等<br>它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li></ul><blockquote><p>注意：<br>并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。<br>当protocol为0时，会自动选择type类型对应的默认协议。</p></blockquote><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h3 id="2-1-2-bind-函数"><a href="#2-1-2-bind-函数" class="headerlink" title="2.1.2 bind()函数"></a>2.1.2 bind()函数</h3><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。<br>例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ul><li><p>sockfd：<br>即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。<br>bind()函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：<br>一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。<br>这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-keyword">sa_family_t</span>    sin_family; <br>    <span class="hljs-keyword">in_port_t</span>      sin_port;   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>   <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span>       s_addr;     <br>&#125;;<br></code></pre></td></tr></table></figure><p>ipv6对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span>     sin6_family;    <br>    <span class="hljs-keyword">in_port_t</span>       sin6_port;      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_flowinfo;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span>      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_scope_id;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> &#123;</span> <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   s6_addr[<span class="hljs-number">16</span>];    <br>&#125;;<br></code></pre></td></tr></table></figure><p>Unix域对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_PATH_MAX    108</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span> sun_family;                <br>    <span class="hljs-keyword">char</span>        sun_path[UNIX_PATH_MAX];   <br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>addrlen：对应的是地址的长度。</p></li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务。<br>客户就可以通过它来接连服务器；</p><p>而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。</p><p>这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p><blockquote><h3 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h3><p><strong>主机字节序</strong>就是我们平常说的大端和小端模式：<br>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。<br>引用标准的Big-Endian和Little-Endian的定义如下：</p><p>　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><p>　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p><strong>网络字节序</strong>：<br>4个字节的32 bit值以下面的次序传输：<br>首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。<br>这种传输次序称作大端字节序。<br><strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong><br>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p><p>所以： 在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。<br>由于 这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再 赋给socket。</p></blockquote><h3 id="2-1-3-listen-、connect-函数"><a href="#2-1-3-listen-、connect-函数" class="headerlink" title="2.1.3 listen()、connect()函数"></a>2.1.3 listen()、connect()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。<br>客户端通过调用connect函数来建立与TCP服务器的连接。</p><h3 id="2-1-4-accept-函数"><a href="#2-1-4-accept-函数" class="headerlink" title="2.1.4 accept()函数"></a>2.1.4 accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。<br>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。<br>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。<br>之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><blockquote><p>注意：<br>accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。<br>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。<br>内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p></blockquote><h3 id="2-1-5-read-、write-等函数"><a href="#2-1-5-read-、write-等函数" class="headerlink" title="2.1.5 read()、write()等函数"></a>2.1.5 read()、write()等函数</h3><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。</p><p>可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。</p><p>它们的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">const</span> struct sockaddr *dest_addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">                 struct sockaddr *src_addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>read函数<br>负责从fd中读取内容<br>当读成功时，read返回实际所读的字节数</p><ul><li>返回的值是0表示已经读到文件的结束了</li><li>返回的值小于0表示出现了错误。<ul><li>如果错误为EINTR说明读是由中断引起的</li><li>如果是ECONNREST表示网络连接出了问题。</li></ul></li></ul></li><li><p>write函数<br>将buf中的nbytes字节内容写入文件描述符fd。</p><ul><li><p>成功时返回写的字节数</p></li><li><p>失败时返回-1，并设置errno变量</p></li><li><p>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</p><ul><li><p>1)write的返回值大于0，表示写了部分或者是 全部的数据。</p></li><li><p>2)返回的值小于0，此时出现了错误。</p></li></ul><p>我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。<br>如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。</p></li></ul></li></ul><p>其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。</p><h3 id="2-1-6-close-函数"><a href="#2-1-6-close-函数" class="headerlink" title="2.1.6 close()函数"></a>2.1.6 close()函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。<br>该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><blockquote><p>注意：<br>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p></blockquote><h2 id="2-2-socket中TCP的三次握手建立连接详解"><a href="#2-2-socket中TCP的三次握手建立连接详解" class="headerlink" title="2.2 socket中TCP的三次握手建立连接详解"></a>2.2 socket中TCP的三次握手建立连接详解</h2><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><p>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0NzYyODYucG5n" srcset="/img/loading.gif" alt="image"></p><p>图1、socket中发送的TCP三次握手</p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><blockquote><p>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</p></blockquote><h2 id="2-3-socket中TCP的四次握手释放连接详解"><a href="#2-3-socket中TCP的四次握手释放连接详解" class="headerlink" title="2.3 socket中TCP的四次握手释放连接详解"></a>2.3 socket中TCP的四次握手释放连接详解</h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0OTQ2OTMucG5n" srcset="/img/loading.gif" alt="image"></p><p>图2、socket中发送的TCP四次握手</p><p>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p>这样每个方向上都有一个FIN和ACK。</p><p>6.下面给出实现的一个实例</p><p>首先，先给出实现的截图</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718155008892.png" srcset="/img/loading.gif" alt="img"></p><p>服务器端代码如下：</p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET sListen = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>//用来指定套接字使用的地址格式，通常使用AF_INET</li><li>//指定套接字的类型，若是SOCK_DGRAM，则用的是udp不可靠传输</li><li>//配合type参数使用，指定使用的协议类型（当指定套接字类型后，可以设置为0，因为默认为UDP或TCP）</li><li>if(sListen == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 填充sockaddr_in结构 ,是个结构体</li><li>sockaddr_in sin;</li><li>sin.sin_family = AF_INET;</li><li>sin.sin_port = htons(4567); //1024 ~ 49151：普通用户注册的端口号</li><li>sin.sin_addr.S_un.S_addr = INADDR_ANY;</li><li>// 绑定这个套节字到一个本地地址</li><li>if(::bind(sListen, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed bind() \n”);</li><li>return 0;</li><li>}</li><li>// 进入监听模式</li><li>//2指的是，监听队列中允许保持的尚未处理的最大连接数</li><li>if(::listen(sListen, 2) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed listen() \n”);</li><li>return 0;</li><li>}</li><li>// 循环接受客户的连接请求</li><li>sockaddr_in remoteAddr;</li><li>int nAddrLen = sizeof(remoteAddr);</li><li>SOCKET sClient = 0;</li><li>char szText[] = “ TCP Server Demo! \r\n”;</li><li>while(sClient==0)</li><li>{</li><li>// 接受一个新连接</li><li>//（(SOCKADDR*)&amp;remoteAddr）一个指向sockaddr_in结构的指针，用于获取对方地址</li><li>sClient = ::accept(sListen, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrLen);</li><li>if(sClient == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed accept()”);</li><li>}</li><li>printf(“接受到一个连接：%s \r\n”, inet_ntoa(remoteAddr.sin_addr));</li><li>continue ;</li><li>}</li><li>while(TRUE)</li><li>{</li><li>// 向客户端发送数据</li><li>gets(szText) ;</li><li>::send(sClient, szText, strlen(szText), 0);</li><li>// 从客户端接收数据</li><li>char buff[256] ;</li><li>int nRecv = ::recv(sClient, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“ 接收到数据：%s\n”, buff);</li><li>}</li><li>}</li><li>// 关闭同客户端的连接</li><li>::closesocket(sClient);</li><li>// 关闭监听套节字</li><li>::closesocket(sListen);</li><li>return 0;</li><li>}</li></ol><p>客户端代码：</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET s = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>if(s == INVALID_SOCKET)</li><li>{</li><li>printf(“ Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 也可以在这里调用bind函数绑定一个本地地址</li><li>// 否则系统将会自动安排</li><li>// 填写远程地址信息</li><li>sockaddr_in servAddr;</li><li>servAddr.sin_family = AF_INET;</li><li>servAddr.sin_port = htons(4567);</li><li>// 注意，这里要填写服务器程序（TCPServer程序）所在机器的IP地址</li><li>// 如果你的计算机没有联网，直接使用127.0.0.1即可</li><li>servAddr.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1”);</li><li>if(::connect(s, (sockaddr*)&amp;servAddr, sizeof(servAddr)) == -1)</li><li>{</li><li>printf(“ Failed connect() \n”);</li><li>return 0;</li><li>}</li><li>char buff[256];</li><li>char szText[256] ;</li><li>while(TRUE)</li><li>{</li><li>//从服务器端接收数据</li><li>int nRecv = ::recv(s, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“接收到数据：%s\n”, buff);</li><li>}</li><li>// 向服务器端发送数据</li><li>gets(szText) ;</li><li>szText[255] = ‘\0’;</li><li>::send(s, szText, strlen(szText), 0) ;</li><li>}</li><li>// 关闭套节字</li><li>::closesocket(s);</li><li>return 0;</li><li>}</li></ol><p>封装的InitSock.h</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include</li><li>#include</li><li>#include</li><li>#include</li><li>#pragma comment(lib, “WS2_32”) // 链接到WS2_32.lib</li><li>class CInitSock</li><li>{</li><li>public:</li><li>CInitSock(BYTE minorVer = 2, BYTE majorVer = 2)</li><li>{</li><li>// 初始化WS2_32.dll</li><li>WSADATA wsaData;</li><li>WORD sockVersion = MAKEWORD(minorVer, majorVer);</li><li>if(::WSAStartup(sockVersion, &amp;wsaData) != 0)</li><li>{</li><li>exit(0);</li><li>}</li><li>}</li><li>~CInitSock()</li><li>{</li><li>::WSACleanup();</li><li>}</li><li>};</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity输入操作</title>
    <link href="/2021/03/25/Unity%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/03/25/Unity%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>输入操作是游戏的基础操作之一。</p><p>Unity支持的操作方式：</p><ul><li>鼠标、键盘，小键盘(PC)</li><li>手柄(主机)</li><li>触屏操作、重力传感器、手势（移动平台）</li><li>VR，AR</li><li>麦克风，摄像头</li></ul><h1 id="2-虚拟输入轴-Virtual-axes"><a href="#2-虚拟输入轴-Virtual-axes" class="headerlink" title="2. 虚拟输入轴(Virtual axes)"></a>2. 虚拟输入轴(Virtual axes)</h1><p>虚拟控制轴将不同的输入设备(比如键盘或摇杆的按键)都归纳到一个统一的虚拟控制系统中。<br>(比如键盘的w、S键以及手柄摇杆的上下运动默认都统一映射到竖直(Verica)输入轴上)<br>这样就屏蔽了不同设备之间的差异，让开发者可以用一套非常简单的输入逻辑，同时兼容多种输入设备。</p><p>使用**输入管理器(Input Manager)**可以查看、修改或增删虚拟轴。</p><p>现代的游戏中往往允许玩家在游戏中自定义按键，所以使用Unity的输入管理器就更为重要要了。<br>通过一层虚拟轴间接操作，可以避免在代码中直接写死操作按钮，而且还能通过动态修改虚拟轴的设置来改变键位的功能。</p><p>关于虚拟输入轴，还有一些需要知道的内容：</p><ol><li><p>脚本可以直接通过虚拟轴的名称读取那个轴的输入状态。</p></li><li><p>创建Unity工程时，默认创建了以下虚拟轴:</p><ul><li><p>横向输入和纵向输入被映射在键盘的W、A、S、 D键以及方向键上</p></li><li><p>Fire1、 Fire2、 Fire3这三个按钮映射到了鼠标的左、中、右键以及键盘的Ctrl. AIt等键位上</p></li><li><p>鼠标移动可以模拟摇杆输入(和鼠标光标在屏幕上的位置无关)，且被映射在专门的鼠标偏移轴上</p></li><li><p>其他常用虚拟轴，例如跳跃(Jump) 、确认(Submit) 和取消(Cancel) </p></li></ul><h2 id="2-1-添加和编辑虚拟输入轴"><a href="#2-1-添加和编辑虚拟输入轴" class="headerlink" title="2.1 添加和编辑虚拟输入轴"></a>2.1 添加和编辑虚拟输入轴</h2></li></ol><p>要添加新的虚拟输入轴，只需要单击主菜单的Edit &gt; Projet Setings &gt; Input 选项，单击路街检视窗口中会显示一个输入管理器，在里面就可以修改或添加虚拟轴了。</p><blockquote><p>注意:<br>虚拟轴具有正、负两个方向。英文记作Positive和Negative.。<br>某些相反的动作可以只用一个轴来表示。<br>比如，如果摇杆向上为正，那么向下就是同一个轴的负方向。</p></blockquote><p>每个虚拟轴可以映射两个按键，第二个按键作为备用，功能一样，备用的英文为Alterative。</p><h2 id="2-2-虚拟输入轴属性表"><a href="#2-2-虚拟输入轴属性表" class="headerlink" title="2.2 虚拟输入轴属性表"></a>2.2 虚拟输入轴属性表</h2><p>下表是虚拟输入轴的属性表：</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>Name</td><td>轴的名字。在脚本中用这个名字来访问这个轴</td></tr><tr><td>Descriptive Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(正方向)</td></tr><tr><td>Descriptive Negative Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(负方向)</td></tr><tr><td>Ncgative Button</td><td>该轴的负方向，用于绑定某个按键</td></tr><tr><td>Positive Button</td><td>该轴的正方向，用于绑定某个按键</td></tr><tr><td>Alt Negative Button</td><td>该轴的负方向，用于绑定某个备用按键</td></tr><tr><td>Alt Positive Button</td><td>该轴的正方向，用于绑定某个备用按键</td></tr><tr><td>Gravity</td><td>轴回中的力度</td></tr><tr><td>Dead</td><td>轴的死区</td></tr><tr><td>Sensitivity</td><td>敏感度</td></tr><tr><td>Snap</td><td>保持式按键。比如按住下方向键，则一直保持下的状态，直到再次按上方向键</td></tr><tr><td>Invert</td><td>如果勾选，则交换正负方向</td></tr><tr><td>Type</td><td>控制该虚拟轴的类型， 比如手柄、键盘是两种不同的类型</td></tr><tr><td>Axis</td><td>很多手柄的输入不是按钮式的，这时就不能配置到Button里面，而是要配置到这里。可以理解为实际的操作轴</td></tr><tr><td>Joy Num</td><td>当有多个控制器时，要填写控制器的编号</td></tr></tbody></table><p>上表中的Gravity、Dead 等属性需要解释一下。</p><h3 id="2-2-1-Gravity"><a href="#2-2-1-Gravity" class="headerlink" title="2.2.1 Gravity"></a>2.2.1 Gravity</h3><p>现代游戏的方向输入和早期游戏的方向输入不太一样。<br>早期游戏中，上、中、下都是离散的状态，可以直接用1、0、-1来表示。<br>而现代游戏输入往往具有中间状态，比如0、0.35、 0.5、0.7、1, 是带有多级梯度的。<br>比如轻推摇杆代表走路，推到底就是跑步。<br>所以现代游戏的输入默认都是采用多梯度的模式。</p><p>虽然键盘没有多级输入的功能，但Unity依然会模拟这个功能，也就是说当你按住W键时，这个轴的值会以很快的速度逐渐从0增加到1。</p><p>所以，上表中Gravity和Sensitivity的含义就不难理解了，它们影响着虚拟轴从1到0、从0到1的速度以及敏感度。</p><blockquote><p>具体调试方法这里不再介绍，建议使用默认值</p></blockquote><h3 id="2-2-2-Dead"><a href="#2-2-2-Dead" class="headerlink" title="2.2.2 Dead"></a>2.2.2 Dead</h3><p>还有死区需要单独说明。</p><p>由于实体手柄、摇杆会有一些误差，比如，手柄放着不动时，某些手柄的输出值可能会在0.05 和0.08之间浮动。这个误差有必要在程序中排除。<br>所以Unity设计了死区的功能，在该值范围内的抖动被忽略为0,这样就可以过滤掉输入设备的误差。</p><h2 id="2-3-在脚本中处理输入"><a href="#2-3-在脚本中处理输入" class="headerlink" title="2.3 在脚本中处理输入"></a>2.3 在脚本中处理输入</h2><p>读取输入轴的方法很简单，代码如下:</p><p><code>float value = Input.GetAxis (&quot;Horizontal&quot;);</code></p><p>得到的值的范围为-1~1,默认位置为0。<br>这个读取虚拟轴的方法与具体控制器是键盘还是手柄无关。</p><blockquote><p>如果用鼠标控制虚拟轴，就有可能由于移动过快导致值超出-1~1的范围。</p></blockquote><blockquote><p>注意:<br>可以创建多个相同名字的虚拟轴。<br>Unity 可以同时管理多个同名的轴，最终结果以变化最大的轴为准。<br>这样做的原因是很多游戏可以同时用多种设备进行操作。<br>比如PC游戏可以用键盘、鼠标或手柄进行操作，手机游戏可以用重力感应器或手柄进行操作。<br>这种设计有助于用户在多种操作设备之间切换，且在脚本中不用去关心这一点。</p></blockquote><h2 id="2-4-按键名称"><a href="#2-4-按键名称" class="headerlink" title="2.4 按键名称"></a>2.4 按键名称</h2><p>要映射按键到轴上，需要在正方向输入框或者负方向输入框中输入正确的按键名称。<br>按键名称的规则和例子如下。</p><ul><li><p>常规按键: A、B、……</p></li><li><p>数字键: 1、2、……</p></li><li><p>方向键: Up、 Down、 Left、 Right…..</p></li><li><p>小键盘键: [1]、 [2]、 [3]、 [+]、 [equals]…..</p></li><li><p>修饰键: Right+Shift、 Lef+Shift、Right+Ctrl、Left+Ctrl、Right+Alt、Left+Alt、Right+Cmd、Left+Cmd….</p></li><li><p>鼠标按钮: mouse 0、mouse 1、mouse2 …..</p></li><li><p>手柄按钮(不指定具体的手柄序号) : joystick button 0、joystick button 1…..</p></li><li><p>手柄按钮(指定具体的手柄序号): joystick 1 button 0、joystick 1 button 1……</p></li><li><p>特殊键: Backspace、 Tab、 Retur、 Escape、 Space、 Delete、 Enter、 Insert、 Home、Page Up…..</p></li><li><p>功能键: FI、F2、…..</p><blockquote><p>可以使用<strong>KeyCode枚举类</strong>型来指定案件，与用字符串的效果一致</p></blockquote></li></ul><h1 id="3-在PC端输入"><a href="#3-在PC端输入" class="headerlink" title="3. 在PC端输入"></a>3. 在PC端输入</h1><p>unity为开发者提供了input库，来支持键盘事件，鼠标事件以及触摸事件。</p><h2 id="3-1-键盘事件"><a href="#3-1-键盘事件" class="headerlink" title="3.1 键盘事件"></a>3.1 键盘事件</h2><p>一般的PC键盘有104个不同的按键，在程序中通过监听这些按键事件，从而进一步执行逻辑操作。<br>如：射击游戏中，W表示前进，S表示后退，A表示左移，D表示右移。</p><h3 id="3-1-1-按下事件"><a href="#3-1-1-按下事件" class="headerlink" title="3.1.1 按下事件"></a>3.1.1 按下事件</h3><p>在脚本中，用<strong>input.GetKeyDown( )方法</strong>将按键值作为参数，监听此按键是否被按下。<br>按下返回true，否者返回false。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了W键&quot;</span>);  <br>            &#125;  <br><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了空格键&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-2-抬起事件"><a href="#3-1-2-抬起事件" class="headerlink" title="3.1.2 抬起事件"></a>3.1.2 抬起事件</h3><p>抬起事件完全依赖于按下事件，因为只有按下才有抬起。</p><p>我们用<strong>Input.GetKeyUp( )方法</strong>监听抬起事件<br>按键抬起后，返回true，否则返回false。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.W))  <br>           &#123;  <br>               Debug.Log(<span class="hljs-string">&quot;您抬起了W键&quot;</span>);  <br>           &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-3-长按事件"><a href="#3-1-3-长按事件" class="headerlink" title="3.1.3 长按事件"></a>3.1.3 长按事件</h3><p>长按事件是监听某一按键是否处于一直按下的状态<br>通过**Input.GetKey( )**来判断键盘中某一按键是否被一直按着。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKey (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//记录按下的帧数  </span><br>                keyFrame++;  <br>                Debug.Log(<span class="hljs-string">&quot;A连按:&quot;</span> + keyFrame+<span class="hljs-string">&quot;帧&quot;</span>);  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//抬起后清空帧数  </span><br>                keyFrame=<span class="hljs-number">0</span>;  <br>                Debug.Log(<span class="hljs-string">&quot;A按键抬起&quot;</span>);  <br>            &#125;     <br></code></pre></td></tr></table></figure><h3 id="3-1-4-任意键事件"><a href="#3-1-4-任意键事件" class="headerlink" title="3.1.4 任意键事件"></a>3.1.4 任意键事件</h3><p>在程序中还可以监听按键中的任意按键是否被按下</p><p>常见于加载完游戏后，按任意键进入。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span>(Input.anyKeyDown)  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;任意键被按下&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-4实例——组合按键"><a href="#3-1-4实例——组合按键" class="headerlink" title="3.1.4实例——组合按键"></a>3.1.4实例——组合按键</h3><p>在经典的格斗游戏中，会有组合键发出牛逼的大招，而这个功能的事件思路其实不难：<br>在玩家按下某一键后，便开始时间记数，在某一时间内按出所需要的键便发出大招。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs c#">    <span class="hljs-keyword">using</span> UnityEngine;  <br>    <span class="hljs-keyword">using</span> System.Collections.Generic;  <br>    <span class="hljs-keyword">using</span> System;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Script_07_05</span> : <span class="hljs-title">MonoBehaviour</span>   <br>    &#123;  <br>        <span class="hljs-comment">//方向键上的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageUp;  <br>        <span class="hljs-comment">//方向键下的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageDown;  <br>        <span class="hljs-comment">//方向键左的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageLeft;  <br>        <span class="hljs-comment">//方向键右的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageRight;  <br>        <span class="hljs-comment">//按键成功的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageSuccess; <br>        <br>        <span class="hljs-comment">//自定义方向键的储存值  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_UP = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_DOWN = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_LEFT = <span class="hljs-number">2</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_RIGHT = <span class="hljs-number">3</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_FIRT = <span class="hljs-number">4</span>;  <br>        <br>        <span class="hljs-comment">//连续按键的事件限制  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> FRAME_COUNT = <span class="hljs-number">100</span>;  <br><br>        <span class="hljs-comment">//仓库中储存技能的数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_SIZE = <span class="hljs-number">3</span>;  <br><br>        <span class="hljs-comment">//每组技能的按键数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_COUNT = <span class="hljs-number">5</span>;  <br><br>        <span class="hljs-comment">//技能仓库  </span><br>        <span class="hljs-built_in">int</span>[,] Sample =   <br>        &#123;  <br>            <span class="hljs-comment">//下 + 前 + 下 + 前 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_RIGHT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 前 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 后 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_LEFT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>        &#125;;  <br>        <span class="hljs-comment">//记录当前按下按键的键值  </span><br>        <span class="hljs-built_in">int</span>  currentkeyCode =<span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//标志是否开启监听按键  </span><br>        <span class="hljs-built_in">bool</span> startFrame = <span class="hljs-literal">false</span>;  <br>        <span class="hljs-comment">//记录当前开启监听到现在的时间  </span><br>        <span class="hljs-built_in">int</span>  currentFrame = <span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//保存一段时间内玩家输入的按键组合  </span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; playerSample;  <br>        <span class="hljs-comment">//标志完成操作  </span><br>        <span class="hljs-built_in">bool</span> isSuccess= <span class="hljs-literal">false</span>;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//初始话按键组合链表  </span><br>            playerSample  = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();  <br>        &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获得按键组合链表中储存按键的数量  </span><br>            <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>            <span class="hljs-comment">//遍历该按键组合链表  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; size; i++)  <br>            &#123;  <br>                <span class="hljs-comment">//将按下按键对应的图片显示在屏幕中  </span><br>                <span class="hljs-built_in">int</span> key = playerSample[i];  <br>                Texture temp = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">switch</span>(key)  <br>                &#123;  <br>                    <span class="hljs-keyword">case</span> KEY_UP:  <br>                        temp = imageUp;  <br>                        <span class="hljs-keyword">break</span>;  <br>                    <span class="hljs-keyword">case</span> KEY_DOWN:<br>                        temp = imageDown;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_LEFT:<br>                        temp = imageLeft;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_RIGHT:<br>                        temp = imageRight;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp != <span class="hljs-literal">null</span>)  <br>                &#123;<br>                    GUILayout.Label(temp);  <br>                &#125;  <br>            &#125;<br>            <span class="hljs-keyword">if</span>(isSuccess)<br>            &#123;<br>                <span class="hljs-comment">//显示成功贴图</span><br>                GUILayout.Label(imageSuccess);<br>            &#125;<br>            <span class="hljs-comment">//默认提示信息</span><br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键1：下、前、下、前、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、前、下、后、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、后、下、后、拳&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//更新按键</span><br>            UpdateKey();<br>            <span class="hljs-keyword">if</span>(Input.anyKeyDown)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(isSuccess)<br>                &#123;<br>                    <span class="hljs-comment">//按键成功后重置</span><br>                    isSuccess = <span class="hljs-literal">false</span>;<br>                    Reset();<br>                &#125;<br>                <span class="hljs-keyword">if</span>(!startFrame)<br>                &#123;<br>                    <span class="hljs-comment">//启动时间计数器</span><br>                    startFrame = <span class="hljs-literal">true</span>;<br>                &#125;  <br>                <span class="hljs-comment">//将按键值添加如链表中  </span><br>                playerSample.Add(currentkeyCode);  <br>                <span class="hljs-comment">//遍历链表  </span><br>                <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>                <span class="hljs-keyword">if</span>(size == SAMPLE_COUNT)  <br>                &#123;  <br>                    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; SAMPLE_SIZE; i++)  <br>                    &#123;  <br>                        <span class="hljs-built_in">int</span> SuccessCount = <span class="hljs-number">0</span>;  <br>                        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j&lt; SAMPLE_COUNT; j++)  <br>                        &#123;  <br>                            <span class="hljs-built_in">int</span> temp = playerSample[j];  <br>                            <span class="hljs-keyword">if</span>(temp== Sample[i,j])<br>                            &#123;  <br>                                SuccessCount++;  <br>                            &#125;  <br>                        &#125;  <br><span class="hljs-comment">//玩家按下的组合按键与仓库中的按键组合相同表示释放技能成功</span><br>                        <span class="hljs-keyword">if</span>(SuccessCount ==SAMPLE_COUNT)  <br>                        &#123;  <br>                            isSuccess = <span class="hljs-literal">true</span>;  <br>                            <span class="hljs-keyword">break</span>;  <br>                        &#125;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(startFrame)  <br>            &#123;  <br>                <span class="hljs-comment">//计数器++  </span><br>                currentFrame++;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(currentFrame &gt;= FRAME_COUNT)  <br>            &#123; <br>                <span class="hljs-comment">//计数器超时  </span><br>                <span class="hljs-keyword">if</span>(!isSuccess)  <br>                &#123;  <br>                    Reset();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>         <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span> (<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>         &#123;  <br>            <span class="hljs-comment">//重置按键相关信息  </span><br>            currentFrame = <span class="hljs-number">0</span>;  <br>            startFrame = <span class="hljs-literal">false</span>;  <br>            playerSample.Clear();  <br>         &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateKey</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获取当前键盘的按键信息  </span><br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                currentkeyCode = KEY_UP;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.S))  <br>            &#123;  <br>                currentkeyCode = KEY_DOWN;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.A))  <br>            &#123;  <br>                currentkeyCode = KEY_LEFT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.D))  <br>            &#123;  <br>                currentkeyCode = KEY_RIGHT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>               currentkeyCode = KEY_FIRT;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>按s,d,s,d,空格：<img src="./images/Unity%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/20160426162352358" srcset="/img/loading.gif" alt="img"></p><h2 id="3-2-鼠标事件"><a href="#3-2-鼠标事件" class="headerlink" title="3.2 鼠标事件"></a>3.2 鼠标事件</h2><p>和键盘事件一样，鼠标一般只有3个按键，左键、右键和中键。</p><p>具体如下：</p><h3 id="3-2-1-按下事件"><a href="#3-2-1-按下事件" class="headerlink" title="3.2.1 按下事件"></a>3.2.1 按下事件</h3><p><code>Input.GetMouseButtonDown()</code><br>来判断鼠标哪个按键被按下：</p><ul><li>返回值为0代表鼠标左键被按下</li><li>返回值为1代表鼠标右键被按下</li><li>返回值为2代表鼠标中键被按下</li></ul><h3 id="3-2-2-抬起事件"><a href="#3-2-2-抬起事件" class="headerlink" title="3.2.2 抬起事件"></a>3.2.2 抬起事件</h3><p><code>Input.GetMouseButtonUp()</code><br>方法监听鼠标按键的抬起事件</p><h3 id="3-2-3-长按事件"><a href="#3-2-3-长按事件" class="headerlink" title="3.2.3 长按事件"></a>3.2.3 长按事件</h3><p><code>Input.GetMouseButton()</code></p><p>监听鼠标某个按键是否一直处于按下状态</p><h1 id="4-在移动端输入"><a href="#4-在移动端输入" class="headerlink" title="4. 在移动端输入"></a>4. 在移动端输入</h1><p>略</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>输入操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>观察者模式是一种对象行为模式。<br>在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。</p><p>它定义对象间的一种一对多的依赖关系：<br>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>主体是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅并接收通知。</p><p>观察者模式（Observer）完美的将观察者和被观察的对象分离开。<br>观察者模式被广泛应用于软件界面元素之间的交互，在业务对象之间的交互、权限管理等方面。</p><blockquote><p>此种模式通常被用来实现事件处理系统</p></blockquote><p>别名：</p><ul><li>发布-订阅(Publish/Subscribe)模式</li><li>模型-视图(Model/View)模式</li><li>源-监听器(Source/Listener)模式</li><li>从属者(Dependents)模式</li></ul><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>交互对象之间尽量采用低耦合设计</li><li>封装代码中经常变化的数据</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/3985563-8f775c097136a39d.png" srcset="/img/loading.gif" alt="img"></p><p>观察者模式所涉及的角色有：</p><ul><li><p><strong>抽象主题(Subject)角色：</strong><br>抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。<br>抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p></li><li><p><strong>具体主题(ConcreteSubject)角色：</strong><br>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。<br>具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p></li><li><p><strong>抽象观察者(Observer)角色：</strong><br>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p></li><li><p><strong>具体观察者(ConcreteObserver)角色：</strong><br>存储与主题的状态自恰的状态。<br>具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。<br>如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p></li></ul><h1 id="4-推模型与拉模型"><a href="#4-推模型与拉模型" class="headerlink" title="4. 推模型与拉模型"></a>4. 推模型与拉模型</h1><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><h2 id="4-1-推模型"><a href="#4-1-推模型" class="headerlink" title="4.1 推模型"></a>4.1 推模型</h2><p>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><h2 id="4-2-拉模型"><a href="#4-2-拉模型" class="headerlink" title="4.2 拉模型"></a>4.2 拉模型</h2><p>主题对象在通知观察者的时候，只传递少量信息。<br>如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。</p><p>一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><h2 id="4-3-二者比较"><a href="#4-3-二者比较" class="headerlink" title="4.3 二者比较"></a>4.3 二者比较</h2><ul><li><ul><li><p>推模型是假定主题对象知道观察者需要的数据</p></li><li><p>拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值</p></li></ul></li><li><ul><li><p>推模型可能会使得观察者对象难以复用<br>因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况<br>这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者</p></li><li><p>拉模型就不会造成这样的情况<br>因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p></li></ul></li></ul><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将设计一个气象监测应用，它要求具备以下几个功能：</p><ul><li><p>可以从气象站更新：温度，湿度，气压三项数据</p></li><li><p>可以给用户用多种视图展示数据：<br>初始三种视图：目前状况，天气统计，天气预报<br>可以随时增加新的视图</p></li><li><p>用户视图更新有两种方式：</p><ul><li><p>系统按事件自动更新数据同时更新视图</p></li><li><p>用户主动请求更新数据与视图</p></li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%A4%A9%E6%B0%94%E7%9B%91%E6%B5%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="天气监测应用设计类图"></p></li></ul><p>从上图可以分析出各个类在观察者模式中他们的角色：</p><ul><li><p>抽象主题(Subject)角色：Subject</p></li><li><p>具体主题(ConcreteSubject)角色：WeatherData</p></li><li><p>抽象观察者(Observer)角色：Observer</p></li><li><p>具体观察者(ConcreteObserver)角色：StatisticsDisplay;ThirdPartDisplay;ForecastDisplay;</p></li></ul><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><h3 id="5-3-1-抽象主题编写"><a href="#5-3-1-抽象主题编写" class="headerlink" title="5.3.1 抽象主题编写"></a>5.3.1 抽象主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//添加观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//移除观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//广播</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-抽象观察者编写"><a href="#5-3-2-抽象观察者编写" class="headerlink" title="5.3.2 抽象观察者编写"></a>5.3.2 抽象观察者编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span>;<span class="hljs-comment">//广播更新的数据(推模型)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//观察者申请数据更新(拉模型)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-具体主题编写"><a href="#5-3-3-具体主题编写" class="headerlink" title="5.3.3 具体主题编写"></a>5.3.3 具体主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherData</span>:<span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Data<br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> temperature;<span class="hljs-comment">//温度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> humidity;<span class="hljs-comment">//湿度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> pressure;<span class="hljs-comment">//气压</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> Data data;<br>    List&lt;Observer&gt; listeners;<span class="hljs-comment">//订阅的观察者名单</span><br>    <span class="hljs-keyword">public</span> Data Datas &#123; <span class="hljs-keyword">get</span> =&gt; data;&#125;<span class="hljs-comment">//用于实现拉模式的get属性</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherData</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123; <br>        listeners = <span class="hljs-keyword">new</span> List&lt;Observer&gt;();<br>        measurementsChanged();<br>        data = <span class="hljs-keyword">new</span> Data();<br>    &#125;<br>    <span class="hljs-comment">//对Subject接口的实现</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Add(a);<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Remove(a);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Observer i <span class="hljs-keyword">in</span> listeners)<br>        &#123;<br>            i.update(data);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//更新天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        getRandomDate();<br>        notifyObserver();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getRandomDate</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//随机产生天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        data.humidity = random.NextDouble();<br>      data.temperature=random.Next(<span class="hljs-number">-40</span>,<span class="hljs-number">40</span>)+random.NextDouble();<br>        data.pressure = random.Next(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)+random.NextDouble();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-4-具体观察者编写"><a href="#5-3-4-具体观察者编写" class="headerlink" title="5.3.4 具体观察者编写"></a>5.3.4 具体观察者编写</h3><p>显示模式的接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">DisplayElement</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>三种显示模式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentConditionsDisplay</span>:<span class="hljs-title">Observer</span>,<span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示当前观测值</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    <span class="hljs-keyword">private</span> Data d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CurrentConditionsDisplay</span>(<span class="hljs-params">Subject x</span>) </span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = x; <br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;---当前天气---&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;当前温度:&quot;</span> + d.temperature.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前气压:&quot;</span> <br>        + d.pressure.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前湿度:&quot;</span>+d.humidity.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StatisticsDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示统计最大最小平均值</span><br>&#123;<br>    Subject weatherData;<br>    <span class="hljs-keyword">private</span> Queue&lt;Data&gt; dates;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StatisticsDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>        dates = <span class="hljs-keyword">new</span> Queue&lt;Data&gt;();<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span>(dates.Count== <span class="hljs-number">3</span>)dates.Dequeue();<br>        dates.Enqueue(x);<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>=&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Double[] average = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">foreach</span> (Data i <span class="hljs-keyword">in</span> dates)<br>        &#123;<br>            average[<span class="hljs-number">0</span>] += i.temperature;<br>            average[<span class="hljs-number">1</span>] += i.pressure;<br>            average[<span class="hljs-number">2</span>] += i.humidity;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;***天气统计***&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;最高温度:&quot;</span> + dates.Max(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低温度:&quot;</span> + dates.Min(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均温度:&quot;</span> +<br>        (average[<span class="hljs-number">0</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高气压:&quot;</span> + dates.Max(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <br>        <span class="hljs-string">&quot;\t最低气压:&quot;</span> + dates.Min(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均气压:&quot;</span> +<br>        (average[<span class="hljs-number">1</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高湿度:&quot;</span> + dates.Max(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低湿度:&quot;</span> + dates.Min(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均湿度:&quot;</span> +<br>        (average[<span class="hljs-number">2</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ForecastDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示天气预报</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    Data d;<br>    String weather;<br>    <span class="hljs-built_in">double</span> t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForecastDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data data</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = data;<br>        <span class="hljs-keyword">if</span> (d.humidity &gt; <span class="hljs-number">0.5</span> &amp;&amp; d.pressure &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(d.temperature&lt;<span class="hljs-number">1</span>) weather = <span class="hljs-string">&quot;雪&quot;</span>;<br>                <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;雨&quot;</span>;<br>            &#125;<br>        <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;晴&quot;</span>;<br>        t = d.temperature;<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;===天气预报===&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;今日天气:&quot;</span> + weather + <span class="hljs-string">&quot;\t 温度:&quot;</span> + t.ToString(<span class="hljs-string">&quot;F2&quot;</span>)+<span class="hljs-string">&quot;\n&quot;</span>); ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-5-测试"><a href="#5-3-5-测试" class="headerlink" title="5.3.5 测试"></a>5.3.5 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    WeatherData weatherData = <span class="hljs-keyword">new</span> WeatherData();<br>    CurrentConditionsDisplay s1 = <span class="hljs-keyword">new</span> CurrentConditionsDisplay(weatherData);<br>    StatisticsDisplay s2 = <span class="hljs-keyword">new</span> StatisticsDisplay(weatherData);<br>    ForecastDisplay s3 = <span class="hljs-keyword">new</span> ForecastDisplay(weatherData);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>    &#123;<br>        weatherData.measurementsChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210325114238949.png" srcset="/img/loading.gif" alt="测试结果"></p><h1 id="6-java中的观察者模式类"><a href="#6-java中的观察者模式类" class="headerlink" title="6. java中的观察者模式类"></a>6. java中的观察者模式类</h1><blockquote><p>略 <a href="https://www.jianshu.com/p/fc4554cda68d">https://www.jianshu.com/p/fc4554cda68d</a></p></blockquote><h1 id="8-C-中实现观察者模式的方法"><a href="#8-C-中实现观察者模式的方法" class="headerlink" title="8. C#中实现观察者模式的方法"></a>8. C#中实现观察者模式的方法</h1><p>整理自：<a href="https://www.jb51.net/article/63077.htm">https://www.jb51.net/article/63077.htm</a></p><h2 id="8-1-利用事件"><a href="#8-1-利用事件" class="headerlink" title="8.1 利用事件"></a>8.1 利用事件</h2><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a></p></blockquote><p>我们将上面讲的天气数据监测应用改成用C#事件实现的观察者模式</p><ol><li><p>在WeatherData类中声明委托与事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WeatherdateUpdate</span>(<span class="hljs-params">Data data</span>)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> WeatherdateUpdate updata;<br></code></pre></td></tr></table></figure></li><li><p>在WeatherData类中编写事件触发函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyByEvent</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span>(updata!=<span class="hljs-literal">null</span>)<br>            &#123;<br>                updata(data);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>在三个具体观察者中编写事件处理函数并在构造函数中订阅到事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//写在构造函数里</span><br>WeatherData.updata += update;<span class="hljs-comment">//事件订阅</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)<span class="hljs-comment">//事件处理</span></span><br><span class="hljs-function"></span>        &#123;<br>            d = x; <br>            display();<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>触发事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            getRandomDate();<br>            <span class="hljs-comment">//notifyObserver();</span><br>            notifyByEvent();<br>        &#125;<br></code></pre></td></tr></table></figure><p>运行输出结果与用接口实现的效果完全相同。</p></li></ol><h2 id="8-2-利用IObservable和IObserver实现"><a href="#8-2-利用IObservable和IObserver实现" class="headerlink" title="8.2 利用IObservable和IObserver实现"></a>8.2 利用IObservable<out T>和IObserver<in T>实现</h2><p>与java中类似，略</p><h2 id="8-3-利用Action函数式"><a href="#8-3-利用Action函数式" class="headerlink" title="8.3 利用Action函数式"></a>8.3 利用Action函数式</h2><p>略</p><h1 id="7-优缺点"><a href="#7-优缺点" class="headerlink" title="7. 优缺点"></a>7. 优缺点</h1><h2 id="7-1-优点"><a href="#7-1-优点" class="headerlink" title="7.1 优点"></a>7.1 优点</h2><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</li><li>目标与观察者之间建立了一套触发机制。</li></ul><h2 id="7-2-缺点"><a href="#7-2-缺点" class="headerlink" title="7.2 缺点"></a>7.2 缺点</h2><ul><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>观察者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>策略模式属于对象的行为模式。<br>其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。<br>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><ul><li><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>找出项目中不稳定的代码（可能需要改动的地方），把它们独立出来，不要把它们和其它稳定的代码混在一起</li><li>针对接口编程而不是针对实现编程</li><li>多用组合少用继承</li></ul></li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p>策略模式是对算法的包装，是把调用算法的责任（行为）和算法本身（行为实现）分割开来，委派给不同的对象管理。</p><p>策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。下面就以一个示意性的实现讲解策略模式实例的结构。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-b97fa59581b3c88c.png" srcset="/img/loading.gif" alt="img"></p><p>这个模式涉及到三个角色：</p><ul><li>环境(Context)角色：<br>持有一个Strategy的引用，即具有复杂多变行为的对象。</li><li>抽象策略(Strategy)角色：<br>这是一个抽象角色，通常由一个接口或抽象类实现。<br>此角色给出所有的具体策略类所需的接口。</li><li>具体策略(ConcreteStrategy)角色：<br>包装了相关的算法或行为。</li></ul><h1 id="4-模式案例"><a href="#4-模式案例" class="headerlink" title="4. 模式案例"></a>4. 模式案例</h1><h2 id="4-1-案例描述"><a href="#4-1-案例描述" class="headerlink" title="4.1 案例描述"></a>4.1 案例描述</h2><p>你将设计一个ARPG文字冒险小游戏，你需要设计以下内容：</p><ul><li>四个角色：<br>女王Queen；国王King；骑士Knight；巨魔Troll；</li><li>四种武器：<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；</li></ul><p>每个角色一次只能使用一种武器，但是在游戏的过程中可以切换武器。</p><p>让他们相互攻击，直到有人胜出。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/423180E36C6DA4925016AA187CA09C05-1616508222683.jpg" srcset="/img/loading.gif" alt="423180E36C6DA4925016AA187CA09C05"></p><p>由上图可以看出类的结构为<br>女王Queen；国王King；骑士Knight；巨魔Troll；继承于Character。<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；实现了WeaponBehavior接口。</p><p>由此可以分析出在策略模式中他们的角色：</p><ul><li>环境(Context)角色：Character</li><li>抽象策略(Strategy)角色：WeaponBehavior</li><li>具体策略(ConcreteStrategy)角色：<br>KnifeBehavior，BowAndArrowBehavior，AxeBehavior，SwordBehavior</li></ul><h2 id="4-3-代码编写"><a href="#4-3-代码编写" class="headerlink" title="4.3 代码编写"></a>4.3 代码编写</h2><h3 id="4-3-1-环境角色编写"><a href="#4-3-1-环境角色编写" class="headerlink" title="4.3.1 环境角色编写"></a>4.3.1 环境角色编写</h3><p>编写所有角色的基类Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> hp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> energy;<br>    WeaponBehavior weapon;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span> =&gt; name; <span class="hljs-keyword">set</span> =&gt; name = <span class="hljs-keyword">value</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Hp &#123; <span class="hljs-keyword">get</span> =&gt; hp; <span class="hljs-keyword">set</span> =&gt; hp = <span class="hljs-keyword">value</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Energy &#123; <span class="hljs-keyword">get</span> =&gt; energy; <span class="hljs-keyword">set</span> =&gt; energy = <span class="hljs-keyword">value</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name,<span class="hljs-built_in">int</span> hp,<span class="hljs-built_in">int</span> energy</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.hp = hp;<br>        <span class="hljs-keyword">this</span>.energy = energy;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeapon</span>(<span class="hljs-params">WeaponBehavior weapon</span>)<span class="hljs-comment">//设置武器</span></span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.weapon = weapon;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">fight</span>(<span class="hljs-params">Character A</span>)<span class="hljs-comment">//攻击！</span></span><br><span class="hljs-function"></span>    &#123;<br>        weapon.useWeapon(<span class="hljs-keyword">this</span>,A);<br>        <span class="hljs-keyword">if</span> (A.Hp &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            Console.WriteLine(A.Name + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;杀死了&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showState</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//显示状态</span></span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(Name+<span class="hljs-string">&quot;:血量 &quot;</span>+ hp+<span class="hljs-string">&quot;精力 &quot;</span>+energy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写四种角色类继承Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Queen</span>:<span class="hljs-title">Character</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Queen</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">10</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> KnifeBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">King</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">King</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">5</span>, <span class="hljs-number">20</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Knight</span> : <span class="hljs-title">Character</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Knight</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">20</span>, <span class="hljs-number">10</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Troll</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Troll</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">15</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> AexBehavior());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-抽象策略角色编写"><a href="#4-3-2-抽象策略角色编写" class="headerlink" title="4.3.2 抽象策略角色编写"></a>4.3.2 抽象策略角色编写</h3><p>编写武器行为接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A,Character B</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-具体策略角色编写"><a href="#4-3-3-具体策略角色编写" class="headerlink" title="4.3.3 具体策略角色编写"></a>4.3.3 具体策略角色编写</h3><p>编写具体的武器行为，实现接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">KnifeBehavior</span>:<span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name+<span class="hljs-string">&quot;对&quot;</span>+B.Name+<span class="hljs-string">&quot;使用了 匕首 刺杀&quot;</span>);<br>        B.Hp--;<br>        A.Energy --;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BowandArrowBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;射了一箭&quot;</span>);<br>        B.Hp--;<br>        A.Energy--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AexBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 斧头 劈砍&quot;</span>);<br>        B.Hp-=<span class="hljs-number">3</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy-=<span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SwordBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 直剑 挥击&quot;</span>);<br>        B.Hp -= <span class="hljs-number">5</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy -= <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-测试"><a href="#4-3-4-测试" class="headerlink" title="4.3.4 测试"></a>4.3.4 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();<br>    List&lt;Character&gt; c = <span class="hljs-keyword">new</span> List&lt;Character&gt;(<span class="hljs-number">4</span>);<span class="hljs-comment">//将各种角色类都装箱成Character</span><br>    c.Add(<span class="hljs-keyword">new</span> King(<span class="hljs-string">&quot;大清皇帝&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Troll(<span class="hljs-string">&quot;林登万&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Knight(<span class="hljs-string">&quot;堂吉诃德&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Queen(<span class="hljs-string">&quot;玛丽&quot;</span>));<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (c.Count != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">int</span> a, b;<br>        a = random.Next(<span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">//随机选取两人PK，直到剩下最后一位角色活着</span><br>        <span class="hljs-keyword">while</span> ((b = random.Next(<span class="hljs-number">0</span>, i)) == a)<br>        &#123;<br>            b = random.Next(<span class="hljs-number">0</span>, i);<br>        &#125;<br>        c[a].showState();<br>        c[b].showState();<br>        <span class="hljs-keyword">if</span> (c[a].fight(c[b]))<br>        &#123;<br>            c.RemoveAt(b);<br>            i--;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//每回合恢复体力</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;c.Count;j++)<br>        &#123;<br>            c[j].Energy++;<br>        &#125;<br>    &#125;<br>    Console.WriteLine(<span class="hljs-string">&quot;胜者是:&quot;</span> + c[<span class="hljs-number">0</span>].Name + <span class="hljs-string">&quot;!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这次中世纪文字吃鸡的结果是：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95.png" srcset="/img/loading.gif" alt="策略模式测试"></p><h1 id="5-对策略模式的深入认识"><a href="#5-对策略模式的深入认识" class="headerlink" title="5.对策略模式的深入认识"></a>5.对策略模式的深入认识</h1><h2 id="5-1-策略模式对多态的使用"><a href="#5-1-策略模式对多态的使用" class="headerlink" title="5.1 策略模式对多态的使用"></a>5.1 策略模式对多态的使用</h2><p> 　通过让环境类持有一个抽象策略类（超类）的引用，在生成环境类实例对象时，让该引用指向具体的策略子类。再对应的方法调用中，就会通过Java的多态，调用对应策略子类的方法。从而可以相互替换，不需要修改环境类内部的实现。同时，在有新的需求的情况下，也只需要修改策略类即可，降低与环境类之间的耦合度。</p><h2 id="5-2-策略模式的重心"><a href="#5-2-策略模式的重心" class="headerlink" title="5.2 策略模式的重心"></a>5.2 策略模式的重心</h2><p>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p><h2 id="5-3算法的平等性"><a href="#5-3算法的平等性" class="headerlink" title="5.3算法的平等性"></a>5.3算法的平等性</h2><p>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p><p>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。</p><h2 id="5-4-运行时策略的唯一性"><a href="#5-4-运行时策略的唯一性" class="headerlink" title="5.4 运行时策略的唯一性"></a>5.4 运行时策略的唯一性</h2><p>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p><h2 id="5-5-公有的行为"><a href="#5-5-公有的行为" class="headerlink" title="5.5 公有的行为"></a>5.5 公有的行为</h2><p>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p><p>这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-398483227b01f042.png" srcset="/img/loading.gif" alt="img"></p><h1 id="6-策略模式的优缺点"><a href="#6-策略模式的优缺点" class="headerlink" title="6. 策略模式的优缺点"></a>6. 策略模式的优缺点</h1><h2 id="6-1-相较于纯继承的优点"><a href="#6-1-相较于纯继承的优点" class="headerlink" title="6.1 相较于纯继承的优点"></a>6.1 相较于纯继承的优点</h2><ul><li><p>代码复用度高，子类中几乎没有重复</p></li><li><p>很容易知道该类的全部策略（算法）</p></li><li><p>在运行时可以更容易的更改策略</p></li><li><p>改动时不会牵一发而动全身，代码耦合度低</p></li></ul><h2 id="6-2-策略模式的优点"><a href="#6-2-策略模式的优点" class="headerlink" title="6.2 策略模式的优点"></a>6.2 策略模式的优点</h2><ul><li>策略模式提供了管理相关的算法族的办法。<br>策略类的等级结构定义了一个算法或行为族。<br>恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。<br>多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li></ul><h2 id="6-3策略模式的缺点"><a href="#6-3策略模式的缺点" class="headerlink" title="6.3策略模式的缺点"></a>6.3策略模式的缺点</h2><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<br>这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p></li><li><p>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p></li></ul><p>总结自：</p><ul><li>《设计模式HeadFirst》</li><li><a href="https://www.jianshu.com/p/7fa8ad000a97">https://www.jianshu.com/p/7fa8ad000a97</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的标签 层级 静态物体 预制体</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-标签"><a href="#1-标签" class="headerlink" title="1. 标签"></a>1. 标签</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>标签(Tag)是一个可以标记在游戏物体上的记号，它一般是一个简单的单词。<br>比如：你可以为游戏人物添加一个Player标签，并为敌人角色添加一个Encemy 标签，还可以为地图上的道具添加一个Collectable标签。</p><p>在脚本中查找和指定物体时，使用标签是一种非常好的方法。<br>这种方法可以避免总是采用某个公开变量的方式来指定游戏物体，那样还需要通过拖曳的操作才能给变量赋初值。通过标签来查找物体可以简化编辑工作。</p><p>标签还特别适合用在处理碰撞的时候，当游戏人物与其他物体发生碰撞时，你可以通过判断碰到的物体是敌人、道具还是其他东西，来进行下一步处理。</p><h2 id="1-2-Unity预制标签"><a href="#1-2-Unity预制标签" class="headerlink" title="1.2. Unity预制标签"></a>1.2. Unity预制标签</h2><p>Uniy预置了一些常用的标签， 在标签管理器中你不能修改下面这些预置的标签：</p><table><thead><tr><th>标签名</th><th>含义</th></tr></thead><tbody><tr><td>Untagged</td><td>没有标签</td></tr><tr><td>Respawn</td><td>出生</td></tr><tr><td>Finish</td><td>完成</td></tr><tr><td>EditorOnly</td><td>编辑器专用</td></tr><tr><td>MainCamera</td><td>主摄像机</td></tr><tr><td>Player</td><td>玩家</td></tr><tr><td>GameController</td><td>游戏控制器</td></tr></tbody></table><h2 id="1-3-创建新标签"><a href="#1-3-创建新标签" class="headerlink" title="1.3. 创建新标签"></a>1.3. 创建新标签</h2><p>要创建一个新的标签，需要在标签下拉菜单中选择Add Tag,之后检视窗口会切换到标签与层级管理器(Tag and Layer Manager)。</p><blockquote><p>注意:标签一旦创建就不可以再被修改，只能删除并重新创建。</p></blockquote><h2 id="1-4-为物体设置标签"><a href="#1-4-为物体设置标签" class="headerlink" title="1.4. 为物体设置标签"></a>1.4. 为物体设置标签</h2><p>检视窗口的上方显示了标签(Tg)和层级(Layer) 的下拉菜单。</p><p>在标装的下技菜单中单击任意.个标签名称，就可以为物体指定该标签了</p><h2 id="1-5-使用标签查找游戏物体"><a href="#1-5-使用标签查找游戏物体" class="headerlink" title="1.5. 使用标签查找游戏物体"></a>1.5. 使用标签查找游戏物体</h2><blockquote><p>略，详见<a href="https://mycroftcooper.github.io/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/">在脚本中访问其他物体2.3</a></p></blockquote><h2 id="1-6-小提示"><a href="#1-6-小提示" class="headerlink" title="1.6. 小提示"></a>1.6. 小提示</h2><ul><li>一个游戏物体只能被指定一个标签</li><li>可以用任意一个单词作为标签的名称<br>甚至可以用一个很长的词组作为名称<br>但是那样非会不太方便，比如在界面中看不到完整的名字</li></ul><h1 id="2-层级"><a href="#2-层级" class="headerlink" title="2. 层级"></a>2. 层级</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>层级最有用、最常用的地方有：</p><ul><li>用来让摄像机仅渲染场景中的一部分物体</li><li>还可以让灯光只照亮一部分物体。</li><li>用来在进行碰撞检测、射线检测时，从而只让某些物体发生碰撞，让另一些物体不发生碰撞。</li></ul><h2 id="2-2-新建层级"><a href="#2-2-新建层级" class="headerlink" title="2.2 新建层级"></a>2.2 新建层级</h2><p>单击主菜单的Edit &gt; Project Settings &gt; Tagsand Layers选项，会在检视窗口中打开层级和标签窗口。<br>这步操作和之前介绍标签时的操作完全一样， 不同的是，在学习标签时我们展开了标签菜单，这里我们要展开层级菜单。<br>将新的层级User Layer8命名为Player,就建立了一个新的Player层级，序号为8.</p><h2 id="2-3-只渲染场景的一部分"><a href="#2-3-只渲染场景的一部分" class="headerlink" title="2.3 只渲染场景的一部分"></a>2.3 只渲染场景的一部分</h2><p>层级配合摄像机的剔除遮眾Culling Mas)使用，就可以有选择性地显示某些层级的物体，而不渲染另一些层级的物体。</p><p>要做到这一点， 只需要在摄像机中选中需要渲染的层级即可。<br>单击摄像机的剔除遮罩下拉菜单，打钩的层就是要显示的层。</p><blockquote><p>注意: Unity 中有很多类似这样的下拉菜单，菜单的最上面两项是特殊的：<br>单击Noting时，所有选项都会被取消勾选，表示全部不选<br>单击Everyhing 时，则所有选项都会被勾选。<br>使用这两个快捷选项有助于快速选中必要的层。<br>比如说，要仅选中Ul层和Player层，就可以先选择Nothing,然后再单独勾选UI层和Player层即可.</p></blockquote><blockquote><p>UI系统如果采用屏幕空间画布，则不会受摄像机别除遮罩的影响。</p></blockquote><h2 id="2-5-选择性的射线检测"><a href="#2-5-选择性的射线检测" class="headerlink" title="2.5 选择性的射线检测"></a>2.5 选择性的射线检测</h2><p>使用层级可以让射线检测忽略某些碰撞体，这种效果也是用“层级”和“遮罩”这两个概念来设置的。</p><p>例如，有时需要发射条射线， 仅和Player 层的物体发生碰撞， 而忽略其他层的物体。<br>Physics.Racast方法用来发射一条射线， 它可以带有一个叫作layerMask 的参数，layerMask是一个利用位标记作为遮罩的参数。</p><blockquote><p>用位(bit)作为标记是二进制相关的一种方法<br>原理是int型的变量由32个位组成，每个位的值只能是0或1<br>因此可以根据某个位是0还是1来选中或者忽略某一层</p></blockquote><ul><li>如果layerMask所有的位都是1,那么就会和所有的层发生碰撞。</li><li>如果layerMask等于0，那么它就不会和任何层、任何物体发生碰撞。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//将1左移8位</span><br><span class="hljs-built_in">int</span> layerMask =<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br><span class="hljs-comment">//将layerMask设置为只有从右数第8位是1,其他位是0，则只会和Layer 8 Player层发生碰撞</span><br><span class="hljs-keyword">if</span> (Physics .Raycast (transform.position, Vector3. forward, Mathf. Infinity, layerMask))<br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;The ray hit the player&quot;</span>) ;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是玩家的游戏人物射击发出的检测射线，就恰恰相反，需要和除玩家的游戏人物以外的所有物体发生碰撞，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//将1左移8位</span><br>    <span class="hljs-built_in">int</span> layerMask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">//按位取反，所有值为0的位变为1,值为1的位变为0</span><br>    layerMask = ~ layerMask;<br>    RaycastHit hit;<br>    <span class="hljs-comment">//发射射线，Debug. DrawRay用于画出辅助框线</span><br>    <span class="hljs-keyword">if</span> (Physics.Raycast(transform.position,traform.TransformDirection(Vector3.forward),<br>                        <span class="hljs-keyword">out</span> hit, Mathf.Infinity,layerMask))<br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<br>                      hit.distance,Color.yellow);<br>        Debug. Log(<span class="hljs-string">&quot;Did Hit&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<span class="hljs-number">1000</span><br>                      Color.white) ;<br>        Debug.Log(<span class="hljs-string">&quot;Did not Hit&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在调用Raycast方法时省略layerMask参数，则默认除了Ignore Raycast这层不会被碰撞，其他层都可能发生碰撞。</p><p>使用lgnore Raycast层可以专门指定某些物体不受射线检测碰撞。</p><blockquote><p>序号为31的最后一层是特别的，编辑器把它作为预览使用，开发者不要使用这一层，会造成冲突</p></blockquote><h1 id="3-静态物体"><a href="#3-静态物体" class="headerlink" title="3. 静态物体"></a>3. 静态物体</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>如果引擎事先知道了某一个物体在游戏进行中是否会移动，那么就可以针对性地应用一系列优化策略。</p><p>如果一个物体是静态的，即不会移动的，那么引擎就可以假定它不会受到任何其他物体或者事件的影响，从而预先计算好物体的信息。<br>比如说，渲染器可以将场景中许多静态物体台并为一个整体，这样就可以通过一次渲染就将它们全部处理完毕，这种做法也被称为批量渲染。</p><p>在检视窗口中，每个游戏物体名称的右侧都有一一个静态(Static) 复选框以及一个菜单，它用来指定物体是否是静态的，且可以进一步指定物体 在某些子系统中是否是静态的，还可以独立地设置游戏物体在每个子系统中是否是静态的，这样就可以对物体进行非常细致的优化。</p><p>下图是静态标记菜单，可以有针对性地设置物体在每个子系统中是否是静态的。</p><h2 id="3-2-子系统的静态特性内容"><a href="#3-2-子系统的静态特性内容" class="headerlink" title="3.2 子系统的静态特性内容"></a>3.2 子系统的静态特性内容</h2><p>静态菜单中的Everyhing和Nothing选项分别用于同时启用或禁用物体在所有子系统中的静态特性以便优化。</p><p>这些子系统包含如下内容：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Lightmap Static</td><td>场景中的高级光照特性</td></tr><tr><td>Occluder Static</td><td>根据物体在特定摄像机下的可见性，进行渲染优化</td></tr><tr><td>Batching Static</td><td>将多个物体合并为一个整体进行渲染</td></tr><tr><td>Navigation Static</td><td>在寻路系统中，将此物体作为静态的障碍物</td></tr><tr><td>Off Mesh Link Generation</td><td>寻路系统中的网格链接</td></tr><tr><td>Reflection Probe Static</td><td>反射探针优化</td></tr></tbody></table><p>某些子系统与内部渲染方式有较大关联，可以在相关文档中阅读它们的细节。</p><h1 id="4-预制体"><a href="#4-预制体" class="headerlink" title="4.预制体"></a>4.预制体</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>在场景中创建物体、添加组件并设置合适参数的操作一开始会令人觉得方便， 但是当场影的用到大量同样的NPC、障碍物或机关时，创建以及设置属性的操作就会带来巨大的麻烦。<br>复制这些物体看似可以解决问题，但是由于这些物体都是独立的，所以还是需要一个一个单独体改它们。</p><p>所以，Unity 提供了预制体这个概念。<br>它允许事先保存一个游戏物体，包括该物体上挂载的组件与设置的参数。<br>这样预制体就可以成为模板，可以用这个模板在场景中创建物体。</p><p>预制体具有以下两个优点</p><ul><li><p>对预制体文件的任何修改可以立即影响所有相关联的物体</p></li><li><p>每个物体还可以重载(override)一些些组件和参数， 以实现与模板有所区别的设置</p></li></ul><blockquote><p>注意:<br>当你拖曳一个资源文件(比如一个模型)到场景中时，Unity 会自动创建一个新的游戏物体，原始资源的修改也会影响到这些相关的游戏物体。<br>这种物体看起来像是预制体，但是和预制体是完全不同的，所以不适用下面介绍的预制体的特性。<br>这种“引用关系”仅仅是与预制体有相似之处。</p></blockquote><h2 id="4-2-使用预制体"><a href="#4-2-使用预制体" class="headerlink" title="4.2 使用预制体"></a>4.2 使用预制体</h2><p>创建预制体有两种常用方法: </p><ul><li>方法一:<br>在工程窗口中的某个文件夹内单击右键，选择Create&gt; Prefab创建一个空白预制体，然后将场景中制作好的某个游戏物体拖曳到空白预制体上。</li><li>方法二:<br>直接将某个游戏物体从场景拖曳到文件夹中。<br>在创建好预制体以后，将另一个游戏物体拖曳到预制体文件上，系统会提示是否替换预制体。</li></ul><blockquote><p>预制体是一个后缀为 .prefab的资源文件。<br>在层级视图中，所有与预制体关联的游戏物体的名称，都会以蓝色显示(普通物体的名称是以黑色显示的)</p></blockquote><blockquote><p>编辑器会用粗体字来显示游戏物体中与预制体不一样的独特属性</p></blockquote><h2 id="4-3-通过游戏物体实例修改预制体"><a href="#4-3-通过游戏物体实例修改预制体" class="headerlink" title="4.3 通过游戏物体实例修改预制体"></a>4.3 通过游戏物体实例修改预制体</h2><p>与预制体关联的游戏物体，会在检视窗口的上方多出三个按钮:</p><ul><li><p>选择( Select)<br>选中与物体相关联的那个预制体，单击后，在工程窗口中会高亮显示该预制体。<br>这有助于迅速找到相关的预制体。</p></li><li><p>回滚(Revert)<br>将游戏物体修改过的组件和属性恢复到和预制体一致。<br>这个功能用于试验性地修改某些参数以后，将物体恢复到原始状态。</p></li><li><p>应用(Apply)<br>将本物体上修改的那些组件和参数写回到原始的预制体中(但是变换组件的位置信息不会写回预制体)。<br>这有助于通过任何一个物体修改预制体，有时会非常方便，特别是在某些预制体只有一个实例的时候。</p></li></ul><h2 id="４-4-预制体实例化"><a href="#４-4-预制体实例化" class="headerlink" title="４.4 预制体实例化"></a>４.4 预制体实例化</h2><p>使用<strong>Instantiate函数</strong></p><p>Instantiate函数实例化是将传入对象的所有子物体和子组件完全复制，成为一个新的对象。<br>这个新的对象拥有与源对象完全一样的东西，包括坐标值等。</p><h3 id="4-4-1-参数"><a href="#4-4-1-参数" class="headerlink" title="4.4.1 参数"></a>4.4.1 参数</h3><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>original</td><td>用来做复制操作的对像物体，源对象</td></tr><tr><td>position</td><td>实例化的对象的位置坐标</td></tr><tr><td>rotation</td><td>实例化的对象的旋转坐标（旋转四元数）</td></tr><tr><td>parent</td><td>实例化对象的父对象，在完成实例化函数处理后，实例化对象将是父对象的子对象</td></tr><tr><td>instantiateWorldSpace</td><td>为TRUE，表示实例化对象相对于世界坐标系的位置（是位置，不是坐标值，比如实例化前在Canvas左上角，实例化后还在左上角）不变，相对于父对象的坐标值变了<br />为false，表示实例化对象相对于父对象的坐标值不变，但在世界坐标系中的位置变了。</td></tr></tbody></table><p><a href="https://blog.csdn.net/qq_29413829/article/details/78934579">https://blog.csdn.net/qq_29413829/article/details/78934579</a></p><h3 id="4-4-2-重载"><a href="#4-4-2-重载" class="headerlink" title="4.4.2 重载"></a>4.4.2 重载</h3><p>![Instantiate函数](./images/Unity中的标签 层级 静态物体/20171229171822891)</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>标签</tag>
      
      <tag>层级</tag>
      
      <tag>静态物体</tag>
      
      <tag>预制体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的事件</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity在C#Event特性的基础上进行了改良，Event只能用于纯代码编程，而UnityEvent可以和UnityEditor配合使用提高效率。</p><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a>！</p></blockquote><h1 id="2-Unity事件的改良"><a href="#2-Unity事件的改良" class="headerlink" title="2. Unity事件的改良"></a>2. Unity事件的改良</h1><p>在C#事件中我们举的例子中，可以看出.Net框架下的事件存在以下几个问题：</p><ul><li>订阅的时机受限<br>你必须在事件触发前完成事件的订阅<br>事件处理程序将收不到订阅前的事件动态</li><li>不方便管理<br>想要查看所有订阅事件的对象，我们就得查找项目中所有对事件的引用，然后再把每个对象的文件打开，可以说是非常麻烦了</li></ul><p>为了避免上述的缺点，Unity使用Serializable（序列化）让用户可以在Editor中直接绑定所有对象的调用，即一目了然又不用担心把握不准订阅的时机，这就是<strong>UnityEvent</strong>。</p><h1 id="3-UnityEvent类"><a href="#3-UnityEvent类" class="headerlink" title="3. UnityEvent类"></a>3. UnityEvent类</h1><p><strong>UnityEvent</strong> 可添加到任何 <strong>MonoBehaviour</strong>，并从标准 .net 委托之类的代码中执行。当 <strong>UnityEvent</strong>添加到 <strong>MonoBehaviour</strong>时，它会出现在 <strong>Inspector</strong> 中，并可添加持久回调。</p><h2 id="3-1-方法"><a href="#3-1-方法" class="headerlink" title="3.1 方法"></a>3.1 方法</h2><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>AddListener</td><td>将一个非持久性侦听器添加到UnityEvent</td></tr><tr><td>Invoke</td><td>调用所有已注册的回调（运行时和持久的）</td></tr><tr><td>RemoveListener</td><td>从UnityEvent中删除一个非持久性侦听器</td></tr></tbody></table><h2 id="3-2-继承的成员"><a href="#3-2-继承的成员" class="headerlink" title="3.2 继承的成员"></a>3.2 继承的成员</h2><p>普通方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetPersistentEventCount</td><td>获取已注册的持久性侦听器的数量</td></tr><tr><td>GetPersistentMethodName</td><td>获取索引为index的侦听器的目标方法名称</td></tr><tr><td>GetPersistentTarget</td><td>在索引index处获取侦听器的目标组件</td></tr><tr><td>RemoveAllListeners</td><td>从事件中删除所有侦听器</td></tr><tr><td>SetPersistentListenerState</td><td>修改持久侦听器的执行状态</td></tr></tbody></table><p>静态方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetValidMethodInfo</td><td>给定对象，函数名称和参数类型列表；找到匹配的方法</td></tr></tbody></table><h2 id="3-3-UnityEvent的使用"><a href="#3-3-UnityEvent的使用" class="headerlink" title="3.3 UnityEvent的使用"></a>3.3 UnityEvent的使用</h2><p>要在 Editor 中配置回调，需执行以下几个步骤：</p><ol><li>确保脚本导入/使用 <code>UnityEngine.Events</code>。</li><li>选择 + 图标为回调添加字段</li><li>选择要接收回调的 UnityEngine.Object（可使用对象选择器进行选择）</li><li>选择要调用的函数</li><li>可为事件添加多个回调</li></ol><p>在 <strong>Inspector</strong> 中配置 <strong>UnityEvent</strong> 时，支持两种类型的函数调用：</p><ul><li>静态。<br>静态调用是预配置的调用，具有在 UI 中设置的预配置值。<br>这意味着，在调用回调时，使用已在 UI 中输入的参数调用目标函数。</li><li>动态。<br>使用从代码发送的参数调用动态调用，并与正在调用的 UnityEvent 类型相关。<br>UI 会过滤回调，仅显示对 UnityEvent 有效的动态调用。</li></ul><h2 id="3-4-UnityEvent的多态（派生自定义事件）"><a href="#3-4-UnityEvent的多态（派生自定义事件）" class="headerlink" title="3.4 UnityEvent的多态（派生自定义事件）"></a>3.4 UnityEvent的多态（派生自定义事件）</h2><p>默认情况下，<strong>Monobehaviour</strong> 中的 UnityEvent 动态绑定到 void 函数。</p><p>但不一定非得如此，<strong>UnityEvent</strong> 的子类支持绑定到最多包含 4 个参数的函数。</p><p>为此，您可以定义一个支持多个参数的自定义 <strong>UnityEvent</strong> 类。</p><p>此定义十分简单：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringEvent</span> : <span class="hljs-title">UnityEvent</span> &lt;<span class="hljs-title">string</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>订阅时订阅此派生类的实例而不是基类 <strong>UnityEvent</strong>，即可回调时传递各种参数。</p><p>然后，可通过调用**Invoke()**函数来对其进行调用。</p><blockquote><p>UnityEvent 可在其通用定义中定义最多 4 个参数。</p></blockquote><h2 id="3-5-使用案例："><a href="#3-5-使用案例：" class="headerlink" title="3.5 使用案例："></a>3.5 使用案例：</h2><p>将C#事件中的用例代码改写成Unity引擎内继承于<strong>UnityEvent</strong>的脚本：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Events;<br><br><span class="hljs-comment">//使用Serializable序列化IdolEvent, 否则无法在Editor中显示</span><br>[<span class="hljs-meta">System.Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IdolEvent</span> : <span class="hljs-title">UnityEvent</span>&lt;<span class="hljs-title">string</span>&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">//public delegate void IdolBehaviour(string behaviour);</span><br>    <span class="hljs-comment">//public event IdolBehaviour IdolDoSomethingHandler;</span><br>    <span class="hljs-keyword">public</span> IdolEvent idolEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (idolEvent == <span class="hljs-literal">null</span>)<br>        &#123;<br>            idolEvent = <span class="hljs-keyword">new</span> IdolEvent();<br>        &#125;<br>        idolEvent.Invoke(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将三个脚本绑定在三个GameObject上，此时两个粉丝还未实现订阅。和Event不同，UnityEvent在序列化后可以在Editor上显示，并且可以在Editor上设置好需要执行的函数</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315164014120.png" srcset="/img/loading.gif" alt="image-20210315164014120"></p><p>运行</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315160434052.png" srcset="/img/loading.gif" alt="image-20210315160434052"></p><p>除此之外，UnityEvent依然提供和C# Event 类似的运行时绑定的功能，不过不同的是，UnityEvent是一个对象，向其绑定函数是通过AddListener()方法实现的。以SubscriberB为例，我们可以在代码中实现同等效果的绑定：</p><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">public</span> Idol myIdol;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        myIdol.idolEvent.AddListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        myIdol.idolEvent.RemoveListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于UnityEvent是一个对象，所以自然可以允许我们通过继承实现自己的Event，实际上Unity中包括Button在内的许多UI组件的点击事件都是通过继承自UnityEvent来复写的。<br>可访问性(public/private)决定了UnityEvent的默认值，当可访问性为public时，默认会为其分配空间(new UnityEvent())；当可访问性为private时，默认UnityEvent为null，需要在Start()中为其分配内存。</p></blockquote><h1 id="4-EventSystem"><a href="#4-EventSystem" class="headerlink" title="4. EventSystem"></a>4. EventSystem</h1><p>EventSystem在Unity中是一个看起来像是专门服务于UGUI系统的组件。<br>每当在场景里创建UGUI对象时，Unity编辑器都会自动产生一个EventSystem对象放在场景中，与之相对应的也有一个Canvas对象，这两个对象就组成了UGUI系统的基础。<br>所有开发人员能看到和能用到的UGUI功能都依附于这两个对象。</p><h2 id="4-1-UGUI中的EventSystem"><a href="#4-1-UGUI中的EventSystem" class="headerlink" title="4.1 UGUI中的EventSystem"></a>4.1 UGUI中的EventSystem</h2><p>使用<strong>UGUI</strong>制作游戏界面时，<strong>EventSystem</strong>的作用就像是一个专为<strong>UGUI</strong>设计好的消息中心，它管理着所有能参与消息处理的<strong>UGUI</strong>组件，包括但不仅限于<strong>Panel</strong>，<strong>Image</strong>，<strong>Button</strong>等。</p><p>如果在<strong>Unity</strong>创建好<strong>EventSystem</strong>之后观察该对象上附带的组件可以看到，至少有两个组件会被自动添加</p><ul><li><p><strong>EventSystem组件</strong>，也就是消息机制的核心；</p></li><li><p><strong>StandaloneInputModule组件</strong>，这个是负责产生输入的组件。<br>StandaloneInputModule本身是个继承自BaseInputModule的实现类，而类似的实现类Unity中还有另外几个，甚至用户也能自定义一个实现类用于事件处理。</p></li></ul><p>看起来这个系统似乎缺少一个部分，就是怎么确定某个事件是发给谁的。<br>因此为了确定操作对象究竟是哪个，一个必不可少的步骤就是检测。</p><p>在GUI之外的游戏场景编辑中，要感知当前鼠标对准的物体是哪个，最常用的方法就是射线检测了：<br>从摄像机对着鼠标指向的方向发出射线，通过碰撞来检测目标。</p><p>这个方案简单实用，可以说在游戏中随处可见，而UGUI所使用的机制也就是这一套射线检测，只不过射线的发射和碰撞处理都被隐藏在了组件之中。</p><p>所以，缺失的部分就是射线检测模块，这个模块不在EventSystem上，而是在Canvas上挂着。<br>这很好理解，Canvas是所有UGUI组件的根对象，所以由他来负责射线处理是相当正常的解决方案，至于射线到底碰到了谁，UGUI组件自然有射线接收反馈来确定。</p><p>Canvas上挂载的组件叫做GraphicRaycaster，它实际上是BaseRaycaster的实现类，专门负责Canvas之下的图形对象的射线检测与计算问题。</p><p>至此，UGUI中的情况就比较清晰了：</p><ul><li><p><strong>EventSystem对象</strong><br>负责管理所有事件相关对象<br>该对象下挂载了EventSystem组件和StandaloneInputModule组件，前者为管理脚本，后者为输入模块</p></li><li><p><strong>Canvas对象</strong><br>下挂载了GraphicRaycaster负责处理射线相关运算<br>用户的操作都会通过射线检测来映射到UGUI组件上，InputModule将用户的操作转化为射线检测，Raycaster则找到目标对象并通知EventSystem，最后EventSystem发送事件让目标对象进行响应</p><p>如下图所示：</p><img src="/images/Unity中的事件/UGUI结构.png" srcset="/img/loading.gif" alt="UGUI结构"  /></li></ul><h3 id="4-1-1-事件响应"><a href="#4-1-1-事件响应" class="headerlink" title="4.1.1 事件响应"></a>4.1.1 事件响应</h3><p>UGUI的事件响应处理有多种方式，这里我们介绍两种常用方法</p><h4 id="4-1-1-1-实现特定接口处理事件响应"><a href="#4-1-1-1-实现特定接口处理事件响应" class="headerlink" title="4.1.1.1 实现特定接口处理事件响应"></a>4.1.1.1 实现特定接口处理事件响应</h4><p>由于Canvas挂载了GraphicRaycaster组件，因此在Canvas对象之下的所有GUI对象都可以通过挂载脚本并且实现一些和事件相关的接口来处理事件，比如常见的IPointerClickHandler接口就是用于处理点击事件的接口。</p><p>可以实现的接口列表大概如下所示：</p><table><thead><tr><th>接口名</th><th>作用</th></tr></thead><tbody><tr><td>IPointerEnterHandler - OnPointerEnter</td><td>当光标进入对象时调用</td></tr><tr><td>IPointerExitHandler - OnPointerExit</td><td>当光标退出对象时调用</td></tr><tr><td>IPointerDownHandler - OnPointerDown</td><td>在对象上按下指针时调用</td></tr><tr><td>IPointerUpHandler - OnPointerUp</td><td>松开鼠标时调用（在指针正在点击的游戏对象上调用）</td></tr><tr><td>IPointerClickHandler - OnPointerClick</td><td>在同一对象上按下再松开指针时调用</td></tr><tr><td>IInitializePotentialDragHandler - OnInitializePotentialDrag</td><td>在找到拖动目标时调用，可用于初始化值</td></tr><tr><td>IBeginDragHandler - OnBeginDrag</td><td>即将开始拖动时在拖动对象上调用</td></tr><tr><td>IDragHandler - OnDrag</td><td>发生拖动时在拖动对象上调用</td></tr><tr><td>IEndDragHandler - OnEndDrag</td><td>拖动完成时在拖动对象上调用</td></tr><tr><td>IDropHandler - OnDrop</td><td>在拖动目标对象上调用</td></tr><tr><td>IScrollHandler - OnScroll</td><td>当鼠标滚轮滚动时调用</td></tr><tr><td>IUpdateSelectedHandler - OnUpdateSelected</td><td>每次勾选时在选定对象上调用</td></tr><tr><td>ISelectHandler - OnSelect</td><td>当对象成为选定对象时调用</td></tr><tr><td>IDeselectHandler - OnDeselect</td><td>取消选择选定对象时调用</td></tr><tr><td>IMoveHandler - OnMove</td><td>发生移动事件（上、下、左、右等）时调用</td></tr><tr><td>ISubmitHandler - OnSubmit</td><td>按下 Submit 按钮时调用</td></tr><tr><td>ICancelHandler - OnCancel</td><td>按下 Cancel 按钮时调用</td></tr></tbody></table><p>只要在挂载的脚本中实现所需要的接口，对应的事件回调也就可以执行了。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EventTest</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerClickHandler</span>, <span class="hljs-title">IDragHandler</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span> <br>&#123;<br>    <span class="hljs-comment">// Execute every update when dragging</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-comment">// quick down and up will perform click</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerClick</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer down</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer up</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Use this for initialization</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Update is called once per frame</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-2-利用EventTrigger组件处理事件响应"><a href="#4-1-1-2-利用EventTrigger组件处理事件响应" class="headerlink" title="4.1.1.2  利用EventTrigger组件处理事件响应"></a>4.1.1.2  利用EventTrigger组件处理事件响应</h4><p>EventTrigger组件是一个通用的事件触发器，它可以用来管理单个组件上的所有可能触发的事件。<br>其使用方法有两种：</p><ul><li><p>编辑器设定方法</p><p>指定组件上添加EventTrigger组件，然后为它添加触发事件类型，再为指定类型添加回调方法。</p></li></ul><p>这种做法的操作很简单，而且灵活性也相当高，想要跨脚本调用方法只需要鼠标拖一拖点一点就好。<br>但是这样在编辑器中设定事件回调会在项目变大时造成比较严重的管理障碍，尤其是当绑定了EventTrigger以及回调指向的物体有修改或者删除情况时，所造成的引用缺失需要花费更多的时间进行处理。</p><blockquote><p>略</p></blockquote><ul><li>动态设定方法</li></ul><p>想要更好地管理大量的事件触发和回调处理，可以尝试采用动态设置的方案。<br>所谓动态设置其实就是在代码中设置EventTrigger来处理事件回调，方法也很简单</p><blockquote><p>略</p></blockquote><h2 id="4-2-场景中的EventSystem"><a href="#4-2-场景中的EventSystem" class="headerlink" title="4.2 场景中的EventSystem"></a>4.2 场景中的EventSystem</h2><p>EventSystem也能在一般的场景中使用。<br>如果没有实现自己的事件系统而又需要一些回调处理的方案的话，可以试着直接将EventSystem应用到一般的游戏场景中。<br>要这样使用EventSystem的话，核心在于前文提到过的事件系统三大部分：</p><ul><li>EventSystem</li><li>InputModule</li><li>Raycaster。</li></ul><p>通过考察三者各自的作用可知，EventSystem和InputModule都和EventSystem对象紧密结合，而唯有Raycaster是孤零零地在Canvas对象上处理所有Canvas内部的射线检测。</p><p>那么想要借助EventSystem的能力来处理场景中的事件传递，肯定不能去动EventSystem对象，毕竟这是建立事件系统时自动创建的对象，不用说一定是要用到的。<br>那么就只剩下Raycaster了，这个组件在Canvas上挂载，用于处理射线检测，那么如果想要在场景里进行射线检测，应该把组件挂到哪里呢？</p><p>一般而言，摄像机是一个不错的选择，因为通常来说游戏大部分时候都只有一个摄像机，而且基本上可以操作的界面也只隶属于一个摄像机，因此将Raycaster挂载到游戏的主摄像机上就是个很自然的考虑了。<br>​ 而Unity编辑器提供的Raycaster一共有三种</p><ul><li>GraphicRaycaster 界面射线处理器，用于Canvas</li><li>Physics2DRaycaster 2D场景射线处理器，用于2D场景</li><li>PhysicsRaycaster 3D场景射线处理器，用于3D场景</li></ul><p>因此要用到的就是后两种了，根据当前场景的特点选择相应的Raycaster并挂载到主摄像机上即可，剩下的就和UGUI中很像了。</p><p>不过需要注意的是，在UGUI中想要让组件可以响应事件必须将组件的RaycasterTarget属性勾选上，而场景中则要在需要响应事件的对象上挂载碰撞器，满足需求的任何碰撞器都可以。<br>然后就和前文讲的一样，实现对应接口或者添加EventTrigger组件来实现各种事件回调。</p><p>使用这样的方案实现的回调，其传递的数据PointerEventData中包含的位置参数还是屏幕位置，而且跟像素相关，以屏幕左下角为原点的坐标。<br>如果希望获取触发事件时的世界坐标，则需要用到PointerEventData类中的pointerCurrentRaycast成员，该成员表示了射线检测的结果，因此其中包含碰撞点的世界坐标。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>底层机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity底层机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#委托</title>
    <link href="/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/"/>
    <url>/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>委托(delegate)是一种存储函数引用的类型。<br>委托是C#的一个语言级特性，而在Java语言中没有直接的对应，但是java利用反射即可实现委托。</p><p>委托最重要的用途在事件和事件处理时才能解释清楚，但这里也将介绍有关委托的许多内容。</p><p>委托是一种数据类型，和类是同级别的，我们可以将delegate与class类比：</p><ul><li>class里存放的是一系列方法，属性，字段，事件，索引。</li><li>delegate里存放的是一系列具有相同类型参数和返回回类型的方法的地址的地址。<br>可以看作为储存方法的载体。</li></ul><p>有了引用函数的变量后，就可以执行无法用其他方式完成的操作。<br>例如，可以把委托变量作为参数传递给-一个函数，这样，该函数就可以使用委托调用它引用的任何函数，而且在运行之前不必知道调用的是哪个函数。下面的示例使用委托访问两个函数中的一个。</p><blockquote><p><a href="https://baike.baidu.com/item/c%23%E5%A7%94%E6%89%98/6916387?fr=aladdin">委托百度百科</a>上看的最明白</p></blockquote><h1 id="2-委托的声明"><a href="#2-委托的声明" class="headerlink" title="2. 委托的声明"></a>2. 委托的声明</h1><p><strong>delegate &lt;函数返回类型&gt; 委托名（函数参数）</strong>   </p><p><strong>例：</strong> <code>public delegate void myDelegate(string name);</code></p><h1 id="3-委托的实例化"><a href="#3-委托的实例化" class="headerlink" title="3. 委托的实例化"></a>3. 委托的实例化</h1><ul><li><strong>&lt;委托名&gt;实例化名= new &lt;委托名&gt;（注册函数）</strong></li></ul><p>例 : <code> myDelegate delegateinstance = new myDelegate(method);</code></p><blockquote><p>注意：注册函数不包含参数，或者可以直接将一个注册函数赋值给委托</p></blockquote><ul><li>匿名方法实例化委托</li></ul><p>​        <strong>&lt;委托类型&gt; &lt;实例化名&gt;=delegate(&lt;函数参数&gt;){函数体}</strong></p><ul><li>使用lamda表达式实例化委托</li></ul><p>实例化例子如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>   <br>&#123;     <br>    <span class="hljs-comment">//声明委托     </span><br>    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)     </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-comment">//实例化委托 </span><br>        <span class="hljs-comment">//1、使用new关键字       </span><br>        MyDelegate _myDelegate = <span class="hljs-keyword">new</span> MyDelegate(GetSum);<br>        <span class="hljs-comment">//2、使用匿名方法       </span><br>        MyDelegate myDelegate = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y)&#123;<span class="hljs-keyword">return</span> x + y;&#125;;<br>        <span class="hljs-comment">//3、使用Lambda表达式       </span><br>        MyDelegate myDelegateLambda = (<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) =&gt; &#123; <span class="hljs-keyword">return</span> x + y; &#125;;  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)     </span><br><span class="hljs-function"></span>    &#123;       <br>        <span class="hljs-keyword">return</span> x + y;     <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-多播委托"><a href="#4-多播委托" class="headerlink" title="4.多播委托"></a>4.多播委托</h1><p>实例化委托时必须将一个匹配函数注册到委托上来实例化一个委托对象，但是一个实例化委托不仅可以注册一个函数还可以注册多个函数。注册多个函数后，在执行委托的时候会根据注册函数的注册先后顺序依次执行每一个注册函数。</p><ul><li><p>多播委托实际上形成委托链 </p><p>函数注册委托的原型：</p><p>​            <strong>&lt;委托类型&gt; &lt;实例化名&gt;+=或者-=new &lt;委托类型&gt;(&lt;注册函数&gt;)</strong><br>如果在委托注册了多个函数后，如果委托有返回值，那么调用委托时，返回的将是最后一个注册函数的返回值。</p><blockquote><p>注意：委托必须先实例化以后，才能使用+=注册其他方法。如果对注册了函数的委托实例从新使用=号赋值，相当于是重新实例化了委托，之前在上面注册的函数和委托实例之间也不再产生任何关系。</p></blockquote></li></ul><blockquote><p>多播委托不支持返回值，也不支持数据引用，是单向广播</p></blockquote><h1 id="5-泛型委托"><a href="#5-泛型委托" class="headerlink" title="5.泛型委托"></a>5.泛型委托</h1><p>委托也支持泛型的使用<br>泛型委托原型：</p><ul><li><strong>delegate <T1> &lt;委托名&gt;&lt;T1,T2,T3…&gt; (T1 t1,T2 t2,T3 t3…)</strong></li></ul><h2 id="5-1-内置泛型委托"><a href="#5-1-内置泛型委托" class="headerlink" title="5.1 内置泛型委托"></a>5.1 内置泛型委托</h2><p>delegate      void   Action&lt;T1，T2，T3&gt;    泛型委托是可以达到16个参数的无返回值委托<br>delegate  Tresult Fun&lt;T1,T2,Tresult&gt;    Fun是内置泛型委托，具有返回值<br>delegate bool Predicate<T>(T obj)    内置泛型委托，返回bool值</p><h1 id="6-委托的清空"><a href="#6-委托的清空" class="headerlink" title="6. 委托的清空"></a>6. 委托的清空</h1><ol><li>在类中申明清空委托方法，依次循环去除委托引用。方法如下：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>&#123;<br>    <span class="hljs-keyword">public</span> DelegateMethod OnDelegate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearDelegate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.OnDelegate != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">this</span>.OnDelegate -= <span class="hljs-keyword">this</span>.OnDelegate;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>如果在类中没有申明清空委托的方法，我们可以利用GetInvocationList查询出委托引用，然后进行去除。</p><p>方法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">TestDelegate test = <span class="hljs-keyword">new</span> TestDelegate();<br><span class="hljs-keyword">if</span> (test.OnDelegate != <span class="hljs-literal">null</span>)<br>&#123;<br>  System.Delegate[] dels = test.OnDelegate.GetInvocationList();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; dels.Length; i++)<br>  &#123;<br>     test.OnDelegate -= dels[i] <span class="hljs-keyword">as</span> DelegateMethod;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-委托的应用"><a href="#7-委托的应用" class="headerlink" title="7.委托的应用"></a>7.委托的应用</h1></li></ol><ul><li>高内聚低耦合</li><li>用于事件系统</li><li>用于设计模式——观察者模式开发</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#事件</title>
    <link href="/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>C#事件的核心思想是基于windows消息处理机制的，只是封装的更好，让开发者无须知道底层的消息处理机制，就可以开发出强大的基于事件的应用程序来。</p><p>关于事件，比较形象的比喻就是广播者和订阅者。事件执行时会广播给订阅他函数，告诉每个函数该运行了，但不管函数的实现细节。</p><p>事件类似于异常，因为它们都由对象引发(抛出)，并且都可以通过我们提供的代码来处理。<br>但它们也有个重要区别：事件并没有与tny. catch类似的结构来处理事件，你必须订阅(Subseribe)它们。</p><p>订阅一个事件的含义是提供代码，在事件发生时执行这些代码，它们称为事件处理程序。</p><p>单个事件可供多个处理程序订阅，在该事件发生时，这些处理程序都会被调用，事件处理程序可以在引发事件的类中，也可以在其他类中。</p><p>事件处理程序本身都是简单方法。对事件处理方法的唯一限制是它必须匹配事件所要求的返回类型和参数，这个限制是事件定义的一部分，由一个委托指定。</p><blockquote><p>学习事件前请先学习<br><a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/">委托</a></p></blockquote><h1 id="2-事件与委托的关系与区别"><a href="#2-事件与委托的关系与区别" class="headerlink" title="2. 事件与委托的关系与区别"></a>2. 事件与委托的关系与区别</h1><p><strong>事件Event</strong>是在<strong>多播委托multicast delegate</strong>的基础上演变而来。</p><ul><li>event是升级版delegate，用event实现的功能用delegate同样可以实现。</li><li>event较之delegate具有继承方面的安全性。<br>用event，别的类只能订阅/取消订阅，如果用一个 public delegate成员变量，别的类可以调用或者覆盖我们的delegate变量。</li><li>一般来说，如果你要创建一个包含多个类的动态体系，使用event而不是delegate。</li></ul><h1 id="3-使用事件的优点"><a href="#3-使用事件的优点" class="headerlink" title="3. 使用事件的优点"></a>3. 使用事件的优点</h1><p>在以往我们编程时，往往采用等待机制，为了等待某件事情的发生，需要不断地检测某些判断变量，而引入事件编程后，大大简化了这种过程：</p><ul><li><p>可以很方便地确定程序执行顺序。</p></li><li><p>当事件驱动程序等待事件时，它不占用很多资源。<br>事件驱动程序与过程式程序最大的不同就在于，程序不再不停地检查输入设备，而是呆着不动，等待消息的到来,每个输入的消息会被排进队列，等待程序处理它。<br>如果没有消息在等待，则程序会把控制交回给操作系统，以运行其他程序。</p></li><li><p>简化了编程。<br>操作系统只是简单地将消息传送给对象，由对象的事件驱动程序确定事件的处理方法。<br>操作系统不必知道程序的内部工作机制，只是需要知道如何与对象进行对话，也就是如何传递消息。</p></li><li><p>在事件源和事件接收器之间启用非常小的耦合。<br>这两个组件可能不会由同一个组织编写，甚至可能会通过完全不同的计划进行更新。</p></li><li><p>订阅事件并从同一事件取消订阅应该非常简单。</p></li><li><p>事件源应支持多个事件订阅服务器。<br>它还应支持不附加任何事件订阅服务器。</p></li></ul><h1 id="4-使用事件需要的步骤"><a href="#4-使用事件需要的步骤" class="headerlink" title="4. 使用事件需要的步骤"></a>4. 使用事件需要的步骤</h1><p>我们编写一个偶像搞事事件来描述使用事件的步骤。</p><p>代码与步骤如下：</p><h2 id="4-1-创建一个委托"><a href="#4-1-创建一个委托" class="headerlink" title="4.1 创建一个委托"></a>4.1 创建一个委托</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像行为委托，参数是行为字符串，返回值为空</p></blockquote><h2 id="4-2-将委托与已有或自定义事件关联"><a href="#4-2-将委托与已有或自定义事件关联" class="headerlink" title="4.2 将委托与已有或自定义事件关联"></a>4.2 将委托与已有或自定义事件关联</h2><p>.Net类库中的很多事件都是已经定制好的，所以他们也就有相应的一个委托，在编写关联事件处理程序——也就是当有事件发生时我们要执行的方法的时候我们需要和这个委托有相同的签名</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像搞事事件，与IdolBehaviour偶像行为委托关联</p></blockquote><h2 id="4-3-编写事件处理程序"><a href="#4-3-编写事件处理程序" class="headerlink" title="4.3 编写事件处理程序"></a>4.3 编写事件处理程序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>&#125;<br><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>的两个事件处理程序函数</p></blockquote><h2 id="4-4-生成委托实例"><a href="#4-4-生成委托实例" class="headerlink" title="4.4 生成委托实例"></a>4.4 生成委托实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br>IdolBehaviour myIdolBehaviour=<span class="hljs-keyword">new</span> IdolBehaviour();<br></code></pre></td></tr></table></figure><blockquote><p>这步可以省略<br>我们在声明event delegate时并没有给它分配内存，使用时直接赋值或添加即可</p></blockquote><h2 id="4-5-订阅事件"><a href="#4-5-订阅事件" class="headerlink" title="4.5 订阅事件"></a>4.5 订阅事件</h2><p>把这个委托实例添加到产生事件对象的事件列表中去，这个过程又叫订阅事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += LikeIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= LikeIdol;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-comment">//OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += HateIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= HateIdol;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>中用于事件订阅</p></blockquote><h2 id="4-6-事件触发"><a href="#4-6-事件触发" class="headerlink" title="4.6 事件触发"></a>4.6 事件触发</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>&#123;<br>    IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>别编写在<strong>Idol.cs</strong>中需要触发事件的地方，Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</p></blockquote><h2 id="4-7-代码汇总"><a href="#4-7-代码汇总" class="headerlink" title="4.7 代码汇总"></a>4.7 代码汇总</h2><p>结果以上6个步骤后，一个自定义事件就完成了，代码汇总如下：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>        &#123;<br>            IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-事件产生和实现的流程"><a href="#5-事件产生和实现的流程" class="headerlink" title="5.事件产生和实现的流程"></a>5.事件产生和实现的流程</h1><ol><li><p>定义A为产生事件的实例，a为A产生的一个事件</p></li><li><p>定义B为接收事件的实例，b为处理事件的方法</p></li><li><p>A由于用户(程序编写者或程序使用者)或者系统产生一个a事件(例如点击一个Button，产生一个Click事件)</p></li><li><p>A通过事件列表中的委托对象将这个事件通知给B</p></li><li><p>B接到一个事件通知(实际是B.b利用委托来实现事件的接收)</p></li><li><p>调用B.b方法完成事件处理</p></li></ol><h1 id="6-参考网站"><a href="#6-参考网站" class="headerlink" title="6. 参考网站"></a>6. 参考网站</h1><ul><li><a href="https://www.jb51.net/article/133032.htm">https://www.jb51.net/article/133032.htm</a></li><li> <a href="https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/">https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yield表达式</title>
    <link href="/2021/03/20/yield%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/03/20/yield%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>unity的协程（Coroutine）认识yield这个关键字的，知道在unity的开发中诸如yield return null、yield return new WaitForSeconds(1.0f)的用法，其实yield是C#的关键字，unity的协程只是在c#的基础上做了一层封装，我们现在来看看yield这个关键字。</p><p>要想整懂yield得先整懂以下几个东西：</p><ul><li><p>设计模式——迭代器模式</p></li><li><p>C#中的IEnumerator、IEnumerable接口</p></li><li><p>Unity的协程（Coroutine）</p><p>目前我还一个不会，先挖个坑吧QAQ</p></li></ul><h1 id="Unity的yield表达式"><a href="#Unity的yield表达式" class="headerlink" title="Unity的yield表达式"></a>Unity的yield表达式</h1><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td>yield return null;</td><td>等1帧执行.暂停协同程序，下一帧再继续往下执行. 通知协程管理器，我到这个点要中断一下，下一帧从这个地方运行而已</td></tr><tr><td>yield return 0;</td><td>同yield return null;,数字改多大没用,都是等一帧</td></tr><tr><td>yield return 666;</td><td>同yield return null;,数字改多大没用,都是等一帧</td></tr><tr><td>yield break;</td><td>不在执行下面的语句,直接rerun</td></tr><tr><td>yield return asynaOperation;</td><td>等待异步操作执行完毕后执行</td></tr><tr><td>yield return StartCoroutine(coroutine);</td><td>等待子协程执行完毕后再执行</td></tr><tr><td>yield return WWW();</td><td>在WWW下载完成之后……waits for a web request to complete (resumes as if WaitForSeconds or null)</td></tr><tr><td>yield return new WaitForEndOfFrame();</td><td>等待帧结束,等待直到所有的摄像机和GUI被渲染完成后，在该帧显示在屏幕之前。用在while循环里减少死机</td></tr><tr><td>yield return new WaitForSeconds(0.3f);</td><td>等待0.3秒 , 一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后注意:受Time.timeScale影响，当Time.timeScale = 0f 时，yield return new WaitForSecond(x) 将不会满足。</td></tr><tr><td>yield return new WaitForFixedUpdate();</td><td>所有脚本上的FixedUpdate函数已经执行调用之后持续</td></tr><tr><td>yield return new WaitUntil</td><td>将协同执行直到 当输入的参数（或者委托）为true的时候…… || yield return new WaitUntil(() =&gt; frame &gt;= 10);</td></tr><tr><td>yield return new WaitWhile</td><td>将协同执行直到 当输入的参数（或者委托）为false的时候…… || yield return new WaitWhile(() =&gt; frame &lt; 10);</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的事件函数</title>
    <link href="/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity中的脚本组织不像传统的游戏循环，有一个持续进行的主循环并在循环体中处理游戏逻辑。</p><p>相对的，Unity 会在特定的事件发生时，调用脚本中特定的函数，然后执行逻辑的任务就交给了该脚本函数，函数执行完毕后，执行的权力重新还给Unty。</p><p>这些特定的函数通常被称为事件函数，因为是在特定事件发生时由引擎层调用的。</p><h1 id="2-必然事件"><a href="#2-必然事件" class="headerlink" title="2.必然事件"></a>2.必然事件</h1><table><thead><tr><th>事件函数</th><th>作用</th></tr></thead><tbody><tr><td>Awake</td><td>脚本实例被创建时调用（用于游戏对象的初始化，注意Awake的执行早于所有脚本的Start函数）</td></tr><tr><td>Start</td><td>Update函数第一次运行之前调用（用于游戏对象的初始化）</td></tr><tr><td>Reset</td><td>用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个最常用的默认值。</td></tr><tr><td>Update</td><td>每帧调用一次（用于更新游戏场景和状态）</td></tr><tr><td>FixedUpdate</td><td>每个固定物理时间间隔调用一次（用于物理引擎的参数更新）</td></tr><tr><td>LateUpdate</td><td>每帧调用一次，在Update之后（用于更新游戏场景和状态，和相机有关的更新一般放在这里）</td></tr></tbody></table><h2 id="2-1-Updata与FixedUpdate的区别"><a href="#2-1-Updata与FixedUpdate的区别" class="headerlink" title="2.1 Updata与FixedUpdate的区别"></a>2.1 Updata与FixedUpdate的区别</h2><ul><li><p>FixedUpdate</p><p>物理更新的事件函数，物理引擎也会按照物理帧更新，机制和<strong>Update函数</strong>类似，但是更新的时机完全不同。</p><p>它在每一次物理更新时被调用。</p></li><li><p>Updata</p><p>帧更新函数，每帧调用一次。</p></li></ul><blockquote><p>要认识到，物理更新的频率和时机与Update函数是相对独立的。尽可能在FixedUpdate函数中进行物理相关的操作，在Update函数中进行其他操作，只有选择正确的函数才能让游戏效果尽可能准确。</p></blockquote><h3 id="2-1-1-帧率"><a href="#2-1-1-帧率" class="headerlink" title="2.1.1 帧率"></a>2.1.1 帧率</h3><p>每一帧所经历的时间并不是一个固定值，所以通过<strong>Updata函数</strong>控制物体移动的速度将不会是稳定的。</p><p>主要是因为硬件负载的原因，引擎默认会按照每秒60帧运行游戏，但是当负载增大时，帧率可能会下降，无法达到60帧，这时可能就只有30帧，帧率降低了一半，每帧的时间增加了一倍。物体的运动由于帧率降低而变慢了。实践中一般不允许这种情况的发生。</p><p>解决方案是将两帧之间的间隔<strong>Time.deltaTime</strong>考虑进去。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleScript</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> distancePerSecond;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        transform.Translate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>，distancePerSecond*Time.deltaTime);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:通过乘以Time.deltaTime的运算，物体的移动不再以“每帧距离”为准，而变成了“每秒距离”。</p><p>物体移动的距离将根据每帧时间的长短而变化，从而在时间上看起来移动是匀速的。</p></blockquote><h3 id="2-1-2-物理帧率"><a href="#2-1-2-物理帧率" class="headerlink" title="2.1.2 物理帧率"></a>2.1.2 物理帧率</h3><p>与主更新函数Update不同，Unity的物理系统必须以固定的时间间隔工作，因为只有固定的时间间隔才能保证物理模拟的准确性。就算当前负载很高、帧率很低，Unity也会尽可能保证物理刷新的频率，因为如果物理刷新帧率无法保证，就可能出现不可预料的计算结果。</p><p>在主菜单的工程选项的TimeManager中可以修改物理更新的时间间隔。<br>在脚本中使用Time. fixedDeltaTime可以获得物理更新间隔。</p><p>较小的物理更新间隔会带来更高的更新频率，更准确、更细腻的运算结果，但是也会极大地增加硬件负担。<br>fixedDeltaTime 的默认值为0.02，当对物理运算的准确性非常在意时，可以考虑适当减小这个值。</p><h1 id="3-事件响应函数"><a href="#3-事件响应函数" class="headerlink" title="3. 事件响应函数"></a>3. 事件响应函数</h1><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>OnMouseEnter</td><td>鼠标移入GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseOver</td><td>鼠标停留在GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseExit</td><td>鼠标移出GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseDown</td><td>鼠标在GUI控件或者碰撞体上按下时调用</td></tr><tr><td>OnMouseUp</td><td>鼠标按键释放时调用</td></tr><tr><td>OnTriggerEnter</td><td>与其他碰撞体进入触发器时调用</td></tr><tr><td>OnTriggerExit</td><td>与其他碰撞体离开触发器时调用</td></tr><tr><td>OnTriggerStay</td><td>当其他碰撞体停留在触发器时调用</td></tr><tr><td>OnCollisionEnter</td><td>当碰撞体或者刚体与其他碰撞体或者刚体接触时调用</td></tr><tr><td>OnCollisionExit</td><td>当碰撞体或者刚体与其他碰撞体或者刚体停止接触时调用</td></tr><tr><td>OnCollisionStay</td><td>当碰撞体或者刚体与其他碰撞体或者刚体保持接触时调用</td></tr><tr><td>OnControllerColliderHit</td><td>当控制器移动时与碰撞体发生碰撞时调用</td></tr><tr><td>OnDestroy</td><td>脚本销毁时调用</td></tr><tr><td>OnGUI</td><td>渲染GUI和处理GUI消息时调用</td></tr><tr><td>OnBecameVisible</td><td>对于任意一个相机可见时调用</td></tr><tr><td>OnBecameInVisible</td><td>对于任意一个相机不可见时调用</td></tr><tr><td>OnEnable</td><td>对象启用或者激活时调用</td></tr><tr><td>OnDisable</td><td>对象禁用或者取消激活时调用</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameObject类</title>
    <link href="/2021/03/20/GameObject%E7%B1%BB/"/>
    <url>/2021/03/20/GameObject%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>GameObject 类是Unity场景中所有实体的基类。</p><p>一个GameObject对象通常由多个组件component组成，且至少含有一个transform组件。</p><p>详细可见<a href="https://blog.csdn.net/a1256242238/article/details/73189101">https://blog.csdn.net/a1256242238/article/details/73189101</a></p><h1 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h1><ul><li><p><code>public GameObject();</code></p></li><li><p><code>public GameObject(string name);</code></p></li><li><p><code>public GameObject(string name,params Type[] components);</code></p></li></ul><h1 id="3-常用成员变量"><a href="#3-常用成员变量" class="headerlink" title="3. 常用成员变量"></a>3. 常用成员变量</h1><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>继承于父类Object，对象的名称</td></tr><tr><td>tag</td><td>游戏对象的标签tag</td></tr><tr><td>layer</td><td>游戏对象所在的层layer，范围为[0…31]</td></tr><tr><td>activeSelf</td><td>游戏对象自身的激活状态</td></tr><tr><td>transform</td><td>游戏对象上的Transform组件，设置对象位置、旋转、缩放</td></tr><tr><td>rigidbody</td><td>游戏对象上的Rigidbody组件，设置物理引擎的刚体属性</td></tr><tr><td>camera</td><td>游戏对象上的Camera组件，设置相机属性</td></tr><tr><td>light</td><td>游戏对象上的Light组件，设置灯光属性</td></tr><tr><td>animation</td><td>游戏对象上的Animation组件，设置动画属性</td></tr><tr><td>renderer</td><td>游戏对象上的Renderer组件，渲染物体模型</td></tr><tr><td>audio</td><td>游戏对象上的AudioSource组件，设置声音属性</td></tr></tbody></table><h1 id="4-常用成员函数"><a href="#4-常用成员函数" class="headerlink" title="4.常用成员函数"></a>4.常用成员函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Find</td><td>静态函数，根据名称查找游戏对象</td></tr><tr><td>FindWithTag</td><td>静态函数，根据标签查找第一个符合条件的游戏对象</td></tr><tr><td>FindGameObjectsWithTag</td><td>静态函数，根据标签查找所有符合条件的游戏对象</td></tr><tr><td>CreatePrimitive</td><td>静态函数，创建一个基本形体的游戏对象（如正方体，球体等）</td></tr><tr><td>SetActive</td><td>激活/取消激活游戏对象</td></tr><tr><td>GetComponent</td><td>获取游戏对象</td></tr><tr><td>GetComponentInChildren</td><td>获取游戏对象或其子对象上指定类型的第一个组件</td></tr><tr><td>GetComponents</td><td>获取游戏对象上指定类型的所有组件</td></tr><tr><td>AddComponent</td><td>为游戏对象添加指定组件</td></tr><tr><td>SendMessage</td><td>调用游戏对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>SendMessageUpwards</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>BroadcastMessage</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>CompareTag</td><td>比较游戏对象的标签</td></tr></tbody></table><h1 id="5-继承自Object类的常用函数"><a href="#5-继承自Object类的常用函数" class="headerlink" title="5. 继承自Object类的常用函数"></a>5. 继承自Object类的常用函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Destroy</td><td>删除一个游戏物体、组件或资源</td></tr><tr><td>DestroyImmediate</td><td>立即销毁物体obj，强烈建议使用Destroy替代</td></tr><tr><td>Instantiate</td><td>克隆原始物体，并返回克隆的物体</td></tr><tr><td>DontDestroyOnLoad</td><td>加载新场景的时候使目标不被自动销毁</td></tr><tr><td>FindObjectOfType</td><td>返回Type类型第一个激活的加载的物体</td></tr></tbody></table><h2 id="5-1-Instantiate创建物体"><a href="#5-1-Instantiate创建物体" class="headerlink" title="5.1 Instantiate创建物体"></a>5.1 Instantiate创建物体</h2><p><strong>Instantiate函数</strong>专门用来创建一个新的物体，但是要提供一个预制体或者已经存在的游戏物体作为模板。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Gameobject enemy;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//以enemy为模板生成5个敌人</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-number">1</span><span class="hljs-number">-0</span>; <span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>; <span class="hljs-number">1</span>++)<br>    &#123;<br>        Instantiate(enemy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用已经存在的物体作为模板，更常见的方式是使用预制体作为模板。</p><p>创建的物体将会具有和原物体一样的组件、参数。</p><h2 id="5-2-Destroy销毁物体"><a href="#5-2-Destroy销毁物体" class="headerlink" title="5.2 Destroy销毁物体"></a>5.2 Destroy销毁物体</h2><p>可以用Destroy函数来销毁游戏物体或者组件。</p><p>例如，下面的代码会在导弹产生碰撞时销毁该导弹，第二个参数0.5f表示在0.5秒之后才执行销毁动作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span> (<span class="hljs-params">Collision otherobj</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (other0bj.gameObject.tag == <span class="hljs-string">&quot;Missile&quot;</span>)<br>    &#123;<br>        Destroy (gameObject,<span class="hljs-number">0.5f</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:由于销毁游戏物体和销毁脚本都是使用Destoy函数，所以经常 会出现误删除组件的情况。</p><p>如以下代码：</p><p><code>Destroy (this);</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在脚本中访问其他游戏物体</title>
    <link href="/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在实际的游戏开发中，脚本不仅会对当前挂载的物体进行操作，还可能会引用其他物体。<br>例如，正在追逐玩家角色的敌人角色会-直保留着对玩家角色的引用， 以便随时确定玩家角色的位置。<br>访问其他游戏物体的方法非常多，使用非常灵活，可以根据不同的情况采用不同的方式。</p><h1 id="2-常用的4种访问操作"><a href="#2-常用的4种访问操作" class="headerlink" title="2.常用的4种访问操作"></a>2.常用的4种访问操作</h1><h2 id="2-1-用属性查看器指定参数访问"><a href="#2-1-用属性查看器指定参数访问" class="headerlink" title="2.1 用属性查看器指定参数访问"></a>2.1 用属性查看器指定参数访问</h2><p>Unity中获得其他物体最简单、最直接的方式就是为脚本添加一个<code>publi Gamebiet</code>变量，不需要设置初始值。<br>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>player变量会显示在检视窗口中，默认值为空。</p><p>现在将任何物体或预制体拖曳到player变量的文本框中，就为player变量赋予了初始值。之在脚本中就可以随意使用Player这个游戏物体。<br>如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//读取player的位置并设置本物体的位置在它后方</span><br>        transform.position=player.transform.position-Vector3.forward*<span class="hljs-number">10f</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，上面说的引用其他物体时，变量类型不仅可以是<strong>GameObject</strong>或一个组件，也可以将戏物体拖到这个变量上，只要被拖曳的物体确实具有这个组件就可以。</p><p><code>public Transform playerTransform;</code></p><p>简单地说，可以用何一个组件来指代游戏物体本身。<br>这是因为组件实体具有“被游戏物体挂载”这样的性质，所通过一个游戏物体可以获得它上面的任何一个组件，通过任何一个组件也可以获得挂载该组件游戏物体。这个对应关系是明确的，因此上面的变量类型可以是组件类型，也可以将游戏物体直接拖上去。</p><p>用变量将物体联系起来的做法非常有用，特别是这种联系是持续存在、不易变化的。还可用一个数组或者列表来保存多个游戏物体。</p><blockquote><p>如果被引用的物体是游戏运行时才动态添加的，或者被引用的物体会随着游戏进行而变化事先拖曳的方式就不可行了，需要动态指定物体，下面将详细说明。</p></blockquote><h2 id="2-2-用父子关系查找子物体"><a href="#2-2-用父子关系查找子物体" class="headerlink" title="2.2 用父子关系查找子物体"></a>2.2 用父子关系查找子物体</h2><p>有时需要管理一系列同类型的游戏物体，例如一批敌人、一批寻路点、 多个障碍物等。<br>如果这时候需要对这些物体进行统一的管理或操作，就需要在脚本中用数组或容器来管理它们。</p><p>使用属性查看器指定参数访问的方法，可以将每个物体拖动到检视窗口中，但是这样做不仅低效，而且容易误操作，在物体增加、减少时还需要再次手动操作。</p><p>所以，在这种情况下是不合适的，可以用父子关系查找子物体的方法来遍历所有子物体。<br>在具体实现时，要用父物体的变换组件来查找子物体。</p><blockquote><p>物体的父子关系访问的属性都在变换组件中，而不在GameObject对象中</p></blockquote><p>以下是遍历所有子物体的例子:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WaypointManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br><span class="hljs-keyword">public</span> Transform[] waypoints;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>waypoints = <span class="hljs-keyword">new</span> Transform[transform.childCount];<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">foreach</span> (Transform t <span class="hljs-keyword">in</span> transform)<br>&#123;<br>waypoints[i++] = t;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以使用<strong>transform.Find</strong>方法指定查找某个子物体，代码如下。</p><p><code>transform.Find (&quot;Gun&quot;);</code></p><blockquote><p>由于<strong>Find函数</strong>的效率不好估计，可能会遍历所有物体才能查找到指定物体，所以如果可以在<strong>Start函数</strong>中使用，就不要在<strong>Updata函数</strong>中使用。因为<strong>start函数</strong>只执行一次而<strong>updata函数</strong>每帧都会执行。</p></blockquote><h2 id="2-3-用标签或名称查找物体"><a href="#2-3-用标签或名称查找物体" class="headerlink" title="2.3 用标签或名称查找物体"></a>2.3 用标签或名称查找物体</h2><p>使用<strong>GameObject.Find方法</strong>可以通过名称查找游戏物体。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.Find (<span class="hljs-string">&quot;ObjectName&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要用标签查找物体，那么就要用到<strong>GameObject.FindWithTag方法</strong> 或<strong>GameObject.FindGameObjectWithTag方法</strong>。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br>GameObject[] enemies;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.FindWithTag(<span class="hljs-string">&quot;Player&quot;</span>);<br>    enemies =GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;Enemy&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
      <tag>Unity常用操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL语句大全</title>
    <link href="/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/"/>
    <url>/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MYSQL语句大全"><a href="#MYSQL语句大全" class="headerlink" title="MYSQL语句大全"></a>MYSQL语句大全</h1><h2 id="0-相关知识"><a href="#0-相关知识" class="headerlink" title="0 相关知识"></a>0 相关知识</h2><ul><li><p><a href="https://blog.csdn.net/chaoyue1861/article/details/80468773">MYSQL逻辑架构</a></p></li><li><p><a href="https://blog.csdn.net/GitChat/article/details/78787837?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">MYSQL底层原理</a></p></li><li><p><a href="https://blog.csdn.net/m0_38075425/article/details/82256315?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">MySQL底层架构原理，工作流程和存储引擎的数据结构讲解</a></p></li></ul><h2 id="1-用户管理操作"><a href="#1-用户管理操作" class="headerlink" title="1 用户管理操作"></a>1 用户管理操作</h2><h3 id="1-1-添加用户"><a href="#1-1-添加用户" class="headerlink" title="1.1 添加用户"></a>1.1 添加用户</h3><ul><li><code> create user username identified by &#39;password&#39;;</code></li></ul><p>参数：用户名：username 密码：password</p><blockquote><p>用户数据存储在mysql.user表内</p></blockquote><h3 id="1-2-用户授权"><a href="#1-2-用户授权" class="headerlink" title="1.2 用户授权"></a>1.2 用户授权</h3><ul><li><code>grant privilegesCode on dbName.tableName to username@host identified by &#39;password&#39;;</code></li></ul><p>将Dbname数据库的所有操作权限都授权给了用户username。</p><p>参数：</p><p><strong>privilegesCode</strong> 权限类型<br>常用的权限类型</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>all privileges</td><td>所有权限</td></tr><tr><td>select</td><td>读取权限</td></tr><tr><td>delete</td><td>删除权限</td></tr><tr><td>update</td><td>更新权限</td></tr><tr><td>create</td><td>创建权限</td></tr><tr><td>drop</td><td>删除数据库、数据表权限</td></tr></tbody></table><p><strong>dbName.tableName</strong> 授权的库或特定表</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>授予该数据库服务器所有数据库的权限</td></tr><tr><td>dbName.*</td><td>授予dbName数据库所有表的权限</td></tr><tr><td>dbName.dbTable</td><td>授予数据库dbName中dbTable表的权限</td></tr></tbody></table><p><strong>username@’host’</strong> 授予的用户以及允许该用户登录的IP地址<br>| 参数         | 含义                 |<br>| ————– | ———————- |<br>| localhost | 只允许该用户在本地登录，不能远程登录 |<br>| % | 允许在除本机之外的任何一台机器远程登录 |<br>| 192.168.52.32 | 具体的IP表示只允许该用户从特定IP登录 |</p><ul><li><p><code> flush privileges;</code></p><p>刷新权限变更</p></li><li><p><code> show grants for &#39;username&#39;;</code></p></li></ul><p>查看用户的已有权限</p><blockquote><p>用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush privileges;<br></code></pre></td></tr></table></figure><p>上面的语句将zhangsanDb数据库的所有操作权限都授权给了用户zhangsan</p></blockquote><ul><li><p><code>REVOKE DELETE ON *.* FROM &#39;test&#39;@&#39;localhost&#39;;</code> </p><p>取消该用户的删除权限</p></li></ul><blockquote><p>用户权限数据存储在mysql.db表内</p></blockquote><h3 id="1-3-修改密码"><a href="#1-3-修改密码" class="headerlink" title="1.3 修改密码"></a>1.3 修改密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update mysql.user set password &#x3D; password(&#39;newpassword&#39;) where user &#x3D; &#39;username&#39; and host &#x3D; &#39;%&#39;; <br>flush privileges;<br></code></pre></td></tr></table></figure><h3 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a>1.4 删除用户</h3><ul><li><code>drop user zhangsan@&#39;%&#39;;</code></li></ul><h3 id="1-5-常用命令组"><a href="#1-5-常用命令组" class="headerlink" title="1.5 常用命令组"></a>1.5 常用命令组</h3><p><strong>创建用户并授予指定数据库全部权限：适用于Web应用创建MySQL用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user zhangsan identified by &#39;zhangsan&#39;;<br>grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush  privileges;<br></code></pre></td></tr></table></figure><p>创建了用户zhangsan，并将数据库zhangsanDB的所有权限授予zhangsan。如果要使zhangsan可以从本机登录，那么可以多赋予localhost权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;localhost&#39; identified by &#39;zhangsan&#39;;<br></code></pre></td></tr></table></figure><h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2 数据库操作"></a>2 数据库操作</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code> show database;</code></td><td>查看所有的数据库</td></tr><tr><td><code>create database DBname;</code></td><td>创建该数据库</td></tr><tr><td><code>drop DBname;</code></td><td>删除该数据库</td></tr><tr><td><code>use DBname;</code></td><td>使用调用该数据库</td></tr></tbody></table><h2 id="3-表操作"><a href="#3-表操作" class="headerlink" title="3 表操作"></a>3 表操作</h2><h3 id="3-1-表的基础操作"><a href="#3-1-表的基础操作" class="headerlink" title="3.1 表的基础操作"></a>3.1 表的基础操作</h3><ul><li><p><code>show tables;</code><br>查看所有的表</p></li><li><p><code>SHOW TABLE STATUS;</code><br>查看所有的表信息（包括视图）</p></li><li><p><code> create table TBname(mode);</code></p><p>创建一个表</p><blockquote><p>例如<br><code>create table n(id INT, name VARCHAR(10));</code></p></blockquote></li><li><p><code> create table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的表</p></li><li><p><code>create table TBname like TBname;</code><br>新创建的表与一个存在的表的数据结构类似</p></li><li><p><code>create temporay table TBname(mode);</code><br>创建一个临时表</p><blockquote><p>临时表将在你连接MySQL期间存在。当断开连接时，MySQL将自动删除表并释放所用的空间。也可手动删除。</p></blockquote></li></ul><ul><li><p><code>create temporary table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的临时表</p></li><li><p><code> drop table if exists TBname;</code><br>删除一个存在表</p></li><li><pre><code>alter table TBname rename TBname;或rename TBname to TBname;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  更改存在表的名称<br><br>  <br>  <br>- ``` <br>  <span class="hljs-keyword">desc</span> TBname;<br>  describe TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">in</span> TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> TBname;<br>  <span class="hljs-keyword">explain</span> TBname;<br></code></pre></td></tr></table></figure>查看表的结构(以上五条语句效果相同）</code></pre></li><li><p><code> show create table TBname;</code><br>查看表的创建语句</p><h3 id="3-2-表的结构操作"><a href="#3-2-表的结构操作" class="headerlink" title="3.2 表的结构操作"></a>3.2 表的结构操作</h3></li></ul><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td><code> alter table TBname add Fieldname mode;</code></td><td>添加字段</td></tr><tr><td><code>alter table TBname drop Fieldname;</code></td><td>删除字段</td></tr><tr><td><code>alter table TBname change Fieldname mode;</code></td><td>更改字段属性</td></tr><tr><td><code>alter table TBname change Fieldname Fieldname mode;</code></td><td>更改字段名与属性</td></tr></tbody></table><h3 id="3-3-表的数据操作"><a href="#3-3-表的数据操作" class="headerlink" title="3.3 表的数据操作"></a>3.3 表的数据操作</h3><ul><li><p>增加数据</p><p><code>INSERT INTO n VALUES (1, &#39;tom&#39;, &#39;23&#39;), (2, &#39;john&#39;, &#39;22&#39;);</code></p><p><code>INSERT INTO n SELECT * FROM n;</code>  把数据复制一遍重新插入</p></li><li><p>删除数据</p><p><code>DELETE FROM n WHERE id = 2;</code></p></li><li><p>更改数据</p><p><code>UPDATE n SET name = &#39;tom&#39; WHERE id = 2;</code></p></li><li><p>数据查找</p><p><code>SELECT * FROM n WHERE name LIKE &#39;%h%&#39;;</code></p></li><li><p>数据排序(反序)</p><p><code>SELECT * FROM n ORDER BY name, id DESC ;</code></p></li></ul><blockquote><p>增删改查请看：<a href="https://www.cnblogs.com/heyangblog/p/7624645.html">https://www.cnblogs.com/heyangblog/p/7624645.html</a></p></blockquote><h2 id="4-键"><a href="#4-键" class="headerlink" title="4 键"></a>4 键</h2><h3 id="4-1-添加主键"><a href="#4-1-添加主键" class="headerlink" title="4.1 添加主键"></a>4.1 添加主键</h3><ul><li><p><code>ALTER TABLE TBname ADD PRIMARY KEY (id);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT pk_n PRIMARY KEY (id);</code>  </p><p>添加主键的同时自定义键名</p></li></ul><h3 id="4-2-删除主键"><a href="#4-2-删除主键" class="headerlink" title="4.2 删除主键"></a>4.2 删除主键</h3><ul><li><code> ALTER TABLE TBname DROP PRIMARY KEY ;</code></li></ul><h3 id="4-3-添加外键"><a href="#4-3-添加外键" class="headerlink" title="4.3 添加外键"></a>4.3 添加外键</h3><ul><li><p><code>ALTER TABLE TBname ADD FOREIGN KEY (id) REFERENCES TBname(id);</code>   </p><p>自动生成键名m_ibfk_1</p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES TBname(id); </code>  </p><p>使用定义的键名fk_id</p></li></ul><h3 id="4-4-删除外键"><a href="#4-4-删除外键" class="headerlink" title="4.4 删除外键"></a>4.4 删除外键</h3><ul><li>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</li></ul><h3 id="4-5-修改外键"><a href="#4-5-修改外键" class="headerlink" title="4.5 修改外键"></a>4.5 修改外键</h3><ul><li><p>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</p><p>ADD CONSTRAINT fk_id2 FOREIGN KEY (id) REFERENCES TBname(id); </p><p>删除之后从新建</p></li></ul><h3 id="4-6-添加唯一键"><a href="#4-6-添加唯一键" class="headerlink" title="4.6 添加唯一键"></a>4.6 添加唯一键</h3><ul><li><p><code> ALTER TABLE TBname ADD UNIQUE (name);</code></p></li><li><p><code> ALTER TABLE TBname ADD UNIQUE u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD UNIQUE INDEX u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT u_name UNIQUE (name);</code></p></li><li><p><code>CREATE UNIQUE INDEX u_name ON TBname(name);</code></p></li></ul><h3 id="4-7-添加索引"><a href="#4-7-添加索引" class="headerlink" title="4.7 添加索引"></a>4.7 添加索引</h3><ul><li><p><code>ALTER TABLE TBname ADD INDEX (age);</code></p></li><li><p><code>ALTER TABLE TBname ADD INDEX i_age (age);</code></p></li><li><p><code>CREATE INDEX i_age ON TBname(age);</code></p></li></ul><h3 id="4-8-删除索引或唯一键"><a href="#4-8-删除索引或唯一键" class="headerlink" title="4.8 删除索引或唯一键"></a>4.8 删除索引或唯一键</h3><ul><li><p><code>DROP INDEX u_name ON n;</code></p></li><li><p><code>DROP INDEX i_age ON n;</code></p></li></ul><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5 视图"></a>5 视图</h2><h3 id="5-1-创建视图"><a href="#5-1-创建视图" class="headerlink" title="5.1 创建视图"></a>5.1 创建视图</h3><ul><li><p><code>CREATE VIEW v AS SELECT id, name FROM n;</code></p></li><li><p><code>CREATE VIEW v(id, name) AS SELECT id, name FROM n;</code></p></li></ul><h3 id="5-2查看视图"><a href="#5-2查看视图" class="headerlink" title="5.2查看视图"></a>5.2查看视图</h3><ul><li><p><code>SELECT * FROM v;</code></p></li><li><p><code>DESC v;</code></p></li></ul><blockquote><p>与表操作类似</p></blockquote><h3 id="5-3查看创建视图语句"><a href="#5-3查看创建视图语句" class="headerlink" title="5.3查看创建视图语句"></a>5.3查看创建视图语句</h3><ul><li><code>SHOW CREATE VIEW v;</code></li></ul><h3 id="5-4-更改视图"><a href="#5-4-更改视图" class="headerlink" title="5.4 更改视图"></a>5.4 更改视图</h3><ul><li><p><code>CREATE OR REPLACE VIEW v AS SELECT name, age FROM n;</code></p></li><li><p><code>ALTER VIEW v AS SELECT name FROM n ;</code></p></li></ul><h3 id="5-5-删除视图"><a href="#5-5-删除视图" class="headerlink" title="5.5 删除视图"></a>5.5 删除视图</h3><ul><li><code>DROP VIEW IF EXISTS v;</code></li></ul><h2 id="6-联接"><a href="#6-联接" class="headerlink" title="6 联接"></a>6 联接</h2><h3 id="6-1-内联接"><a href="#6-1-内联接" class="headerlink" title="6.1 内联接"></a>6.1 内联接</h3><ul><li><code>SELECT * FROM m INNER JOIN n ON m.id = n.id;</code></li></ul><h3 id="6-2-外连接"><a href="#6-2-外连接" class="headerlink" title="6.2 外连接"></a>6.2 外连接</h3><ul><li><code>SELECT * FROM m LEFT JOIN n ON m.id = n.id;</code>左外连接</li><li><code>SELECT * FROM m RIGHT JOIN n ON m.id = n.id;</code>右外连接</li></ul><h3 id="6-3-交叉联接"><a href="#6-3-交叉联接" class="headerlink" title="6.3 交叉联接"></a>6.3 交叉联接</h3><ul><li><p><code>SELECT * FROM m CROSS JOIN n;</code>  标准写法</p></li><li><p><code>SELECT * FROM m, n;</code></p></li></ul><h3 id="6-4-类似全连接full-join的联接用法"><a href="#6-4-类似全连接full-join的联接用法" class="headerlink" title="6.4 类似全连接full join的联接用法"></a>6.4 类似全连接full join的联接用法</h3><ul><li><pre><code>SELECT id,name FROM mUNIONSELECT id,name FROM n;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs sql">## <span class="hljs-number">7</span> 函数<br><br>### <span class="hljs-number">7.1</span> 聚合函数<br><br><span class="hljs-operator">|</span> 语句                               <span class="hljs-operator">|</span> 含义   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">---------------------------------- | ------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(id) <span class="hljs-keyword">AS</span> total <span class="hljs-keyword">FROM</span> n;  <span class="hljs-operator">|</span> 总数   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 总和   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 平均值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">max</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最大值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最小值 <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.2</span> 数学函数<br><br><span class="hljs-operator">|</span> 语句                              <span class="hljs-operator">|</span> 含义                                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">--------------------------------- | ------------------------------------------------------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">abs</span>(<span class="hljs-number">-5</span>);                   <span class="hljs-operator">|</span> 绝对值                                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> bin(<span class="hljs-number">15</span>), oct(<span class="hljs-number">15</span>), hex(<span class="hljs-number">15</span>); <span class="hljs-operator">|</span> 二进制，八进制，十六进制                               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> pi();                      <span class="hljs-operator">|</span> 圆周率<span class="hljs-number">3.141593</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">5.5</span>);                 <span class="hljs-operator">|</span> 大于x的最小整数值<span class="hljs-number">6</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">5.5</span>);                <span class="hljs-operator">|</span> 小于x的最大整数值<span class="hljs-number">5</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> greatest(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>); <span class="hljs-operator">|</span> 返回集合中最大的值<span class="hljs-number">9</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> least(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);    <span class="hljs-operator">|</span> 返回集合中最小的值<span class="hljs-number">1</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);                  <span class="hljs-operator">|</span> 余数<span class="hljs-number">2</span>                                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand();                    <span class="hljs-operator">|</span> 返回０到１内的随机值，每次不一样                       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 提供一个参数(种子)使RAND()随机数生成器生成一个指定的值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>);          <span class="hljs-operator">|</span> 四舍五入<span class="hljs-number">1415</span>                                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);       <span class="hljs-operator">|</span> 四舍五入三位数<span class="hljs-number">1415.142</span>                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);      <span class="hljs-operator">|</span> 四舍五入整数位数<span class="hljs-number">1420</span>                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);    <span class="hljs-operator">|</span> 截短为<span class="hljs-number">3</span>位小数<span class="hljs-number">1415.141</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);   <span class="hljs-operator">|</span> 截短为<span class="hljs-number">-1</span>位小数<span class="hljs-number">1410</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">-5</span>);                  <span class="hljs-operator">|</span> 符号的值负数<span class="hljs-number">-1</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 符号的值正数<span class="hljs-number">1</span>                                          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">9</span>);                   <span class="hljs-operator">|</span> 平方根<span class="hljs-number">3</span>                                                <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.3</span> 字符串函数<br><br><span class="hljs-operator">|</span> 语句                                        <span class="hljs-operator">|</span> 含义                                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------- | ------------------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>);         <span class="hljs-operator">|</span> 连接字符串<span class="hljs-operator">-</span>apple                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>); <span class="hljs-operator">|</span> 连接用<span class="hljs-string">&#x27;,&#x27;</span>分割字符串<span class="hljs-operator">-</span>a,p,p,le                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">insert</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;IN&#x27;</span>);       <span class="hljs-operator">|</span> 将字符串<span class="hljs-string">&#x27;chinese&#x27;</span>从<span class="hljs-number">3</span>位置开始的<span class="hljs-number">2</span>个字符替换为<span class="hljs-string">&#x27;IN&#x27;</span><span class="hljs-operator">-</span>chINese <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">left</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">4</span>);                  <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>左边的<span class="hljs-number">4</span>个字符<span class="hljs-operator">-</span>chin                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">right</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);                 <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>右边的<span class="hljs-number">3</span>个字符<span class="hljs-operator">-</span>ese                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);             <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的子字符串<span class="hljs-operator">-</span>inese       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">-3</span>);            <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>倒数第三个字符之后的子字符串<span class="hljs-operator">-</span>ese     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);          <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的两个字符<span class="hljs-operator">-</span><span class="hljs-keyword">in</span>          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27; chinese &#x27;</span>);                   <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese&#x27;</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ltrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese &#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rtrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27; chinese&#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> repeat(<span class="hljs-string">&#x27;boy&#x27;</span>, <span class="hljs-number">3</span>);                    <span class="hljs-operator">|</span> 重复字符<span class="hljs-string">&#x27;boy&#x27;</span>三次<span class="hljs-operator">-</span><span class="hljs-string">&#x27;boyboyboy&#x27;</span>                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> reverse(<span class="hljs-string">&#x27;chinese&#x27;</span>);                  <span class="hljs-operator">|</span> 反向排序<span class="hljs-operator">-</span><span class="hljs-string">&#x27;esenihc&#x27;</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> length(<span class="hljs-string">&#x27;chinese&#x27;</span>);                   <span class="hljs-operator">|</span> 返回字符串的长度<span class="hljs-number">-7</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>), <span class="hljs-built_in">lower</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ucase(<span class="hljs-string">&#x27;chINese&#x27;</span>), lcase(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;i&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-3</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;e&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-5</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abd&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数小于第二个返回负数<span class="hljs-operator">-</span> <span class="hljs-number">-1</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abb&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数大于第二个返回正数<span class="hljs-operator">-</span> <span class="hljs-number">1</span>             <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.4</span> 时间函数<br><br><span class="hljs-operator">|</span> 语句                                                         <span class="hljs-operator">|</span> 含义                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------------------------ | -------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">current_date</span>, <span class="hljs-built_in">current_time</span>, now();                    <span class="hljs-operator">|</span> <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span>   <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span>    <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span> <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">hour</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">minute</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">second</span>(<span class="hljs-built_in">current_time</span>); <span class="hljs-operator">|</span> <span class="hljs-number">12</span>  <span class="hljs-number">31</span>   <span class="hljs-number">34</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">year</span>(<span class="hljs-built_in">current_date</span>), <span class="hljs-keyword">month</span>(<span class="hljs-built_in">current_date</span>), week(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">2018</span>    <span class="hljs-number">1</span>   <span class="hljs-number">1</span>                                <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> quarter(<span class="hljs-built_in">current_date</span>);                                <span class="hljs-operator">|</span> <span class="hljs-number">1</span>                                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> monthname(<span class="hljs-built_in">current_date</span>), dayname(<span class="hljs-built_in">current_date</span>);       <span class="hljs-operator">|</span> January  Saturday                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> dayofweek(<span class="hljs-built_in">current_date</span>), dayofmonth(<span class="hljs-built_in">current_date</span>), dayofyear(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">7</span>   <span class="hljs-number">13</span>  <span class="hljs-number">13</span>                                   <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.5</span> 控制流函数<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> if(<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>), if(<span class="hljs-number">3</span><span class="hljs-operator">&lt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>);`    <br><br>  t f<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> ifnull(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;t&#x27;</span>), ifnull(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>);`    <br><br>  t <span class="hljs-number">2</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> isnull(<span class="hljs-number">1</span>), isnull(<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>);`    <br><br>   <span class="hljs-number">0</span> <span class="hljs-number">1</span> 是<span class="hljs-keyword">null</span>返回<span class="hljs-number">1</span>，不是<span class="hljs-keyword">null</span>返回<span class="hljs-number">0</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);`    <br><br>  <span class="hljs-keyword">null</span> a 参数相同或成立返回<span class="hljs-keyword">null</span>，不同或不成立则返回第一个参数<br><br><span class="hljs-operator">-</span> ```<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-number">2</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;first&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;second&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;third&#x27;</span><br>         <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;other&#x27;</span><br>         <span class="hljs-keyword">END</span> ;     <br></code></pre></td></tr></table></figure>second&gt; 这一块不是完全看不懂吗！</code></pre></li></ul><h1 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h1><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td>SELECT database();</td><td>当前数据库名-test</td></tr><tr><td>SELECT connection_id();</td><td>当前用户id-306</td></tr><tr><td>SELECT user();</td><td>当前用户-root@localhost</td></tr><tr><td>SELECT version();</td><td>当前mysql版本</td></tr><tr><td>SELECT found_rows();</td><td>返回上次查询的检索行数</td></tr></tbody></table><h2 id="8-存储过程"><a href="#8-存储过程" class="headerlink" title="8 存储过程"></a>8 存储过程</h2><h3 id="8-1-创建存储过程"><a href="#8-1-创建存储过程" class="headerlink" title="8.1 创建存储过程"></a>8.1 创建存储过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">DELIMITER <span class="hljs-comment">//    # 无参数</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> ;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_2</span><span class="hljs-params">(<span class="hljs-keyword">IN</span> id INT)</span>    # <span class="hljs-title">in</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> <span class="hljs-title">WHERE</span> <span class="hljs-title">a</span> = <span class="hljs-title">id</span>;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_3</span><span class="hljs-params">(<span class="hljs-keyword">OUT</span> sum INT)</span>    # <span class="hljs-title">out</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">sum</span> = <span class="hljs-params">(<span class="hljs-keyword">SELECT</span> count(*)</span> <span class="hljs-title">FROM</span> <span class="hljs-title">test</span>);</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_4</span><span class="hljs-params">(INOUT i INT)</span>    # <span class="hljs-title">inout</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">i</span> = <span class="hljs-title">i</span> + 1;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="8-2-删除存储过程"><a href="#8-2-删除存储过程" class="headerlink" title="8.2 删除存储过程"></a>8.2 删除存储过程</h3><ul><li><code>DROP PROCEDURE IF EXISTS getDates;</code></li></ul><h3 id="8-3-修改存储过程的特性"><a href="#8-3-修改存储过程的特性" class="headerlink" title="8.3 修改存储过程的特性"></a>8.3 修改存储过程的特性</h3><ul><li><code>ALTER PROCEDURE getDates MODIFIES SQL DATA ;</code></li></ul><h3 id="8-4-查看存储过程"><a href="#8-4-查看存储过程" class="headerlink" title="8.4 查看存储过程"></a>8.4 查看存储过程</h3><ul><li><p><code>SHOW PROCEDURE STATUS LIKE &#39;getDates&#39;;</code>    </p><p> 状态</p></li><li><p><code>SHOW CREATE PROCEDURE getDates_3;</code> </p><p> 语句</p></li></ul><h3 id="8-5-调用存储过程"><a href="#8-5-调用存储过程" class="headerlink" title="8.5 调用存储过程"></a>8.5 调用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> getDates();<br><span class="hljs-keyword">CALL</span> getDates_2(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">CALL</span> getDates_3(<span class="hljs-variable">@s</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@s</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">CALL</span> getDates_4(<span class="hljs-variable">@i</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@i</span>;    # <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="9-数据库安全"><a href="#9-数据库安全" class="headerlink" title="9 数据库安全"></a>9 数据库安全</h2><h3 id="9-1-数据库备份"><a href="#9-1-数据库备份" class="headerlink" title="9.1 数据库备份"></a>9.1 数据库备份</h3><ul><li><pre><code>mysqldump -u root -p db_name &gt; file.sqlmysqldump -u root -p db_name table_name &gt; file.sql</code></pre><h3 id="9-2数据库还原"><a href="#9-2数据库还原" class="headerlink" title="9.2数据库还原"></a>9.2数据库还原</h3></li><li><code>mysql -u root -p &lt; C:\file.sql</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>数据库</tag>
      
      <tag>MYSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-排序</title>
    <link href="/2021/03/09/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/09/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1.题目要求"></a>1.题目要求</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个无序单链表，实现单链表的排序(按升序排序)。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>说明：本题目包含复杂数据结构ListNode</p><h1 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2.题目分析"></a>2.题目分析</h1><p>该题目主要考察的是排序算法，常用的排序算法可以参考该网站</p><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p><p><img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png" srcset="/img/loading.gif" alt="十种常见排序算法"></p><h1 id="3-解题"><a href="#3-解题" class="headerlink" title="3.解题"></a>3.解题</h1><h2 id="3-1-冒泡排序"><a href="#3-1-冒泡排序" class="headerlink" title="3.1 冒泡排序"></a>3.1 冒泡排序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; head</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; p = head; p.Next != <span class="hljs-literal">null</span>; p = p.Next)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; q = p.Next; q != <span class="hljs-literal">null</span>; q = q.Next)<br>            <span class="hljs-keyword">if</span> (p.Value &gt; p.Next.Value)<br>            &#123;<br>                <span class="hljs-built_in">int</span> t = p.Value;<br>                p.Value = p.Next.Value;<br>                p.Next.Value = t;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-选择排序"><a href="#3-2-选择排序" class="headerlink" title="3.2 选择排序"></a>3.2 选择排序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">selectionSort</span>(<span class="hljs-params">LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; head</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; p = head; p.Next != <span class="hljs-literal">null</span>; p = p.Next)<br>            &#123;<br>                LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; min = <span class="hljs-keyword">new</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">255</span>);<br>                <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; q = p; q.Next != <span class="hljs-literal">null</span>; q = q.Next)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (q.Value &lt; min.Value)<br>                    &#123;<br>                        min = q;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">int</span> t = p.Value;<br>                p.Value = min.Value;<br>                min.Value = t;<br>            &#125;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-插入排序"><a href="#3-3-插入排序" class="headerlink" title="3.3 插入排序"></a>3.3 插入排序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">insertionSort</span>(<span class="hljs-params">LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; head</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; p = head.Next; p.Next != <span class="hljs-literal">null</span>; p = p.Next)<br>            &#123;<br>                <span class="hljs-built_in">int</span> t = p.Value;<br>                LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; q = p.Previous;<br>                <span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(p.Value&gt;q.Value)<br>                    &#123;<br>                        q.Next.Value= t;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    q.Next.Value = q.Value;<br>                    q = q.Previous;<br>                &#125;                <br>            &#125;<br>                <span class="hljs-keyword">return</span> head;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-希尔排序"><a href="#3-4-希尔排序" class="headerlink" title="3.4 希尔排序"></a>3.4 希尔排序</h2>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序算法</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量基础知识</title>
    <link href="/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在数学中，几何向量（也称为欧几里得向量，通常简称向量、矢量），指具有大小和方向的量。</p><p>向量可以形象化地表示为带箭头的线段。</p><p>箭头所指：代表向量的方向；线段长度：代表向量的大小。</p><p>标量：只有大小,没有方向。</p><h1 id="2-向量的运算"><a href="#2-向量的运算" class="headerlink" title="2. 向量的运算"></a>2. 向量的运算</h1><h2 id="2-1-基础运算"><a href="#2-1-基础运算" class="headerlink" title="2.1 基础运算"></a>2.1 基础运算</h2><table><thead><tr><th>运算</th><th>描述</th></tr></thead><tbody><tr><td>加减</td><td>各个分量分别相加减</td></tr><tr><td>数乘</td><td>向量与标量的乘数，可以对向量的长度进行缩放，如果标量&gt;0，向量的方向不变，如果&lt;0,向量的方向为反方向</td></tr></tbody></table><h2 id="2-2-点乘（点积）"><a href="#2-2-点乘（点积）" class="headerlink" title="2.2 点乘（点积）"></a>2.2 点乘（点积）</h2><p>两个向量点乘得到一个标量 ，数值等于两个向量长度相乘后再乘以二者夹角的余弦值 。<br>如果两个向量a,b均 为单位 向量 ,那么a.b等于向量b在向量a方向上的投影的长度</p><p>点乘后得到的是一个值</p><ul><li><p>若结果 == 0，则 两向量 互垂直 </p></li><li><p>若结果 &lt; 0 ，则 两向量夹角大于90°</p></li><li><p>若结果 &gt;0 ，则两向量夹角小于 90°</p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E4%B9%98.png" srcset="/img/loading.gif" alt="点乘"></p></li></ul><blockquote><p>两个单位向量的点积得到两个向量的夹角的cos值，通过它可以知道两个向量的相似性。</p></blockquote><blockquote><p>利用点积可判断一个多边形是否面向摄像机还是背向摄像机。</p></blockquote><blockquote><p>如果点积越大，说明夹角越小，则物理离光照的轴线越近，光照越强。</p></blockquote><h2 id="2-3-叉乘"><a href="#2-3-叉乘" class="headerlink" title="2.3 叉乘"></a>2.3 叉乘</h2><p>两个向量的叉乘得到一个新的向量，新向量垂直于原来两个向量，并且长度等于原向量长度相乘后再乘以夹角的正弦值，类似左手坐标系Z。</p><p>在Unity3D里面。两个向量的点乘所得到的是两个向量的余弦值，也就是-1 到1之间，0表示垂直，-1表示相反，1表示相同方向。 </p><p>两个向量的叉乘所得到的是两个向量所组成的面的垂直向量，分两个方向。 </p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8F%89%E4%B9%98.png" srcset="/img/loading.gif" alt="叉乘"></p><blockquote><p>简单的说，点乘判断角度，叉乘判断方向。 </p><p>形象的说当一个敌人在你身后的时候，叉乘可以判断你是往左转还是往右转更好的转向敌人，点乘得到你当前的面朝向的方向和你到敌人的方向的所成的角度大小。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>跨专业知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
      <tag>跨专业知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vector3类</title>
    <link href="/2021/02/21/Vector3%E7%B1%BB/"/>
    <url>/2021/02/21/Vector3%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Vector3是结构体,Vector3类在Unity中一般用于表示3D向量和三维坐标点。</p><h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2. 属性"></a>2. 属性</h1><h2 id="2-1静态成员变量"><a href="#2-1静态成员变量" class="headerlink" title="2.1静态成员变量"></a>2.1静态成员变量</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>right</code>（右）</td><td>代表坐标轴（1,0,0）</td></tr><tr><td><code>left</code> （左）</td><td>代表坐标轴（-1,0,0）</td></tr><tr><td><code>up</code>（上）</td><td>代表坐标轴（0,1,0）</td></tr><tr><td><code>down</code>（下）</td><td>代表坐标轴（0,-1,0）</td></tr><tr><td><code>forward</code>  （前）</td><td>代表坐标轴（0,0,1）</td></tr><tr><td><code>back</code>（后）</td><td>代表坐标轴（0,0,-1）</td></tr><tr><td><code>zero</code>（零）</td><td>代表坐标轴（0,0,0）</td></tr><tr><td><code>one</code>（一）</td><td>代表坐标轴（1,1,1）</td></tr></tbody></table><h2 id="2-2-实例成员变量"><a href="#2-2-实例成员变量" class="headerlink" title="2.2 实例成员变量"></a>2.2 实例成员变量</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Magnitude</code></td><td>返回向量的长度，向量的长度是(x<em>x+y</em>y+z*z)的平方根（只读）</td></tr><tr><td><code>Normalized</code></td><td>返回一个归一化的新向量，原向量长度不变</td></tr><tr><td><code>sqrMagnitude</code></td><td>返回向量的长度的平方（只读）</td></tr></tbody></table><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><h2 id="3-1-静态方法"><a href="#3-1-静态方法" class="headerlink" title="3.1 静态方法"></a>3.1 静态方法</h2><table><thead><tr><th>方法名称</th><th>方法体</th><th>描述</th></tr></thead><tbody><tr><td><code>Angle</code></td><td><code>public static float Angle(Vector3 from, Vector3 to);</code></td><td>此方法用于返回向量from和to的夹角，单位为角度，返回值范围为[0,180]，且当from和to中至少有一个为Vector3.zero时，方法返回值为90</td></tr><tr><td><code>ClampMagnitude</code></td><td><code>public static Vector3 ClampMagnitude(Vector3 vector, float maxLength);</code></td><td>此方法用于返回向量vector的一个同方向向量，模长受maxLength限制</td></tr><tr><td><code>Cross</code></td><td><code>public static Vector3 Cross(Vector3 Ihs,Vecxtor3 rhs);</code></td><td>向量叉乘</td></tr><tr><td><code>Dot</code></td><td><code>public static float Dot(Vector3 Ihs, Vector3 rhs);</code></td><td>向量点乘</td></tr><tr><td><code>Lerp</code></td><td><code>public static Vector3 Lerp(Vector3 from, Vector3 to, float t);</code></td><td>参数from为差值起始点坐标，参数to为插值结束点坐标，参数t为插值系数</td></tr><tr><td><code>MoveTowards</code></td><td><code>public static Vector3 MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta);</code></td><td>此方法用于返回一个从参数current到参数target的差值向量</td></tr><tr><td><code>OrthoNormalize</code></td><td><code>public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent);</code></td><td>此方法用于对向量normal进行单位化处理，并对tangent进行正交化处理。即normal变成单位向量，tangent变成与该单位向量垂直的模长为1的向量，且这些向量处于同一平面</td></tr><tr><td><code>OrthoNormalize</code></td><td><code>public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent, ref Vector3 binormal);</code></td><td>此方法用于对向量normal进行单位化处理，并对向量tangent和binormal进行正交化处理，于上面两个参数的重载相同，binormal垂直于normal和tangent组成的平面</td></tr><tr><td><code>Project</code></td><td><code>public static Vector3 Project(Vector3 vector, Vector3 onNormal);</code></td><td>此方法用于返回向量vector在向量onNormal上的投影向量</td></tr><tr><td><code>Reflect</code></td><td><code>public static Vector3 Reflect(Vector3 inDirection, Vector3 inNormal);</code></td><td>参数inDirection为入射向量，inNormal为镜面向量。参数inNormal向量必须为单位向量，否则入射角和反射角不相等。当inNormal取反时，反射向量不受影响</td></tr><tr><td><code>RotateTowards</code></td><td><code>public static Vector3 RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)</code></td><td>参数current为起始点坐标，参数target为目标点坐标，参数maxRadiansDelta为角度旋转系数，参数maxMagnitudeDelta为模长系数</td></tr><tr><td><code>Scale</code></td><td><code>public static Vector3 Scale(Vector3 a, Vector3 b);</code></td><td>此方法返回向量a和b的乘积</td></tr><tr><td><code>Slerp</code></td><td><code>public static Vector3 Slerp(Vector3 from, Vector3 to, float t);</code></td><td>参数from为插值起始点坐标，参数to为插值结束点坐标，参数t为插值系数。此方法用于返回从参数from点到参数to点的球形差值向量。</td></tr><tr><td><code>SmoothDamp</code></td><td>见下</td><td>见下</td></tr></tbody></table><p> <code>SmoothDamp</code>方法：阻尼运动</p><ul><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime);</code></p></li><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed);</code></p></li><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed, float maxSpeed);</code></p></li><li><p>参数表</p></li></ul><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td><code>current</code></td><td>起点坐标</td></tr><tr><td><code>target</code></td><td>终点坐标</td></tr><tr><td><code>currentVelocity</code></td><td>当前帧移动向量</td></tr><tr><td><code>smoothTime</code></td><td>接近目标时的阻尼强度</td></tr><tr><td><code>maxSpeed</code></td><td>最大移动速度，默认值为无穷大</td></tr><tr><td><code>deltaTime</code></td><td>控制当前帧实际移动的距离，即为maxSpeed*deltaTime，默认值为Time.deltaTime。</td></tr></tbody></table><h2 id="3-2-实例方法"><a href="#3-2-实例方法" class="headerlink" title="3.2 实例方法"></a>3.2 实例方法</h2><p><code>Scale</code>方法：向量放缩</p><p><code>public void Scale(Vector3 scale);</code></p><p>此方法可以对Vector3实例按参考向量scale进行放缩，即分量依次相乘。</p><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h1><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code></td><td>向量相加</td></tr><tr><td><code>-</code></td><td>向量相减</td></tr><tr><td><code>*</code></td><td>向量乘以标量</td></tr><tr><td><code>/ </code></td><td>向量除以标量</td></tr><tr><td><code>==</code></td><td>若向量相等返回true</td></tr><tr><td><code>!=</code></td><td>若向量不等于则返回true</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vector2类</title>
    <link href="/2021/02/21/Vector2%E7%B1%BB/"/>
    <url>/2021/02/21/Vector2%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Vector2类在Unity中一般用于表示2D向量和二维坐标点。</p><p>例如<a href="https://docs.unity3d.com/530/Documentation/ScriptReference/Mesh.html">Mesh</a>（纹理坐标）或<a href="https://docs.unity3d.com/530/Documentation/ScriptReference/Material.html">Material</a>（纹理偏移）。</p><h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h1><h2 id="2-1-静态属性"><a href="#2-1-静态属性" class="headerlink" title="2.1 静态属性"></a>2.1 静态属性</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>down</code></td><td>Vector2（0，-1）的简写</td></tr><tr><td><code>left</code></td><td>Vector2（-1，0）的简写</td></tr><tr><td><code>one</code></td><td>Vector2（1，1）的简写</td></tr><tr><td><code>right</code></td><td>Vector2（1，0）的简写</td></tr><tr><td><code>up</code></td><td>Vector2（0，1）的简写</td></tr><tr><td><code>zero</code></td><td>Vector2（0，0）的简写</td></tr></tbody></table><h2 id="2-2-普通属性"><a href="#2-2-普通属性" class="headerlink" title="2.2 普通属性"></a>2.2 普通属性</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>magnitude</td><td>返回此向量的长度（只读）</td></tr><tr><td>normalized</td><td>返回此向量的归一化（只读）</td></tr><tr><td>sqrMagnitude</td><td>返回此向量的平方长度（只读）</td></tr><tr><td>this[int]</td><td>分别使用[0]或[1]访问x或y分量</td></tr><tr><td><code>x</code></td><td>向量的X分量</td></tr><tr><td><code>y</code></td><td>向量的Y分量</td></tr></tbody></table><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><h2 id="3-1-静态方法"><a href="#3-1-静态方法" class="headerlink" title="3.1 静态方法"></a>3.1 静态方法</h2><table><thead><tr><th>方法名称</th><th>描述</th><th>方法体</th></tr></thead><tbody><tr><td><code>Angle</code></td><td>返回两向量夹角，参数from为起始向量，to为结束向量。此方法用于返回两个Vector2实例的夹角，单位为角度，返回值的取值范围为[0,180]，并且当from和to中至少有一个向量为Vector2.zero的时候返回值为90</td><td><code>public static float Angle(Vector2 from, Vector2 to);</code></td></tr><tr><td><code>ClampMagnitude</code></td><td>此方法用于返回向量的长度，且最大不超过maxLength</td><td><code>public static Vector2 ClampMagnitude(Vector2 vector, float maxLength);</code></td></tr><tr><td><code>Distance</code></td><td>返回两个向量间的距离</td><td></td></tr><tr><td><code>Dot</code></td><td>返回两个向量的点积</td><td></td></tr><tr><td><code>Lerp</code></td><td>向量差值，参数from为插值的起始向量，参数to为插值的结束向量，参数t为插值系数</td><td><code>public static Vector2 Lerp(Vector from, Vector2 to, float t);</code></td></tr><tr><td><code>LerpUnclamped</code></td><td>返回向量在向量a和b之间线性插值t</td><td></td></tr><tr><td><code>Max</code></td><td>返回由两个向量的最大分量组成的向量</td><td></td></tr><tr><td><code>Min</code></td><td>返回由两个向量的最小分量构成的向量</td><td></td></tr><tr><td><code>MoveTowards</code></td><td>向量差值，参数current为移动起始点坐标，参数target为移动目标点，参数maxDistanceDelta为移动的参考系数。</td><td><code>public static Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta);</code></td></tr><tr><td><code>Reflect</code></td><td>返回从法线定义的向量上反射向量</td><td></td></tr><tr><td><code>Scale</code></td><td>向量放缩，此方法用于返回向量a按向量b进行放缩后的值，即向量a，b的乘积</td><td></td></tr><tr><td><code>SmoothDamp</code></td><td>无法理解</td><td></td></tr></tbody></table><blockquote><p><a href="https://blog.csdn.net/andyhebear/article/details/51818534">MoveTowards、Lerp、Slerp三个函数的解析</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/e5b06b7be721">差值函数Lerp和SmoothDamp的解析</a></p></blockquote><h2 id="3-2-公有方法"><a href="#3-2-公有方法" class="headerlink" title="3.2 公有方法"></a>3.2 公有方法</h2><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Normalize</code></td><td>单位化Vector2实例。此方法改变了原始向量，无返回值。实例属性normalized与此方法功能相同，但使用属性normalized来单位化向量时，不改变原始向量值，且有返回值。</td></tr><tr><td><code>Set</code></td><td>设置向量的x,y值</td></tr><tr><td><code>ToString</code></td><td>返回字符串</td></tr></tbody></table><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h1><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>-</code></td><td>向量相减</td></tr><tr><td><code>!=</code></td><td>向量不同，则返回true</td></tr><tr><td><code>*</code></td><td>向量乘以数字</td></tr><tr><td><code>/</code></td><td>向量除以数字</td></tr><tr><td><code>+</code></td><td>向量相加</td></tr><tr><td><code>=</code></td><td>向量相等，则返回true</td></tr><tr><td><code>Vector2</code></td><td>将Vector3转换为Vector2</td></tr><tr><td><code>Vector3</code></td><td>将Vector2转换为Vector3</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transform类</title>
    <link href="/2021/02/19/Transform%E7%B1%BB/"/>
    <url>/2021/02/19/Transform%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><strong>Transform</strong>组件是Unity3D的重点之一，主要用于控制物体的旋转、移动、缩放。</p><p><strong>Unity</strong>规定所有游戏物体都必须<strong>有且只有一个</strong>变换组件(<strong>Transform</strong>)且<strong>不能删除</strong>。</p><p>变换组件(<strong>Transform</strong>)实现了Unity的父子关系功能。</p><p>那么接下来我们将详细学习下<strong>Transform</strong>类所包含的成员变量和成员函数。</p><h1 id="2-父子关系"><a href="#2-父子关系" class="headerlink" title="2. 父子关系"></a>2. 父子关系</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>父子关系是Uniy中重要的基本概念之一。<br>当一个物体是另一个物体的父物体时，子物体会严格地随着父物体起移动、 旋转、缩放。<br>可以将父子关系理解为你的手臂与身体的关系，当身体移动时，手臂也定会跟着一 起移动， 且手臂还可以有自己下一级的子物体，比如手掌就是手名臂的子物体、手指是手掌的子物体等。</p><blockquote><p>在unity中带有local字样的属性也就意味着其数值是相对于父物体的。</p></blockquote><h2 id="2-2-底层原理与规则"><a href="#2-2-底层原理与规则" class="headerlink" title="2.2 底层原理与规则"></a>2.2 底层原理与规则</h2><p>规则：</p><ul><li>任何物体都可以有多个子物体，但是每个物体都只能有一个父物体。</li></ul><p>原理：</p><p>这种父子关系组成一个树状的层级结构，最基层的那个物体是唯一不具有父物体的物体，它被称为根节点。</p><p>由于物体的移动、旋转、缩放与父子关系密切相关，且游戏物体和变换组件是一一对应的。所以在Unity中，游戏物体的层级结构完全可以理解为变换组件的层级结构。父子关系的操作在脚本中确实是在变换组件上进行的。<br>子物体的变换组件的参数其实是相对父物体的值，再次考虑之前身体和手臂的例子，无论身体如何移动，手臂和身体的连接处是固定不变的。</p><h2 id="2-3-关于父子物体的一些现象"><a href="#2-3-关于父子物体的一些现象" class="headerlink" title="2.3 关于父子物体的一些现象"></a>2.3 关于父子物体的一些现象</h2><h3 id="2-3-1-position："><a href="#2-3-1-position：" class="headerlink" title="2.3.1 position："></a>2.3.1 position：</h3><ul><li><p>改变父物体的position，父物体连同子物体一起移动；</p></li><li><p>改变子物体的position，父物体不随子物体移动。</p></li><li><p>当子物体的position设置为（0，0，0）时，子物体与父物体中心点重合。</p></li></ul><h3 id="2-3-2-rotation："><a href="#2-3-2-rotation：" class="headerlink" title="2.3.2 rotation："></a>2.3.2 rotation：</h3><p>介绍两个位于unity快捷工具栏右侧的选项：<strong>Pivot</strong>与<strong>Local</strong></p><ul><li><p><strong>Poivt</strong></p><p>用于调节物体轴心点，有两个子选项</p><ul><li><p>Pivot    父物体的中心点</p></li><li><p>Center 当前父子物体的中心点</p></li></ul></li><li><p><strong>Local</strong><br>用于调节当前被选中物体的坐标轴，有两个子选项</p><ul><li><p>Local    自身坐标系</p></li><li><p>World  世界坐标系</p></li></ul></li></ul><h3 id="2-3-3-Scale"><a href="#2-3-3-Scale" class="headerlink" title="2.3.3 Scale:"></a>2.3.3 Scale:</h3><p><strong>子物体的真实缩放比例Scale=子物体Scale比例×父物体Scale比例</strong></p><p>可以通过下述代码在unity脚本中直接查看：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3 _truthScale = <span class="hljs-keyword">this</span>.transform.LossyScale;<span class="hljs-comment">//此属性为只读属性</span><br></code></pre></td></tr></table></figure><h2 id="2-4-坐标系的选择"><a href="#2-4-坐标系的选择" class="headerlink" title="2.4 坐标系的选择"></a>2.4 坐标系的选择</h2><p>局部坐标与世界坐标各有各的适用情况：</p><ul><li><p>在搭建场景时，我们更喜欢使用局部坐标系<br>比如移动一个房屋时，屋子里所有的东西都会跟着一起移动;</p></li><li><p>而在编写游戏逻辑时，更多的时候需要获得物体在空间中的实际位置。<br>比如我们要将摄像机对准人物的眼睛，这时候眼睛和人物的相对坐标就没有太大价值，而应当让摄像机对准眼睛在世界坐标系中的位置。</p></li></ul><p>所以，在脚本系统中，变换组件的大部分操作都提供了两类操作方式，分别是世界坐标系的和局部坐标系的，我们可以根据需求进行使用。</p><h2 id="2-5-关于父子物体使用的小技巧"><a href="#2-5-关于父子物体使用的小技巧" class="headerlink" title="2.5 关于父子物体使用的小技巧"></a>2.5 关于父子物体使用的小技巧</h2><p>在处理美工交过来的模型时，推荐将模型拉入一个空的gameobject，形成父子物体关系，组件只给空的gameobject上。</p><p>这样就可以防止日后更换模型时需要重新上组件的情况。</p><p>空物体通常用来管理和控制多个相互之间无关联的游戏物体。</p><h1 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3. 成员变量"></a>3. 成员变量</h1><table><thead><tr><th>position</th><th>在世界空间坐标transform的位置。</th></tr></thead><tbody><tr><td>localPosition</td><td>相对于父级的变换的位置。  如果该变换没有父级，那么等同于Transform.position。</td></tr><tr><td>eulerAngles</td><td>世界坐标系中的旋转（欧拉角）。</td></tr><tr><td>localEulerAngles</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>right</td><td>世界坐标系中的右方向。  （世界空间坐标变换的红色轴。也就是x轴。）</td></tr><tr><td>up</td><td>世界坐标系中的上方向。  （在世界空间坐标变换的绿色轴。也就是y轴。）</td></tr><tr><td>forward</td><td>世界坐标系中的前方向。  （在世界空间坐标变换的蓝色轴。也就是z轴。）</td></tr><tr><td>rotation</td><td>世界坐标系中的旋转（四元数）。</td></tr><tr><td>localRotation</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>localScale</td><td>相对于父级的缩放比例。</td></tr><tr><td>parent</td><td>父对象Transform组件。</td></tr><tr><td>worldToLocalMatrix</td><td>矩阵变换的点从世界坐标转为自身坐标（只读）。</td></tr><tr><td>localToWorldMatrix</td><td>矩阵变换的点从自身坐标转为世界坐标（只读）。</td></tr><tr><td>root</td><td>对象层级关系中的根对象的Transform组件。</td></tr><tr><td>childCount</td><td>子对象数量。</td></tr><tr><td>lossyScale</td><td>全局缩放比例（只读）。</td></tr></tbody></table><h1 id="4-成员函数"><a href="#4-成员函数" class="headerlink" title="4. 成员函数"></a>4. 成员函数</h1><h2 id="4-1-LookAt函数"><a href="#4-1-LookAt函数" class="headerlink" title="4.1 LookAt函数"></a>4.1 LookAt函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void LookAt(Transform target);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition, Vector3 worldUp = Vector3.up);</td></tr><tr><td>public void  LookAt(Transform target, Vector3 worldUp = Vector3.up);</td></tr></tbody></table><p>旋转物体，使物体的z轴指向<strong>target/worldPosition</strong>，对于<strong>worldUp</strong>的描述是，在完成上面的旋转之后，继续旋转自身，使得当前对象的正y轴朝向与worldUp所指向的朝向一致。</p><p>这里的朝向一致指的是新旋转后的y轴与<strong>worldUp</strong>在该对象初次旋转后的xy平面上的投影向量一致。之所以取投影是因为第一次旋转使物体的z轴指向<strong>target/worldPosition</strong>后，此时的<strong>worldUp</strong>向量可能不在xy平面上，要在z轴指向<strong>target/worldPosition</strong>前提下是y轴朝向与<strong>worldUp</strong>一致，只能取<strong>worldUp</strong>在xy平面上的投影。</p><blockquote><p>注意：使用<strong>worldPosition向量</strong>时要注意方向，一定是<strong>target-transform.position</strong>，顺序反了会使物体背向目标；若使用<strong>Transform</strong>作为参数，则不必注意。默认情况下，<strong>worldUp</strong>是<strong>Vector3.up</strong>（世界坐标系下的y轴）</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-2-Rotate函数"><a href="#4-2-Rotate函数" class="headerlink" title="4.2 Rotate函数"></a>4.2 Rotate函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 eulerAngles);</td></tr><tr><td>public void  Rotate(Vector3 eulerAngles, Space relativeTo = Space.Self);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo =  Space.Self);</td></tr></tbody></table><p>旋转一个欧拉角度，它按照zxy的顺序进行旋转，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 axis, float angle);</td></tr><tr><td>public void  Rotate(Vector3 axis, float angle,Space relativeTo = Space.Self);</td></tr></tbody></table><p>绕axis轴旋转angle角度，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><p><strong>transform.rotation</strong>和<strong>Rotate</strong>有个区别：</p><ul><li><p>Rotate()方法是： 旋转多少度。</p><p>在原有的基础上累加，即旋转了多少角度。  又旋转了多少角度，是在原有的基础上在旋转</p></li><li><p>rotation属性是：  旋转到某个角度，就是是在update中每帧都执行。 </p><p> 但每次旋转到的角度都是5，所以是旋转到5度。一直都是。 </p></li></ul><p>比如你只想让他旋转到多少, 用rotation; 假如想让他一直转,可以用Rotate</p><p>rotation直接改变了数值, 以达到旋转效果</p><p>Rotate应用一个的旋转角度每秒1度慢慢的旋转物体</p><p>当然:rotation()还可以通过插值旋转</p><h2 id="4-3-RotateAround函数"><a href="#4-3-RotateAround函数" class="headerlink" title="4.3 RotateAround函数"></a>4.3 RotateAround函数</h2><p>让物体以某一点为轴心成圆周运动。</p><p><code>public void RotateAround (point : Vector3, axis : Vector3, angle : float) : void</code></p><p>让物体以<strong>point</strong>为中心，绕<strong>axis</strong>为轴向旋转<strong>angle</strong>度。保持原来与<strong>point</strong>的距离。</p><h2 id="4-4-TransformDirection函数"><a href="#4-4-TransformDirection函数" class="headerlink" title="4.4 TransformDirection函数"></a>4.4 TransformDirection函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public Vector3  TransformDirection(Vector3 direction);</td></tr><tr><td>public Vector3  TransformDirection(float x, float y, float z);</td></tr></tbody></table><p>从自身坐标到世界坐标变换方向（这个强调的是方向）这个操作不会受到变换的缩放和位置的影响。</p><p>返回的向量与<strong>direction</strong>有同样的长度。</p><h2 id="4-5-InverseTransformDirection函数"><a href="#4-5-InverseTransformDirection函数" class="headerlink" title="4.5 InverseTransformDirection函数"></a>4.5 InverseTransformDirection函数</h2><table><thead><tr><th>重载的多种函数</th></tr></thead><tbody><tr><td>public Vector3  InverseTransformDirectionTransformDirection (direction : Vector3)  : Vector3</td></tr><tr><td>public Vector3  InverseTransformDirectionTransformDirection (x : float, y : float,  z : float) : Vector3</td></tr></tbody></table><p>与<strong>TransformDirection</strong>相反，从世界坐标转换到自身相对坐标。</p><h2 id="4-6-TransformPoint函数"><a href="#4-6-TransformPoint函数" class="headerlink" title="4.6 TransformPoint函数"></a>4.6 TransformPoint函数</h2><table><thead><tr><th>public Vector3  TransformPoint(Vector3 position);</th></tr></thead><tbody><tr><td>public Vector3  TransformPoint(float x, float y, float z);</td></tr></tbody></table><p>变换位置从自身坐标到世界坐标。</p><p>注意，返回位置受缩放影响</p><h2 id="4-7-InverseTransformPoint函数"><a href="#4-7-InverseTransformPoint函数" class="headerlink" title="4.7 InverseTransformPoint函数"></a>4.7 InverseTransformPoint函数</h2><table><thead><tr><th>public  Vector3 InverseTransformPoint (position : Vector3)  : Vector3</th></tr></thead><tbody><tr><td>public  Vector3 InverseTransformPoint (x : float, y : float, z  : float) : Vector3</td></tr></tbody></table><p>把一个点从时间坐标转换到自身坐标的位置。</p><h2 id="4-8-TransformVector函数"><a href="#4-8-TransformVector函数" class="headerlink" title="4.8 TransformVector函数"></a>4.8 TransformVector函数</h2><table><thead><tr><th>public Vector3  TransformVector(Vector3 vector);</th></tr></thead><tbody><tr><td>public Vector3  TransformVector(float x, float y, float z);</td></tr></tbody></table><p>变换一个向量从局部坐标空间到世界坐标空间。</p><p>这个操作不受变换位置的影响，但是受缩放的影响</p><h2 id="4-9-Translate函数"><a href="#4-9-Translate函数" class="headerlink" title="4.9 Translate函数"></a>4.9 Translate函数</h2><table><thead><tr><th>public void  Translate(Vector3 translation);</th></tr></thead><tbody><tr><td>public void  Translate(Vector3 translation, Space relativeTo = Space.Self);</td></tr></tbody></table><p>沿着<strong>translation</strong>方向移动<strong>translation</strong>向量长度的距离。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(float x, float y, float z);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Space relativeTo = Space.Self);</td></tr></tbody></table><p>移动变换由x沿着x轴，y沿着y轴，z沿着z轴。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(Vector3 translation, Transform relativeTo);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Transform relativeTo);</td></tr></tbody></table><p>第一个参数的解释跟前面的一样，重点在移动<strong>relativeTo</strong>，解释为被应用相对于（relativeTo :Transform）的自身坐标系统。</p><p>日光相对于为<strong>null</strong>，则移动被应用相对于世界坐标系统</p><p>例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//相对于摄像机每秒1单位向右移动物体</span><br><br>transform.Translate(Vector3.right * Time.deltaTime, Camera.main.transform);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-10-DetachChildren函数"><a href="#4-10-DetachChildren函数" class="headerlink" title="4.10 DetachChildren函数"></a>4.10 DetachChildren函数</h2><p><code>public void DetachChildren () : void</code></p><p>把自身所有的子物体的父物体都设成世界，也就是跟自己的所有子物体接触父子关系。</p><h2 id="4-11-Find-函数"><a href="#4-11-Find-函数" class="headerlink" title="4.11 Find 函数"></a>4.11 <strong>Find</strong> <strong>函数</strong></h2><p><code>public Transform Find (name : string) : Transform</code></p><p>找到一个名字是name的物体并返回</p><p>如果没有找到则返回null。如果字符串被/隔离，函数则会像文件路径一样逐级下查。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// The magical rotating finger</span><br><br><span class="hljs-function">function <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>aFinger = transform.Find(<span class="hljs-string">&quot;LeftShoulder/Arm/Hand/Finger&quot;</span>);<br><br>aFinger.Rotate(Time.deltaTime*<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-12-IsChildOf函数"><a href="#4-12-IsChildOf函数" class="headerlink" title="4.12 IsChildOf函数"></a>4.12 IsChildOf函数</h2><p><code>public bool IsChildOf (parent : Transform) : bool</code></p><p>如果物体是<strong>parent</strong>的父子层级关系下的一员，返回<strong>true</strong>;</p><h1 id="5-组件使用注意事项"><a href="#5-组件使用注意事项" class="headerlink" title="5. 组件使用注意事项"></a>5. 组件使用注意事项</h1><h2 id="5-1-非等比缩放的问题"><a href="#5-1-非等比缩放的问题" class="headerlink" title="5.1 非等比缩放的问题"></a>5.1 非等比缩放的问题</h2><p>某些组件不完全支持非等比缩放，在非等比缩放的情况下可能会出现意想不到的结果。<br>因为当该游戏物体具有一个球体或者胶囊体的外壳，而这些外壳的大小是通过一个半径参数指定的。<br>在物体或者父物体被拉伸或压扁的时候，这些组件的球体范围并不会跟着压扁成椭球体，它们实际上仍然是球体或胶囊体。<br>所以当物体中具有这类组件时，由于组件形状和物体形状不一致，可能会导致穿透模型被意外阻挡等情况发生。</p><p>例如，碰撞体、角色控制器这些组件和灯光、音源。</p><p>这些问题不致命，但是会引起奇怪的bug。</p><h2 id="5-2-其它注意事项"><a href="#5-2-其它注意事项" class="headerlink" title="5.2 其它注意事项"></a>5.2 其它注意事项</h2><ul><li>当为一个物体添加子物体时， 可以考虑先将父物体的位置设置为原点，这样子物体的局部坐标系就和世界坐标系重合，方便我们指定子物体的准确位置。</li><li>粒子系统不会受变换组件的缩放系数的影响。要改变- -个粒子的整体比例，还是需要在粒子系统中适当改变相关参数。</li><li>修改物体缩放比例时不仅会直接影响子物体的比例，还会影响子物体的实际位置(因为要保证相对位置不变)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MonoBehaviour基类</title>
    <link href="/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/"/>
    <url>/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-脚本基类-MonoBehaviour"><a href="#Unity-脚本基类-MonoBehaviour" class="headerlink" title="Unity 脚本基类 MonoBehaviour"></a>Unity 脚本基类 MonoBehaviour</h1><h2 id="1-MonoBehaviour-简介"><a href="#1-MonoBehaviour-简介" class="headerlink" title="1. MonoBehaviour 简介"></a>1. MonoBehaviour 简介</h2><p><strong>MonoBehaviour</strong> 是 <strong>Unity</strong> 中所有脚本的基类。</p><p>如果你使用<strong>JS</strong>的话，脚本会自动继承<strong>MonoBehaviour</strong>。</p><p>如果使用<strong>C#**的话，你需要显式继承</strong>MonoBehaviour**。</p><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><p>下面用一张图来更形象地说明一下这几个类的在<strong>MonoBehaviour</strong>的<em>生命周期</em>中是如何被调用的：<br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125028717" srcset="/img/loading.gif" alt="这里写图片描述"></p><h2 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h2><h3 id="3-1-不可重写函数："><a href="#3-1-不可重写函数：" class="headerlink" title="3.1 不可重写函数："></a>3.1 不可重写函数：</h3><h4 id="3-1-1-Invoke函数"><a href="#3-1-1-Invoke函数" class="headerlink" title="3.1.1 Invoke函数"></a>3.1.1 Invoke函数</h4><p><code>function Invoke (methodName : string, time : float) : void</code><br>在 <strong>time</strong> 秒之后，调用 <strong>methodName</strong> 方法；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">example</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><span class="hljs-keyword">public</span> Rigidbody projectile;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchProjectile</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Rigidbody instance = Instantiate(projectile);<br>    instance.velocity = Random.insideUnitSphere * <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Invoke(<span class="hljs-string">&quot;LaunchProjectile&quot;</span>, <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-InvokeRepeating"><a href="#3-1-2-InvokeRepeating" class="headerlink" title="3.1.2 InvokeRepeating"></a>3.1.2 InvokeRepeating</h4><p><code>function InvokeRepeating (methodName : string, time : float, repeatRate : float) : void</code><br>从第一次调用开始,每隔<strong>repeatRate</strong>时间调用一次.</p><h4 id="3-1-3-CancelInvoke"><a href="#3-1-3-CancelInvoke" class="headerlink" title="3.1.3 CancelInvoke"></a>3.1.3 CancelInvoke</h4><p><code>function CancelInvoke () : void</code><br>取消这个<strong>MonoBehaviour</strong>上的所有调用<strong>Invoke</strong>。</p><h4 id="3-1-4-IsInvoking"><a href="#3-1-4-IsInvoking" class="headerlink" title="3.1.4 IsInvoking"></a>3.1.4 IsInvoking</h4><p><code>function IsInvoking (methodName : string) : bool</code><br>某指定函数是否在等候调用。</p><h4 id="3-1-5-StartCoroutine"><a href="#3-1-5-StartCoroutine" class="headerlink" title="3.1.5 StartCoroutine"></a>3.1.5 StartCoroutine</h4><p><code>function StartCoroutine (routine : IEnumerator) : Coroutine</code><br>一个协同程序在执行过程中,可以在任意位置使用 <strong>yield</strong> 语句。</p><p><strong>yield</strong> 的返回值控制何时恢复协同程序向下执行。</p><p>协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。</p><p><strong>StartCoroutine</strong>函数是立刻返回的,但是<strong>yield</strong>可以延迟结果。直到协同程序执行完毕。</p><h4 id="3-1-6-StopCoroutine-StopAllCoroutines"><a href="#3-1-6-StopCoroutine-StopAllCoroutines" class="headerlink" title="3.1.6 StopCoroutine / StopAllCoroutines"></a>3.1.6 StopCoroutine / StopAllCoroutines</h4><h3 id="3-2-可重写函数："><a href="#3-2-可重写函数：" class="headerlink" title="3.2 可重写函数："></a>3.2 可重写函数：</h3><p>可重写函数会在游戏中发生某些事件的时候被调用。</p><p>我们在<strong>Unity</strong>中最常用到的几个可重写函数是这几个：</p><table><thead><tr><th align="left">可重写函数</th><th>描述</th></tr></thead><tbody><tr><td align="left"><code>Awake</code></td><td>当一个脚本被实例化时，<strong>Awake</strong> 被调用。我们大多在这个类中完成成员变量的初始化。</td></tr><tr><td align="left"><code>Start</code></td><td>仅在 <strong>Update</strong> 函数第一次被调用前调用。因为它是在<strong>Awake</strong> 之后被调用的，我们可以把一些需要依赖 <strong>Awake</strong> 的变量放在<strong>Start</strong>里面初始化。 同时我们还大多在这个类中执行 <strong>StartCoroutine</strong> 进行一些协程的触发。要注意在用C#写脚本时，必须使用 <strong>StartCoroutine</strong> 开始一个协程，但是如果使用的是 <strong>JavaScript</strong>，则不需要这么做。</td></tr><tr><td align="left"><code>Update</code></td><td>当开始播放游戏帧时（此时，<strong>GameObject</strong> 已实例化完毕），其 **Update **在 每一帧 被调用。</td></tr><tr><td align="left"><code>LateUpdate</code></td><td><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。</td></tr><tr><td align="left"><code>FixedUpdate</code></td><td>当 <strong>MonoBehaviour</strong>启用时，其 <strong>FixedUpdate</strong> 在每一固定帧被调用</td></tr><tr><td align="left"><code>OnEnable</code></td><td>当对象变为可用或激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDisable</code></td><td>当对象变为不可用或非激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDestroy</code></td><td>当 <strong>MonoBehaviour</strong> 将被销毁时，这个函数被调用</td></tr></tbody></table><h4 id="3-2-1-Update"><a href="#3-2-1-Update" class="headerlink" title="3.2.1 Update"></a>3.2.1 Update</h4><p>当 <strong>MonoBehaviour</strong> 实例化完成之后，<strong>Update</strong> 在每一帧被调用。</p><p>所以Update函数可以用来实现用户输入、角色移动和角色行动等功能。</p><p>基本上大部分游戏逻辑都离不开Update函数。</p><p>Unity 提供了非常多的基本方法来读取输入、查找某个游戏物体、查找组件、修改组件信息等，这些方法都可以在Update函数中使用，用来完成实际的游戏功能。</p><h4 id="3-2-2-LateUpdate"><a href="#3-2-2-LateUpdate" class="headerlink" title="3.2.2 LateUpdate"></a>3.2.2 LateUpdate</h4><p><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。这可用于调整脚本执行顺序。</p><p>例如:当物体在Update里移动时，跟随物体的相机可以在<strong>LateUpdate</strong>里实现。</p><h4 id="3-2-3-FixedUpdate"><a href="#3-2-3-FixedUpdate" class="headerlink" title="3.2.3 FixedUpdate"></a>3.2.3 FixedUpdate</h4><p>处理 <strong>Rigidbody</strong> 时，需要用<strong>FixedUpdate</strong>代替<strong>Update</strong>。</p><p>例如:给刚体加一个作用力时，你必须应用作用力在<strong>FixedUpdate</strong>里的固定帧，而不是<strong>Update</strong>中的帧。(两者帧长不同)</p><h4 id="3-2-4-Awake"><a href="#3-2-4-Awake" class="headerlink" title="3.2.4 Awake"></a>3.2.4 Awake</h4><p><strong>Awake</strong> 用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次。<strong>Awake</strong> 在所有对象被初始化之后调用，所以你可以安全的与其他对象对话或用诸如 <strong>GameObject.FindWithTag</strong> 这样的函数搜索它们。</p><p>每个游戏物体上的<strong>Awke</strong>以随机的顺序被调用。因此，你应该用<strong>Awake</strong>来设置脚本间的引用，并用<strong>Start</strong>来传递信息<strong>Awake</strong>总是在<strong>Start</strong>之前被调用。它不能用来执行协同程序。</p><p>C#和Boo用户注意：<strong>Awake</strong> 不同于构造函数，物体被构造时并没有定义组件的序列化状态。<strong>Awake</strong>像构造函数一样只被调用一次。</p><h4 id="3-2-5-Start"><a href="#3-2-5-Start" class="headerlink" title="3.2.5 Start"></a>3.2.5 Start</h4><p><strong>Start</strong>在<strong>behaviour</strong>的生命周期中只被调用一次。<br>它和 <strong>Awake</strong> 的不同是，<strong>Start</strong> 只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。<strong>Awake</strong> 总是在<strong>Start</strong>之前执行。</p><p>Start函数适合用来做一些初始化工作。<br>对有经验的程序编写者来说，要注意脚本组件通常不使用构造函数来做初始化，因为构造函数可控制性较差，会导致调用时机和预想的不一致。 所以最好的方式是遵循Unity的设计惯例。</p><h4 id="3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag"><a href="#3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag" class="headerlink" title="3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag"></a>3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag</h4><p>当鼠标进入 ／ 悬浮 ／ 移出 ／ 点击 ／ 释放 ／ 拖拽<strong>GUIElement</strong>(GUI元素)或<strong>Collider</strong>(碰撞体)中时调用<strong>OnMouseEnter</strong>。</p><h4 id="3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay"><a href="#3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay" class="headerlink" title="3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay"></a>3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay</h4><p>当<strong>Collider</strong>(碰撞体)进入 ／ 退出 ／ 停留在 <strong>trigger</strong>(触发器)时调用<strong>OnTriggerEnter</strong>。</p><p><strong>OnTriggerStay</strong> 将会在每一帧被调用。</p><h4 id="3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay"><a href="#3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay" class="headerlink" title="3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay"></a>3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay</h4><p>当此<strong>collider/rigidbody</strong>触发另一个<strong>rigidbody/collider</strong>时，被调用。</p><p><strong>OnCollisionStay</strong> 将会在每一帧被调用。</p><h2 id="4-脚本与GameObject的关系"><a href="#4-脚本与GameObject的关系" class="headerlink" title="4. 脚本与GameObject的关系"></a>4. 脚本与GameObject的关系</h2><p>被显式添加到 <strong>Hierarchy</strong> 中的 <strong>GameObject</strong> 会被最先实例化，<strong>GameObject</strong> 被实例化的顺序是从下往上。<strong>GameObject</strong> 被实例化的同时，加载其组件 <strong>component</strong> 并实例化，如果挂载了脚本组件，则实例化脚本组件时，将调用脚本的 <strong>Awake</strong> 方法，组件的实例化顺序是也是从下往上。在所有显式的 <strong>GameObject</strong> 及其组件被实例化完成之前，游戏不会开始播放帧。</p><p>当 <strong>GameObject</strong> 实例化工作完成之后，将开始播放游戏帧。每个脚本的第一帧都是调用 <strong>Start</strong> 方法，其后每一帧调用 <strong>Update</strong>，而且每个脚本在每一帧中的调用顺序是从下往上。</p><blockquote><p>总结：被挂载到 <strong>GameObject</strong> 下面的脚本会被实例化成 <strong>GameObject</strong> 的一个成员。</p></blockquote><h3 id="4-1-脚本变量的引用"><a href="#4-1-脚本变量的引用" class="headerlink" title="4.1 脚本变量的引用"></a>4.1 脚本变量的引用</h3><p>在脚本中声明另一个脚本的变量。在 <strong>ClassA</strong> 中建立一个 <strong>public</strong> 的变量类型是 <strong>ClassB</strong>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-非同一个-GameObject-的脚本引用"><a href="#4-1-1-非同一个-GameObject-的脚本引用" class="headerlink" title="4.1.1 非同一个 GameObject 的脚本引用"></a>4.1.1 非同一个 GameObject 的脚本引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125148891" srcset="/img/loading.gif" alt="这里写图片描述"><br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125157563" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，如果 <strong>classA</strong> 中的成员 <strong>B</strong> 想要引用由 <strong>GameObjectB</strong> new 出来的 <strong>classB</strong> 对象，只需要将 <strong>GameObjectB</strong> 拖拽到 <strong>GameObjectA</strong> 中 <strong>classA</strong> 脚本即可。</p><h4 id="4-1-2-同一个-GameObject-中互相引用"><a href="#4-1-2-同一个-GameObject-中互相引用" class="headerlink" title="4.1.2 同一个 GameObject 中互相引用"></a>4.1.2 同一个 GameObject 中互相引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125328273" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，发现没法通过拖拽的方式建立 <strong>classA</strong> 和 <strong>classB</strong> 的引用。因为 <strong>Unity</strong> 编辑器里面的拖拽绑定方式是 <strong>GameObject</strong> 级别的。</p><p>那么此时如何解决互相引用的问题呢？此时，需要用到 <strong>gameObject</strong> 这个变量。</p><p>被挂载到 <strong>GameObject</strong> 中的脚本，被实例化时，其内部继承自 <strong>Monobehavior</strong> 的 <strong>gameObject</strong> 成员会绑定所挂载的 <strong>GameObject</strong> 对象。可以注意到，在本例中，<strong>classA</strong> 和 <strong>classB</strong> 都是同一个 <strong>GameObject</strong> 下的组件，所以通过 <strong>GetComponent</strong> 便可以获得另一个脚本变量的引用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>        b = gameObject.GetComponent (<span class="hljs-string">&quot;ClassB&quot;</span>) <span class="hljs-keyword">as</span> ClassB;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>       a = gameObject.GetComponent (<span class="hljs-string">&quot;ClassA&quot;</span>) <span class="hljs-keyword">as</span> ClassA;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-父子关系的-GameObject-中引用"><a href="#4-1-3-父子关系的-GameObject-中引用" class="headerlink" title="4.1.3 父子关系的 GameObject 中引用"></a>4.1.3 父子关系的 GameObject 中引用</h4><p>把问题引申一步,还是那两个脚本<strong>ClassA</strong>,<strong>ClassB</strong>,不过这回不是绑在同一个<strong>GameObject</strong>上面，而是分辨绑定在两个<strong>GameObject</strong>：Parent(ClassA),Child(ClassB)</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125418710" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>首先还是来尝试拖拽，虽然无法在Unity的编辑器中通过拖拽互相引用脚本(Componet),不过绑定 <strong>GameObject</strong> 是可以的。所以只需要建立两个<strong>public</strong>的变量，然后类型都是 <strong>GameObject</strong>，在Unity里面互相拖拽引用,最后在 <strong>Start</strong> 函数时候通过已经绑定好的 <strong>gameObject</strong> 调用其 <strong>GetComponent</strong> 方法即可。</p><p>的确，这个方法是可行，不过有个更好的方法就是使用 <strong>Transform</strong>。<strong>Transform</strong> 是一个很特殊的<strong>Component</strong>，其内部保留着 <strong>GameObject</strong>之间的显示树结构.所以就上面的例子来说，当要从 <strong>Child</strong> 访问到 <strong>Parent</strong>，只需要在 <strong>Child</strong> 对应的脚本里面写 <code>transform.parent.gameObject.GetComponent() </code>即可</p><p>返过来就相对麻烦一点,因为无法保证一个<strong>parent</strong>只有一个<strong>child</strong>，所以无法简单的使用 <strong>transform.child.gameObject</strong>这样访问, 但是Unity给我们提供了一个很方便的函数，那就是<strong>Find</strong>。</p><p>需要注意的是<strong>Find</strong>只能查找其<strong>Child</strong>,举个复杂点的例子</p><p><strong>Parent-&gt;ChildA-&gt;ChildB-&gt;ChildC</strong></p><p>当在 <strong>Patent</strong> 中想要找到 <strong>ChildC</strong>中的一个<strong>Component</strong>时候，调用 <code>transform.Find(“ChildA/ChildB/ChildC”).gameObject;</code></p><h2 id="5-普通类与继承MonoBehaviour类的区别："><a href="#5-普通类与继承MonoBehaviour类的区别：" class="headerlink" title="5. 普通类与继承MonoBehaviour类的区别："></a>5. 普通类与继承MonoBehaviour类的区别：</h2><ul><li><p>1.继承<strong>MonoBehaviour</strong>的类不需要创建它的实例，也不能自己创建(用new)，因为从<strong>MonoBehaviour</strong>继承过来的类Unity会自动创建实例，并且调用被重载的函数(Awake，Start…..)。</p><p>如果用new会出现警告，警告说的很明显，就是如果继承了MonoBehaviour就不允许你用new创建，你可以用添加组件的方式替代，或者根本没有基类(不继承MonoBehaviour的普通类)，但是好像并不影响程序，这点很奇怪。</p></li><li><p>2.不继承MonoBehaviour不能使用Invoke，Coroutine，print以及生命周期函数等。</p></li><li><p>3.不继承MonoBehaviour不能挂在到Inspector上，也就是说不能当组件使用也不能看到一些数据。</p></li></ul><h2 id="6-MonoBehaviour-的那些坑"><a href="#6-MonoBehaviour-的那些坑" class="headerlink" title="6. MonoBehaviour 的那些坑"></a>6. MonoBehaviour 的那些坑</h2><ul><li><strong>私有（private）</strong>和<strong>保护（protected）</strong>变量只能在<strong>专家模式</strong>中显示。属性不被序列化或显示在检视面板。</li><li>不要使用<strong>命名空间（namespace）</strong></li><li>记得使用 缓存组件查找， 即在<strong>MonoBehaviour</strong>的长远方法中经常被访问的组件最好在把它当作一个私有成员变量存储起来。</li><li>在游戏里经常出现需要检测敌人和我方距离的问题，这时如果要寻找所有的敌人，显然要消耗的运算量太大了，所以最好的办法是将攻击范围使用<strong>Collider</strong>表示，然后将<strong>Collider</strong>的<strong>isTrigger</strong>设置为<strong>True</strong>。最后使用<strong>OnTriggerEnter</strong>来做攻击范围内的距离检测，这样会极大提升程序性能。</li></ul><blockquote><p>整理自: <a href="https://blog.csdn.net/hihozoo/article/details/66970467">https://blog.csdn.net/hihozoo/article/details/66970467</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客中添加音乐播放器</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是介绍基于网易云iframe插件在hexo博客中加装音乐播放器的方法，无需安装任何额外插件。</p><h1 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2.安装步骤"></a>2.安装步骤</h1><ol><li><p>在网易云音乐中打开你想要插入的音乐页面，点击 <strong>生成外联播放器</strong>。</p></li><li><p>在网页中调整好播放器插件后，复制下方的HTML代码。</p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">330</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=1488285208&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>打开本地架设hexo博客的文件夹，寻找正在使用主题文件夹下的layout文件夹。</p><p>例如我在使用的fluid主题的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">F:\MyBlog\node_modules\hexo-theme-fluid\layout<br></code></pre></td></tr></table></figure></li><li><p>在layout文件夹下寻找你想要添加音乐播放器位置的ejs文件。</p><p>例如我想放在所有页面的页脚，则ejs文件的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\layout\_partial\footer.ejs<br></code></pre></td></tr></table></figure></li><li><p>打开ejs文件(可以用vscode或者记事本)，找到生成相关位置html文件的代码。</p><p>这些ejs文件相当于是生成html文件的模板。</p></li><li><p>将复制来的HTML代码加上div加进相关的位置</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center mt-5 py-3&quot;</span>&gt;</span>//原本的页脚生成代码<br>--------------------------------------------------------<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;music-player&quot;</span>&gt;</span>//复制来的外链播放器插件代码<br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">530</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=572328440&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;&gt;</span><br>---------------------------------------------------------<br>  //原本的页脚生成代码<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer-content&quot;</span>&gt;</span><br>  &lt;%- theme.footer.content %&gt;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> &lt;%- partial(&#x27;_partial/statistics.ejs&#x27;) %&gt;<br> &lt;%- partial(&#x27;_partial/beian.ejs&#x27;) %&gt;<br> &lt;% if(theme.web_analytics.cnzz) &#123; %&gt;<br>  *<span class="hljs-comment">&lt;!-- cnzz Analytics Icon --&gt;</span>*<br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cnzz_stat_icon_&lt;%- theme.web_analytics.cnzz %&gt;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> &lt;% &#125; %&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>清理服务器缓存后再重新部署，音乐播放器就出现在对应位置了！</p></li></ol><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h1><blockquote><p>音乐不能是网易云里的VIP音乐，它是不会给你播的</p></blockquote><blockquote><p>当页面转换或者刷新时，播放器状态将被重置，目前还没有办法解决</p></blockquote><h1 id="4-其它的实现方法"><a href="#4-其它的实现方法" class="headerlink" title="4.其它的实现方法"></a>4.其它的实现方法</h1><p>在hexo框架的基础下，还可以用音乐播放插件<strong>Aplayer</strong>来实现。</p><p>相关链接：<a href="https://aplayer.js.org/#/zh-Hans/"><strong>Aplayer</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown快速入门</title>
    <link href="/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>.md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言。</p><p>本博客中的所有文章都是用.md文件编写的，而且很多企业也在在鼓励使用这种编辑方式。</p><h1 id="1-基本符号：-gt"><a href="#1-基本符号：-gt" class="headerlink" title="1.基本符号：* - +. &gt;"></a>1.基本符号：* - +. &gt;</h1><p>基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。</p><h1 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h1><p>分别表示h1-h6,只到h6，而且h1下面会有一条横线。</p><p>有两种方法，一种是只在前面加#，另一种是闭合式标签，两者效果相同。</p><p>例如：</p><p>方法一：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 </span><br><span class="hljs-section">## 二级标题 </span><br><span class="hljs-section">### 三级标题 </span><br><span class="hljs-section">#### 四级标题 </span><br><span class="hljs-section">##### 五级标题 </span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 # </span><br><span class="hljs-section">## 二级标题 ## </span><br><span class="hljs-section">### 三级标题 ### </span><br><span class="hljs-section">#### 四级标题 #### </span><br><span class="hljs-section">##### 五级标题 ##### </span><br><span class="hljs-section">###### 六级标题 #####</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h1><h2 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//形式一 <br><span class="hljs-bullet">+</span> a <br><span class="hljs-bullet">+</span> b <br><span class="hljs-bullet">+</span> c <br>//形式二<br><span class="hljs-bullet">-</span> d <br><span class="hljs-bullet">-</span> e <br><span class="hljs-bullet">-</span> f <br>//形式三 <br><span class="hljs-bullet">*</span> g <br><span class="hljs-bullet">*</span> h <br><span class="hljs-bullet">*</span> i<br></code></pre></td></tr></table></figure><p>以上三种形式，效果其实都是一样的：</p><ul><li>a </li><li>b </li><li>c </li></ul><ul><li>d </li><li>e </li><li>f </li></ul><ul><li>g </li><li>h </li><li>i</li></ul><h2 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//正常形式<br><span class="hljs-bullet">1.</span> abc<br><span class="hljs-bullet">2.</span> bcd<br><span class="hljs-bullet">3.</span> cde<br>//错序效果<br><span class="hljs-bullet">2.</span> fgh<br><span class="hljs-bullet">3.</span> ghi<br><span class="hljs-bullet">5.</span> hij<br></code></pre></td></tr></table></figure><p>效果如下：</p><ol><li><p>abc</p></li><li><p>bcd</p></li><li><p>cde</p></li><li><p>fgh</p></li><li><p>ghi</p></li><li><p>hij</p></li></ol><blockquote><p>注意，数字后面的点只能是英文的点，有序列表的序号是根据第一行列表的数字顺序来的，错序列表的序号本来是序号是乱的， 但是还是显示 4 5 6</p></blockquote><h1 id="4-引用说明区块"><a href="#4-引用说明区块" class="headerlink" title="4.引用说明区块"></a>4.引用说明区块</h1><p>对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。</p><h2 id="4-1-正常形式"><a href="#4-1-正常形式" class="headerlink" title="4.1 正常形式"></a>4.1 正常形式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 引用内容、说明内容。</span><br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>引用内容、说明内容。<br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</p></blockquote><h2 id="4-2-嵌套区块"><a href="#4-2-嵌套区块" class="headerlink" title="4.2 嵌套区块"></a>4.2 嵌套区块</h2><p>这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 一级引用 </span><br>&gt;&gt; 二级引用 <br>&gt;&gt;&gt; 三级引用 <br>&gt;&gt;&gt;&gt; 四级引用 <br>&gt;&gt;&gt;&gt;&gt; 五级引用 <br>&gt;&gt;&gt;&gt;&gt;&gt; 六级引用<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>一级引用 </p><blockquote><p>二级引用 </p><blockquote><p>三级引用 </p><blockquote><p>四级引用 </p><blockquote><p>五级引用 </p><blockquote><p>六级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5. 代码块"></a>5. 代码块</h1><p>在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。</p><h2 id="5-1-少量代码，单行使用，直接用-包裹起来就行了"><a href="#5-1-少量代码，单行使用，直接用-包裹起来就行了" class="headerlink" title="5.1 少量代码，单行使用，直接用`包裹起来就行了"></a>5.1 少量代码，单行使用，直接用`包裹起来就行了</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`shaoliangdaima,danhangshiyong`</span> <br></code></pre></td></tr></table></figure><p>效果如下：</p><p><code>shaoliangdaima,danhangshiyong</code></p><h2 id="5-2大量代码，需要多行使用，用-包裹起来"><a href="#5-2大量代码，需要多行使用，用-包裹起来" class="headerlink" title="5.2大量代码，需要多行使用，用```包裹起来"></a>5.2大量代码，需要多行使用，用```包裹起来</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">​<span class="hljs-code">```</span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong    </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong   </span><br><span class="hljs-code">​```</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong    <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong   <br></code></pre></td></tr></table></figure><h1 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h1><h2 id="6-1行内式"><a href="#6-1行内式" class="headerlink" title="6.1行内式"></a>6.1行内式</h2><p>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">烤麸的博客</span>](<span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot;</span>), 是烤麸自己学习用的博客<br></code></pre></td></tr></table></figure><h2 id="6-2参数式"><a href="#6-2参数式" class="headerlink" title="6.2参数式"></a>6.2参数式</h2><p>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot; </span><br>[烤麸的博客]是烤麸自己学习用的博客。 <br>//参数定义的其他写法 <br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ &#x27;烤麸的博客&#x27; </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ (烤麸的博客) </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">&lt;https://mycroftcooper.github.io/&gt; &quot;烤麸的博客&quot;</span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果都是一样的，如下：</p><p><a href="https://mycroftcooper.github.io/%22%E7%83%A4%E9%BA%B8%E7%9A%84%E5%8D%9A%E5%AE%A2%22">烤麸的博客</a>, 是烤麸自己学习用的博客</p><h1 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h1><h2 id="7-1-行内式"><a href="#7-1-行内式" class="headerlink" title="7.1 行内式"></a>7.1 行内式</h2><p>和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）</p><blockquote><p>注意的是[]前要加上!</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">markdown快速入门示例图.png</span>](<span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="7-2-参数式"><a href="#7-2-参数式" class="headerlink" title="7.2 参数式"></a>7.2 参数式</h2><p>图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">markdown快速入门示例图.png</span>]: <span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot; ![markdown快速入门示例图.png] </span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果图都是一样的，如下：</p><p><img src="/images/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="markdown快速入门示例图"></p><h1 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8. 分割线"></a>8. 分割线</h1><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">--- - - - ------ *** * * * ****** ___ _ _ _ ______<br></code></pre></td></tr></table></figure><p>以上代码的效果均为：</p><hr><h1 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h1><h2 id="9-1-强调字体"><a href="#9-1-强调字体" class="headerlink" title="9.1 强调字体"></a>9.1 强调字体</h2><p>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*md*</span>   <span class="hljs-strong">**md**</span> <span class="hljs-emphasis">_md_</span>   <span class="hljs-strong">__md__</span><br></code></pre></td></tr></table></figure><p>效果：<br><em>md</em><br><strong>md</strong><br><em>md</em><br><strong>md</strong></p><h2 id="9-2-转义"><a href="#9-2-转义" class="headerlink" title="9.2 转义"></a>9.2 转义</h2><p>基本上和js转义一样,\加需要转义的字符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\\ <br>\<span class="hljs-emphasis">* </span><br><span class="hljs-emphasis">\+ </span><br><span class="hljs-emphasis">\- </span><br><span class="hljs-emphasis">\` </span><br><span class="hljs-emphasis">\_</span><br></code></pre></td></tr></table></figure><h2 id="9-3-删除线"><a href="#9-3-删除线" class="headerlink" title="9.3 删除线"></a>9.3 删除线</h2><p>用~~把需要显示删除线的字符包裹起来</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">~~删除~~<br></code></pre></td></tr></table></figure><p>效果：</p><p><del>删除</del></p><h1 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//例子一 <br>|123|234|345| <br>|:-|:-:|-:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子二 <br>|123|234|345| <br>|:---|:---:|---:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子三 <br>123|234|345 <br>:-|:-:|-: <br>abc|bcd|cde <br>abc|bcd|cde <br>abc|bcd|cde<br></code></pre></td></tr></table></figure><p>上面三个例子的效果一样，由此可得：</p><ol><li><p>表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的</p></li><li><p>分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中</p></li></ol><p>效果如下：</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table><p>整理自：<a href="https://www.jianshu.com/p/399e5a3c7cc5">https://www.jianshu.com/p/399e5a3c7cc5</a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>博客使用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客使用手册</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是关于hexo框架下博客的使用方法总结，以便更好的学习与使用博客整理笔记。</p><h1 id="2-写作"><a href="#2-写作" class="headerlink" title="2. 写作"></a>2. 写作</h1><p>要创建新帖子或新页面，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>[layout]</code>是可选参数<code>布局</code>，<code>布局</code>分为以下几种：</p><table><thead><tr><th align="left">布局</th><th align="left">保存路径</th><th>用途</th></tr></thead><tbody><tr><td align="left">post</td><td align="left">source/_posts</td><td>创建新文章</td></tr><tr><td align="left">page</td><td align="left">source</td><td>创建新页面</td></tr><tr><td align="left">draft</td><td align="left">source/_drafts</td><td>创建新草稿</td></tr></tbody></table><p>该指令可以增加附加选项：</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--path</code></td><td align="left">发布路径。自定义帖子的路径。</td></tr><tr><td align="left"><code>-r</code>， <code>--replace</code></td><td align="left">替换当前帖子（如果存在）。</td></tr><tr><td align="left"><code>-s</code>， <code>--slug</code></td><td align="left">文章缩略名，自定义帖子的URL。</td></tr></tbody></table><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><h2 id="2-1-文档名称"><a href="#2-1-文档名称" class="headerlink" title="2.1 文档名称"></a>2.1 文档名称</h2><p>默认情况下，Hexo使用帖子标题作为其文件名。您可以在<code>_config.yml</code>中编辑<code>new_post_name</code>设置以更改默认文件名。</p><p>例如，<code>:year-:month-:day-:title.md</code>在文件名前加上创建日期。</p><p>您可以使用以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">帖子标题（小写，空格用连字符代替）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">创建年份，例如 <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">创建的月份（前导零），例如 <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">创建的月份（无前导零），例如 <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">创建日期（前导零），例如 <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">创建日期（无前导零），例如 <code>7</code></td></tr></tbody></table><h2 id="2-2-文档头"><a href="#2-2-文档头" class="headerlink" title="2.2 文档头"></a>2.2 文档头</h2><p>当新建.md文档后，打开文档可以看见如下文件头：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">title: hexo博客使用手册<br>date: 2021-02-18 14:11:04<br>tags: 博客使用手册<br>categories: 博客使用手册<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title:</code></td><td align="left">帖子标题</td></tr><tr><td align="left"><code>date:</code></td><td align="left">创建日期</td></tr><tr><td align="left"><code>tags:</code></td><td align="left">帖子所属标签</td></tr><tr><td align="left"><code>categories:</code></td><td align="left">帖子所属分类(需要手动添加)</td></tr></tbody></table><p>当想要新增标签与分类时，直接创建新的文档后在文件头填写参数即可。</p><p>多个标签时使用：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span>  <br><br>- [tag1]<br><br>- [tag2]<br></code></pre></td></tr></table></figure><p>含父子分类时，将父类写在前，子类写在后:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories: <br><span class="hljs-bullet">-</span> [categorie1]<br><span class="hljs-bullet">-</span> [categorie2]<br></code></pre></td></tr></table></figure><h2 id="2-3-添加图片"><a href="#2-3-添加图片" class="headerlink" title="2.3 添加图片"></a>2.3 添加图片</h2><p>关于图片和图片路径的设置，有以下教程。</p><p>事先声明，所有博客文件均保存在 <code>hexo/_posts/</code>文件夹下</p><p>首先在 <code>hexo &gt; source</code>目录下建一个文件夹叫images，用来保存博客中的图片。</p><p>然后打开Typora的 <code>文件 &gt; 偏好设置</code>，进行如下设置。</p><p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" alt="插入图片设置"></p><p>这样的话所有的博客中的图片都将会保存到 <code>/source/images/该博客md文件名/图片名称</code></p><p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p><p>在typora菜单栏点击 <code>格式-&gt;图像-&gt;设置图片根目录</code>，将<code>hexo/source</code>作为其根目录即可。</p><p><strong>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确喔！</strong></p><h2 id="2-4-草稿"><a href="#2-4-草稿" class="headerlink" title="2.4 草稿"></a>2.4 草稿</h2><p><code>draft</code>布局初始化的帖子将保存到该<code>source/_drafts</code>文件夹中。</p><p>您可以使用<code>publish</code>命令将草稿移至<code>source/_posts</code>文件夹。</p><p><code>publish</code>命令与<code>new</code>命令相似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>默认不显示草稿。</p><p>您可以在运行Hexo时添加选项<code>--draft</code>，也可以在<code>_config.yml</code>中启用<code>render_drafts</code>设置以渲染草稿。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --draft<br></code></pre></td></tr></table></figure><p>显示草稿（存储在<code>source/_drafts</code>文件夹中）。</p><h2 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h2><p>创建帖子时，Hexo将基于文件<code>scaffolds</code>夹中的相应模板文件来构建文件。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new photo <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>当您运行此命令时，Hexo将尝试在<code>scaffolds</code>文件夹中查找<code>photo.md</code>，并基于该文件构建帖子。模板中提供以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件创建日期</td></tr></tbody></table><h2 id="2-6-支持的格式"><a href="#2-6-支持的格式" class="headerlink" title="2.6 支持的格式"></a>2.6 支持的格式</h2><p>只要安装了相应的渲染器插件，Hexo支持帖子就可以以任何格式编写。、</p><p>本博客支持的编写格式：<code>markdown</code>，<code>ejs</code>。</p><h1 id="3-服务器指令"><a href="#3-服务器指令" class="headerlink" title="3. 服务器指令"></a>3. 服务器指令</h1><h2 id="3-1-init-安装指令"><a href="#3-1-init-安装指令" class="headerlink" title="3.1 init 安装指令"></a>3.1 init 安装指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init [folder]<br></code></pre></td></tr></table></figure><p>将hexo框架文件安装到当前/指定文件夹内。</p><h2 id="3-2-server-本地服务器启动指令"><a href="#3-2-server-本地服务器启动指令" class="headerlink" title="3.2 server 本地服务器启动指令"></a>3.2 server 本地服务器启动指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server 或 $ hexo s<br></code></pre></td></tr></table></figure><p>启动本地服务器。默认情况下，该位置为<code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--port</code></td><td align="left">覆盖默认端口</td></tr><tr><td align="left"><code>-s</code>， <code>--static</code></td><td align="left">仅提供静态文件</td></tr><tr><td align="left"><code>-l</code>， <code>--log</code></td><td align="left">启用记录器。覆盖记录器格式。</td></tr></tbody></table><h2 id="3-3-deploy-部署指令"><a href="#3-3-deploy-部署指令" class="headerlink" title="3.3 deploy 部署指令"></a>3.3 deploy 部署指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy 或 $ hexo d<br></code></pre></td></tr></table></figure><p>部署您的网站。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>， <code>--generate</code></td><td align="left">部署前生成</td></tr></tbody></table><h2 id="3-4-clean-清除缓存指令"><a href="#3-4-clean-清除缓存指令" class="headerlink" title="3.4 clean 清除缓存指令"></a>3.4 clean 清除缓存指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean <br></code></pre></td></tr></table></figure><p>清除缓存文件（<code>db.json</code>）和生成的文件（<code>public</code>）。</p><h2 id="3-5-version查看版本指令"><a href="#3-5-version查看版本指令" class="headerlink" title="3.5 version查看版本指令"></a>3.5 version查看版本指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo version 或 $ hexo v<br></code></pre></td></tr></table></figure><p>显示版本信息。</p><h2 id="3-6-选项"><a href="#3-6-选项" class="headerlink" title="3.6 选项"></a>3.6 选项</h2><h3 id="3-6-1-安全模式"><a href="#3-6-1-安全模式" class="headerlink" title="3.6.1 安全模式"></a>3.6.1 安全模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --safe<br></code></pre></td></tr></table></figure><p>禁用加载插件和脚本。如果在安装新插件后遇到问题，请尝试此操作。</p><h3 id="3-6-2-调试模式"><a href="#3-6-2-调试模式" class="headerlink" title="3.6.2 调试模式"></a>3.6.2 调试模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --debug<br></code></pre></td></tr></table></figure><p>将详细消息记录到终端和<code>debug.log</code>。如果遇到Hexo任何问题，请尝试此操作。如果看到错误，请<a href="https://github.com/hexojs/hexo/issues/new">提出GitHub问题</a>。</p><h3 id="3-6-3-静音模式"><a href="#3-6-3-静音模式" class="headerlink" title="3.6.3 静音模式"></a>3.6.3 静音模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --silent<br></code></pre></td></tr></table></figure><p>静音输出到终端。</p><h3 id="3-6-4-自定义配置文件路径"><a href="#3-6-4-自定义配置文件路径" class="headerlink" title="3.6.4 自定义配置文件路径"></a>3.6.4 自定义配置文件路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml<br></code></pre></td></tr></table></figure><p>使用自定义配置文件（而不是<code>_config.yml</code>）。</p><p>还接受以逗号分隔的JSON或YAML配置文件列表，该列表会将文件合并为一个<code>_multiconfig.yml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml，custom2.json<br></code></pre></td></tr></table></figure><h3 id="3-6-5-自定义CWD"><a href="#3-6-5-自定义CWD" class="headerlink" title="3.6.5 自定义CWD"></a>3.6.5 自定义CWD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --cwd / path / to / cwd<br></code></pre></td></tr></table></figure><p>自定义当前工作目录的路径。</p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
