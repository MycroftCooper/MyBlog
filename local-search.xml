<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DinoParkour开发文档</title>
    <link href="/2021/09/11/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"/>
    <url>/2021/09/11/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DinoParkour开发文档"><a href="#DinoParkour开发文档" class="headerlink" title="DinoParkour开发文档"></a>DinoParkour开发文档</h1><p><strong>项目信息：</strong><br>项目负责人：买烤麸烤饼<br>程序：买烤麸烤饼<br>美工：买烤麸烤饼，一周<br>音效：洛一<br>项目开发周期：2021.9.1- 2021.9.10</p><p><strong>版本信息：</strong></p><ul><li><p>v1.0  完成小恐龙跑酷的基本玩法</p></li><li><p>v1.5</p><ul><li>将操作按钮放到了屏幕两侧</li><li>解决了摄像头无法归位的BUG</li><li>重置了所有碰撞器，精细化了碰撞检测</li><li>增加了全新的翼龙模式与全新的BUG</li></ul></li><li><p>v2.0</p><ul><li>降低了翼龙的敏感度</li><li>修复了翼龙模式天空块之间会有缝隙的bug</li></ul></li></ul><h1 id="1-玩法分析"><a href="#1-玩法分析" class="headerlink" title="1. 玩法分析"></a>1. 玩法分析</h1><p><strong>游戏原型：</strong><br>chrome://dino/</p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909224440720.png" srcset="/img/loading.gif" alt="游戏原型"></p><p>该游戏是谷歌浏览器自带的一款恐龙跑酷小游戏。<br>当在无网络的情况下使用谷歌浏览器访问网站时会出现一个小恐龙，再按下空格就可以触发这个小游戏了。</p><p>在该游戏中，玩家通过键盘操控小恐龙进行跑酷，躲避各种沙漠上的障碍物来取得高分。</p><p><strong>游戏目标：</strong><br>躲过更多障碍，跑的更远以取得更高的分数</p><p><strong>得分计算：</strong><br>小恐龙存活时间就是得分</p><p><strong>玩家操作：</strong><br>玩家可以通过按钮(移动端)键盘(pc)端等方式来操控小恐龙进行跑酷。<br>可以操作的动作：</p><ul><li>下箭头：低头</li><li>上箭头：跳跃</li></ul><p><strong>失败判定：</strong><br>小恐龙碰到任何障碍物就触发游戏失败</p><h1 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h1><h2 id="2-1-游戏实体分析"><a href="#2-1-游戏实体分析" class="headerlink" title="2.1 游戏实体分析"></a>2.1 游戏实体分析</h2><h3 id="2-1-1-总分析"><a href="#2-1-1-总分析" class="headerlink" title="2.1.1 总分析"></a>2.1.1 总分析</h3><p><strong>主要实体：</strong></p><ul><li>小恐龙Dino 1个</li><li>陆地Land 动态生成</li><li>背景墙TimeRing 1个</li></ul><p>其中动态生成的陆地中应该动态生成多个障碍实体</p><p><strong>障碍实体：</strong></p><ul><li>仙人掌Cactu 共10种<ul><li>单体仙人掌 5种</li><li>双体仙人掌 3种</li><li>三体仙人掌 1种</li><li>四体仙人掌 1种</li></ul></li><li>翼龙Pterosaur 1种</li></ul><p>每种障碍实体的碰撞体积均不相同</p><p><strong>其它实体：</strong></p><ul><li>灯光Light</li><li>摄影机MainCamera</li></ul><h3 id="2-1-2-实体动画分析"><a href="#2-1-2-实体动画分析" class="headerlink" title="2.1.2 实体动画分析"></a>2.1.2 实体动画分析</h3><p>应当设计动画的实体主要是小恐龙与翼龙：</p><h4 id="2-1-2-1-小恐龙动画分析"><a href="#2-1-2-1-小恐龙动画分析" class="headerlink" title="2.1.2.1 小恐龙动画分析"></a>2.1.2.1 小恐龙动画分析</h4><p><strong>状态分析：</strong></p><ul><li>开始状态Start:0 (1帧)</li><li>奔跑状态Run:1 (2帧)</li><li>跳跃状态Jump:2 (1帧)</li><li>低头状态DownRun:3 (2帧)</li><li>死亡状态Dead:4 (1帧)</li></ul><p><strong>状态机</strong>如下图所示：<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909223752586.png" srcset="/img/loading.gif" alt="Dino状态机"></p><blockquote><p>其中:</p><ul><li>实线为可打断当前状态进行状态转换</li><li>虚线为当前状态执行完毕前不可打断</li></ul></blockquote><p><strong>需求：</strong>6张美术素材<br>小恐龙共需要6张美术素材用于制作帧动画，其中跳跃帧和开始帧可共用一张</p><h4 id="2-1-2-2-翼龙动画分析"><a href="#2-1-2-2-翼龙动画分析" class="headerlink" title="2.1.2.2 翼龙动画分析"></a>2.1.2.2 翼龙动画分析</h4><p><strong>状态分析：</strong><br>仅需要一种状态</p><ul><li>奔跑状态 2帧</li></ul><p><strong>需求：</strong>2张美术素材<br>翼龙共需要2张美术素材</p><h3 id="2-1-3-障碍实体动态生成分析"><a href="#2-1-3-障碍实体动态生成分析" class="headerlink" title="2.1.3 障碍实体动态生成分析"></a>2.1.3 障碍实体动态生成分析</h3><p>障碍实体应当动态生成在陆地实体上，而陆地实体也是动态生成的，所以这两者用预制体实现比较合适。</p><p><strong>障碍实体动态生成需求：</strong></p><ul><li>随机生成种类</li><li>随机生成个数</li><li>随机生成的障碍实体的碰撞体积要与种类相关有所变化</li></ul><p><strong>陆地实体动态生成需求：</strong></p><ul><li>同一时间游戏内应当有三个陆地实体<ul><li>正在运行的陆地实体 (1个)</li><li>准备运行的陆地实体 (2个)</li></ul></li><li>运行到指定位置自动销毁</li><li>运行到指定位置自动启动下一个陆地实体</li><li>陆地上动态生成的障碍实体数量应该在0-2之间随机</li><li>陆地上动态生成的障碍实体的位置应该是固定的<br>如果随机位置，容易挨在一起造成死局</li><li>陆地的运动速度应该随着分数的提高而提高</li></ul><h3 id="2-1-4-背景墙分析"><a href="#2-1-4-背景墙分析" class="headerlink" title="2.1.4 背景墙分析"></a>2.1.4 背景墙分析</h3><p><strong>背景墙需求：</strong></p><ul><li>是个时间环，通过转动来展示昼夜变化</li><li>时间环的转动要与灯光配合，展示昼夜光线变化</li></ul><h2 id="2-2-美术需求分析"><a href="#2-2-美术需求分析" class="headerlink" title="2.2 美术需求分析"></a>2.2 美术需求分析</h2><p><strong>美术风格：</strong><br>彩色像素风格</p><p><strong>美术需求清单：</strong>(按优先级排序)</p><ol><li>小恐龙的六张帧序列用于制作各种状态的动画</li><li>多种障碍实体(详见实体分析)<ul><li>仙人掌 十张</li><li>翼龙 两张</li></ul></li><li>陆地</li><li>背景时间环</li><li>各种UI制作</li><li>游戏LOGO</li></ol><h2 id="2-3-UI需求分析"><a href="#2-3-UI需求分析" class="headerlink" title="2.3 UI需求分析"></a>2.3 UI需求分析</h2><h3 id="2-3-1-UI需求树"><a href="#2-3-1-UI需求树" class="headerlink" title="2.3.1 UI需求树"></a>2.3.1 UI需求树</h3><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909231310761.png" srcset="/img/loading.gif" alt="UI需求树"></p><h3 id="2-3-2-细节需求"><a href="#2-3-2-细节需求" class="headerlink" title="2.3.2 细节需求"></a>2.3.2 细节需求</h3><ul><li><p>开始界面</p><ul><li>三个主要按钮需要支持键盘选择</li><li>三个主要按钮需要支持选中提示(键盘与鼠标)</li></ul></li><li><p>游戏界面</p><ul><li>当前分数需要实时刷新</li><li>最佳分数在每次开始游戏时需要读取</li></ul></li><li><p>游戏失败界面</p><ul><li>当玩家取得更高的分数时，需要弹出提示并保存新最佳分数</li></ul></li></ul><h2 id="2-4-音效分析"><a href="#2-4-音效分析" class="headerlink" title="2.4 音效分析"></a>2.4 音效分析</h2><ul><li>游戏BGM<br>8bit音乐</li><li>小恐龙音效<ul><li>跳跃音效</li><li>死亡音效</li></ul></li><li>游戏音效<ul><li>开始游戏音效</li><li>每百分音效</li><li>新分数音效</li></ul></li></ul><p>共需要8bit风格音效6段。</p><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><h2 id="3-1-工程类图"><a href="#3-1-工程类图" class="headerlink" title="3.1 工程类图"></a>3.1 工程类图</h2><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/Dino%E5%B7%A5%E7%A8%8B%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt="Dino工程类图"></p><h2 id="3-2-UI实现"><a href="#3-2-UI实现" class="headerlink" title="3.2 UI实现"></a>3.2 UI实现</h2><p><strong>开始界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160306730.png" srcset="/img/loading.gif" alt="image-20210910160306730"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910153817356.png" srcset="/img/loading.gif" alt="开始界面"></p><p><strong>关于界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160422573.png" srcset="/img/loading.gif" alt="image-20210910160422573"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910154143211.png" srcset="/img/loading.gif" alt="关于界面"></p><p><strong>游戏界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160454308.png" srcset="/img/loading.gif" alt="image-20210910160454308"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910153929870.png" srcset="/img/loading.gif" alt="游戏界面"></p><p><strong>暂停界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160519755.png" srcset="/img/loading.gif" alt="image-20210910160519755"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910154116353.png" srcset="/img/loading.gif" alt="暂停界面"></p><p><strong>失败界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160553087.png" srcset="/img/loading.gif" alt="image-20210910160553087"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910154015705.png" srcset="/img/loading.gif" alt="失败界面"></p><h2 id="3-3-技术实现亮点与难点"><a href="#3-3-技术实现亮点与难点" class="headerlink" title="3.3 技术实现亮点与难点"></a>3.3 技术实现亮点与难点</h2><h3 id="3-3-1-开始界面UI的多种响应方式"><a href="#3-3-1-开始界面UI的多种响应方式" class="headerlink" title="3.3.1 开始界面UI的多种响应方式"></a>3.3.1 开始界面UI的多种响应方式</h3><h4 id="3-3-1-1-效果描述"><a href="#3-3-1-1-效果描述" class="headerlink" title="3.3.1.1 效果描述"></a>3.3.1.1 效果描述</h4><p>根据UI需求分析中的细节部分对于开始界面UI的描述，我们可以知道，该UI需要支持三种操作方式：</p><ul><li>鼠标操作</li><li>键盘方向键操作</li><li>移动端触摸操作</li></ul><p>其中鼠标操作与键盘方向键操作时，会有一个选中的按钮变色的效果。</p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910163606363.png" srcset="/img/loading.gif" alt="image-20210910163606363"><br>当使用键盘选中about按钮或者光标落在上面时，颜色变浅。</p><p>该效果实现的难点主要在鼠标与键盘两种操作方式上，移动端的触摸输入使用普通的按钮响应函数即可</p><h4 id="3-3-1-2-键盘方向键操作"><a href="#3-3-1-2-键盘方向键操作" class="headerlink" title="3.3.1.2 键盘方向键操作"></a>3.3.1.2 键盘方向键操作</h4><p>在该操作模式下，会默认选中第一个Start Game按钮并使其变色，按上下键可以变更选中的按钮。</p><p>想要实现这种效果，我想到了使用双向循环链表，将三个按钮按顺序放入循环链表中，每次按下方向就到下一个节点的按钮，以此类推。</p><p>在C#中，可以使用LinkedList(双向链表)加一点小改动，就能成满足我们需求的双向循环链表，代码如下：</p><p><strong>初始化双向循环链表：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//循环链表，里面装的是每个按钮的背景图片组件</span><br><span class="hljs-keyword">private</span> LinkedList&lt;Image&gt; startPageBtnImg;<br><span class="hljs-comment">//当前选中的链表节点</span><br><span class="hljs-keyword">private</span> LinkedListNode&lt;Image&gt; onBtnImg;<br><span class="hljs-comment">//普通按钮背景图片精灵</span><br><span class="hljs-keyword">private</span> Sprite btnBGSprite;<br><span class="hljs-comment">//被选中的按钮背景图片精灵</span><br><span class="hljs-keyword">private</span> Sprite onBtnBGSprite;<br><br><span class="hljs-comment">// 初始化循环链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initBtnLinkedList</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    startPageBtnImg = <span class="hljs-keyword">new</span> LinkedList&lt;Image&gt;();<br>startPageBtnImg.AddLast(GameObject.Find(<span class="hljs-string">&quot;StartBtn&quot;</span>).GetComponent&lt;Image&gt;());<br>startPageBtnImg.AddLast(GameObject.Find(<span class="hljs-string">&quot;AboutBtn&quot;</span>).GetComponent&lt;Image&gt;());<br>startPageBtnImg.AddLast(GameObject.Find(<span class="hljs-string">&quot;ExitBtn&quot;</span>).GetComponent&lt;Image&gt;());<br><span class="hljs-comment">//设置当前选中的按钮为 StartBtn</span><br>onBtnImg = startPageBtnImg.First;<br>&#125;<br><br><span class="hljs-comment">// 玩家键盘输入监听函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return))<br>        OnTheBtn();<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.UpArrow))<br>        lastBtn();<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.DownArrow))<br>        nextBtn();<br>&#125;<br><br><span class="hljs-comment">// 按钮的切换函数</span><br><span class="hljs-comment">// 按下下方向箭头时选中下一个按钮并更改按钮背景</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextBtn</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    onBtnImg.Value.sprite = btnBGSprite;<span class="hljs-comment">//将当前按钮背景图改为普通背景图</span><br>    onBtnImg = onBtnImg.Next;<span class="hljs-comment">//将当前被选中按钮改为下一个按钮</span><br>    <span class="hljs-keyword">if</span> (onBtnImg == <span class="hljs-literal">null</span>)<span class="hljs-comment">//如果倒了链表尾</span><br>        onBtnImg = startPageBtnImg.First;<span class="hljs-comment">//手动循环链表</span><br>    onBtnImg.Value.sprite = onBtnBGSprite;<span class="hljs-comment">//将更改后的选中按钮的背景图改为选中背景图</span><br>&#125;<br><span class="hljs-comment">// 按下上方向箭头时选中上一个按钮并更改按钮背景</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastBtn</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    onBtnImg.Value.sprite = btnBGSprite;<br>    onBtnImg = onBtnImg.Previous;<br>    <span class="hljs-keyword">if</span> (onBtnImg == <span class="hljs-literal">null</span>)<span class="hljs-comment">//手动循环链表</span><br>        onBtnImg = startPageBtnImg.Last;<br>    onBtnImg.Value.sprite = onBtnBGSprite;<br>&#125;<br><br><span class="hljs-comment">// 按钮执行的函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTheBtn</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">string</span> btnName = onBtnImg.Value.gameObject.name;<br><span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">&quot;StartBtn&quot;</span>)<br>        OnStartGame();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">&quot;AboutBtn&quot;</span>)<br>        OnAboutGame();<br>    <span class="hljs-keyword">else</span><br>        OnExitGame();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-3-鼠标操作模式"><a href="#3-3-1-3-鼠标操作模式" class="headerlink" title="3.3.1.3 鼠标操作模式"></a>3.3.1.3 鼠标操作模式</h4><p>在鼠标操作模式下，则需要使鼠标放在哪个按钮上，哪个按钮就成为选中按钮。<br>所以实现的关键就在于检测鼠标是否在按钮上，鼠标在哪个按钮上。</p><p>这就需要用到Unity封装好的一些UI事件接口了。<br>详细内容可以看：<a href="https://mycroftcooper.github.io/2021/09/07/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/">UI事件接口</a></p><p>在这里需要用到的只有两个接口：</p><ul><li><strong>IPointerEnterHandler</strong><br>鼠标移入对象时触发响应函数</li><li><strong>IPointerExitHandler</strong><br>鼠标移出对象时触发响应函数</li></ul><p>因为这两个接口是面对对象的，使用应该写一个脚本挂到对应的按钮上去。<br>脚本代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StartPageBtnController</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerEnterHandler</span>, <span class="hljs-title">IPointerExitHandler</span><br>&#123;<br>    <span class="hljs-comment">//UI控制器，管理所有按钮响应函数</span><br>    UIManager UIM;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; UIM = GameObject.Find(<span class="hljs-string">&quot;UI&quot;</span>).GetComponent&lt;UIManager&gt;();<br>    <span class="hljs-comment">// 鼠标移入按钮时触发该响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerEnter</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"><span class="hljs-comment">// 将该按钮的背景图片组件发送至UI控制器</span></span><br><span class="hljs-function"></span>        =&gt; UIM.setSelectBtn(gameObject.GetComponent&lt;Image&gt;());<br><span class="hljs-comment">// 鼠标移出按钮时触发该响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerExit</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"></span>        =&gt; UIM.setSelectBtn(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将这个写好的StartPageBtnController挂在到需要该功能的那三个按钮上后，再去UI控制器里编写响应函数setSelectBtn。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSelectBtn</span>(<span class="hljs-params">Image btnImg</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (btnImg == onBtnImg.Value)<span class="hljs-comment">//如果选中按钮没变，就啥也不干</span><br>        <span class="hljs-keyword">return</span>;<br>    onBtnImg.Value.sprite = btnBGSprite;<span class="hljs-comment">//先将当前的选中按钮背景图复原</span><br>    <span class="hljs-keyword">if</span> (btnImg != <span class="hljs-literal">null</span>)<span class="hljs-comment">//如果没有按钮被选中，就选中默认按钮</span><br>    &#123;<br>        onBtnImg = startPageBtnImg.Find(btnImg);<br>        onBtnImg.Value.sprite = onBtnBGSprite;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//有选中按钮，就把选中的按钮赋值给当前选中按钮节点</span><br>    &#123;<br>        onBtnImg = startPageBtnImg.First;<br>        onBtnImg.Value.sprite = onBtnBGSprite;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个功能就这样实现了。</p><h3 id="3-3-2-动画器与状态机的使用"><a href="#3-3-2-动画器与状态机的使用" class="headerlink" title="3.3.2 动画器与状态机的使用"></a>3.3.2 动画器与状态机的使用</h3><h4 id="3-3-2-1-状态机的设置"><a href="#3-3-2-1-状态机的设置" class="headerlink" title="3.3.2.1 状态机的设置"></a>3.3.2.1 状态机的设置</h4><p>根据实体分析中对小恐龙Dino的状态机分析图(下图)<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909223752586.png" srcset="/img/loading.gif" alt="Dino状态机"></p><p>可以在Unity中制作动画器，并设置好状态机<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910201330605.png" srcset="/img/loading.gif" alt="动画器"></p><p>动画转变的判断参数是 int DinoState</p><h4 id="3-3-2-2-代码实现"><a href="#3-3-2-2-代码实现" class="headerlink" title="3.3.2.2 代码实现"></a>3.3.2.2 代码实现</h4><p>将动画器结合使用简单状态模式的脚本DinoController一起使用，就完成了对小恐龙的状态控制与动画播放。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DinoController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> DinoState &#123; Start, Run, Jump, Down, Dead &#125;<br>    <span class="hljs-comment">//小恐龙状态：0:开始 1:跑 2:跳 3:低头 4:死亡</span><br>    <span class="hljs-keyword">public</span> DinoState state;<br>    <span class="hljs-comment">// 利用属性来完成简单的状态改变响应函数</span><br>    <span class="hljs-keyword">public</span> DinoState State<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            state = (DinoState)animator.GetInteger(<span class="hljs-string">&quot;DinoState&quot;</span>);<br>            <span class="hljs-keyword">return</span> state; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            state = <span class="hljs-keyword">value</span>;<br>            animator.SetInteger(<span class="hljs-string">&quot;DinoState&quot;</span>, (<span class="hljs-built_in">int</span>)<span class="hljs-keyword">value</span>);<br>            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">value</span>)<br>            &#123;<br>                <span class="hljs-keyword">case</span> DinoState.Run:<br>                    run();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DinoState.Jump:<br>                    jump();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DinoState.Down:<br>                    down();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DinoState.Dead:<br>                    dead();<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> GameController GC;<br>    <span class="hljs-keyword">public</span> Animator animator;<br>    <span class="hljs-keyword">private</span> List&lt;Vector3&gt; dinoBoxColliderSize<br>        = <span class="hljs-keyword">new</span> List&lt;Vector3&gt; &#123; <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">2.5f</span>, <span class="hljs-number">3f</span>, <span class="hljs-number">1f</span>), <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">4f</span>, <span class="hljs-number">2f</span>, <span class="hljs-number">1f</span>) &#125;;<br>    <span class="hljs-keyword">public</span> Rigidbody dinoRigidbody;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        GC = GameObject.Find(<span class="hljs-string">&quot;GameController&quot;</span>).GetComponent&lt;GameController&gt;();<br>        animator = gameObject.GetComponent&lt;Animator&gt;();<br>        dinoRigidbody = gameObject.GetComponent&lt;Rigidbody&gt;();<br>    &#125;<br>    <span class="hljs-comment">// 监听用户输入来改变小恐龙状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (GC.gameState != <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.UpArrow))<br>            State = DinoState.Jump;<br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.DownArrow))<br>            State = DinoState.Down;<br>        <span class="hljs-keyword">if</span> (Input.GetKeyUp(KeyCode.DownArrow))<br>            State = DinoState.Run;<br>    &#125;<br><br>    <span class="hljs-comment">// 当状态改变后更改小恐龙碰撞体积</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBoxCollider</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isDown</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        BoxCollider bc = gameObject.GetComponent&lt;BoxCollider&gt;();<br>        <span class="hljs-keyword">if</span> (isDown)<br>            bc.size = dinoBoxColliderSize[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span><br>            bc.size = dinoBoxColliderSize[<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">//状态改变响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; setBoxCollider(<span class="hljs-literal">false</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jump</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (transform.position.y &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        setBoxCollider(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; setBoxCollider(<span class="hljs-literal">true</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dead</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; dinoRigidbody.isKinematic = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 碰撞检测响应函数，发送碰撞后将小恐龙状态设置为死亡</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collisionInfo</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (collisionInfo.gameObject.name == <span class="hljs-string">&quot;LandPrefab&quot;</span> || collisionInfo.gameObject.name == <span class="hljs-string">&quot;LandPrefab(Clone)&quot;</span>)<br>            <span class="hljs-keyword">return</span>;<br>        State = DinoState.Dead;<br>        GameObject.Find(<span class="hljs-string">&quot;GameController&quot;</span>).GetComponent&lt;GameController&gt;().GameOver(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-3-需要注意的点"><a href="#3-3-2-3-需要注意的点" class="headerlink" title="3.3.2.3 需要注意的点"></a>3.3.2.3 需要注意的点</h4><h5 id="状态的可打断性："><a href="#状态的可打断性：" class="headerlink" title="状态的可打断性："></a>状态的可打断性：</h5><p>在状态机分析图中分两种箭头：</p><ul><li>实线箭头<br>该状态的转换过程可以打断当前状态</li><li>虚线箭头<br>该状态的转换过程不可以打断当前状态，只能等当前状态的动画播放完毕才能进行状态转换</li></ul><p>想在Unity的状态机中实现这种设定，需要更改<strong>有退出时间</strong>属性：<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910203147899.png" srcset="/img/loading.gif" alt="image-20210910203147899"></p><ul><li>可打断则不勾选</li><li>不可打断则勾选</li></ul><blockquote><p>如果不做此调整会导致用户输入被延迟到状态动画播放完后执行，导致输入延迟验证，影响玩家体验</p></blockquote><h5 id="状态的自动转换："><a href="#状态的自动转换：" class="headerlink" title="状态的自动转换："></a>状态的自动转换：</h5><p>当跳远状态的动画播放完毕后，应当自动切换至奔跑状态。</p><p>为了实现这个功能，就需要使用动画的回调函数接口了。<br>详细可以阅读我的个人博客：[Unity-动画-回调函数接口](<a href="https://mycroftcooper.github.io/2021/09/07/Unity-%E5%8A%A8%E7%94%BB-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"> - Mycroft’s Blog (mycroftcooper.github.io)</a>****)</p><p>而在这里只需要使用两个个接口：</p><ul><li><p><strong>OnStateEnter</strong><br>进入该状态时调用</p></li><li><p><strong>OnStateExit</strong><br>在该状态结束退出时调用</p></li></ul><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JumpCallBack</span> : <span class="hljs-title">StateMachineBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// 进入该状态时播放跳跃音效</span><br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateEnter</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        GameObject.Find(<span class="hljs-string">&quot;GameController&quot;</span>).GetComponent&lt;SoundsController&gt;().PlayVoice(<span class="hljs-string">&quot;Sounds/Jump&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 退出该状态时自动转换到奔跑状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateUpdate</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">int</span> stateIndex = animator.GetInteger(<span class="hljs-string">&quot;DinoState&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateIndex != <span class="hljs-number">1</span> &amp;&amp; stateIndex != <span class="hljs-number">4</span>)<br>            GameObject.Find(<span class="hljs-string">&quot;DinoPrefab&quot;</span>).GetComponent&lt;DinoController&gt;().State = DinoController.DinoState.Run;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将该脚本挂到状态机中对应的状态(Run)上，就实现了目标</p><h5 id="按键连续按下时状态的连贯性："><a href="#按键连续按下时状态的连贯性：" class="headerlink" title="按键连续按下时状态的连贯性："></a>按键连续按下时状态的连贯性：</h5><p>当玩家连续按下跳跃键时，小恐龙应该持续保持在跳跃状态<br>当玩家持续按下低头键时，小恐龙应该持续保持在低头状态</p><p>要想实现这两个功能，这就需要用到Unity封装好的一些UI事件接口了。<br>详细内容可以看：<a href="https://mycroftcooper.github.io/2021/09/07/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/">UI事件接口</a></p><p>在这里需要用到的只有两个接口：</p><ul><li><strong>IPointerDownHandler</strong><br>鼠标在对象范围内按下时触发响应函数</li><li><strong>IPointerUpHandler</strong><br>鼠标在对象范围内抬起时触发响应函数</li></ul><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GamePageBtnController</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span><br>&#123;<br>    <span class="hljs-keyword">private</span> DinoController DC;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isDown = <span class="hljs-literal">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    =&gt; DC = GameObject.Find(<span class="hljs-string">&quot;DinoPrefab&quot;</span>).GetComponent&lt;DinoController&gt;();<br><br>    <span class="hljs-comment">// 按钮按下回调函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"></span>        =&gt; isDown = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 按钮松开回调函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        isDown = <span class="hljs-literal">false</span>;<br>        DC.State = DinoController.DinoState.Run;<br>    &#125;<br><br>    <span class="hljs-comment">//每帧检测是否按钮按下</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span>(isDown)<br>        &#123;<br>            <span class="hljs-comment">//判断按钮种类，根据种类改变小恐龙状态</span><br>            <span class="hljs-keyword">if</span> (gameObject.name == <span class="hljs-string">&quot;UpBtn&quot;</span>)<br>                DC.State = DinoController.DinoState.Jump;<br>            <span class="hljs-keyword">if</span> (gameObject.name == <span class="hljs-string">&quot;DownBtn&quot;</span>)<br>                DC.State = DinoController.DinoState.Down;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了以上代码，就可以正常实现功能了</p><h3 id="3-3-3-背景时间环与灯光的配合"><a href="#3-3-3-背景时间环与灯光的配合" class="headerlink" title="3.3.3 背景时间环与灯光的配合"></a>3.3.3 背景时间环与灯光的配合</h3><h4 id="3-3-3-1-效果描述"><a href="#3-3-3-1-效果描述" class="headerlink" title="3.3.3.1 效果描述"></a>3.3.3.1 效果描述</h4><p>根据实体分析中对背景时间环的分析可以知道，时间环以一定的速度转动来表达昼夜变化。而想用灯光来配合时间环的转动，来将昼夜变化更加自然的体现出来。</p><p>灯光主要可以通过以下两个方面来体现时间的变化：</p><ul><li>光照强度<ul><li>正午时光照强度最强</li><li>午夜时光照强度最弱</li></ul></li><li>光照颜色<ul><li>正午时光照颜色为橘黄色</li><li>午夜时光照颜色为暗蓝色</li></ul></li></ul><p>光照的变化应当是随着背景时间环而渐变的。</p><p>表现如下图所示：<br><strong>正午时：</strong><br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910183325819.png" srcset="/img/loading.gif" alt="image-20210910183325819"></p><p><strong>午夜时：</strong><br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910183450256.png" srcset="/img/loading.gif" alt="image-20210910183450256"></p><h4 id="3-3-3-2-解决思路"><a href="#3-3-3-2-解决思路" class="headerlink" title="3.3.3.2 解决思路"></a>3.3.3.2 解决思路</h4><p>背景时间环是一直在转动的，可以根据当前的转动角度来决定灯光的强度与颜色属性。<br>分析可得以下映射表：</p><table><thead><tr><th>时间</th><th>角度a</th><th>灯光强度s</th><th>灯光颜色c</th></tr></thead><tbody><tr><td>正午</td><td>0°</td><td>1.5</td><td>255，244，214</td></tr><tr><td>午夜</td><td>-180°</td><td>0.25</td><td>144，259，204</td></tr></tbody></table><p>可以看出输入值是角度，输出值是灯光强度与灯光颜色，而这两个输出值都是在一定范围内周期性变化。<br>由此可想到使用三角函数公式。</p><p><strong>灯光强度公式如下：</strong><br>$s=0.625cos(a)+0.65$</p><p>因为开始旋转角度为0时是正午，灯光强度为最大值1.5，所以使用cos函数<br>其中振幅A = 0.625 是根据(1.5-0.25)/2得到的。</p><h4 id="3-3-3-3-代码实现"><a href="#3-3-3-3-代码实现" class="headerlink" title="3.3.3.3 代码实现"></a>3.3.3.3 代码实现</h4><p>时间环控制代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TimeRingController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> LightController LC;<br>    <span class="hljs-keyword">public</span> Vector3 playSpeed;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isDayTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isPlaying;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsDayTime &#123; <span class="hljs-keyword">get</span> =&gt; isDayTime; <span class="hljs-keyword">set</span> =&gt; setTime(<span class="hljs-keyword">value</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsPlaying &#123; <span class="hljs-keyword">get</span> =&gt; isPlaying; <span class="hljs-keyword">set</span> =&gt; isPlaying = <span class="hljs-keyword">value</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        LC = GameObject.Find(<span class="hljs-string">&quot;Light&quot;</span>).GetComponent&lt;LightController&gt;();<br>        isDayTime = <span class="hljs-literal">true</span>;<br>        isPlaying = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//转动时间环函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (isPlaying)<br>        &#123;<br>            transform.Rotate(playSpeed, Space.Self);<br>            <span class="hljs-comment">//根据当前角度设置灯光属性</span><br>            LC.setTimeByAngle(transform.rotation.eulerAngles.z);<br>        &#125;<br>            <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isDayTime</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.isDayTime = isDayTime;<br>        <span class="hljs-keyword">if</span> (isDayTime)<br>        &#123;<br>            transform.rotation = Quaternion.Euler(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>            LC.setTime(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            transform.rotation = Quaternion.Euler(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">180</span>, <span class="hljs-number">0</span>));<br>            LC.setTime(<span class="hljs-literal">false</span>);<br>        &#125;<br>            <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>灯光控制代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LightController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Light theLight;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> maxInstensity;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> minInstensity;<br>    <span class="hljs-keyword">public</span> Color dayTimeColor;<br>    <span class="hljs-keyword">public</span> Color nightTimeColor;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        theLight = gameObject.GetComponent&lt;Light&gt;();<br>    &#125;<br>    <span class="hljs-comment">//三角函数的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> <span class="hljs-title">trigonometric</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> min, <span class="hljs-built_in">float</span> max,<span class="hljs-built_in">float</span> angle</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">float</span> rad = angle * Mathf.Deg2Rad;<br>        <span class="hljs-built_in">float</span> A = (max - min) / <span class="hljs-number">2.0f</span>;<br>        <span class="hljs-built_in">float</span> fai = min + A;<br>        <span class="hljs-keyword">return</span> A * Mathf.Cos(rad) + fai;<br>    &#125;<br>    <span class="hljs-comment">//根据角度转换灯光属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTimeByAngle</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> angle</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        theLight.intensity = trigonometric(minInstensity,maxInstensity,angle);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">100</span>&lt;angle &amp;&amp; angle&lt;<span class="hljs-number">200</span>)<br>            theLight.color = nightTimeColor;<br>        <span class="hljs-keyword">else</span><br>            theLight.color = dayTimeColor;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isDayTime</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (isDayTime)<br>        &#123;<br>            theLight.intensity = maxInstensity;<br>            theLight.color = dayTimeColor;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            theLight.intensity = minInstensity;<br>            theLight.color = nightTimeColor;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-3-4-需要注意的点"><a href="#3-3-3-4-需要注意的点" class="headerlink" title="3.3.3.4 需要注意的点"></a>3.3.3.4 需要注意的点</h4><ul><li>GameObject的transform.rotation属性是四元数，得转换为欧拉角然后再转换为弧度制才能使用</li><li>2D精灵是无法对3D的灯光有反应的<br>因为2D精灵使用的是默认的2D图片材质<br>想要让3D灯光在2D精灵图片上有效果，需要自定义材质<br>如下图所示：<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910200427517.png" srcset="/img/loading.gif" alt="image-20210910200427517"><br>其中渲染模式(RenderingMode)要设置为：Cutout，其它设置根据需求进行更改。</li></ul><h3 id="3-3-4-不同画面比的自适应匹配"><a href="#3-3-4-不同画面比的自适应匹配" class="headerlink" title="3.3.4 不同画面比的自适应匹配"></a>3.3.4 不同画面比的自适应匹配</h3><h4 id="3-3-4-1-效果描述"><a href="#3-3-4-1-效果描述" class="headerlink" title="3.3.4.1 效果描述"></a>3.3.4.1 效果描述</h4><p>当游戏打包发布到安卓端时，需要解决目前市场上各式各样屏幕比例的自适应问题。<br>UI方面只要在编辑器中设置好就问题不大，主要是游戏实体的缩放与生成和销毁位置的问题。</p><p>需求如下：</p><ul><li>陆地块的生成位置必须在屏幕外</li><li>陆地块的开始运动位置必须在屏幕右侧边缘</li><li>陆地块运动至屏幕外需要销毁</li><li>陆地块右侧边缘位于屏幕右侧边缘时，需要启动下一个陆地块</li><li>时间环无论在什么屏幕下都应该充满背景</li></ul><h4 id="3-3-4-2-代码实现"><a href="#3-3-4-2-代码实现" class="headerlink" title="3.3.4.2 代码实现"></a>3.3.4.2 代码实现</h4><p>想要实现如上需求，就必须要知道屏幕的边缘在哪里，也就是将屏幕的边缘坐标从屏幕坐标转化为世界坐标。可以通过如下代码实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> leftBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> rightBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> topBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> downBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> height;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> width;<br><span class="hljs-keyword">public</span> Vector3 scale;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBorder</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//世界坐标的右上角  因为视口坐标右上角是1,1,点</span><br>    Vector3 cornerPos = Camera.main.ViewportToWorldPoint(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1f</span>, <span class="hljs-number">1f</span>,Mathf.Abs(-Camera.main.transform.position.z)));<br>    <span class="hljs-comment">//世界坐标左边界</span><br>    leftBorder = Camera.main.transform.position.x - (cornerPos.x - Camera.main.transform.position.x);<br>    <span class="hljs-comment">//世界坐标右边界</span><br>    rightBorder = cornerPos.x;<br>    <span class="hljs-comment">//世界坐标上边界</span><br>    topBorder = cornerPos.y;<br>    <span class="hljs-comment">//世界坐标下边界</span><br>    downBorder = Camera.main.transform.position.y - (cornerPos.y - Camera.main.transform.position.y);<br>    width = rightBorder - leftBorder;<br>    height = topBorder - downBorder;<br>    <span class="hljs-comment">//在默认比例:16:9下的宽高</span><br>    <span class="hljs-built_in">float</span> deffultH = <span class="hljs-number">13.85643f</span>;<br>    <span class="hljs-built_in">float</span> deffultW = <span class="hljs-number">24.60183f</span>;<br>    <span class="hljs-comment">//缩放求出比例</span><br>    scale = <span class="hljs-keyword">new</span> Vector3(width/deffultW, height/deffultH, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>把上述代码挂在到摄像机上，当摄像机就位后运行，就能得到：</p><ul><li>画面四个边界的世界坐标</li><li>当前画面比例下与默认画面比例的缩放比</li></ul><p>其中物体运行到视野外销毁还可以使用另一种方法：<br>使用 <strong>OnBecameInvisible()</strong> 函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//物体进入视野内触发响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBecameVisible</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-comment">//物体离开视野内触发响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBecameInvisible</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="4-附录"><a href="#4-附录" class="headerlink" title="4. 附录"></a>4. 附录</h1><p>GitHub链接：<a href="https://github.com/MycroftCooper/DinoParkour">https://github.com/MycroftCooper/DinoParkour</a></p>]]></content>
    
    
    <categories>
      
      <category>项目开发文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGUI详解-事件接口</title>
    <link href="/2021/09/10/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/09/10/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>UGUI 系统虽然提供了很多封装好的组件，但是要实现一些特定的功能还是显得非常有限，这时候就需要使用事件接口来完成UI功能的实现。</p><p>比如我们想实现鼠标移动到图片上时自动显示图片的文字介绍，一般思路会想到写个射线来检测。<br>但其实这样的检测UGUI已经替我们完成了，我们只需要实现检测到目标对象后所要执行的代码即可！</p><p><strong>事件系统：UnityEngine.EventSystems;</strong></p><p>UI 组件都是基于 UGUI 封装好的类和接口以及一些 Editor 文件来进行封装制作供开发者使用的，开发者利用这些封装好的工具，只需更专注于功能开发即可。</p><h1 id="2-事件系统的前置条件"><a href="#2-事件系统的前置条件" class="headerlink" title="2. 事件系统的前置条件"></a>2. 事件系统的前置条件</h1><h2 id="2-1-使用该事件系统的条件"><a href="#2-1-使用该事件系统的条件" class="headerlink" title="2.1 使用该事件系统的条件"></a>2.1 使用该事件系统的条件</h2><ul><li>对象必须是 Canvas 的子对象；</li><li>对象必须有 Rect 范围；</li><li>鼠标的操作不分左键 中键 右键；</li></ul><h2 id="2-2-事件触发条件"><a href="#2-2-事件触发条件" class="headerlink" title="2.2 事件触发条件"></a>2.2 事件触发条件</h2><ul><li><p>对象或其子对象所附加的 UI 组件含有 Raycast Target 属性（为 true）</p></li><li><p>鼠标光标进入该对象的 Rect 范围时</p></li></ul><h2 id="2-3-事件系统的特殊情况"><a href="#2-3-事件系统的特殊情况" class="headerlink" title="2.3 事件系统的特殊情况"></a>2.3 事件系统的特殊情况</h2><ul><li><p><strong>若：</strong>该对象实现事件接口，而其子对象所附加的 UI 组件含有 Raycast Target         属性且没有实现事件接口<br><strong>则：</strong>只有该对象会触发事件，而其子对象不会触发事件</p></li><li><p><strong>当：</strong>该对象和其子对象同时具有触发事件接口的条件时：<br><strong>若：</strong>该对象的 Rect 范围被其子对象的 Rect 范围完全覆盖掉<br><strong>则：</strong>该对象不会触发事件，只有其子对象会触发事件。</p></li></ul><h1 id="3-事件接口一览"><a href="#3-事件接口一览" class="headerlink" title="3. 事件接口一览"></a>3. 事件接口一览</h1><ul><li><p><strong>IPointerEnterHandler</strong></p><p><strong>功能：</strong><br>鼠标移入对象时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerEnter</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IPointerExitHandler</strong><br><strong>功能：</strong><br>鼠标移出对象时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerExit</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IPointerDownHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IPointerUpHandler</strong><br><strong>功能</strong>：<br>鼠标在对象范围内抬起时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>无论鼠标在何处抬起（即不在A对象中）都会在A对象中响应此事件</li><li>响应此事件的前提是A对象必须响应过OnPointerDown事件</li></ul></blockquote></li><li><p><strong>IPointerClickHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下并抬起后触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerClick</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>按下和抬起时鼠标要处于同一对象上</p></blockquote></li><li><p><strong>IDragHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下并拖拽时，对象每帧响应一次此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>如果不实现此接口，则后面的四个接口方法都不会触发</p></blockquote></li><li><p><strong>IInitializePotentialDragHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下还没开始拖拽时，对象响应此事件</p><blockquote><p>与IPointerDownHandler接口事件类似</p></blockquote><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInitializePotentialDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IBeginDragHandler</strong><br><strong>功能：</strong><br>当鼠标在对象范围内按下并开始拖拽时，对象响应此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBeginDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：<br>此事件在OnInitializePotentialDrag之后响应 OnDrag之前响应</p></blockquote></li><li><p><strong>IEndDragHandler</strong><br><strong>功能：</strong><br>当鼠标完成拖拽抬起时，对象响应此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEndDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IDropHandler</strong><br><strong>功能：</strong><br>当鼠标从A对象上开始拖拽，在B对象上抬起时，B对象响应此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrop</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><pre><code>A、B对象必须均实现IDropHandler接口，且A至少实现IDragHandler接口</code></pre></li><li><pre><code>此时eventData.pointerDrag.name获取到的是B对象的name属性</code></pre></li><li><pre><code>eventData.pointerDrag表示发起拖拽的对象（GameObject）</code></pre></li></ul></blockquote></li></ul><h1 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h1><p>总结整理自：<br><a href="https://blog.csdn.net/eazey_wj/article/details/65632664">https://blog.csdn.net/eazey_wj/article/details/65632664</a></p><p>他这还有很多案例和代码，建议去看看</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>UGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>UGUI</tag>
      
      <tag>事件接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-动画-回调函数接口</title>
    <link href="/2021/09/07/Unity-%E5%8A%A8%E7%94%BB-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/09/07/Unity-%E5%8A%A8%E7%94%BB-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>当你想在状态机的某个状态执行中干些什么的时候(增加状态机行为)<br>比如：播放音效，添加粒子特效，增加逻辑代码等等操作。<br>那么就可以试一试Unity封装好的回调函数接口：<strong>StateMachineBehaviour</strong></p><p>想要添加（State machine behaviours）状态机行为到状态或子状态机，可以选中某个状态后在inspector中的Add Behaviour按钮。</p><h1 id="2-使用该动画回调接口的前置条件"><a href="#2-使用该动画回调接口的前置条件" class="headerlink" title="2. 使用该动画回调接口的前置条件"></a>2. 使用该动画回调接口的前置条件</h1><ul><li>必须继承StateMachineBehaviour</li><li>脚本必须挂在到状态上</li></ul><h1 id="3-回调函数接口一览"><a href="#3-回调函数接口一览" class="headerlink" title="3. 回调函数接口一览"></a>3. 回调函数接口一览</h1><ul><li><p><strong>OnStateEnter</strong><br>进入该状态时调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateEnter</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnStateUpdate</strong><br>在该状态下每帧调用<br>(MonoBehaviour Updates 更新后)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateUpdate</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnStateExit</strong><br>在该状态结束退出时调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateExit</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnStateMove</strong><br>在Animator.OnAnimatorMove()执行后调用(普通动画开始播放后)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateMove</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>用于实现处理和影响根运动的代码</p></blockquote></li><li><p><strong>OnStateIK</strong><br>在Animator.OnAnimatorIK()执行后调用(骨骼动画开始播放后)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateIK</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="4-参数解释"><a href="#4-参数解释" class="headerlink" title="4. 参数解释"></a>4. 参数解释</h1></li><li><p><strong>Animator animator</strong><br>当前动画器，是这个状态机行为的引用。</p></li><li><p><strong>AnimatorStateInfo stateInfo</strong><br>当前状态的详细信息</p><ul><li>int fullPathHash<br>当前状态的全路径哈希值</li><li>int nameHash<br>当前状态名称的哈希值</li><li>int shortNameHash<br>不包括父层名称的短名称哈希值</li><li>float normalizedTime<br>状态的标准化时间</li><li>float length<br>状态当前已经持续的时间</li><li>float speed<br>动画播放速度(1为正常速度)</li><li>float speedMultiplier<br>动画播放倍速</li><li>int tagHash<br>标签的哈希值</li><li>bool loop<br>当前状态是否循环</li><li>bool IsName(string name)</li><li>bool IsTag(string tag)</li></ul></li><li><p><strong>int layerIndex</strong><br>是状态机行为状态的layer 层</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>动画</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>动画</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-射线检测</title>
    <link href="/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/"/>
    <url>/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>射线是3D世界中一个点向一个方向发射的一条无终点的线。在发射的轨迹中，一旦与其他物体发生碰撞，它就会停止。</p><p>在游戏中，射线检测可以有如下用途：</p><ul><li>检测光标位置的三维物体</li><li>检测角色前面的物体（自动开门）</li><li>从空中向下检测（凹凸不平的地形的瞬移）</li><li>测量距离（激光测距）</li></ul><p>等等，可以说是相当重要了。</p><h1 id="2-Ray射线"><a href="#2-Ray射线" class="headerlink" title="2. Ray射线"></a>2. Ray射线</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>要想使用射线检测，就要先定义一条射线。而Ray就是Unity提供的一个封装好的射线结构体。</p><p>一条无穷的线，开始于origin点，朝向direction方向</p><blockquote><p>根据项目验证来看:其默认长度为单位向量，只有对direction进行乘以倍率，才可实现延长射线，而非无穷</p></blockquote><h2 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2 结构"></a>2.2 结构</h2><p>Ray是一个结构体：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Ray</span> (<span class="hljs-params">Vector3 origin,Vector3 direction</span>)</span><br></code></pre></td></tr></table></figure><p>其中参数为：</p><ul><li>Origin： 射线的起点    </li><li>direction：射线的方向</li></ul><p>初始化方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Ray ray = <span class="hljs-keyword">new</span> Ray(Vector3 origin,Vector3 direction)<br></code></pre></td></tr></table></figure><h2 id="2-3-常见用法"><a href="#2-3-常见用法" class="headerlink" title="2.3 常见用法"></a>2.3 常见用法</h2><ul><li><p>从物体中心创建一条指向前方的射线:<br><code>Ray ray = new Ray(transform.position,transform.forward)</code></p></li><li><p>从摄像机产生、指向屏幕上光标的射线<br><code>Ray camerRay = Camera.main.ScreenPointToRay(Input.mousePosition)</code>：。</p><blockquote><p>相机为perspective模式:<br>射线在相机梯形视野内发散；<br>相机为orthoGraphic模式:<br>则为垂直与相机面的直线段;</p></blockquote></li></ul><h1 id="3-RaycastHit-光线投射碰撞信息"><a href="#3-RaycastHit-光线投射碰撞信息" class="headerlink" title="3. RaycastHit 光线投射碰撞信息"></a>3. RaycastHit 光线投射碰撞信息</h1><p><strong>定义：</strong><br>通过射线检测得到的碰撞信息。</p><p>常用信息如下：</p><p><strong>常用参数：</strong></p><ul><li>collider<br>射线检测到的collider，这个非常常用，因为能根据collider.gameObject获取到对应GameObject</li><li>distance<br>射线发射源与检测到的位置的距离</li><li>normal<br>射线碰撞位置的法线</li><li>point<br>射线碰撞位置的世界坐标</li><li>transform<br>射线碰撞物体的transform组件</li></ul><h1 id="4-LayerMask-层级蒙版"><a href="#4-LayerMask-层级蒙版" class="headerlink" title="4. LayerMask 层级蒙版"></a>4. LayerMask 层级蒙版</h1><p><strong>Layer与LayerMask的关系:</strong></p><ul><li>Layer是0-31的数字</li><li>LayerMask是按位对应0-31</li></ul><blockquote><p>如&gt;<br>Layer9：Enemy<br>LayerMask用二进制表示：<br>00000000 00000000 000000<strong>1</strong>0 00000000<br>从右往左第10位，等于表达式：1&lt;&lt;9</p></blockquote><p>这是一种二进制思想，使用mask(掩码)表示时，可以同时表示多个状态的有无。</p><p><strong>根据Layer获取LayerMask:</strong></p><ul><li><p>如果你知道Layer的名字:<br>可以通过LayerMask.GetMask()方法获取<br><code>int mask = LayerMask.GetMask(&quot;Player&quot;, &quot;NPC&quot;);</code></p><blockquote><p>注意这个方法可以传入一个或多个string类型参数。</p></blockquote></li><li><p>如果你知道Layer的数字:<br>比如Layer9，可以通过移位操作1&lt;&lt;9来获取</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> playerMask = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">9</span>;<br><span class="hljs-built_in">int</span> npcMask = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> mask = playerMask | npcMask; <span class="hljs-comment">// 通过位操作“或(|)”同时检测player 和 npc层</span><br><span class="hljs-built_in">int</span> reverse = ~mask; <span class="hljs-comment">// 通过位操作&quot;求反(~)&quot;，检测除了player 和 npc的其他层</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="5-检测方法"><a href="#5-检测方法" class="headerlink" title="5. 检测方法"></a>5. 检测方法</h1><h2 id="5-1-线型检测"><a href="#5-1-线型检测" class="headerlink" title="5.1 线型检测"></a>5.1 线型检测</h2><p>在使用射线检测时，调用的是<code>public static bool Physics.Raycast()</code>函数</p><h3 id="5-1-1-Physics-Raycast-光线投射"><a href="#5-1-1-Physics-Raycast-光线投射" class="headerlink" title="5.1.1 Physics.Raycast 光线投射"></a>5.1.1 Physics.Raycast 光线投射</h3><h4 id="5-1-1-1-功能"><a href="#5-1-1-1-功能" class="headerlink" title="5.1.1.1 功能"></a>5.1.1.1 功能</h4><p>在已有一条射线（也可无）的基础上，使用射线（新建射线）进行一定距离内的定向检测。</p><ul><li>可修改射线长度</li><li>可限制其检测的Layer层</li><li>可得到射线检测到的碰撞信息</li></ul><blockquote><p>仅能检测到<strong>第一个被射线碰撞的物体</strong>，后面的物体无法被检测到</p></blockquote><p><strong>适用场合：</strong><br>配合相机坐标转换实现各类交互</p><h4 id="5-1-1-2-用法"><a href="#5-1-1-2-用法" class="headerlink" title="5.1.1.2 用法"></a>5.1.1.2 用法</h4><p><strong>用法一：</strong></p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br> transform.position, <br>     Vector.forward, <br>     distance, <br>     LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li><p><code>transform.position</code>：<br>从物体中心点起</p></li><li><p><code>Vector.forward</code>：<br>朝向该方向发射一条射线</p></li><li><p><code>distance</code>：<br>该射线长度为distance</p></li><li><p><code>LayerMask.GetMask(&quot;Enemy&quot;)</code>：<br>射线可检测到的层为Enemy层</p></li><li><p>返回bool类型</p></li></ul><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br>    transform.position, <br>    Vector.forward, <br>    distance, <br>    <span class="hljs-keyword">out</span> RaycastHitInformation ,<br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)；<br></code></pre></td></tr></table></figure><ul><li>相同参数同上</li><li><code>out RaycastHitInformation</code>：<br>将碰撞信息反馈到RaycastHitInformation上</li></ul><p><strong>用法三：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br>    MyRay, <br>    distance, <br>    LayerMash.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>相同参数同上</li><li><code>MyRay</code><br>从已有的射线MyRay出发</li><li><code>distance</code><br>长度延伸至distance</li></ul><p><strong>用法四：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br>MyRay, <br>    <span class="hljs-keyword">out</span> RaycastHitInformation, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>相同参数同上</li></ul><h3 id="5-1-2-Physics-RaycastAll-所有光线投射"><a href="#5-1-2-Physics-RaycastAll-所有光线投射" class="headerlink" title="5.1.2 Physics.RaycastAll 所有光线投射"></a>5.1.2 Physics.RaycastAll 所有光线投射</h3><h4 id="5-1-2-1-功能"><a href="#5-1-2-1-功能" class="headerlink" title="5.1.2.1 功能"></a>5.1.2.1 功能</h4><p>机理用法大致同Raycast，区别在于可检测射线路径上的<strong>所有物体</strong>，<strong>返回RaycastHit[]</strong> 。<br>其他带All后缀的方法也同理</p><p><strong>适用场合：</strong><br>穿透性检测</p><h4 id="5-1-2-2-用法"><a href="#5-1-2-2-用法" class="headerlink" title="5.1.2.2 用法"></a>5.1.2.2 用法</h4><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">RaycastHit[] hits = RaycastAll(<br>    Vector3.zero, <br>    Vector.forward, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">RaycastHit[] hits = RaycastAll(<br>    MyRay, <br>    distance, <br>    LayerMash.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-1-3-线段投射"><a href="#5-1-3-线段投射" class="headerlink" title="5.1.3 线段投射"></a>5.1.3 线段投射</h3><h4 id="5-1-3-1-功能"><a href="#5-1-3-1-功能" class="headerlink" title="5.1.3.1 功能"></a>5.1.3.1 功能</h4><p>建立<strong>某两点之间</strong>的射线进行检测，返回bool类型</p><p><strong>适用场合：</strong><br>特定地点局部距离射线检测</p><h4 id="5-1-3-2-用法"><a href="#5-1-3-2-用法" class="headerlink" title="5.1.3.2 用法"></a>5.1.3.2 用法</h4><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Linecast(<br>    startPos, <br>    endPos, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Linecast(<br>startPos, <br>    endPos, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h2 id="5-2-体型检测"><a href="#5-2-体型检测" class="headerlink" title="5.2 体型检测"></a>5.2 体型检测</h2><h3 id="5-2-1-Physics-XXXCast-体投射"><a href="#5-2-1-Physics-XXXCast-体投射" class="headerlink" title="5.2.1 Physics.XXXCast 体投射"></a>5.2.1 Physics.XXXCast 体投射</h3><h4 id="5-2-1-1-BoxCast-立方体投射"><a href="#5-2-1-1-BoxCast-立方体投射" class="headerlink" title="5.2.1.1 BoxCast 立方体投射"></a>5.2.1.1 BoxCast 立方体投射</h4><p><strong>功能：</strong><br>检测范围是正立方，返回bool。</p><p><strong>适用场合：</strong><br>检测目的地是否可抵达，从而判断可移动性</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">BoxCast(<br>    originPos, <br>    halfExtents, <br>    direction, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li>originPos, halfExtents：<br>在originPos点创建半径halfBoxLength的立方体<br>（Vector3型，代表为正立方体在三个方向上的大小，一般用localScale/2）</li><li>direction, distance:<br>以朝向direction方向的平面为起始面（另一面舍弃）<br>移动distance距离，期间经过的区域即为检测区域。</li></ul><h4 id="5-2-1-2-SphereCast-球体投射"><a href="#5-2-1-2-SphereCast-球体投射" class="headerlink" title="5.2.1.2 SphereCast 球体投射"></a>5.2.1.2 SphereCast 球体投射</h4><p><strong>功能：</strong><br>扩展检测范围为球形，返回bool类型。</p><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">SphereCast(<br>    originPos, <br>    originPos, <br>    direction, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li><p>originPos, originPos:<br>在originPos点创建半径为radius的球体</p></li><li><p>direction, distance:<br>以朝向direction方向的球面为起始面（另一面舍弃）<br>移动distance距离<br>期间半球面经过的区域即为检测区域。</p></li></ul><p>那么originPos到originPos+radius内的半球区域呢？<br>答案是舍弃，用官方的话来说，<strong>是边界而不是包围体</strong> 。</p><blockquote><p>立体结构：<br>以左右球球心为轴线，建立半径为radius、高为distance的圆柱体<br>左球挖去右半体积，右球添加右半体积</p></blockquote><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">SphereCast (<br>    Ray, <br>    radius, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-1-3-CapsuleCast-胶囊体投射"><a href="#5-2-1-3-CapsuleCast-胶囊体投射" class="headerlink" title="5.2.1.3 CapsuleCast 胶囊体投射"></a>5.2.1.3 CapsuleCast 胶囊体投射</h4><p><strong>功能：</strong><br>检测范围是胶囊体，返回bool</p><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">Physics.CapsuleCast(<br>    pos1, <br>    pos2, <br>    radius, <br>    direction, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    maxDistance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Anchor&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li><p>机理和SphereCast类似</p></li><li><p>pos1, pos2, radius:<br>在pos1、pos2两点创建半径为0.5f的球体，以此作为胶囊体模型两端；</p></li><li><p>direction, maxDistance:<br>以朝向direction方向的半胶囊体面为起始面，移动maxDistance距离<br>期间该面经过的区域即为检测区域。</p><blockquote><p>注：<br>maxDistance和上面的distance必须非0否则无用</p></blockquote></li></ul><h5 id="5-2-1-4-XXXCastAll-穿透投射"><a href="#5-2-1-4-XXXCastAll-穿透投射" class="headerlink" title="5.2.1.4 XXXCastAll 穿透投射"></a>5.2.1.4 XXXCastAll 穿透投射</h5><p><strong>功能：</strong><br>上述三种投射都只返回bool，只能检测单个物体，但是All方法的可检测射线上的所有物体，返回 <strong>RaycastHit[]</strong></p><blockquote><p>慎用，<strong>产生GC极多</strong></p></blockquote><h3 id="5-2-2-Physics-OverlapXXX-相交体"><a href="#5-2-2-Physics-OverlapXXX-相交体" class="headerlink" title="5.2.2 Physics.OverlapXXX 相交体"></a>5.2.2 Physics.OverlapXXX 相交体</h3><h4 id="5-2-2-1-OverlapBox-相交盒"><a href="#5-2-2-1-OverlapBox-相交盒" class="headerlink" title="5.2.2.1 OverlapBox 相交盒"></a>5.2.2.1 OverlapBox 相交盒</h4><p><strong>功能：</strong><br>检测与正立方体接触、重叠、或者处于其内的所有collider</p><p><strong>适用场合：</strong><br>检测挂载物体范围内是否存在碰撞，常用方法</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Collider[] hits = OverlapBox(<br>    Pos, <br>    halfExtents, <br>    Quaternion.identity, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>Pos, halfExtents:<br>以Pos点为中心创建三维半径halfExtents的正立方体</li><li>Quaternion.identity：<br>不对其进行旋转</li></ul><h4 id="5-2-2-2-OverlapSphere-相交球"><a href="#5-2-2-2-OverlapSphere-相交球" class="headerlink" title="5.2.2.2 OverlapSphere 相交球"></a>5.2.2.2 OverlapSphere 相交球</h4><p><strong>功能：</strong><br>检测与球体接触、重叠、或者处于其内的所有collider，即<strong>包围体</strong>。</p><blockquote><p>注意:<br><strong>自身collider也会被检测</strong>到（下列Overlap方法都是）</p></blockquote><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Collider[] hits = Physics.OverlapSphere(<br>    Pos, <br>    radius, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li><p>Pos, radius：<br>以Pos为原点，创建半径为radius的球形<br>检测区域为整个球形包围体（实心）<br>返回所有碰撞物体的collider而不是RaycastHit</p><blockquote><p>注意：<br>存在于球内部的物体也会被检测到</p></blockquote></li></ul><h4 id="5-2-2-3-OverlapCapsule-相交胶囊体"><a href="#5-2-2-3-OverlapCapsule-相交胶囊体" class="headerlink" title="5.2.2.3 OverlapCapsule 相交胶囊体"></a>5.2.2.3 OverlapCapsule 相交胶囊体</h4><p><strong>功能：</strong><br>检测与胶囊体接触、重叠、或者处于其内的所有collider</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Collider[] hits = OverlapCapsule(<br>    pos1, <br>    pos2, <br>    radius, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>在pos1、pos2两点创建半径为radius的球体，加上中间部分组成胶囊体</li></ul><h3 id="5-2-3-Physics-OverlapXXXNonAlloc-无GC相交体"><a href="#5-2-3-Physics-OverlapXXXNonAlloc-无GC相交体" class="headerlink" title="5.2.3 Physics.OverlapXXXNonAlloc 无GC相交体"></a>5.2.3 Physics.OverlapXXXNonAlloc 无GC相交体</h3><h4 id="5-2-3-1-OverlapBoxNonAlloc-无GC相交盒"><a href="#5-2-3-1-OverlapBoxNonAlloc-无GC相交盒" class="headerlink" title="5.2.3.1 OverlapBoxNonAlloc 无GC相交盒"></a>5.2.3.1 OverlapBoxNonAlloc 无GC相交盒</h4><p><strong>功能：</strong><br>实现OverlapBox的所有功能，但是另<strong>传递进colliders[]</strong> ，<strong>返回相交物体数量</strong>，从而<strong>杜绝GC的产生</strong></p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">CollAmount = Physics.OverlapBoxNonAlloc(<br>    Pos, <br>    halfExtents, <br>    colliders, <br>    Quaternion.identity, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-3-2-OverlapSphereNonAlloc-无GC相交球"><a href="#5-2-3-2-OverlapSphereNonAlloc-无GC相交球" class="headerlink" title="5.2.3.2 OverlapSphereNonAlloc 无GC相交球"></a>5.2.3.2 OverlapSphereNonAlloc 无GC相交球</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">CollAmount = OverlapSphereNonAlloc(<br>    Pos, <br>    radius, <br>    colliders, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-3-3-OverlapCapsuleNonAlloc-无GC相交胶囊体"><a href="#5-2-3-3-OverlapCapsuleNonAlloc-无GC相交胶囊体" class="headerlink" title="5.2.3.3 OverlapCapsuleNonAlloc 无GC相交胶囊体"></a>5.2.3.3 OverlapCapsuleNonAlloc 无GC相交胶囊体</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">CollAmount = OverlapCapsuleNonAlloc(<br>    pos1, <br>    pos2, <br>    radius, <br>    colliders, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-2-4-Physics-CheckXXX-检验体"><a href="#5-2-4-Physics-CheckXXX-检验体" class="headerlink" title="5.2.4 Physics.CheckXXX 检验体"></a>5.2.4 Physics.CheckXXX 检验体</h3><h4 id="5-2-4-1-CheckBox-检验盒"><a href="#5-2-4-1-CheckBox-检验盒" class="headerlink" title="5.2.4.1 CheckBox 检验盒"></a>5.2.4.1 CheckBox 检验盒</h4><p><strong>功能：</strong><br>创建检测盒，检测是否被碰撞。<br>较比与上面的检测方法，该类方法特点在于:<br>    <strong>检验是否发生了碰撞</strong>，而<strong>不是取得碰撞体信息</strong>，效率最高。</p><blockquote><p>注:<br>此方法同样也会检验自身collider</p></blockquote><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">IsOverlapAnyCollider = Physics.CheckBox(<br>    transform.position, <br>    transform.localScale / <span class="hljs-number">2</span>, <br>    Quaternion.identity, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>在物体中心创建检验盒，一定大小，不旋转，检测Enemy层，若有检测到碰撞则返回True</li></ul><h4 id="5-2-4-2-CheckSphere-检验球"><a href="#5-2-4-2-CheckSphere-检验球" class="headerlink" title="5.2.4.2 CheckSphere 检验球"></a>5.2.4.2 CheckSphere 检验球</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">IsOverlapAnyCollider = Physics.CheckSphere(<br>transform.position, <br>    radius, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-4-3-CheckCapsule-检验胶囊体"><a href="#5-2-4-3-CheckCapsule-检验胶囊体" class="headerlink" title="5.2.4.3 CheckCapsule 检验胶囊体"></a>5.2.4.3 CheckCapsule 检验胶囊体</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">IsOverlapAnyCollider = Physics.CheckCapsule(<br>pos1, <br>pos2，<br>    radius, <br>    LayerMask.<br>    GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-2-5-Physics-IgnoreCollision-忽略碰撞"><a href="#5-2-5-Physics-IgnoreCollision-忽略碰撞" class="headerlink" title="5.2.5 Physics.IgnoreCollision 忽略碰撞"></a>5.2.5 Physics.IgnoreCollision 忽略碰撞</h3><p><strong>功能：</strong><br>屏蔽两个collider的碰撞，第三个参数为bool</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">IgnoreCollision (collider1, collider2, ignore)<br></code></pre></td></tr></table></figure><h1 id="6-调试小技巧"><a href="#6-调试小技巧" class="headerlink" title="6. 调试小技巧"></a>6. 调试小技巧</h1><h2 id="6-1-绘制线段"><a href="#6-1-绘制线段" class="headerlink" title="6.1 绘制线段"></a>6.1 绘制线段</h2><ul><li><code>DrawLine(startPos, endPos, color)</code>：<br>绘制一条从startPos到endPos点、颜色为color的线段</li></ul><h2 id="6-2-绘制射线"><a href="#6-2-绘制射线" class="headerlink" title="6.2 绘制射线"></a>6.2 绘制射线</h2><p>使用Debug.DrawRay()方法可以在Scene中画出射线或者检测到的位置，更好的方便调试。</p><ul><li><p><code>DrawRay(startPos, direction, color)</code>：<br>绘制一条从startPos出发，指向direction的、颜色color的射线</p><blockquote><p>默认长度为单位向量，再乘以倍率即可边长<br>在下一次绘制才会覆盖上一次的射线</p></blockquote></li><li><p><code>Debug.DrawRay(startPos , direction, color, duration)</code> ：<br>同理绘制一定方向射线，但射线持续时间为duration </p></li></ul><h2 id="6-3-Gimos-DrawXXX方法"><a href="#6-3-Gimos-DrawXXX方法" class="headerlink" title="6.3 Gimos.DrawXXX方法"></a>6.3 Gimos.DrawXXX方法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123; <br>    Gizmos.DrawCube(transform.position, transform.localScale);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-GC开销问题"><a href="#7-GC开销问题" class="headerlink" title="7. GC开销问题"></a>7. GC开销问题</h1><p>从上面对几种检测方法的分析及对比其<strong>返回值</strong>不难发现：<br><strong>不同方法产生GC情况相差甚远</strong></p><p>因此在工程项目上应该慎重使用。</p><p>此处引用网友 <a href="https://www.cnblogs.com/hont/p/6180822.html">HONT</a>的测试作为GC情况参考：</p><ul><li>同方法下不同模型GC开销：<strong>Box &lt; Sphere &lt; Capsule</strong></li><li>同模型下不同方法GC开销：<strong>CheckXXX &lt; OverlapXXX &lt; XXXCast</strong></li></ul><h1 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h1><ul><li><a href="https://www.cnblogs.com/SouthBegonia/p/11732340.html">https://www.cnblogs.com/SouthBegonia/p/11732340.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>射线检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>当对象可能会根据不同的情况做出不同的行为，我们就把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。</p><p>当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变。</p><p>对这种有状态的对象编程有两种解决方法：</p><p><strong>传统的解决方案</strong>：<br>使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理。<br>但是显然这种做法存在弊端：<br>条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。</p><p><strong>状态模式的解决方案：</strong><br>当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理。<br>这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。</p><blockquote><p>状态模式<br>允许对象在内部状态改变时改变它的行为，对象看起来好像被修改了它的类</p></blockquote><h1 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h1><p>通常在以下情况下可以考虑使用状态模式。</p><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><blockquote><p>Unity中的动画控制器本质上来讲就是个使用状态模式的有限状态机</p></blockquote><h1 id="4-模式结构"><a href="#4-模式结构" class="headerlink" title="4. 模式结构"></a>4. 模式结构</h1><p>状态模式包含以下主要角色。</p><ul><li>环境类（Context）角色：<br>也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</li><li>抽象状态（State）角色：<br>定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</li><li>具体状态（Concrete State）角色：<br>实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li></ul><p>类图如下图所示：<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20210831211640607.png" srcset="/img/loading.gif" alt="image-20210831211640607"></p><h1 id="5-状态机"><a href="#5-状态机" class="headerlink" title="5. 状态机"></a>5. 状态机</h1><p>为了能够更好的描述状态模式中各种状态之间的转换关系，我们一般会使用有限状态机来更加具体的描述它。</p><h2 id="5-1-什么是状态机"><a href="#5-1-什么是状态机" class="headerlink" title="5.1 什么是状态机"></a>5.1 什么是状态机</h2><p><strong>定义:</strong><br>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。</p><p><strong>要素：</strong></p><ul><li>现态：<br>是指当前所处的状态。</li><li>条件：<br>又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</li><li>动作：<br>条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。</li><li>次态：<br>条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li></ul><h2 id="5-2-如何实现状态机"><a href="#5-2-如何实现状态机" class="headerlink" title="5.2 如何实现状态机"></a>5.2 如何实现状态机</h2><p>实现状态机主要体现在两部:<br>画出状态转换图和将有限状态机用代码实现。<br>其中代码实现部分其实就是状态模式的实现。</p><ol><li><p>画出状态转换图</p><ol><li>找出所有状态(圆圈表示)</li><li>找出所有状态间的转换条件(圆圈间的线段表示)</li><li>分析每个状态需要执行的策略(圆圈边的大括号表示)</li></ol></li><li><p>将有限状态机用代码实现</p><ol><li>定义一个状态机类</li><li>根据状态转换图的<strong>状态节点(圆圈)**，定义</strong>状态**(可使用类(推荐)，枚举或无符号整数)</li><li>根据状态转换图的<strong>转换条件(边)**，实现</strong>转换动作**方法</li></ol></li></ol><h1 id="6-模式案例"><a href="#6-模式案例" class="headerlink" title="6. 模式案例"></a>6. 模式案例</h1><h2 id="6-1-案例分析"><a href="#6-1-案例分析" class="headerlink" title="6.1 案例分析"></a>6.1 案例分析</h2><p><strong>案例描述：</strong><br>用状态模式设计一个多线程的状态转换程序</p><p><strong>状态分析：</strong><br>多线程存在 5 种状态，分别为：</p><ul><li>新建状态（New）</li><li>就绪状态（Runnable ）</li><li>运行状态（Running）</li><li>阻塞状态（Blocked）</li><li>死亡状态（Dead）</li></ul><p>各个状态当遇到相关方法调用或事件触发时会转换到其他状态。</p><p><strong>状态转换图：</strong><br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20210831223512143.png" srcset="/img/loading.gif" alt="image-20210831223512143"></p><h2 id="6-2-类定义"><a href="#6-2-类定义" class="headerlink" title="6.2 类定义"></a>6.2 类定义</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20210831223846969.png" srcset="/img/loading.gif" alt="image-20210831223846969"></p><h2 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScoreStateTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadContext context = <span class="hljs-keyword">new</span> ThreadContext();<br>        context.start();<br>        context.getCPU();<br>        context.suspend();<br>        context.resume();<br>        context.getCPU();<br>        context.stop();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//环境类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadContext</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ThreadState state;<br>    ThreadContext() &#123;<br>        state = <span class="hljs-keyword">new</span> New();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(ThreadState state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadState <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        ((New) state).start(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCPU</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Runnable) state).getCPU(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Running) state).suspend(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Running) state).stop(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Blocked) state).resume(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象状态类：线程状态</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String stateName; <span class="hljs-comment">//状态名</span><br>&#125;<br><span class="hljs-comment">//具体状态类：新建状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">New</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;新建状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：新建状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用start()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;新建状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Runnable());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是新建状态，不能调用start()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：就绪状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Runnable</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;就绪状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：就绪状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCPU</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;获得CPU时间--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;就绪状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Running());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是就绪状态，不能获取CPU.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：运行状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Running</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Running</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;运行状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：运行状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用suspend()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;运行状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Blocked());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是运行状态，不能调用suspend()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用stop()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;运行状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Dead());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是运行状态，不能调用stop()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：阻塞状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blocked</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Blocked</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;阻塞状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：阻塞状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用resume()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;阻塞状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Runnable());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是阻塞状态，不能调用resume()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：死亡状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dead</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dead</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;死亡状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：死亡状态.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">当前线程处于：新建状态.<br>调用<span class="hljs-built_in">start</span>()方法<span class="hljs-comment">--&gt;当前线程处于：就绪状态.</span><br>获得CPU时间<span class="hljs-comment">--&gt;当前线程处于：运行状态.</span><br>调用suspend()方法<span class="hljs-comment">--&gt;当前线程处于：阻塞状态.</span><br>调用resume()方法<span class="hljs-comment">--&gt;当前线程处于：就绪状态.</span><br>获得CPU时间<span class="hljs-comment">--&gt;当前线程处于：运行状态.</span><br>调用<span class="hljs-built_in">stop</span>()方法<span class="hljs-comment">--&gt;当前线程处于：死亡状态.</span><br></code></pre></td></tr></table></figure><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><h2 id="7-2-优缺点"><a href="#7-2-优缺点" class="headerlink" title="7.2 优缺点"></a>7.2 优缺点</h2><p><strong>优点：</strong></p><ul><li>结构清晰：<br>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将状态转换显示化，减少对象间的相互依赖：<br>将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，有利于程序的扩展：<br>通过定义新的子类很容易地增加新的状态和转换。</li></ul><p><strong>缺点：</strong></p><ul><li>状态模式的使用必然会增加系统的类与对象的个数。 </li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。 </li><li>状态模式对开闭原则的支持并不太好:<br>对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li></ul><h2 id="7-3-与其他模式的区别"><a href="#7-3-与其他模式的区别" class="headerlink" title="7.3 与其他模式的区别"></a>7.3 与其他模式的区别</h2><p>状态模式与策略模式看起来像双胞胎，但他们还是不相同的。</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>策略模式</td><td>将可以互换的行为封装，使用委托的方法决定使用哪个行为</td></tr><tr><td>状态莫斯</td><td>封装基于状态的行为，将行为委托至当前状态</td></tr><tr><td>模板方法</td><td>由子类决定如何实现算法中的某些步骤</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>状态模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2021/07/15/%E5%89%91%E6%8C%87offer/"/>
    <url>/2021/07/15/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h1 id="03-找出数组中重复的数字"><a href="#03-找出数组中重复的数字" class="headerlink" title="03. 找出数组中重复的数字"></a>03. 找出数组中重复的数字</h1><p>21-7-15</p><h2 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a>3.1 描述</h2><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。<br>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。<br>请找出数组中任意一个重复的数字。</p><p>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></p><h2 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h2><p>示例 1：<br>输入：<br>    [2, 3, 1, 0, 2, 5, 3]<br>输出：<br>    2 或 3<br>限制：<br>    2 &lt;= n &lt;= 100000</p><h2 id="3-3解"><a href="#3-3解" class="headerlink" title="3.3解"></a>3.3解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber1</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//哈希表法 时间复杂度o(n) 空间复杂度o(n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; numMap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (numMap.find(nums[i]) == numMap.end())<br>                numMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(nums[i], <span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//原地置换法 </span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] != nums[nums[i]])<br>                swap(nums[i], nums[nums[i]]);<br>            <span class="hljs-keyword">if</span> (nums[i] != i) <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-keyword">int</span> output;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(&#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span> &#125;)</span></span>;<br>    output =s.findRepeatNumber1(v);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    output = s.findRepeatNumber2(v);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-思路"><a href="#3-4-思路" class="headerlink" title="3.4 思路"></a>3.4 思路</h2><ul><li>要求空间复杂度低<ul><li>先排序，然后看相邻元素是否有相同的，有直接return。<br>时间复杂度O(nlogn)，空间复杂度O(1)</li><li>原地置换<br>题目说明尚未被充分使用<br>即：在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内<br>此说明含义：数组元素的 索引 和 值 是 一对多 的关系。<br>因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = inums[i]=i ）。<br>因而，就能通过索引映射对应的值，起到与字典等价的作用。</li></ul></li><li>均衡的方法<br>使用哈希表(map)<br>时间复杂度O(n)，空间复杂度O（n）</li></ul><h1 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. 二维数组中的查找</h1><p>21-7-15</p><h2 id="4-1-描述"><a href="#4-1-描述" class="headerlink" title="4.1 描述"></a>4.1 描述</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p><h2 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h2><p>现有矩阵 matrix 如下：<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p><p>限制：<br>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p><h2 id="4-3-解"><a href="#4-3-解" class="headerlink" title="4.3 解"></a>4.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (col &gt; <span class="hljs-number">-1</span> &amp;&amp; row&lt;matrix.size())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (target == matrix[row][col])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (target &gt; matrix[row][col])<br>                row++;<br>            <span class="hljs-keyword">else</span><br>                col--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a1(&#123; <span class="hljs-number">1</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a2(&#123; <span class="hljs-number">2</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a3(&#123; <span class="hljs-number">3</span>,   <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a4(&#123; <span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">24</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a5(&#123; <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">26</span>, <span class="hljs-number">30</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; inputMatrix(&#123;a1,a2,a3,a4,a5&#125;);<br>    <span class="hljs-keyword">int</span> target;<br>    <span class="hljs-keyword">bool</span> output;<br><br>    target = <span class="hljs-number">5</span>;<br>    output =s.findNumberIn2DArray(inputMatrix,target);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    target = <span class="hljs-number">20</span>;<br>    output = s.findNumberIn2DArray(inputMatrix, target);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-思路"><a href="#4-4-思路" class="headerlink" title="4.4 思路"></a>4.4 思路</h2><p>线性查找</p><p>从二维数组的右上角开始查找。</p><ul><li>如果当前元素等于目标值，则返回 true。</li><li>如果当前元素大于目标值，则移到左边一列。</li><li>如果当前元素小于目标值，则移到下边一行。</li><li>若数组为空，返回 false</li><li>循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false</li></ul><p>可以证明这种方法不会错过目标值。</p><ul><li>如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值<br>因此往下查找不可能找到目标值，往左查找可能找到目标值。</li><li>如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值<br>因此往左查找不可能找到目标值，往下查找可能找到目标值。</li></ul><h1 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a>05. 替换空格</h1><p>21-7-15</p><h2 id="5-1-描述"><a href="#5-1-描述" class="headerlink" title="5.1 描述"></a>5.1 描述</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。<br>链接：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof</a></p><h2 id="5-2-示例"><a href="#5-2-示例" class="headerlink" title="5.2 示例"></a>5.2 示例</h2><p>输入：<br>            s = “We are happy.”<br>输出：<br>            “We%20are%20happy.”</p><p>限制：<br>            0 &lt;= s 的长度 &lt;= 10000</p><h2 id="5-3-解"><a href="#5-3-解" class="headerlink" title="5.3 解"></a>5.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">string</span> output=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>)<br>                output += <span class="hljs-string">&quot;%20&quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                output += s[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">string</span> target = <span class="hljs-string">&quot;We are happy.&quot;</span>;<br>    <span class="hljs-built_in">string</span> output = s.replaceSpace(target);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-4-思路"><a href="#5-4-思路" class="headerlink" title="5.4 思路"></a>5.4 思路</h2><p>字符串拼接或转为字符数组操作</p><h1 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a>06. 从尾到头打印链表</h1><p>21-7-15</p><h2 id="6-1-描述"><a href="#6-1-描述" class="headerlink" title="6.1 描述"></a>6.1 描述</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>链接：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</a></p><h2 id="6-2-示例"><a href="#6-2-示例" class="headerlink" title="6.2 示例"></a>6.2 示例</h2><p>输入：head = [1,3,2]<br>输出：[2,3,1]<br>限制：0 &lt;= 链表长度 &lt;= 10000</p><h2 id="6-3-解"><a href="#6-3-解" class="headerlink" title="6.3 解"></a>6.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* next;<br>    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint1</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-comment">//利用vector的insert特性</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output;<br>        ListNode* p = head;<br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            output.insert(output.begin(),p-&gt;val);<br>            p = p-&gt;next;<br>        &#125; <br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint2</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-comment">//回溯法</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output;<br>        ListNode* p = head;<br>        flashBack(p, output);<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flashBack</span><span class="hljs-params">(ListNode* p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;output)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;next!= <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ListNode* q = p-&gt;next;<br>            flashBack(q, output);<br>        &#125;<br>        output.push_back(p-&gt;val);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    ListNode *target=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    target-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>    target-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output = s.reversePrint2(target);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; output.size(); i++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; output[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-4-思路"><a href="#6-4-思路" class="headerlink" title="6.4 思路"></a>6.4 思路</h2><p>法一：回溯法<br>法二：用栈<br>法三：利用vector的insert特性</p><h1 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07. 重建二叉树"></a>07. 重建二叉树</h1><p>21-7-16</p><h2 id="7-1-描述"><a href="#7-1-描述" class="headerlink" title="7.1 描述"></a>7.1 描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>相关知识点：</p><ul><li><a href="https://www.cnblogs.com/jpfss/p/11141956.html">树的三种遍历与推导</a></li></ul><p>链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof</a></p><h2 id="7-2-示例"><a href="#7-2-示例" class="headerlink" title="7.2 示例"></a>7.2 示例</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210716143123077.png" srcset="/img/loading.gif" alt="image-20210716143123077"></p><p><strong>Input:</strong><br>preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</p><p><strong>Output:</strong><br> [3,9,20,null,null,15,7]</p><h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><p><strong>Input:</strong><br>preorder = [-1], inorder = [-1]</p><p><strong>Output:</strong><br>[-1]</p><h3 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h3><p>0 &lt;= 节点个数 &lt;= 5000</p><h2 id="7-3-解"><a href="#7-3-解" class="headerlink" title="7.3 解"></a>7.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">NULL</span>), right(<span class="hljs-literal">NULL</span>) &#123;&#125;   <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;preMap;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;inoMap;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; preorder;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorder.size() == <span class="hljs-number">0</span> || inorder.size() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; preorder.size(); i++)<br>        &#123;<br>            preMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; (preorder[i],i));<br>            inoMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; (inorder[i], i));<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;preorder = preorder;<br>        <span class="hljs-keyword">this</span>-&gt;inorder = inorder;<br>        treeBuilder(<span class="hljs-number">0</span>,inorder.size()<span class="hljs-number">-1</span>, root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">treeBuilder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inorderBegin, <span class="hljs-keyword">int</span> inorderEnd, TreeNode* nowRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> boundary;<br>        boundary = inoMap[nowRoot-&gt;val];<br><br>        <span class="hljs-keyword">int</span> leftBegin = inorderBegin;<br>        <span class="hljs-keyword">int</span> leftEnd = boundary - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (leftEnd &lt; inorderBegin)leftEnd = inorderBegin;<br>        <span class="hljs-keyword">int</span> rightBegin = boundary + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (rightBegin &gt; inorderEnd)rightBegin = inorderEnd;<br>        <span class="hljs-keyword">int</span> rightEnd = inorderEnd;<br>        <span class="hljs-keyword">if</span> (leftBegin == rightEnd)<span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (inorder[leftBegin] != nowRoot-&gt;val)<br>        &#123;<br>            nowRoot-&gt;left=findRootNode(leftBegin, leftEnd);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (inorder[rightBegin] != nowRoot-&gt;val)<br>        &#123;<br>            nowRoot-&gt;right = findRootNode(rightBegin,rightEnd);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nowRoot-&gt;left !=<span class="hljs-literal">NULL</span>)<br>            treeBuilder(leftBegin, leftEnd, nowRoot-&gt;left);<br>        <span class="hljs-keyword">if</span> (nowRoot-&gt;right !=<span class="hljs-literal">NULL</span>)<br>            treeBuilder(rightBegin, rightEnd, nowRoot-&gt;right);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">findRootNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> root_p = preMap[inorder[begin]];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = begin; j &lt;= end; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (preMap[inorder[j]] &lt; root_p)<br>            &#123;<br>                root_p = preMap[inorder[j]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(preorder[root_p]);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(&#123; <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span> &#125;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorder</span><span class="hljs-params">(&#123; <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span> &#125;)</span></span>;<br>    TreeNode* output = s.buildTree(preorder,inorder);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-思路"><a href="#7-4-思路" class="headerlink" title="7.4 思路"></a>7.4 思路</h2><h3 id="7-4-1-二叉树的遍历"><a href="#7-4-1-二叉树的遍历" class="headerlink" title="7.4.1 二叉树的遍历"></a>7.4.1 二叉树的遍历</h3><p>二叉树前序遍历的顺序为：</p><ul><li>先遍历根节点；</li><li>随后递归地遍历左子树；</li><li>最后递归地遍历右子树。</li></ul><p>二叉树中序遍历的顺序为：</p><ul><li>先递归地遍历左子树；</li><li>随后遍历根节点；</li><li>最后递归地遍历右子树。</li></ul><p>在「递归」地遍历某个子树的过程中，我们也是将这颗子树看成一颗全新的树，按照上述的顺序进行遍历。<br>挖掘「前序遍历」和「中序遍历」的性质，我们就可以得出本题的做法。</p><h3 id="7-4-2-方法一：递归"><a href="#7-4-2-方法一：递归" class="headerlink" title="7.4.2 方法一：递归"></a>7.4.2 方法一：递归</h3><p>对于任意一颗树而言，前序遍历的形式总是</p><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p><p>而中序遍历的形式总是</p><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p><p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><blockquote><p>注意：<br>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。<br>我们可以考虑使用哈希表来帮助我们快速地定位根节点。<br>对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。<br>在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。<br>在此后构造二叉树的过程中，我们就只需要 O(1)O(1) 的时间对根节点进行定位了。</p></blockquote><p>复杂度分析：</p><ul><li>时间复杂度：O(n)O(n)<br>其中 nn 是树中的节点个数。</li><li>空间复杂度：O(n)O(n)<br>除去返回的答案需要的 O(n)O(n) 空间之外，我们还需要使用 O(n)O(n) 的空间存储哈希映射，以及 O(h)O(h)（其中 hh 是树的高度）的空间表示递归时栈空间。<br>这里 h &lt; nh&lt;n，所以总空间复杂度为 O(n)O(n)。</li></ul><h3 id="7-4-3-方法二：迭代"><a href="#7-4-3-方法二：迭代" class="headerlink" title="7.4.3 方法二：迭代"></a>7.4.3 方法二：迭代</h3><p>略，详见：链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</a></p><h1 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09. 用两个栈实现队列"></a>09. 用两个栈实现队列</h1><p>21-7-16</p><h2 id="9-1-描述"><a href="#9-1-描述" class="headerlink" title="9.1 描述"></a>9.1 描述</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。<br>(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a></p><h2 id="9-2-示例"><a href="#9-2-示例" class="headerlink" title="9.2 示例"></a>9.2 示例</h2><h3 id="9-2-1-示例-1："><a href="#9-2-1-示例-1：" class="headerlink" title="9.2.1 示例 1："></a>9.2.1 示例 1：</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><h3 id="9-2-2-示例-2："><a href="#9-2-2-示例-2：" class="headerlink" title="9.2.2 示例 2："></a>9.2.2 示例 2：</h3><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-literal">null</span>,<span class="hljs-number">-1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h3 id="9-2-3-提示："><a href="#9-2-3-提示：" class="headerlink" title="9.2.3 提示："></a>9.2.3 提示：</h3><p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p><h2 id="9-3-解"><a href="#9-3-解" class="headerlink" title="9.3 解"></a>9.3 解</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;a;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;b;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;<br><span class="hljs-keyword">public</span>:<br>    CQueue() <br>    &#123;<br>        <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        a.push(value);<br>        <span class="hljs-built_in">size</span>++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (b.empty())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (!a.empty())<br>            &#123;<br>                b.push(a.top());<br>                a.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> value = b.top();<br>        b.pop();<br>        <span class="hljs-built_in">size</span>--;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="9-4-思路"><a href="#9-4-思路" class="headerlink" title="9.4 思路"></a>9.4 思路</h2><p><a href="https://blog.csdn.net/cherrydreamsover/article/details/80466781">队列与栈的互相实现</a></p><p>复杂度分析</p><ul><li>时间复杂度：<br>对于插入和删除操作，时间复杂度均为 O(1)O(1)。<br>插入不多说，对于删除操作，虽然看起来是 O(n)O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 stack2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)O(1)。</li><li>空间复杂度：<br>O(n)O(n)。<br>需要使用两个栈存储已有的元素。</li></ul><h1 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10-1. 斐波那契数列"></a>10-1. 斐波那契数列</h1><p>21-7-17</p><h2 id="10-1-1-描述"><a href="#10-1-1-描述" class="headerlink" title="10-1.1 描述"></a>10-1.1 描述</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。</p><p>斐波那契数列的定义如下：<br>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1</p><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>链接：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a></p><h2 id="10-1-2-示例"><a href="#10-1-2-示例" class="headerlink" title="10-1.2 示例"></a>10-1.2 示例</h2><p><strong>示例 1：</strong><br>输入：n = 2<br>输出：1</p><p><strong>示例 2：</strong><br>输入：n = 5<br>输出：5</p><p><strong>提示：</strong><br>0 &lt;= n &lt;= 100</p><h2 id="10-1-3-解"><a href="#10-1-3-解" class="headerlink" title="10-1.3 解"></a>10-1.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;fibMap;<br>    <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    Solution()<br>    &#123;<br>        fibMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        fibMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//纯递归</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">return</span> fib1(n<span class="hljs-number">-1</span>) + fib1(n<span class="hljs-number">-2</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//带记录的递归</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">if</span> (fibMap.find(n) == fibMap.end())<br>        &#123;<br>            fibMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(n, (fib2(n - <span class="hljs-number">1</span>) + fib2(n - <span class="hljs-number">2</span>)) % mod));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (fibMap[n - <span class="hljs-number">1</span>] + fibMap[n - <span class="hljs-number">2</span>]) % mod;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//动态规划</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        *p = <span class="hljs-number">0</span>;<br>        *(p + <span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        &#123;<br>            *(p + i) = (*(p + i - <span class="hljs-number">1</span>) + *(p + i - <span class="hljs-number">2</span>))%mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *(p + n);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.fib3(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-1-4-思路"><a href="#10-1-4-思路" class="headerlink" title="10-1.4 思路"></a>10-1.4 思路</h2><p>斐波那契数列的定义是 f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ，生成第 nn 项的做法有以下几种：</p><ul><li><strong>递归法：</strong><br><strong>原理：</strong><br>把 f(n)f(n) 问题的计算拆分成 f(n-1)f(n−1) 和 f(n-2)f(n−2) 两个子问题的计算，并递归，以 f(0)f(0) 和 f(1)f(1) 为终止条件。<br><strong>缺点：</strong><br>大量重复的递归计算，例如 f(n)f(n) 和 f(n - 1)f(n−1) 两者向下递归需要 各自计算 f(n - 2)f(n−2) 的值。</li><li><strong>记忆化递归法：</strong><br><strong>原理：</strong><br>在递归法的基础上，新建一个长度为 nn 的数组，用于在递归时存储 f(0)f(0) 至 f(n)f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。<br><strong>缺点：</strong><br>记忆化存储需要使用 O(N)O(N) 的额外空间。</li><li><strong>动态规划：</strong><br><strong>原理：</strong><br>以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) 为转移方程。<br>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</li></ul><h1 id="10-2-青蛙跳台阶"><a href="#10-2-青蛙跳台阶" class="headerlink" title="10-2. 青蛙跳台阶"></a>10-2. 青蛙跳台阶</h1><p>21-7-17</p><h2 id="10-2-1-描述"><a href="#10-2-1-描述" class="headerlink" title="10-2.1 描述"></a>10-2.1 描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>链接：<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a></p><h2 id="10-2-2-示例"><a href="#10-2-2-示例" class="headerlink" title="10-2.2 示例"></a>10-2.2 示例</h2><p><strong>示例 1：</strong><br>输入：n = 2<br>输出：2</p><p><strong>示例 2：</strong><br>输入：n = 7<br>输出：21</p><p><strong>示例 3：</strong><br>输入：n = 0<br>输出：1</p><p><strong>提示：</strong><br>0 &lt;= n &lt;= 100</p><h2 id="10-2-3-解"><a href="#10-2-3-解" class="headerlink" title="10-2.3 解"></a>10-2.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        *p = <span class="hljs-number">1</span>;<br>        *(p + <span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br>        *(p + <span class="hljs-number">2</span>) = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>        &#123;<br>            *(p + i) = (*(p + i - <span class="hljs-number">1</span>) + *(p + i - <span class="hljs-number">2</span>)) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *(p + n);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.numWays(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-2-4-思路"><a href="#10-2-4-思路" class="headerlink" title="10-2.4 思路"></a>10-2.4 思路</h2><p>同10-2动态规划，略</p><h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h1><p>21-7-17</p><h2 id="11-1-描述"><a href="#11-1-描述" class="headerlink" title="11.1 描述"></a>11.1 描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a></p><h2 id="11-2-示例"><a href="#11-2-示例" class="headerlink" title="11.2 示例"></a>11.2 示例</h2><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="11-3-解"><a href="#11-3-解" class="headerlink" title="11.3 解"></a>11.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray1</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span><span class="hljs-comment">//线性查找</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers[<span class="hljs-number">0</span>]&lt;numbers[numbers.size() - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = numbers.size() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (numbers[i - <span class="hljs-number">1</span>] &gt; numbers[i])<br>                <span class="hljs-keyword">return</span> numbers[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span><span class="hljs-comment">//二分法</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> size = numbers.size();<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = size - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;<br>                <span class="hljs-comment">// [3, 4, 5, 1, 2]，mid 以及 mid 的左边一定不是最小数字</span><br>                <span class="hljs-comment">// 下一轮搜索区间是 [mid + 1, right]</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] == numbers[right]) &#123;<br>                <span class="hljs-comment">// 只能把 right 排除掉，下一轮搜索区间是 [left, right - 1]</span><br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 此时 numbers[mid] &lt; numbers[right]</span><br>                <span class="hljs-comment">// mid 的右边一定不是最小数字，mid 有可能是，下一轮搜索区间是 [left, mid]</span><br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[left];<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-4-思路"><a href="#11-4-思路" class="headerlink" title="11.4 思路"></a>11.4 思路</h2><p>二分查找（减治思想）<br>题目中给出的是半有序数组，虽然传统二分告诉我们二分只能用在有序数组中，但事实上，只要是可以减治的问题，仍然可以使用二分思想。</p><p><strong>思路：</strong><br>数组中最特殊的位置是左边位置 left 和右边位置 right，将它们与中间位置 mid 的值进行比较，进而判断最小数字出现在哪里。</p><p>用左边位置 left 和中间位置 mid 的值进行比较是否可以？<br>举例：[3, 4, 5, 1, 2] 与 [1, 2, 3, 4, 5] ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，因此这种做法不能有效地减治。</p><p>用右边位置 right 和中间位置 mid 的值进行比较是否可以？<br>举例：[1, 2, 3, 4, 5]、[3, 4, 5, 1, 2]、[2, 3, 4, 5 ,1]，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。</p><p>补充说明：遇到 nums[mid] == nums[right] 的时候，不能草率地下定结论最小数字在哪一边，但是可以确定的是，把 right 舍弃掉，并不影响结果。</p><h1 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a>12. 矩阵中的路径</h1><p>21-7-18</p><h2 id="12-1-描述"><a href="#12-1-描述" class="headerlink" title="12.1 描述"></a>12.1 描述</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。<br>如果 word 存在于网格中，返回 true ；<br>否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。<br>同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210717130732349.png" srcset="/img/loading.gif" alt="image-20210717130732349"><br>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p><h2 id="12-2-示例"><a href="#12-2-示例" class="headerlink" title="12.2 示例"></a>12.2 示例</h2><p><strong>示例 1：</strong><br>输入：<br>board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：<br>true</p><p><strong>示例 2：</strong><br>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false</p><p><strong>提示：</strong><br>1 &lt;= board.length &lt;= 200<br>1 &lt;= board[i].length &lt;= 200<br>board 和 word 仅由大小写英文字母组成</p><h2 id="12-3-解"><a href="#12-3-解" class="headerlink" title="12.3 解"></a>12.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-built_in">string</span> word;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;board;<br>    <span class="hljs-keyword">int</span> rowNum,colNum;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span> word)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        rowNum = board.size();<br>        colNum = board[<span class="hljs-number">0</span>].size();<br>        <br>        <span class="hljs-keyword">this</span>-&gt;word = word;<br>        <span class="hljs-keyword">this</span>-&gt;board = board;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rowNum; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; colNum; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (dfs(i, j, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i&gt;=rowNum || j&gt;=colNum)<span class="hljs-comment">//越界判断</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (board[i][j]==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (board[i][j] != word[k])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (k == word.size() - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            board[i][j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dfs(i + <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || dfs(i - <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || dfs(i, j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>) || dfs(i, j - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                board[i][j] = word[k];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;  <br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(&#123; <span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span> &#125;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(&#123; <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span> &#125;)</span></span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board(&#123;a,b,c&#125;);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.exist(board,<span class="hljs-string">&quot;ABCCED&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-4-思路"><a href="#12-4-思路" class="headerlink" title="12.4 思路"></a>12.4 思路</h2><p>本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。<br><img src="/images/%E5%89%91%E6%8C%87offer/image-20210718125453317.png" srcset="/img/loading.gif" alt="image-20210718125453317"></p><p><strong>深度优先搜索：</strong><br>可以理解为暴力法遍历矩阵中所有字符串可能性。<br>DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p><p><strong>剪枝：</strong><br>在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况<br>（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p><p><strong>DFS 解析：</strong></p><ul><li><p>递归参数：<br>当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</p></li><li><p>终止条件：</p><ul><li><p>返回 false：<br> (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过<br>（ (3) 可合并至 (2) ） </p></li><li><p>返回 true：<br>k = len(word) - 1 ，即字符串 word 已全部匹配。</p></li></ul></li><li><p>递推工作：</p><ul><li>标记当前矩阵元素：<br>将 board[i][j] 修改为 空字符 ‘’ ，代表此元素已访问过，防止之后搜索时重复访问。</li><li>搜索下一单元格：<br>朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。</li><li>还原当前矩阵元素：<br>将 board[i][j] 元素还原至初始值，即 word[k] 。</li><li>返回值：<br>返回布尔量 res ，代表是否搜索到目标字符串。</li></ul></li></ul><blockquote><p>使用空字符（Python: ‘’ , Java/C++: ‘\0’ ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。</p></blockquote><p><strong>复杂度分析：</strong><br>M, NM,N 分别为矩阵行列大小， KK 为字符串 word 长度。</p><ul><li><strong>时间复杂度</strong>$O(3^KMN)$：<br>最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为$O(3^K)$；<br>矩阵中共有 MN个起点，时间复杂度为 O(MN) 。</li><li><strong>方案数计算：</strong><br>设字符串长度为 KK ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 33 种选择，因此方案数的复杂度为 $O(3^K)$。</li><li><strong>空间复杂度</strong> O(K) ：<br>搜索过程中的递归深度不超过 KK ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。<br>最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN)的额外空间。</li></ul><h1 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a>13. 机器人的运动范围</h1><p>21-7-18</p><h2 id="13-1-描述"><a href="#13-1-描述" class="headerlink" title="13.1 描述"></a>13.1 描述</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。<br>一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。<br>例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。<br>但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p><h2 id="13-2-示例"><a href="#13-2-示例" class="headerlink" title="13.2 示例"></a>13.2 示例</h2><p><strong>示例 1：</strong><br>输入：m = 2, n = 3, k = 1<br>输出：3</p><p><strong>示例 2：</strong><br>输入：m = 3, n = 1, k = 0<br>输出：1</p><p><strong>提示：</strong><br>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p><h2 id="13-3-解"><a href="#13-3-解" class="headerlink" title="13.3 解"></a>13.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> rowNum,colNum;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> s1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> s2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i != <span class="hljs-number">0</span> || j!=<span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>            &#123;<br>                s1 += i % <span class="hljs-number">10</span>;<br>                i = i / <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>)<br>            &#123;<br>                s2 += j % <span class="hljs-number">10</span>;<br>                j = j / <span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s1+s2&lt;=k;<br>    &#125;<br>    <span class="hljs-keyword">int</span> m, n, k;<br>    <span class="hljs-keyword">int</span> counter;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;* visited;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        rowNum = m;<br>        colNum = n;<br>        <span class="hljs-keyword">this</span>-&gt;k=k;<br>        counter = <span class="hljs-number">0</span>;<br>        visited=<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-number">0</span>));<br>        bfs();<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>*&gt;q;<br>        q.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]&#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;);<br>        <span class="hljs-keyword">while</span> (!q.empty())<br>        &#123;<br>            <span class="hljs-keyword">int</span>* p = q.front();<br>            <span class="hljs-keyword">int</span> i = p[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> j = p[<span class="hljs-number">1</span>];<br>            q.pop();<br><br>            <span class="hljs-keyword">if</span> (i &gt;= rowNum || j &gt;= colNum || !sums(i, j) || visited-&gt;at(i).at(j))<br>                <span class="hljs-keyword">continue</span>;<br>            counter++;<br>            visited-&gt;at(i).at(j) = <span class="hljs-literal">true</span>;<br><br>            q.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]&#123; i + <span class="hljs-number">1</span>,j &#125;); <br>            q.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]&#123; i,j + <span class="hljs-number">1</span> &#125;);     <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= rowNum || j &gt;= colNum)<span class="hljs-comment">//越界判断</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (visited-&gt;at(i).at(j))<br>            <span class="hljs-keyword">return</span>;<br>        visited-&gt;at(i).at(j) = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!sums(i, j))<br>            <span class="hljs-keyword">return</span>;<br>        counter++;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        dfs(i + <span class="hljs-number">1</span>, j);<br>        dfs(i, j + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.movingCount(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">17</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-4-思路"><a href="#13-4-思路" class="headerlink" title="13.4 思路"></a>13.4 思路</h2><p>类似与12题，深搜与广搜两种解法</p><h1 id="14-剪绳子1"><a href="#14-剪绳子1" class="headerlink" title="14. 剪绳子1"></a>14. 剪绳子1</h1><p>21-7-19</p><h2 id="14-1-描述"><a href="#14-1-描述" class="headerlink" title="14.1 描述"></a>14.1 描述</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。<br>请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？</p><p>例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>链接：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p><h2 id="14-2-示例"><a href="#14-2-示例" class="headerlink" title="14.2 示例"></a>14.2 示例</h2><p><strong>示例 1：</strong><br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p><p><strong>示例 2:</strong><br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p><strong>提示：</strong><br>2 &lt;= n &lt;= 58</p><h2 id="14-3-解"><a href="#14-3-解" class="headerlink" title="14.3 解"></a>14.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dpf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//动态规划</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>* dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> max_val = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++)<br>            &#123;<br>                max_val = max(max_val, dp[i - j] * dp[j]);<br>            &#125;<br>            dp[i] = max_val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">greedy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//贪心算法</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-comment">//能全部拆成3</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>) <span class="hljs-comment">//余1，少拆个3，换成3+1=4</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;<span class="hljs-comment">//余2，直接乘2</span><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.dpf(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.greedy(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-4-思路"><a href="#14-4-思路" class="headerlink" title="14.4 思路"></a>14.4 思路</h2><h3 id="14-4-1-动态规划"><a href="#14-4-1-动态规划" class="headerlink" title="14.4.1 动态规划"></a>14.4.1 动态规划</h3><p><strong>算法流程：</strong></p><ul><li>我们想要求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来</li><li>用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1</li><li>我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪</li><li>剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话长度乘积即为j * (i - j)；如果剪的话长度乘积即为j * dp[i - j]。取两者最大值max(j * (i - j), j * dp[i - j])</li><li>第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为<br>dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</li><li>最后返回dp[n]即可</li></ul><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n ^ 2)<em>O</em>(<em>n</em>2)</li><li>空间复杂度：O(n)<em>O</em>(<em>n</em>)</li></ul><h3 id="14-4-2-贪心算法"><a href="#14-4-2-贪心算法" class="headerlink" title="14.4.2 贪心算法"></a>14.4.2 贪心算法</h3><p>找规律或数学证明可知： <strong>尽可能将绳子以长度 3 等分为多段时，乘积最大。</strong></p><p><strong>算法流程：</strong><br>当 n≤3 时，按照规则应不切分，但由于题目要求必须剪成 m&gt;1 段，因此必须剪出一段长度为 1 的绳子，即返回 n - 1。<br>当 n&gt;3时，求 n除以 3 的 整数部分 a 和 余数部分 b（即 n = 3a + b），并分为以下三种情况：</p><ul><li>当 b = 0时，直接返回 pow(3,a)；</li><li>当 b = 1时，要将一个 1 + 3 转换为 2+2，因此返回pow(3,a-1)*4；</li><li>当 b = 2b=2 时，返回 pow(3,a)*2 ;</li></ul><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1)：<br>仅有求整、求余、次方运算。<ul><li>求整和求余运算：<br>资料提到不超过机器数的整数可以看作是 O(1)O(1) ；</li><li>幂运算：<br>查阅资料，提到浮点取幂为 O(1)O(1) 。</li></ul></li><li>空间复杂度 O(1)： 变量 a 和 b 使用常数大小额外空间。</li></ul><h1 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a>15. 二进制中1的个数</h1><p>21-7-19</p><h2 id="15-1-描述"><a href="#15-1-描述" class="headerlink" title="15.1 描述"></a>15.1 描述</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p><blockquote><p>提示：<br>请注意，在某些语言（如 Java）中，没有无符号整数类型。<br>在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。<br>因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p></blockquote><p>链接：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p><h2 id="15-2-示例"><a href="#15-2-示例" class="headerlink" title="15.2 示例"></a>15.2 示例</h2><p><strong>示例 1：</strong><br>输入：n = 11<br>(控制台输入 00000000000000000000000000001011)<br>输出：3<br>解释：<br>输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p><p><strong>示例 2：</strong><br>输入：n = 128<br>(控制台输入 00000000000000000000000010000000)<br>输出：1<br>解释：<br>输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p><p><strong>示例 3：</strong><br>输入：n = 4294967293<br> (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）<br>输出：31<br>解释：<br>输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><p><strong>提示：</strong><br>输入必须是长度为 32 的 二进制串 。</p><h2 id="15-3-解"><a href="#15-3-解" class="headerlink" title="15.3 解"></a>15.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>)<br>                counter++;<br>            n = n &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.hammingWeight(<span class="hljs-number">4294967293</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-4-思路"><a href="#15-4-思路" class="headerlink" title="15.4 思路"></a>15.4 思路</h2><p>简单位运算，略</p><h1 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a>16. 数值的整数次方</h1><p>21-7-26</p><h2 id="16-1-描述"><a href="#16-1-描述" class="headerlink" title="16.1 描述"></a>16.1 描述</h2><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。</p><p>不得使用库函数，同时不需要考虑大数问题。</p><p>链接：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p><h2 id="16-2-示例"><a href="#16-2-示例" class="headerlink" title="16.2 示例"></a>16.2 示例</h2><p><strong>示例 1：</strong><br>输入：x = 2.00000, n = 10<br>输出：1024.00000</p><p><strong>示例 2：</strong><br>输入：x = 2.10000, n = 3<br>输出：9.26100</p><p><strong>示例 3：</strong><br>输入：x = 2.00000, n = -2<br>输出：0.25000<br>解释：2-2 = 1/22 = 1/4 = 0.25</p><p><strong>提示：</strong><br>-100.0 &lt; x &lt; 100.0<br>-231 &lt;= n &lt;= 231-1<br>-104 &lt;= xn &lt;= 104</p><h2 id="16-3-解"><a href="#16-3-解" class="headerlink" title="16.3 解"></a>16.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow1</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span> </span><br><span class="hljs-function">        <span class="hljs-comment">//递归快速幂+位运算(会爆栈)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>/myPow1(x, -n);<br><br>        <span class="hljs-keyword">if</span>((n&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> myPow1(x, n<span class="hljs-number">-1</span>)*x;<br>        n = n &gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">double</span> t = myPow1(x, n);<br>        <span class="hljs-keyword">return</span> t * t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow2</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//迭代快速幂</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / x;<br><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            n = -n;<br>            x = <span class="hljs-number">1.0</span> / x;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> output = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>                output *= x;<br>            x *= x;<br>            n = n &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow3</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//2分法</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / x;<br>        <span class="hljs-keyword">double</span> half = myPow3(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">double</span> mod = myPow3(x, n % <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> half * half * mod;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.myPow2(<span class="hljs-number">2.00000</span>, <span class="hljs-number">-2147483648</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="16-4-思路"><a href="#16-4-思路" class="headerlink" title="16.4 思路"></a>16.4 思路</h2><ul><li>快速幂</li><li>二分法</li><li>位运算</li><li>int类型边界<br>-2147483648</li></ul><h1 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a>17. 打印从1到最大的n位数</h1><p>21-7-26</p><h2 id="17-1-描述"><a href="#17-1-描述" class="headerlink" title="17.1 描述"></a>17.1 描述</h2><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。</p><p>比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>链接：<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</a></p><h2 id="17-2-示例"><a href="#17-2-示例" class="headerlink" title="17.2 示例"></a>17.2 示例</h2><p><strong>示例 1:</strong><br>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p><p><strong>说明：</strong><br>用返回一个整数列表来代替打印<br>n 为正整数</p><h2 id="17-3-解"><a href="#17-3-解" class="headerlink" title="17.3 解"></a>17.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">char</span> numChar[<span class="hljs-number">10</span>] = &#123; <span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span> &#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; output;<br>    <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        dfs(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;intOutput;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; output.size(); i++)<br>        &#123;<br>            intOutput.push_back(atoi(output[i].c_str()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> intOutput;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> num,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == n)<br>        &#123;<br>            output.push_back(num);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">string</span> str = num+numChar[i];<br>            dfs(str, x + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;intOutput=s.printNumbers(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intOutput.size(); i++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; intOutput[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="17-4-思路"><a href="#17-4-思路" class="headerlink" title="17.4 思路"></a>17.4 思路</h2><p>本题的主要考点是大数越界情况下的打印。</p><p>需要解决以下三个问题：</p><ul><li>表示大数的变量类型：<br>无论是 short / int / long … 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。</li><li>生成数字的字符串集：<br>使用 int 类型时，每轮可通过 +1+1 生成下个数字，而此方法无法应用至 String 类型。<br>并且， String 类型的数字的进位操作效率较低，例如 “9999” 至 “10000” 需要从个位到千位循环判断，进位 4 次。<br>观察可知，生成的列表实际上是 nn 位 00 - 99 的 全排列 ，因此可避开进位操作，通过递归生成数字的 String 列表。</li><li>递归生成全排列：<br>基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。<br>例如当 n = 2n=2 时（数字范围 1 - 991−99 ），固定十位为 00 - 99 ，按顺序依次开启递归，固定个位 00 - 99 ，终止递归并添加数字字符串。</li></ul><p><img src="../images/%E5%89%91%E6%8C%87offer/image-20210726150257820.png" srcset="/img/loading.gif" alt="image-20210726150257820"></p><p>即：使用深度优先搜索算法(dfs)。</p><h1 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h1><p>21-7-26</p><h2 id="18-1-描述"><a href="#18-1-描述" class="headerlink" title="18.1 描述"></a>18.1 描述</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。<br>链接：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a></p><h2 id="18-2-示例"><a href="#18-2-示例" class="headerlink" title="18.2 示例"></a>18.2 示例</h2><p><strong>示例 1:</strong><br>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p><strong>示例 2:</strong><br>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p><strong>说明：</strong><br>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><h2 id="18-3-解"><a href="#18-3-解" class="headerlink" title="18.3 解"></a>18.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* next;<br>    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (head-&gt;val == val)<span class="hljs-keyword">return</span> head-&gt;next;<br>        ListNode* p, * q;<br>        p = head;<br>        q = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (q-&gt;next!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (q-&gt;val == val)<br>            &#123;<br>                p-&gt;next = q-&gt;next;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            p = p-&gt;next;<br>            q = p-&gt;next;<br>        &#125;<br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br>    <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    ListNode* head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    ListNode* p = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        p-&gt;next = <span class="hljs-keyword">new</span> ListNode(i);<br>        p = p-&gt;next;<br>    &#125;<br>    p = s.deleteNode(head, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; p-&gt;val &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        p = p-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-4-思路"><a href="#18-4-思路" class="headerlink" title="18.4 思路"></a>18.4 思路</h2><p>简单的链表删除节点，双指针操作</p><h1 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19.正则表达式匹配"></a>19.正则表达式匹配</h1><p>21-7-26</p><h2 id="19-1-描述"><a href="#19-1-描述" class="headerlink" title="19.1 描述"></a>19.1 描述</h2><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。</em></p><p><em>模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。</p><p>在本题中，匹配是指字符串的所有字符匹配整个模式。<br>例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><p>链接：<a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p><h2 id="19-2-示例"><a href="#19-2-示例" class="headerlink" title="19.2 示例"></a>19.2 示例</h2><p><strong>示例 1:</strong><br>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p><p><strong>示例 2:</strong><br>输入:<br>s = “aa”<br>p = “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p><strong>示例 3:</strong><br>输入:<br>s = “ab”<br>p = “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。</p><p><strong>示例 4:</strong><br>输入:<br>s = “aab”<br>p = “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p><p><strong>示例 5:</strong><br>输入:<br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br>输出: false</p><p><strong>注意：</strong></p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘\</em>’。</li></ul><h2 id="19-3-解"><a href="#19-3-解" class="headerlink" title="19.3 解"></a>19.3 解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> m = s.size()+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> n = p.size()+<span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; dp(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 初始化首行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; n; j += <span class="hljs-number">2</span>)<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>] &amp;&amp; p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (dp[i][j - <span class="hljs-number">2</span>] ||<br>                        (dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">2</span>]) ||<br>                        (dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; p[j - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                    &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> ((dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>]) ||<br>                        dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span><br>                        )<br>                    &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;   <br>                &#125;<br>                dp[i][j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br>    <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.isMatch(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-4-思路"><a href="#19-4-思路" class="headerlink" title="19.4 思路"></a>19.4 思路</h2><ul><li><p>状态数组：设二维数组</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dp</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>，m和n是s、p的长度</p><ul><li>特殊说明：<code>dp[i][j]</code>表示s下标为<code>s[i-1]</code>的字符，p下标为<code>p[j-1]</code>字符</li></ul></li><li><p>初始化：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span><br></code></pre></td></tr></table></figure><p>表示 s的前i个字符和p的前j个字符是否匹配</p><ul><li><code>dp[0][0]=true</code>，表示s和p的前0个字符均为空串肯定匹配</li><li>若s是空串且p 的偶数次下标为$*$,那也是匹配的</li></ul></li><li><p>状态转移：</p><ul><li><pre><code>p.charAt(j - 1) == &#39;*&#39;<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>  ,有三种情况匹配<br><br>  - `dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j - 2]</span>`，既是`<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-2]</span>`出现<span class="hljs-number">0</span>次<br>  - `(dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> &amp;&amp; s<span class="hljs-selector-class">.charAt</span>(<span class="hljs-selector-tag">i</span> - <span class="hljs-number">1</span>) == <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.charAt</span>(j - <span class="hljs-number">2</span>)`，`<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-2]</span>`出现<span class="hljs-number">1</span>次 且 当前i-<span class="hljs-number">1</span>和j-<span class="hljs-number">2</span>指向的字符相同<br>  - `dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> &amp;&amp; <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.charAt</span>(j - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>`，最特殊情况:`<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-2]</span>=. <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-1]</span>=*`时，根据条件知是万能匹配<br><br>- ```<br>  <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.charAt</span>(j - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure>,有两种情况匹配- `dp[i - 1][j - 1] &amp;&amp; s.charAt(i - 1) == p.charAt(j - 1)`，前面元素之前都匹配 且 当前元素也相容- `dp[i - 1][j - 1] &amp;&amp; p.charAt(j - 1) == &#39;.&#39;`，前面元素之前都匹配 且 p的当期元素是`.`</code></pre></li></ul></li><li><p>返回值：<code>dp[m-1][n-1]</code></p></li></ul><h1 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串"></a>20. 表示数值的字符串</h1><p>21-7-26</p><h2 id="20-1-描述"><a href="#20-1-描述" class="headerlink" title="20.1 描述"></a>20.1 描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><p>数值（按顺序）可以分成以下几个部分：</p><ul><li><p>若干空格</p></li><li><p>一个 小数 或者 整数</p></li><li><p>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</p></li><li><p>若干空格</p></li></ul><p>小数（按顺序）可以分成以下几个部分：</p><ul><li>（可选）一个符号字符（’+’ 或 ‘-‘）</li><li>下述格式之一：<ul><li>至少一位数字，后面跟着一个点 ‘.’</li><li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li><li>一个点 ‘.’ ，后面跟着至少一位数字</li></ul></li></ul><p>整数（按顺序）可以分成以下几个部分：</p><ul><li><p>（可选）一个符号字符（’+’ 或 ‘-‘）</p></li><li><p>至少一位数字</p></li></ul><p>部分数值列举如下：</p><ul><li>[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]</li></ul><p>部分非数值列举如下：</p><ul><li>[“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”]</li></ul><p>链接：<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof</a></p><h2 id="20-2-示例"><a href="#20-2-示例" class="headerlink" title="20.2 示例"></a>20.2 示例</h2><p><strong>示例 1：</strong><br>输入：s = “0”<br>输出：true</p><p><strong>示例 2：</strong><br>输入：s = “e”<br>输出：false</p><p><strong>示例 3：</strong><br>输入：s = “.”<br>输出：false</p><p><strong>示例 4：</strong><br>输入：s = “    .1  “<br>输出：true</p><p><strong>提示：</strong><br>1 &lt;= s.length &lt;= 20<br>s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，空格 ‘ ‘ 或者点 ‘.’ 。</p><h2 id="20-3-解"><a href="#20-3-解" class="headerlink" title="20.3 解"></a>20.3 解</h2><h2 id="20-4-思路"><a href="#20-4-思路" class="headerlink" title="20.4 思路"></a>20.4 思路</h2><h1 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h1><h2 id="21-1-描述"><a href="#21-1-描述" class="headerlink" title="21.1 描述"></a>21.1 描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p>链接：<a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</a></p><h2 id="21-2-示例"><a href="#21-2-示例" class="headerlink" title="21.2 示例"></a>21.2 示例</h2><p><strong>示例：</strong><br>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p><p><strong>提示：</strong><br>0 &lt;= nums.length &lt;= 50000<br>1 &lt;= nums[i] &lt;= 10000</p><h2 id="21-3-解"><a href="#21-3-解" class="headerlink" title="21.3 解"></a>21.3 解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>]</span>) -&gt; List[int]:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> nums<br>        iStart = <span class="hljs-number">0</span><br>        iEnd = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> iStart != iEnd:<br>            <span class="hljs-keyword">if</span> nums[iStart] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                iStart += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> nums[iEnd] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                iEnd -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            t = nums[iStart]<br>            nums[iStart] = nums[iEnd]<br>            nums[iEnd] = t<br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure><h2 id="21-4-思路"><a href="#21-4-思路" class="headerlink" title="21.4 思路"></a>21.4 思路</h2><p>双指针</p><h1 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22. 链表中倒数第k个节点"></a>22. 链表中倒数第k个节点</h1><h2 id="22-1-描述"><a href="#22-1-描述" class="headerlink" title="22.1 描述"></a>22.1 描述</h2><p>输入一个链表，输出该链表中倒数第k个节点。<br>为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。<br>这个链表的倒数第 3 个节点是值为 4 的节点。</p><p>链接：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></p><h2 id="22-2-示例"><a href="#22-2-示例" class="headerlink" title="22.2 示例"></a>22.2 示例</h2><p><strong>示例：</strong><br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2。<br>返回链表 4-&gt;5。</p><h2 id="22-3-解"><a href="#22-3-解" class="headerlink" title="22.3 解"></a>22.3 解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getKthFromEnd</span>(<span class="hljs-params">self, head: ListNode, k: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span><br>        <span class="hljs-keyword">if</span> head == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        first = head<br>        last = head<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k-<span class="hljs-number">1</span>):<br>            first = first.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> first == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> first.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            first = first.<span class="hljs-built_in">next</span><br>            last = last.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> last<br></code></pre></td></tr></table></figure><h2 id="22-4-思路"><a href="#22-4-思路" class="headerlink" title="22.4 思路"></a>22.4 思路</h2><p>快慢双指针</p><h1 id="24-反转列表"><a href="#24-反转列表" class="headerlink" title="24.  反转列表"></a>24.  反转列表</h1><h2 id="24-1-描述"><a href="#24-1-描述" class="headerlink" title="24.1 描述"></a>24.1 描述</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a></p><h2 id="24-2-示例"><a href="#24-2-示例" class="headerlink" title="24.2 示例"></a>24.2 示例</h2><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>限制：<br>0 &lt;= 节点个数 &lt;= 5000</p><h2 id="24-3-解"><a href="#24-3-解" class="headerlink" title="24.3 解"></a>24.3 解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>         self.val = x<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head</span>):</span><br>        <span class="hljs-keyword">if</span> head == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> head.<span class="hljs-built_in">next</span> == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> head<br>        <br>        first = head<br>        last = <span class="hljs-literal">None</span><br>        t = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> t <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            first.<span class="hljs-built_in">next</span> = last<br>            last = first<br>            first = t<br>            t = t.<span class="hljs-built_in">next</span><br>        first.<span class="hljs-built_in">next</span> = last<br>        <span class="hljs-keyword">return</span> first<br>        <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    head = ListNode(<span class="hljs-number">1</span>)<br>    Node1 = ListNode(<span class="hljs-number">2</span>)<br>    head.<span class="hljs-built_in">next</span> = Node1<br>    Node2 = ListNode(<span class="hljs-number">3</span>)<br>    Node1.<span class="hljs-built_in">next</span> = Node2<br>    s = Solution()<br>    output = s.reverseList(head)<br>    <span class="hljs-keyword">while</span> output <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        print(output.val)<br>        output = output.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="24-4-思路"><a href="#24-4-思路" class="headerlink" title="24.4 思路"></a>24.4 思路</h2><p>快慢三指针</p><h1 id="25-合并两个排序的列表"><a href="#25-合并两个排序的列表" class="headerlink" title="25. 合并两个排序的列表"></a>25. 合并两个排序的列表</h1><h2 id="25-1-描述"><a href="#25-1-描述" class="headerlink" title="25.1 描述"></a>25.1 描述</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><h2 id="25-2-示例"><a href="#25-2-示例" class="headerlink" title="25.2 示例"></a>25.2 示例</h2><p><strong>示例1：</strong><br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p><strong>限制：</strong><br>0 &lt;= 链表长度 &lt;= 1000</p><h2 id="25-3-解"><a href="#25-3-解" class="headerlink" title="25.3 解"></a>25.3 解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>         self.val = x<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br>        <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> l2<br>        <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> l1<br>        p1 = l1<br>        p2 = l2<br>        head = ListNode(-<span class="hljs-number">1</span>)<br>        p3 = head<br>        <span class="hljs-keyword">while</span> p1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> p2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> p1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                p3.<span class="hljs-built_in">next</span> = p2<br>                p2 = p2.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> p2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                p3.<span class="hljs-built_in">next</span> = p1<br>                p1 = p1.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> p1.val &lt; p2.val:<br>                p3.<span class="hljs-built_in">next</span> = p1<br>                p1 = p1.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                p3.<span class="hljs-built_in">next</span> = p2<br>                p2 = p2.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br>        <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    head1 = ListNode(<span class="hljs-number">1</span>)<br>    Node1 = ListNode(<span class="hljs-number">3</span>)<br>    head1.<span class="hljs-built_in">next</span> = Node1<br>    Node2 = ListNode(<span class="hljs-number">5</span>)<br>    Node1.<span class="hljs-built_in">next</span> = Node2<br><br>    head2 = ListNode(<span class="hljs-number">2</span>)<br>    Node1 = ListNode(<span class="hljs-number">4</span>)<br>    head2.<span class="hljs-built_in">next</span> = Node1<br>    Node2 = ListNode(<span class="hljs-number">6</span>)<br>    Node1.<span class="hljs-built_in">next</span> = Node2<br><br>    s = Solution()<br>    output = s.mergeTwoLists(head1, head2)<br>    <span class="hljs-keyword">while</span> output <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        print(output.val)<br>        output = output.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="25-4-思路"><a href="#25-4-思路" class="headerlink" title="25.4 思路"></a>25.4 思路</h2><p>归并排序</p><h1 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h1><h2 id="27-1-描述"><a href="#27-1-描述" class="headerlink" title="27.1 描述"></a>27.1 描述</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a></p><h2 id="27-2-示例"><a href="#27-2-示例" class="headerlink" title="27.2 示例"></a>27.2 示例</h2><p>例如输入：<br>     4<br>   /   <br>  2     7<br> / \   / <br>1   3 6   9</p><p>镜像输出：<br>     4<br>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p><p><strong>示例 1：</strong></p><p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p><strong>限制：</strong></p><p>0 &lt;= 节点个数 &lt;= 1000</p><h2 id="27-3-解"><a href="#27-3-解" class="headerlink" title="27.3 解"></a>27.3 解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mirrorTree</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        self.dfs(root)<br>        <span class="hljs-keyword">return</span> root<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self,root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <br>        t = root.left<br>        root.left = root.right<br>        root.right = t<br>        self.dfs(root.left)<br>        self.dfs(root.right)<br></code></pre></td></tr></table></figure><h2 id="27-4-思路"><a href="#27-4-思路" class="headerlink" title="27.4 思路"></a>27.4 思路</h2><p>递归与深度优先搜索</p><h1 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a>28. 对称的二叉树</h1><h2 id="28-1-描述"><a href="#28-1-描述" class="headerlink" title="28.1 描述"></a>28.1 描述</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>    1<br>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br>    1<br>   / <br>  2   2<br>   \   <br>   3    3</p><p>链接：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof</a></p><h2 id="28-2-示例"><a href="#28-2-示例" class="headerlink" title="28.2 示例"></a>28.2 示例</h2><p><strong>示例 1：</strong><br>输入：root = [1,2,2,3,4,4,3]<br>输出：true</p><p><strong>示例 2：</strong><br>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><p><strong>限制：</strong><br>0 &lt;= 节点个数 &lt;= 1000</p><h2 id="28-3-解"><a href="#28-3-解" class="headerlink" title="28.3 解"></a>28.3 解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSymmetric</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> self.dfs(root.left,root.right)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self,L,R</span>):</span><br>        <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> R <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> R <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> L.val != R.val:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> self.dfs(L.left,R.right) <span class="hljs-keyword">and</span> self.dfs(L.right,R.left)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>New2048开发文档</title>
    <link href="/2021/07/01/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <url>/2021/07/01/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="New2048开发日志"><a href="#New2048开发日志" class="headerlink" title="New2048开发日志"></a>New2048开发日志</h1><p><strong>项目信息：</strong><br>项目负责人：买烤麸烤饼<br>主程序：买烤麸烤饼<br>美工：买烤麸烤饼<br>音效：洛一<br>配音：小鸠<br>项目开发周期：2021.6.25-2021.7.4</p><p><strong>版本信息：</strong></p><ul><li>v1.0 完成2048的基础玩法</li><li>v2.0 增加球球新玩法</li></ul><h1 id="1-玩法分析"><a href="#1-玩法分析" class="headerlink" title="1. 玩法分析"></a>1. 玩法分析</h1><h2 id="1-1-经典模式"><a href="#1-1-经典模式" class="headerlink" title="1.1 经典模式"></a>1.1 经典模式</h2><p><strong>游戏原型：</strong>2048</p><p><strong>游戏目标：</strong><br>合成更多数字块以得到更高的分数</p><p><strong>得分计算：</strong><br>当两个相同数字块合并时，得分+=新数字块的数字</p><p><strong>玩家操作：</strong></p><ul><li>向上滑动<br>上方向键</li><li>向下滑动<br>下方向键</li><li>向左滑动<br>左方向键</li><li>向右滑动<br>右方向键</li></ul><p><strong>失败判定：</strong><br>棋盘被数字填满，无法进行有效移动，判负，游戏结束。</p><p><strong>流程简述：</strong><br>开始时棋盘内随机出现两个数字<br>出现的数字仅可能为2或4。</p><p>玩家可以选择上下左右四个方向<br>若棋盘内的数字出现位移或合并，视为有效移动。</p><p>玩家选择的方向上若有相同的数字则合并<br>每次有效移动可以同时合并，但不可以连续合并。</p><p>合并所得的所有新生成数字想加即为该步的有效得分。</p><p>玩家选择的方向行或列前方有空格则出现位移。</p><p>每有效移动一步，棋盘的空位(无数字处)随机出现一个数字(依然可能为2或4)。</p><p>棋盘被数字填满，无法进行有效移动，判负，游戏结束。</p><p>棋盘上出现2048，判胜，游戏结束。<br>也可以继续游戏，攒出更大的数字</p><h2 id="1-1-球球模式"><a href="#1-1-球球模式" class="headerlink" title="1.1 球球模式"></a>1.1 球球模式</h2><p><strong>游戏原型：</strong>合成大西瓜</p><p><strong>游戏目标：</strong><br>合成更多数字球以得到更高的分数</p><p><strong>得分计算：</strong><br>当两个相同数字球合并时，得分+=新数字块的数字</p><p><strong>玩家操作：</strong></p><ul><li>触摸控制球球生成位置<br>鼠标控制球球生成位置</li><li>长按抖动水池<br>按空格抖动水池</li></ul><p><strong>失败判断：</strong><br>当水池被球球填满时游戏结束</p><p><strong>流程简述：</strong><br>随机生成2，4，8的球，掉落至水池中<br>遇到相同数字的球则合并</p><p>玩家可以在水池上方控制潜水艇的左右位置决定新生成球的位置</p><p>当水池被填满时游戏结束</p><h1 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h1><h2 id="2-1-游戏实体分析"><a href="#2-1-游戏实体分析" class="headerlink" title="2.1 游戏实体分析"></a>2.1 游戏实体分析</h2><h3 id="2-1-1-经典模式"><a href="#2-1-1-经典模式" class="headerlink" title="2.1.1 经典模式"></a>2.1.1 经典模式</h3><ul><li>数字块<br>有数字2,4,8,16,32…<br>不同数字使用不同的精灵图片<br>但是是同一个预制体</li><li>棋盘<br>能放下4*4=16个数字块的棋盘</li></ul><h3 id="2-1-2-球球模式"><a href="#2-1-2-球球模式" class="headerlink" title="2.1.2 球球模式"></a>2.1.2 球球模式</h3><ul><li>数字球<br>有数字2,4,8,16,32…<br>不同数字使用不同的精灵图片，有不同的大小<br>但是是同一个预制体</li><li>水池<br>左，右，下三个方向有碰撞体积<br>上方有触发器<br>可以晃动</li><li>潜水艇<br>通过潜水艇来释放数字球<br>潜水艇在水池上方固定高度移动</li></ul><h2 id="2-2-UI需求分析"><a href="#2-2-UI需求分析" class="headerlink" title="2.2 UI需求分析"></a>2.2 UI需求分析</h2><p>UI需求树如下：</p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210911211247880.png" srcset="/img/loading.gif" alt="UI需求树"></p><h2 id="2-3-音效需求分析"><a href="#2-3-音效需求分析" class="headerlink" title="2.3 音效需求分析"></a>2.3 音效需求分析</h2><p><strong>配音内容：</strong></p><table><thead><tr><th>用于</th><th>内容</th><th>描述</th></tr></thead><tbody><tr><td>游戏开始</td><td>Game Start！</td><td>日式大佐英语，元气语气</td></tr><tr><td>游戏开始</td><td>游戏开始了哦！</td><td>中文，认真系美少女语气</td></tr><tr><td>游戏结束</td><td>Game Over…</td><td>日式大佐英语，惋惜语气</td></tr><tr><td>游戏结束</td><td>失敗しました(失败啦…)</td><td>日语，无口少女棒读</td></tr><tr><td>新纪录</td><td>New Score！</td><td>日式大佐英语，元气语气</td></tr></tbody></table><p>配音员：小鸠</p><ul><li>BGM 一条</li><li>人声配音5条</li></ul><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h1><h2 id="3-1-工程类图"><a href="#3-1-工程类图" class="headerlink" title="3.1 工程类图"></a>3.1 工程类图</h2><h3 id="3-1-1-主场景-HomePageScene"><a href="#3-1-1-主场景-HomePageScene" class="headerlink" title="3.1.1 主场景(HomePageScene)"></a>3.1.1 主场景(HomePageScene)</h3><p><strong>实体类图设计</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210704201328215.png" srcset="/img/loading.gif" alt="主场景(HomePageScene)实体类图设计"></p><p><strong>活动图</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210704203522669.png" srcset="/img/loading.gif" alt="主场景活动图"></p><p><strong>View视图类：</strong></p><p>该场景为游戏开始时的主场景，用于玩家选择模式，加载游戏，查看游戏介绍等功能的实现。<br>在该场景下有一个主画布，该主画布下有3个功能面板，详细情况如下：</p><ul><li>HomePanel<br>主面板<br>是游戏的入口界面</li><li>AboutPanel<br>关于面板<br>是游戏的介绍界面</li><li>ModeChosePanel<br>模式选择面板<br>用于选择开始与加载的游戏模式</li></ul><p>该场景的所有视图对象(UI)由<strong>HomePageUIManager</strong>类控制，它作为组件挂载在主画布<strong>Canvas</strong>上，其中包含了各个面板的全部按键响应函数。</p><p><strong>Controller控制类：</strong></p><p><strong>PlayerSetting</strong>类是该场景的唯一控制类，该类用于记录用户两种游戏设置：</p><ul><li>bool Mute<br>游戏是否静音</li><li>bool IsLoad<br>是否加载之前保存的游戏进度</li></ul><p>该类的脚本挂载至一个名叫<strong>PlayerSetting</strong>的空物体上，并设置为<strong>DontDestroyOnLoad</strong>(切换场景时不销毁该GO)。它会传递到下一个场景，即游戏场景，来决定是否加载之前保存的游戏进度。</p><h3 id="3-1-2-经典模式场景-GameScene1"><a href="#3-1-2-经典模式场景-GameScene1" class="headerlink" title="3.1.2 经典模式场景(GameScene1)"></a>3.1.2 经典模式场景(GameScene1)</h3><p><strong>实体类图设计:</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt="经典模式实体类图"></p><p><strong>场景活动图:</strong></p><p><img src="images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2048-%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%BC%8F%E5%9C%BA%E6%99%AF%E6%B4%BB%E5%8A%A8%E5%9B%BE.png" srcset="/img/loading.gif" alt="2048-经典模式场景活动图"></p><p><strong>View视图类:</strong></p><p>该场景为经典模式游戏的场景，用于玩家游玩经典模式的2048小游戏。<br>在该场景下有三个画布，详细情况如下：</p><ul><li>GameCanvas<br>游戏画布<br>是进行游戏的界面</li><li>PauseCanvas<br>暂停画布<br>是游戏暂停时的功能性画布</li><li>GGCanvas<br>游戏失败画布<br>是游戏失败后弹出的画布</li></ul><p>该场景的所有视图对象(UI)由<strong>GamePageUIManager</strong>类控制，它作为组件挂载在EventSystem上，其中包含了各个画布的全部按键响应函数。</p><p>值得注意的是，因为UI与游戏物体高度融合，Map应当显示在UI背景的前方。因此画布应当设置为<strong>Screen Space-Camera渲染模式</strong>。相关知识详见<a href="https://mycroftcooper.github.io/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/">UGUI详解-画布</a></p><h3 id="3-1-3-球球模式场景-GameScene2"><a href="#3-1-3-球球模式场景-GameScene2" class="headerlink" title="3.1.3 球球模式场景(GameScene2)"></a>3.1.3 球球模式场景(GameScene2)</h3><p><strong>实体类图设计:</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2048-%E7%90%83%E7%90%83%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt="2048-球球模式设计类图"></p><h2 id="3-2-UI实现"><a href="#3-2-UI实现" class="headerlink" title="3.2 UI实现"></a>3.2 UI实现</h2><p><strong>开始界面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629220904860.png" srcset="/img/loading.gif" alt="开始界面"></p><p><strong>模式选择页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221015700.png" srcset="/img/loading.gif" alt="模式选择页面"></p><p><strong>经典模式页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221144410.png" srcset="/img/loading.gif" alt="经典模式页面"></p><p><strong>球球模式页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221506826.png" srcset="/img/loading.gif" alt="球球模式页面"></p><p><strong>暂停页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221318433.png" srcset="/img/loading.gif" alt="暂停页面"></p><p><strong>失败页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221350145.png" srcset="/img/loading.gif" alt="失败页面"></p><h2 id="3-3-技术实现亮点与难点"><a href="#3-3-技术实现亮点与难点" class="headerlink" title="3.3 技术实现亮点与难点"></a>3.3 技术实现亮点与难点</h2><h3 id="3-3-1-2048经典模式核心玩法算法"><a href="#3-3-1-2048经典模式核心玩法算法" class="headerlink" title="3.3.1 2048经典模式核心玩法算法"></a>3.3.1 2048经典模式核心玩法算法</h3><h4 id="数字块的抽象"><a href="#数字块的抽象" class="headerlink" title="数字块的抽象"></a>数字块的抽象</h4><p>将每个数字抽象为一个数字块类，放入棋盘的格子中。</p><p>是用Block类的二维数组存储数字块</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> GameController_Mode1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Map</span>:<span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> sideLength;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> blockCounter;<br>    <span class="hljs-keyword">private</span> Block [][] blocks;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Score &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> BestScore &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitMap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> sideLength</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.sideLength = sideLength;<br>        blocks = <span class="hljs-keyword">new</span> Block[sideLength][];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sideLength; i++)<br>        &#123;<br>            blocks[i] = <span class="hljs-keyword">new</span> Block[sideLength];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; sideLength; j++)<br>            &#123;<br>                blocks[i][j] = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">new</span> Vector2Int(i, j), screenPosition[i, j]);<br>            &#125;<br>        &#125;<br>        blockCounter = <span class="hljs-number">0</span>;<br>        transform.position = originalPosition;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DestroyMap</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Block[] i <span class="hljs-keyword">in</span> blocks)<br>        &#123;<br>            <span class="hljs-keyword">foreach</span>(Block j <span class="hljs-keyword">in</span> i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!j.isEmpty())<br>                &#123;<br>                    GameObject.Destroy(j.Entity.gameObject);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//剩下的代码在下面</span><br></code></pre></td></tr></table></figure><h4 id="数字块的生成与合并"><a href="#数字块的生成与合并" class="headerlink" title="数字块的生成与合并"></a>数字块的生成与合并</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 生成数字块</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNewNumber</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//在哪里生成</span><br><span class="hljs-built_in">int</span> putWhere = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">15</span> - blockCounter);<br><span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sideLength; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; sideLength; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!blocks[i][j].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (counter == putWhere)<br>            &#123;<br>                blocks[i][j].Entity = EntityControllerMode1.createNewEntity(blocks[i][j]);<br>                blockCounter++;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> counter++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//合并数字块</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeNumber</span>(<span class="hljs-params">Block blockA,Block blockB</span>)</span><br><span class="hljs-function"></span>&#123;<br>    blockA.Entity.isChanged = <span class="hljs-literal">true</span>;<br>    Score += blockB.Entity.Num;<br>    GameObject.Destroy(blockB.Entity.gameObject);<br>    blockCounter--;<br>    blockB.Entity = blockA.Entity;<br>    blockA.Entity = <span class="hljs-literal">null</span>;<br>    blockB.Entity.doEntityMove(blockB);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数字块的移动"><a href="#数字块的移动" class="headerlink" title="数字块的移动"></a>数字块的移动</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveNumber</span>(<span class="hljs-params">Block blockA, Block blockB</span>)<span class="hljs-comment">//AtoB</span></span><br><span class="hljs-function"></span>&#123;<br>    blockB.Entity = blockA.Entity;<br>    blockA.Entity = <span class="hljs-literal">null</span>;<br>    blockB.Entity.doEntityMove(blockB);<br>&#125;<br><br><span class="hljs-comment">//判断是否有数字块正在移动(其实可以用回调函数)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">isNowMoving</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (transform.localPosition != originalPosition)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sideLength;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;sideLength;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!blocks[i][j].isEmpty() &amp;&amp;<br>                !blocks[i][j].Entity.isOnPosition( blocks[i][j].ScreenPosition))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//向四个方向移动的算法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveUp</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">1</span>; row &lt; sideLength; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; sideLength; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextRow = row - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[nextRow][col].isEmpty() &amp;&amp; nextRow != <span class="hljs-number">0</span>)<br>                nextRow--;<br>            <span class="hljs-keyword">if</span> (!blocks[nextRow][col].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[nextRow][col].Entity.Num &amp;&amp; !blocks[nextRow][col].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[nextRow][col]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>; <br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextRow == (row - <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextRow++;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[nextRow][col]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveDown</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = sideLength<span class="hljs-number">-2</span>; row &gt;=<span class="hljs-number">0</span>; row--)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; sideLength; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextRow = row + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[nextRow][col].isEmpty() &amp;&amp; nextRow != sideLength<span class="hljs-number">-1</span>)<br>                nextRow++;<br>            <span class="hljs-keyword">if</span> (!blocks[nextRow][col].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[nextRow][col].Entity.Num &amp;&amp; !blocks[nextRow][col].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[nextRow][col]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextRow == (row + <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextRow--;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[nextRow][col]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveLeft</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; sideLength; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">1</span>; col &lt; sideLength; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextCol = col - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[row][nextCol].isEmpty() &amp;&amp; nextCol != <span class="hljs-number">0</span>)<br>                nextCol--;<br>            <span class="hljs-keyword">if</span> (!blocks[row][nextCol].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[row][nextCol].Entity.Num &amp;&amp; !blocks[row][nextCol].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[row][nextCol]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextCol == (col - <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextCol++;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[row][nextCol]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveRight</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; sideLength; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = sideLength - <span class="hljs-number">2</span>; col &gt;=<span class="hljs-number">0</span>; col--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextCol = col + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[row][nextCol].isEmpty() &amp;&amp; nextCol != sideLength - <span class="hljs-number">1</span>)<br>                nextCol++;<br>            <span class="hljs-keyword">if</span> (!blocks[row][nextCol].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[row][nextCol].Entity.Num &amp;&amp; !blocks[row][nextCol].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[row][nextCol]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextCol == (col + <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextCol--;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[row][nextCol]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是逻辑层面移动数字块，实际上每个数字块的移动是用协程实现的。<br>协程是用法可见：<br><a href="https://mycroftcooper.github.io/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/">https://mycroftcooper.github.io/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/</a></p><h4 id="判断游戏结束"><a href="#判断游戏结束" class="headerlink" title="判断游戏结束"></a>判断游戏结束</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">isLose</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (blockCounter != (<span class="hljs-built_in">int</span>)Mathf.Pow((<span class="hljs-built_in">float</span>)sideLength, <span class="hljs-number">2f</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;sideLength;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;sideLength<span class="hljs-number">-1</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[i][j].Entity.Num == blocks[i][j + <span class="hljs-number">1</span>].Entity.Num) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(blocks[j][i].Entity.Num == blocks[j+<span class="hljs-number">1</span>][i].Entity.Num) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-3-球球模式的潜水艇控制"><a href="#3-3-3-球球模式的潜水艇控制" class="headerlink" title="3.3.3 球球模式的潜水艇控制"></a>3.3.3 球球模式的潜水艇控制</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//用户输入检测</span><br><span class="hljs-keyword">private</span> Touch touch;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PhoneInput</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!GC.IsPause() &amp;&amp; !GC.isShaking)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Input.touchCount != <span class="hljs-number">1</span> &amp;&amp; Input.touchCount != <span class="hljs-number">2</span>) <br>            <span class="hljs-keyword">return</span>;<br>        touch = Input.GetTouch(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (Input.touchCount == <span class="hljs-number">2</span>)<br>        &#123;<br>            GC.dropTheEntity();<br>            GC.shakePool();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Input.GetTouch(<span class="hljs-number">0</span>).phase == TouchPhase.Moved)<br>            GC.moveSubmarine(Camera.main.ScreenToWorldPoint(touch.position));<br>        <span class="hljs-keyword">if</span> (!GC.hasNewEntity() <br>            &amp;&amp; touch.phase==TouchPhase.Began &amp;&amp; Input.touchCount ==<span class="hljs-number">1</span>)<br>            GC.createNewEntity();<br>        <span class="hljs-keyword">if</span> (touch.phase == TouchPhase.Ended)<br>            GC.dropTheEntity();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//潜水艇移动响应函数</span><br><span class="hljs-keyword">private</span> Vector3 LeftLimiter = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-2f</span>, <span class="hljs-number">2.65f</span>, <span class="hljs-number">0f</span>);<br><span class="hljs-keyword">private</span> Vector3 RightLimiter = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">2f</span>, <span class="hljs-number">2.65f</span>, <span class="hljs-number">0f</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move_EventHandle</span>(<span class="hljs-params">Vector3 targetPosition</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (targetPosition.x &lt; LeftLimiter.x)<br>        transform.position = LeftLimiter;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetPosition.x &gt; RightLimiter.x)<br>        transform.position = RightLimiter;<br>    <span class="hljs-keyword">else</span><br>        transform.position = <span class="hljs-keyword">new</span> Vector3(targetPosition.x, <span class="hljs-number">2.65f</span>, <span class="hljs-number">0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目开发文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader 标准光照模型(一)理论基础</title>
    <link href="/2021/06/22/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/06/22/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>虽然光照模型有很多种类，但在早期的游戏引擎中往往只使用一个光照模型，这个模型被称为标准光照模型。</p><p>在1975年，著名学者<strong>裴祥风(Bui Tuong Phong)</strong> 提出了标准光照模型背后的基本理念。</p><p>标准光照模型只关心**直接光照(directlight)**，也就是那些直接从光源发射出来照射到物体表面后,经过物体表面的一次反射直接进入摄像机的光线。</p><p>它的基本方法是，把进入到摄像机内的光线分为4个部分，每个部分使用一种方法来计算它的贡献度。</p><p>这4个部分是：</p><ul><li><p><strong>自发光 (emissive)</strong><br>这个部分用于描述当给定一个方向时，一个表面本身会向该方向发射多少辐射量。<br>需要注意的是：<br>如果没有使用<strong>全局光照(globalillumination)技术</strong>，这些自发光的表面并不会真的照亮周围的物体，而是它本身看起来更亮了而已。</p></li><li><p><strong>高光反射(specular)</strong><br>这个部分用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。</p></li><li><p><strong>漫反射(diffuse)</strong><br>这个部分用于描述，当光线从光源照射到模型表面时，该表面会向每个方向散射多少辐射量。</p></li><li><p><strong>环境光 (ambient)</strong><br>它用于描述其他所有的间接光照。</p></li></ul><p>标准光照模型仅仅是一个经验模型，它并不完全符合真实世界中的光照现象。<br>但由于它的易用性、计算速度和得到的效果都比较好，因此仍然被广泛使用。</p><p>但这种模型有很多局限性。</p><ul><li>有很多重要的物理现象无法用<strong>Blinn-Phong模型</strong>表现出来，<br>例如**菲涅耳反射(Fresnel reflection)**。</li><li><strong>Blinn-Phong 模型</strong>是<strong>各项同性(isotropic)</strong> 的<br>当我们固定视角和光源方向旋转这个表面时，反射不会发生任何改变。<br>但有些表面是具有**各向异性(anisotropic)**反射性质的例如拉丝金属、毛发等。<br>所以它看起来不够真实</li></ul><h1 id="2-理论基础"><a href="#2-理论基础" class="headerlink" title="2. 理论基础"></a>2. 理论基础</h1><h2 id="2-1-环境光"><a href="#2-1-环境光" class="headerlink" title="2.1 环境光"></a>2.1 环境光</h2><p>虽然标准光照模型的重点在于描述直接光照，但在真实的世界中，物体也可以被间接光照(indirect light)所照亮。</p><p>间接光照指：光线通常会在多个物体之间反射，最后进入摄像机。<br>也就是说，在光线进入摄像机之前，经过了不止一次的物体反射。<br>例如：<br>在红地毯上放置一个浅灰色的沙发，那么沙发底部也会有红色，这些红色是由红地毯反射了一部分光线，再反弹到沙发上的。</p><p>在标准光照模型中，我们使用了一种被称为环境光的部分来近似模拟间接光照。<br>环境光的计算非常简单，它通常是一个 全局变量，即场景中的所有物体都使用这个环境光。</p><p><strong>环境光计算公式：</strong><br>$c_{ambient}=g_{ambient}$<br><strong>物体环境光=全局环境光</strong></p><h2 id="2-2-自发光"><a href="#2-2-自发光" class="headerlink" title="2.2 自发光"></a>2.2 自发光</h2><p>光线也可以直接由光源发射进入摄像机，而不需要经过任何物体的反射。</p><p>标准光照模型使用自发光来计算这个部分的贡献度。<br>它的计算也很简单，就是直接使用了该材质的自发光颜色:</p><p><strong>自发光计算公式：</strong><br>$c_{emissive}=m_{emissive}$<br><strong>物体自发光=该物体材质自发光</strong></p><blockquote><p>通常在实时渲染中，自发光的表面往往并不会照亮周围的表面<br>也就是说，这个物体并不会被当成一个光源。<br>Unity5引入的全新的全局光照系统则可以模拟这类自发光物体对周围物体的影响</p></blockquote><h2 id="2-3-漫反射"><a href="#2-3-漫反射" class="headerlink" title="2.3 漫反射"></a>2.3 漫反射</h2><p>漫反射光照是用于对那些被物体表面随机散射到各个方向的辐射度进行建模的。</p><p>在漫反射中，视角的位置是不重要的，因为反射是完全随机的，因此可以认为在任何反射方向上的分布都是一样的。但是，入射光线的角度很重要。</p><p>漫反射光照符合<strong>兰伯特定律(Lambert’s law)</strong>:<br>反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比。</p><p><strong>漫反射计算公式：</strong><br>$c_{diffuse}=(c_{light}·m_{diffuse})max(0,n·I)$<br><strong>物体漫反射光=(光源颜色·物体材质漫反射颜色)·取大值(0,法线方向矢量·光源方向矢量)</strong><br>其中：</p><ul><li><p>n是表面法线</p></li><li><p>I是指向光源的单位矢量</p></li><li><p>$m_{diffuse}$是材质的漫反射颜色</p></li><li><p>$c_{light}$ 是光源颜色。</p></li></ul><blockquote><p>需要注意的是:<br>我们需要防止法线和光源方向点乘的结果为负值，<br>为此，我们使用取最大值的函数来将其截取到0，<br>这可以防止物体被从后面来的光源照亮。</p></blockquote><h2 id="2-4-高光反射"><a href="#2-4-高光反射" class="headerlink" title="2.4 高光反射"></a>2.4 高光反射</h2><h3 id="2-4-1-Phong模型"><a href="#2-4-1-Phong模型" class="headerlink" title="2.4.1 Phong模型"></a>2.4.1 Phong模型</h3><p>这里的高光反射是一种经验模型， 也就是说，它并不完全符合真实世界中的高光反射现象。</p><p>它可用于计算那些沿着完全镜面反射方向被反射的光线，这可以让物体看起来是有光泽的，例如金属材质。</p><p>计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。<br>我们假设这些矢量都是单位矢量。如下图所示：<br><img src="/images/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/image-20210622112428355.png" srcset="/img/loading.gif" alt="image-20210622112428355"></p><p>在这四个矢量中，我们实际上只需要知道其中3个矢量即可，而反射方向可以通过其他信息计算得到：<br>$\hat r=2(\hat n·I)\hat n-I$</p><p>这样，我们就可以利用Phong 模型来计算高光反射的部分:<br><strong>高光反射计算公式(Phong模型)：</strong><br>$c_{spscular}=(c_{light}·m_{specular})max(0,\hat v·\hat r)^{m_{gloss}} $<br><strong>物体高光反射=(光源颜色·物体材质高光反射颜色)·取大值(0,视角向量方向·反射向量方向)物体光泽度次幕</strong><br>其中:</p><ul><li><p>$m_{specular}$是材质的光泽度(gloss)， 也被称为反光度(shininess)。<br>它用于控制高光区域的亮点”有多宽，mgloss越大，亮点就越小。</p></li><li><p>$m_{specular}$是材质的高光反射颜色，<br>它用于控制该材质对于高光反射的强度和颜色。</p></li><li><p>$c_{light}$ 则是光源的颜色和强度。</p></li></ul><p>同样，这里也需要防止$\hat v·\hat r$的结果为负数。</p><h3 id="2-4-2-Blinn模型"><a href="#2-4-2-Blinn模型" class="headerlink" title="2.4.2 Blinn模型"></a>2.4.2 Blinn模型</h3><p>和上述的Phong 模型相比，Blinn 提出了一个简单的修改方法来得到类似的效果。<br>它的基本思想是，避免计算反射方向$\hat r$。<br>为此，Blin 模型引入了一个新的矢量$\hat h$，它是通过对$\hat v$和$\hat I$的取平均后再归一化得到的。</p><p>即:<br>$\hat h=\frac {\hat v+I}{|\hat v+I|}$<br>然后，使用$\hat h$和$\hat n$之间的夹角进行计算，而非$\hat v$和$\hat r$之间的夹角如下图所示：<br><img src="/images/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/image-20210622114447454.png" srcset="/img/loading.gif" alt="image-20210622114447454"><br><strong>高光反射计算公式(Blinn模型)：</strong><br>$c_{spscular}=(c_{light}·m_{specular})max(0,\hat n·\hat h)^{m_{gloss}} $<br><strong>物体高光反射=(光源颜色·物体材质高光反射颜色)·取大值(0,法线方向·向量h方向)物体光泽度次幕</strong></p><p>$\hat h=\frac {\hat v+I}{|\hat v+I|}$<br><strong>$向量h方向=\frac {视角方向向量+光源方向向量}{|视角方向向量+光源方向向量|}$</strong></p><p>在硬件实现时:</p><ul><li>若摄像机和光源距离模型足够远<br>Blinn 模型会快于Phong模型<br>因为此时可以认为$\hat v$和$\hat I$都是定值，因此$\hat h$将是一个常量。</li><li>当$\hat v$和$\hat I$不是定值时，Phong 模型可能反而更快一些。</li></ul><blockquote><p>注意:<br>这两种光照模型都是经验模型<br>也就是说，我们不应该认为Blinn 模型是对“正确的”Phong模型的近似。<br>实际上，在一些情况下，Blinn 模型更符合实验结果。</p></blockquote><h2 id="2-5-标准光照模型的两种着色"><a href="#2-5-标准光照模型的两种着色" class="headerlink" title="2.5 标准光照模型的两种着色"></a>2.5 标准光照模型的两种着色</h2><p>计算光照模型通有两种选择:</p><ul><li><p><strong>在片元着色器中计算——逐像素光照(per-pixel lighting)</strong><br>也被称为<strong>Phong着色(Phong shading)**或</strong>Phong插值<strong>或</strong>法线插值**着色技术<br>在逐像素光照中，我们会以每个像素为基础，得到它的法线<br>(可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的)，然后进行光照模型的计算。</p><blockquote><p>这不同于我们之前讲到的Phong光照模型。</p></blockquote></li><li><p><strong>在顶点着色器中计算——逐顶点光照(per-vertex lighting)</strong><br>也被称为**高洛德着色(Gouraud shading)**。<br>我们在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。<br>由于顶点数目往往远小于像素数目，因此逐顶点光照的计算量往往要小于逐像素光照。</p><blockquote><p>注意：<br>由于逐顶点光照依赖于线性插值来得到像素光照<br>因此，当光照模型中有非线性的计算( 例如计算高光反射时)时，逐顶点光照就会出问题。<br>而且，由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，<br>这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，这在某些情况下会产生明显的棱角现象。</p></blockquote></li></ul><h1 id="3-动手实践"><a href="#3-动手实践" class="headerlink" title="3.动手实践"></a>3.动手实践</h1><h2 id="3-1-在Unity中实现环境光与自发光"><a href="#3-1-在Unity中实现环境光与自发光" class="headerlink" title="3.1 在Unity中实现环境光与自发光"></a>3.1 在Unity中实现环境光与自发光</h2><p>在标准光照模型中，环境光和自发光的计算是最简单的。<br>在Unity中,场景中的环境光可以在：<br>Window-&gt;Lighting -&gt; Ambient Source/Ambient Color/Ambient Intensity(英文)<br>窗口-&gt;渲染-&gt;光照-&gt;场景-&gt;环境中控制，</p><p>如下图所示：<br><img src="/images/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/image-20210622131750865.png" srcset="/img/loading.gif" alt="image-20210622131750865"></p><p>在Shader中，我们只需要通过Unity的内置变量UNITY_ LIGHTMODEL AMBIENT就可以得到环境光的颜色和强度信息。</p><p>而大多数物体是没有自发光特性的。<br>如果要计算自发光也非常简单，我们只需要在片元着色器输出最后的颜色之前，把材质的自发光颜色添加到输出颜色上即可。</p><h2 id="3-2-在UnityShader中实现漫反射光照模型"><a href="#3-2-在UnityShader中实现漫反射光照模型" class="headerlink" title="3.2 在UnityShader中实现漫反射光照模型"></a>3.2 在UnityShader中实现漫反射光照模型</h2><p>从公式可以看出，要计算漫反射需要知道4个参数:入射光线的颜色和强度Cight, 材质的漫<br>反射系数mdij<br>lifuse<br>表面法线介 以及光源方向I。2<br>为了防止点积结果为负值，我们需要使用max操作，而CG提供了这样的函数。在本例中，<br>使用CG的另一个函数可以达到同样的目的，即saturate函数。<br>函数: saturate(x)<br>参数: x:为用于操作的标量或矢量，可以是float、 float2、 float3 等类型。<br>描述:把x截取在[0, 1]范围内，如果x是一一个矢量，那么会对它的每一一个分量进行这样的操作。</p><h3 id="3-2-1-逐项点光照"><a href="#3-2-1-逐项点光照" class="headerlink" title="3.2.1 逐项点光照"></a>3.2.1 逐项点光照</h3><p>我们首先来看如何实现-一个逐顶点的漫反射光照效果。在学习完本节后，我们会得到类似<br>图6.6中的效果。<br>为此，我们进行如下准备工作。<br>(1)在Unity中新建一一个场景。在本书资源中，该场景名为Scene_ 6 _4。 在Unity 5.2中，默<br>认情况下场景将包含一个摄像机和一个平行光，并且使用了内置的天空盒子。在Window -&gt;</p><p>Lighting -&gt; Skybox中去掉场景中的天空盒子。<br>(2) 新建一个材质。在本书资源中，该材质名为DiffuseVertexLevelMato<br>(3)新建一一个 Unity Shader.在本书资源中，该Shader<br>名为Chapter6-DiffuseVertexLevel。 把新的Shader 赋给<br>第2步中创建的材质。<br>(4)在场景中创建一个胶囊体，并把第2步中的材<br>质赋给该胶囊体。<br>(5)保存场景。<br>下面，我们需要编写自己的Shader来实现–个逐顶<br>点的漫反射效果。打开第3步中创建的Unity Shader,<br>删除所有已有代码，并进行如下修改。<br>(1)首先，我们需要为这个Shader起一 一个名字:<br>Shader “Unity Shaders Book/Chapter 6/Dlffuse Vertex-Level” {<br>(2)为了得到并且控制材质的漫反射颜色，我们首先在Shader的Properties语义块中声明了<br>个Color类型的属性，并把它的初始值设为白色:<br>Properties {.<br>Diffuse (“Diffuse”, Color) = (1, 1, 1, 1)<br>(3)然后，我们在SsubShader语义块中定义了一个Pass 语义块。这是因为顶点/片元着色器的<br>代码需要写在Pass 语义块，而非SubShader语义块中。而且，我们在Pass的第一行指明 了该Pass<br>的光照模式:<br>SubShader {<br>Pass<br>Tags { “LightMode “= “ForwardBase” }<br>LightMode标签是Pass标签中的一种，它用于定义该Pass在Unity的光照流水线中的角色，<br>在第9章中我们会更加详细地解释它。在这里，我们只需要知道，只有定义了正确的LightMode,<br>我们才能得到一些Unity的内置光照变量，例如下面要讲到的_ LightColor0。<br>(4)然后，我们使用CGPROGRAM和ENDCG米包围CG代码片，以定义最重要的顶点着色<br>器和片元着色器代码。首先，我们使用#pragma指令来告诉Unity,我们定义的顶点着色器和片元<br>着色器叫什么名字。在本例中，它们的名字分别是vert和frag:<br>CGPROGRAM<br>#pragma vertex vert<br>#pragma fragment frag<br>(5)为了使用Unity内置的一些变量， 如后面要讲到的<em>LightColor0， 还需要包含进Unity的<br>内置文件Lighting.cginc:<br>#include “Lighting. cginc”<br>(6) 为了在Shader中使用Properties语义块中声明的属性，我们需要定义一个和该属性类型<br>相匹配的变量:<br>fixed4</em> Diffuse;<br>通过这样的方式，我们就可以得到漫反射公式中需要的参数之一一一材 质的漫反射属性。由<br>于颜色属性的范围在0到1之间，因此我们可以使用fixed精度的变量来存储它。</p><p>(7)然后，我们定义了顶点着色器的输入和输出结构体(输出结构体同时也是片元着色器的<br>输入结构体):<br>struct a2v {<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>struct v2f (<br>float4 pos : SV_ POSITION;<br>fixed3 color : COLOR;<br>;<br>为了访问顶点的法线，我们需要在a2v中定义-个normal变量，并通过使用NORMAL语义<br>来告诉Unity要把模型项点的法线信息存储到normal变量中。为了把在项点着色器中计算得到的<br>光照颜色传递给片元着色器，我们需要在v2f中定义-一个color变量，且并不是必须使用COLOR<br>语义，一些资料中会使用TEXCOORDO语义。<br>(8)接下来是关键的顶点着色器。由于本小节关注如何实现一一个逐顶点的漫反射光照，因此<br>漫反射部分的计算都将在顶点着色器中进行:<br>v2f vert(a2v v) {<br>v2f o;<br>// Transform the vertex from object. space, to projection space<br>o.pos = mul (UNITY_ MATRIX MVP，v.vertex);<br>/ Get ambient term<br>fixed3 ambient = UNITY_ LIGHTMODEL_ AMBIENT 。xyz;<br>// Transform the normal fram object space to world space<br>fixed3 worldNormal = normalize (mul (v.normal, (f1oat3x3)_ Wor1d20bject));<br>// Get the 1ight direction in world space<br>fixed3 worldLight . normalize(_ WorldSpaceLightPos0.xyz);<br>// Compute diffuse term<br>fixed3 diffuse = LightColor0.rgb * Diffuse.rgb * saturate (dot (worldNormal,<br>worldLight));<br>o.color = ambient + diffuse;<br>return o;<br>在第一行，我们首先定义了返回值0。我们已经重复过很多次，顶点着色器最基本的任务就<br>是把顶点位置从模型空间转换到裁剪空间中，因此我们需要使用Unity内置的模型<em>世界</em>投影矩<br>阵UNITY MATRIX MVP来完成这样的坐标变换。接下来，我们通过Unity 的内置变量<br>UNITY LIGHTMODEL_ AMBIENT得到了环境光部分。<br>然后，就是真正计算漫反射光照的部分。回忆一下，为了计算漫反射光照我们需要知道4个<br>参数。在前面的步骤中，我们已经知道了材质的漫反射颜色<em>Diffuse 以及顶点法线v.normal。我们<br>还需要知道光源的颜色和强度信息以及光源方向。Unity 提供给我们一“个内置变量LightColor0 来<br>访问该Pass 处理的光源的颜色和强度信息(注意，想要得到正确的值需要定义合适的LightMode<br>标签)，而光源方向可以由</em> WorldSpaceLightPos0 来得到。需要注意的是，这里对光源方向的计算<br>并不具有通用性。在本节中，我们假设场景中只有一个光源且该光源的类型是平行光。但如果场<br>景中有多个光源并且类型可能是点光源等其他类型，直接使用_ WorldSpaceLightPos0就不能得到<br>正确的结果。我们将在6.6节中学习如何使用内置函数来处理更复杂的光源类型。<br>在计算法线和光源方向之间的点积时，我们需要选择它们所在的坐标系，只有两者处于同一<br>坐标空间下，它们的点积才有意义。在这里，我们选择了世界坐标空间。而由a2v得到的顶点法<br>线是位于模型空间下的，因此我们首先需要把法线转换到世界空间中。在4.7节中，我们已经知</p><h3 id="3-2-2-逐像素光照"><a href="#3-2-2-逐像素光照" class="headerlink" title="3.2.2 逐像素光照"></a>3.2.2 逐像素光照</h3>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-协程</title>
    <link href="/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/"/>
    <url>/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>unity的<strong>协程（Coroutine）</strong>只是在c#的基础上做了一层封装，其实yield是C#的关键字。</p><p>unity协程是一个能够暂停协程执行，暂停后立即返回主函数，执行主函数剩余的部分，直到中断指令完成后，从中断指令的下一行继续执行协程剩余的函数。<br>函数体全部执行完成，协程结束。<br>由于中断指令的出现，使得可以将一个函数分割到多个帧里去执行。</p><p>协程不是进程，也不是线程，它就是一个特殊的函数——可以在某个地方挂起，并且可以重新在挂起处继续运行。</p><p><strong>协程方法与普通方法的区别：</strong></p><ul><li>普通方法<br>被调用时，原来执行的部分保留现场，停止执行，然后去执行要调用的方法，并且，被调用的方法执行完之后才能返回到调用前的状态接着往下执行。</li><li>协同方法<br>执行不用等协同方法执行完再执行调用之前原来方法的代码，而是两者异步执行。</li></ul><p>协程不是多线程，它与主线程同时运行，它在主线程运行的同时开启另一段逻辑处理。<br>类似一个子线程单独出来处理一些问题，性能开销较小。<br>Unity的协程会在每帧结束之后去检测yield的条件是否满足，满足则执行yield return之后的代码。</p><p>在一个MonoBehaviour提供的主线程里只能有一个处于运行状态的协程，而其他协程处于休眠状态。<br>协程实际上是在一个线程中，只不过每个协程对CUP进行分时，协程可以访问和使用unity的所有方法和component。</p><p><strong>性能：</strong><br>在性能上相比于一般函数没有更多的开销</p><p><strong>协程的好处：</strong><br>让原来要使用异步 + 回调方式写的非人类代码, 可以用看似同步的方式写出来。<br>能够分步做一个比较耗时的事情，如果需要大量的计算，将计算放到一个随时间进行的协程来处理，能分散计算压力</p><p><strong>协程的坏处：</strong><br>协程本质是迭代器，且是基于unity生命周期的，大量开启协程会引起gc<br>如果同时激活的协程较多，就可能会出现多个高开销的协程挤在同一帧执行导致的卡帧</p><p><strong>协程书写时的性能优化：</strong><br>常见的问题是直接new 一个中断指令，带来不必要的 GC 负担，可以复用一个全局的中断指令对象，优化掉开销；在 Yielders.cs 这个文件里，已经集中地创建了上面这些类型的静态对象<br>这个链接分析了一下<a href="https://link.zhihu.com/?target=https://blog.csdn.net/liujunjie612/article/details/70623943">https://blog.csdn.net/liujunjie612/article/details/70623943</a></p><p><strong>协程是在什么地方执行？</strong><br>协程不是线程，不是异步执行；协程和monobehaviour的update函数一样也是在主线程中执行<br>unity在每一帧都会处理对象上的协程，也就是说，协程跟update一样都是unity每帧会去处理的函数<br>经过测试，协程至少是每帧的lateUpdate后运行的。<br>参照unity的生命周期图</p><p><strong>前驱知识：</strong></p><ul><li>设计模式——迭代器模式</li><li>C#中的IEnumerator、IEnumerable接口</li></ul><h1 id="2-协程的实现"><a href="#2-协程的实现" class="headerlink" title="2. 协程的实现"></a>2. 协程的实现</h1><p>协程的实现需要在Unity中继承MonoBehaviour并使用C#的迭代器IEnumrator，格式如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumrator 函数名(形参表)  <span class="hljs-comment">//最多只能有一个形参 </span><br>&#123;   <br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> xxx; <span class="hljs-comment">//恢复执行条件</span><br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在IEnumerator类型的方法中写入需要执行的操作，遇到yield后会暂时挂起，等到yield return后的条件满足才继续执行yield语句后面的内容。</p><h1 id="3-协程的开启与中止"><a href="#3-协程的开启与中止" class="headerlink" title="3. 协程的开启与中止"></a>3. 协程的开启与中止</h1><p>相关测试：<a href="https://blog.csdn.net/qq_37421018/article/details/88560239?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">Unity 协程的一些基本用法及测试</a></p><h2 id="3-1-协程的开启"><a href="#3-1-协程的开启" class="headerlink" title="3.1 协程的开启"></a>3.1 协程的开启</h2><p>开启协程需要使用StartCoroutine()方法：</p><ul><li><p>开启无参数的协程：<br><code>StartCoroutine(协程名());</code>或<code>StartCoroutine(&quot;协程名&quot;);</code></p></li><li><p>开启单参数的协程：<br><code>StartCoroutine(协程名(参数));</code>或<code>StartCoroutine(&quot;协程名&quot;,参数);</code></p></li><li><p>开启多参数的协程：<br><code>StartCoroutine(协程名(参数1,......));</code><br>或</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//开启协程的函数</span></span><br><span class="hljs-function"></span>&#123;<br>    IEnumerator coroutine = Test(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>    StartCoroutine(coroutine);<br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)<span class="hljs-comment">//协程</span></span><br><span class="hljs-function"></span> &#123;<br>     <span class="hljs-comment">//等待帧画面渲染结束</span><br>     <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForEndOfFrame</span>(<span class="hljs-params"></span>)</span>;<br>     a=<span class="hljs-number">2</span>;<br>     b=<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>用“协程名”启动的方式不允许传入 一个以上的参数</p></blockquote></li></ul><h2 id="3-2-协程的结束"><a href="#3-2-协程的结束" class="headerlink" title="3.2 协程的结束"></a>3.2 协程的结束</h2><p>结束协程有两种情况：</p><ul><li><p>当协程的方法体执行完毕将会自动结束</p></li><li><p>调用StopCoroutine();方法中止协程执行</p></li></ul><p>中止协程的几种情况：</p><ul><li><p>中止所有协程：<br><code>StopAllCoroutines();</code></p></li><li><p>使用对象实例中止指定协程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#">Coroutine c;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    c = StartCoroutine(CountSeconds());        <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.J))<br>    &#123;<br>        StopCoroutine(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用字符串中止指定协程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">StartCoroutine(<span class="hljs-string">&quot;协程名&quot;</span>);<br>StopCoroutine(<span class="hljs-string">&quot;协程名&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>只有以协程名字符串启动的协程可以用此方法中止<br>既：<strong>StartCoroutine(“协程名”);**或</strong>StartCoroutine(“协程名”,参数);**</p><p>允许使用**StopCoroutine(“协程名”);**中止协程</p></blockquote><blockquote><p>不允许使用直接调用协程方法的方式中止指定协程<br>既：**StopCoroutine(协程名([参数]));**不被允许</p></blockquote></li></ul><h1 id="4-yield-协程回复条件语句"><a href="#4-yield-协程回复条件语句" class="headerlink" title="4. yield 协程回复条件语句"></a>4. yield 协程回复条件语句</h1><p><strong>快查表：</strong></p><table><thead><tr><th>yield语句</th><th>功能</th></tr></thead><tbody><tr><td>yield return null;</td><td>下一帧再执行后续代码</td></tr><tr><td>yield return 0;</td><td>下一帧再执行后续代码</td></tr><tr><td>yield return 6;(任意数字)</td><td>下一帧再执行后续代码</td></tr><tr><td>yield break;</td><td>直接结束该协程的后续操作</td></tr><tr><td>yield return asyncOperation;</td><td>等异步操作结束后再执行后续代码</td></tr><tr><td>yield return StartCoroution(其它协程);</td><td>调用执行其它协程后再执行后续代码</td></tr><tr><td>yield return WWW();</td><td>等待WWW操作完成后再执行后续代码</td></tr><tr><td>yield return new WaitForEndOfFrame();</td><td>等待帧结束,等待直到所有的摄像机和GUI被渲染完成后，在该帧显示在屏幕之前执行</td></tr><tr><td>yield return new WaitForSeconds(0.3f);</td><td>等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间会受到Time.timeScale的影响）;</td></tr><tr><td>yield return new WaitForSecondsRealtime(0.3f);</td><td>等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间不受到Time.timeScale的影响）;</td></tr><tr><td>yield return WaitForFixedUpdate();</td><td>等待下一次FixedUpdate开始时再执行后续代码</td></tr><tr><td>yield return new WaitUntil()</td><td>将协同执行直到当输入的参数（或者委托）为true的时候</td></tr><tr><td>yield return new WaitWhile()</td><td>将协同执行直到 当输入的参数（或者委托）为false的时候</td></tr></tbody></table><p><strong>生命周期图：</strong><br><img src="/images/Unity-%E5%8D%8F%E7%A8%8B/image-20210619124505977.png" srcset="/img/loading.gif" alt="image-20210619124505977"></p><h2 id="4-1-yield-return-null"><a href="#4-1-yield-return-null" class="headerlink" title="4.1 yield return null;"></a>4.1 yield return null;</h2><p>从生命周期图中可以看到，在GameLogic部分对协程中挂起的条件进行了判断。</p><p>也就是说，协程顺序为：<br>（当前帧为第1帧）<br>第1帧在start中开启协程，执行协程（自上而下），遇到yield return null 将后面的内容挂起。<br>这时继续执行第1帧剩下的东西直到第1帧Update执行结束，这时对挂起的协程进行判断 是否满足return条件，<br>满足则在第2帧Update之后，在LateUpdate前执行协程中yield return 以后的代码；<br>不满足条件则继续执行第1帧的LateUpdate。<br>第2帧同第1帧相同。</p><p><strong>测试如下：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CorTest2</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//update中判断次数的变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;start 1&quot;</span>);<br>        <span class="hljs-comment">//开启协程1</span><br>        StartCoroutine(Test());<br>        Debug.Log(<span class="hljs-string">&quot;start 2&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;第&quot;</span> + ++i + <span class="hljs-string">&quot;帧开始&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;帧结束&quot;</span>);<br>    &#125;<br>    <span class="hljs-function">IEnumerator <span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;协程1第一次&quot;</span>);<br>            <span class="hljs-comment">//挂起时机</span><br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            Debug.Log(<span class="hljs-string">&quot;协程1第二次&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="/images/Unity-%E5%8D%8F%E7%A8%8B/image-20210619124653298.png" srcset="/img/loading.gif" alt="image-20210619124653298"></p><p>可以看到，协程运行到一半在第一帧被挂起，第二帧Update执行完后满足条件继续执行。</p><h2 id="4-2-yield-return-StartCoroutine"><a href="#4-2-yield-return-StartCoroutine" class="headerlink" title="4.2 yield return StartCoroutine();"></a>4.2 yield return StartCoroutine();</h2><p><strong>测试如下：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>   &#123;<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>       &#123;<br>           Debug.Log(<span class="hljs-string">&quot;协程1第一次&quot;</span>);<br>           <span class="hljs-comment">//挂起时机</span><br>           <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">Test2(</span>))</span>;<br>           Debug.Log(<span class="hljs-string">&quot;协程1第二次&quot;</span>);<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-function">IEnumerator <span class="hljs-title">Test2</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>   &#123;<br>       Debug.Log(<span class="hljs-string">&quot;协程2第一次&quot;</span>);<br>       <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       Debug.Log(<span class="hljs-string">&quot;协程2第二次&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>结果如下：</strong><br><img src="/images/Unity-%E5%8D%8F%E7%A8%8B/image-20210619125001267.png" srcset="/img/loading.gif" alt="image-20210619125001267"></p><p>原理都是一样的，执行完yield return 后挂起（注意不是遇到就挂起，而是执行），在每一帧的update与lateupdate之间对挂起的内容进行判断，满足则继续执行被挂起的协程的剩余部分。</p><h2 id="4-3-yield-return-new-WaitUntil"><a href="#4-3-yield-return-new-WaitUntil" class="headerlink" title="4.3 yield return new WaitUntil();"></a>4.3 yield return new WaitUntil();</h2><p><strong>案例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter;<br><span class="hljs-function">IEnumerator <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    counter=<span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitUntil</span>(<span class="hljs-params">TestWait</span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;Start执行完毕&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TestWait</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当方法TestWait的返回值为true的时候<br>Start会一次性执行完。</li><li>当方法TestWait的返回值为false的时候<br>Start会一直等待着，只要返回值为false，那么Start的最后一句打印就不会执行。</li></ul><blockquote><p>可以使用lambda表达式</p></blockquote><h2 id="4-4-yield-return-new-WaitWhile"><a href="#4-4-yield-return-new-WaitWhile" class="headerlink" title="4.4 yield return new WaitWhile()"></a>4.4 yield return new WaitWhile()</h2><p><strong>案例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter;<br><span class="hljs-function">IEnumerator <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    counter=<span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitWhile</span>(<span class="hljs-params">TestWait</span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;Start执行完毕&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TestWait</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当方法TestWait的返回值为true的时候<br>Start会一直等待着，只要返回值为true，那么Start的最后一句打印就不会执行。</li><li>当方法TestWait的返回值为false的时候<br>Start会一次性执行完。</li></ul><blockquote><p>可以使用lambda表达式</p></blockquote><h1 id="5-协程的嵌套"><a href="#5-协程的嵌套" class="headerlink" title="5. 协程的嵌套"></a>5. 协程的嵌套</h1><p>利用<code>yield return StartCoroution(其它协程);</code>可以实现多个协程的嵌套使用。<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">SaySomeThings</span>(<span class="hljs-params"></span>)   </span><br><span class="hljs-function"></span>&#123;       <br>    Debug.Log(<span class="hljs-string">&quot;The routine has started&quot;</span>);       <br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">RepeatMessage(<span class="hljs-number">1</span>, <span class="hljs-number">1f</span>, <span class="hljs-string">&quot;Hello&quot;</span></span>))</span>;       <br>    Debug.Log(<span class="hljs-string">&quot;1 second has passed since the last message&quot;</span>);       <br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">RepeatMessage(<span class="hljs-number">1</span>, <span class="hljs-number">2.5f</span>, <span class="hljs-string">&quot;Hello&quot;</span></span>))</span>;       <br>    Debug.Log(<span class="hljs-string">&quot;2.5 seconds have passed since the last message&quot;</span>);   <br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/Unity-%E5%8D%8F%E7%A8%8B/image-20210619123813192.png" srcset="/img/loading.gif" alt="image-20210619123813192"></p><h1 id="6-注意"><a href="#6-注意" class="headerlink" title="6. 注意"></a>6. 注意</h1><ul><li>IEnumerator 类型的方法不能带 ref 或者 out 型的参数，但可以带被传递的引用</li><li>在函数 Update 和 FixedUpdate 中不能使用 yield 语句，否则会报错， 但是可以启动协程</li><li>在一个协程中，StartCoroutine()和 yield return StartCoroutine()是不一样的。<br>前者仅仅是开始一个新的Coroutine，这个新的Coroutine和现有Coroutine并行执行。<br>后者是返回一个新的Coroutine，是一个中断指令，当这个新的Coroutine执行完毕后，才继承执行现有Coroutine。</li></ul><h1 id="7-使用案例"><a href="#7-使用案例" class="headerlink" title="7. 使用案例"></a>7. 使用案例</h1><h2 id="7-1-运动到某一位置"><a href="#7-1-运动到某一位置" class="headerlink" title="7.1 运动到某一位置"></a>7.1 运动到某一位置</h2><p>在Inspector面板中设置目标位置和运动速度，在游戏开始时将一个物体移动到目标位置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Vector3 targetPosition;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> moveSpeed=<span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    c = StartCoroutine(MoveToPosition(targetPosition));<br>&#125;<br><span class="hljs-function">IEnumerator <span class="hljs-title">MoveToPosition</span>(<span class="hljs-params">Vector3 target</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (transform.position != target)<br>    &#123;<br>        transform.position = Vector3.MoveTowards(transform.position,target,moveSpeed*Time.deltaTime);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-按指定路径前进"><a href="#7-2-按指定路径前进" class="headerlink" title="7.2 按指定路径前进"></a>7.2 按指定路径前进</h2><p>我们可以让运动到某一位置的程序做更多，不仅仅是一个指定位置，我们还可以通过数组来给它赋值更多的位置，通过MoveToPosition() ，我们可以让它在这些点之间持续运动。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> List&lt;Vector3&gt; path;    <br><span class="hljs-function">IEnumerator <span class="hljs-title">MoveOnPath</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> loop</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> point <span class="hljs-keyword">in</span> path)<br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">MoveToPosition(point</span>))</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (loop);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-倒计时"><a href="#7-3-倒计时" class="headerlink" title="7.3 倒计时"></a>7.3 倒计时</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">CountDown</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> time</span>)</span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> t = time;t &gt;= <span class="hljs-number">0</span>;t -= <span class="hljs-number">1</span>)<br>        &#123;<br>            print(time);<br>            time -= <span class="hljs-number">1</span>; <br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSecondsRealtime</span>(<span class="hljs-params"><span class="hljs-number">1f</span></span>)</span>; <span class="hljs-comment">//WaitForSecondsRealtime不受时间缩放影响</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>底层机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>协程 - yield</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 资源处理</title>
    <link href="/2021/06/17/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/"/>
    <url>/2021/06/17/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>实际的游戏开发中，其实有相当一部分静态数据是可以放在客户端的。<br>所以势必会产生要动态读取这些文件的需求，比如csv（其实就是文本文件），xml等等。</p><p>做unity3d开发时，都一定要先在editor中去实现基本的功能，再具体到各个移动平台上去调试。<br>所以作为要读取外部文件的第一步，显然我们要先在editor也就是pc上实现这个功能。</p><p>既然是用Unity3D来开发游戏，那么自然要使用Unity3D规定的操作方式，而不是我们在PC上很原始的那种操作方式来操作。</p><p>否则就会写出移动端无法使用的很傻的代码来。</p><h1 id="2-资源处理分类"><a href="#2-资源处理分类" class="headerlink" title="2. 资源处理分类"></a>2. 资源处理分类</h1><p>Unity中的资源资源的处理种类大致分为：Resources、StreamingAssets、AssetBundle、PersistentDataPath 四类。</p><h2 id="2-1-Resources"><a href="#2-1-Resources" class="headerlink" title="2.1 Resources"></a>2.1 Resources</h2><p>是作为一个Unity的保留文件夹出现的，也就是如果你新建的文件夹的名字叫Resources，那么里面的内容在打包时都会被无条件的打到发布包中。</p><h3 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点"></a>2.1.1 特点</h3><ul><li>只读，即不能动态修改。所以想要动态更新的资源不要放在这里。</li><li>会将文件夹内的资源打包集成到.asset文件里面。因此建议可以放一些Prefab，因为Prefab在打包时会自动过滤掉不需要的资源，有利于减小资源包的大小。</li><li>资源读取使用Resources.Load()。</li></ul><h3 id="2-1-2-使用方法"><a href="#2-1-2-使用方法" class="headerlink" title="2.1.2 使用方法"></a>2.1.2 使用方法</h3><h4 id="2-1-2-1-加载"><a href="#2-1-2-1-加载" class="headerlink" title="2.1.2.1 加载"></a>2.1.2.1 加载</h4><ul><li>Resources.Load<br>加载Resources目录的一个asset</li><li>Resources.LoadAsync<br>Resources.Load的异步方法</li><li>Resources.LoadAll<br>类似Resources.Load，但是用于加载某目录下所有asset</li><li>Resources.LoadAssetAtPath<br>加载Asset/目录下的资源，只能用于编辑器模式，写打包工具时可能用到</li></ul><p>Resources类只能加载Resources文件夹下的资源，若出现嵌套，都会加载</p><p>Resources加载资源时应使用相对路径，且不包含扩展名。<br>如 Resources.Load&lt;Texture2D&gt;(“images/texture1”); </p><blockquote><p>建议在Assets下放一个Resource文件夹就好；</p></blockquote><h4 id="2-1-2-2-卸载资源："><a href="#2-1-2-2-卸载资源：" class="headerlink" title="2.1.2.2 卸载资源："></a>2.1.2.2 卸载资源：</h4><ul><li>Resources.UnloadAsset(Object assetToUnload)<br>卸载指定的asset，只能用于从磁盘加载的；<br>如果场景中有此asset的引用，Unity会自动重新加载它，CPU开销小。</li><li>Resources.UnloadUnusedAssets<br>卸载所有未被引用的asset，可以在画面切换时调用，或定时调用释放全局未使用资源。<br>被脚本的静态变量引用的资源不会被卸载。<br>尽量避免在游戏进行中调用，因为该接口开销较大，容易引起卡顿<br>可尝试用Resources.Unload(obj)逐个卸载，保证游戏的流畅度。</li></ul><h3 id="2-1-3-案例"><a href="#2-1-3-案例" class="headerlink" title="2.1.3 案例"></a>2.1.3 案例</h3><p>需要新建一个Resources目录，并且并将资源放在这目录中。<br>使用Resources.Load(Path)静态方法加载该目录路径下的资源。</p><p>示例：</p><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617174912162.png" srcset="/img/loading.gif" alt="image-20210617174912162"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine; <br><span class="hljs-keyword">using</span> System.Collections; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadResources</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123; <br><span class="hljs-keyword">public</span> Image image; <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-built_in">string</span> str = Resources.Load (<span class="hljs-string">&quot;Text&quot;</span>).ToString(); <br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2-2-StreamingAssets"><a href="#2-2-StreamingAssets" class="headerlink" title="2.2 StreamingAssets"></a>2.2 StreamingAssets</h2><p>StreamingAssets和Resources很像。<br>同样作为一个只读的Unity3D的保留文件夹出现。</p><p>不过两者也有很大的区别。<br>那就是Resources文件夹中的内容在打包时会被压缩和加密。<br>而StreamingAsset文件夹中的内容则会原封不动的打入包中，因此StreamingAssets主要用来存放一些二进制文件。</p><h3 id="2-2-1-特点"><a href="#2-2-1-特点" class="headerlink" title="2.2.1 特点"></a>2.2.1 特点</h3><ul><li>只读不可写。</li><li>主要用来存放二进制文件。</li><li>只能用过WWW类来读取。</li></ul><h3 id="2-2-2-使用方法"><a href="#2-2-2-使用方法" class="headerlink" title="2.2.2 使用方法"></a>2.2.2 使用方法</h3><p>首先我们新建一个StreamingAssets目录，并且并将资源放在这目录中。</p><blockquote><p>StreamingAssets文件夹内的东西并不会被压缩和加密，放进去什么就是什么<br>所以一般是要放二进制文件的<br>在实际操作中切记不要直接把数据文件放到这个目录中打包</p></blockquote><p>示例：</p><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617175047000.png" srcset="/img/loading.gif" alt="image-20210617175047000"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine; <br><span class="hljs-keyword">using</span> System.Collections; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadResources</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123; <br>    <span class="hljs-built_in">string</span> _result;  <br>    Start () <br>    &#123;  <br>        StartCoroutine(LoadXML());  <br>    &#125;  <br>    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadXML</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-built_in">string</span> sPath= Application.streamingAssetsPath + <span class="hljs-string">&quot;/Test.xml&quot;</span>; <br>        WWW www = <span class="hljs-keyword">new</span> WWW(sPath); <br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> www; <br>        _result = www.text; <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2-3-AssetBundle"><a href="#2-3-AssetBundle" class="headerlink" title="2.3 AssetBundle"></a>2.3 AssetBundle</h2><p>AssetBundle就是把prefab或者二进制文件封装成AssetBundle文件。</p><h3 id="2-3-1-生存周期"><a href="#2-3-1-生存周期" class="headerlink" title="2.3.1 生存周期"></a>2.3.1 生存周期</h3><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617180330593.png" srcset="/img/loading.gif" alt="image-20210617180330593"></p><p>1.Unity 在使用 WWW 方法时会分配一系列的内存空间来存放 WWW 实例对象、 WebStream 数据。该数据包括原始的 AssetBundle 数据、解压后的 AssetBundle 数据以及一个用于解压的 Decompression Buffer 。（一般情况下， Decompression Buffer 会在原始的 AssetBundle 解压完成后自动销毁，但需要注意的是， Unity 会自动保留一个 Decompression Buffer ，不被系统回收，这样做的好处是不用过于频繁的开辟和销毁解压 Buffer ，从而在一定程度上降低 CPU 的消耗。）</p><p>2.当把AssetBundle 解压到内存后，可以使用WWW .assetBundle属性来获取AssetBundle 对象，从而可以得到各种Asset，进而对这些Assets进行加载或者实例化操作。加载过程中，Unity 会将AssetBundle 中的数据流转变为引擎可以识别的信息类型(纹理、材质、对象等)。加载完成后，开发者可以对其进行进一步的操作，比如对象的实例化、纹理和材质的复制和替换等。</p><p>更新：</p><p>游戏一开始运行时，通过文件里面记录的版本号，和服务器上文件中的版本号比对。如果本地版本号低，下载对应的AB包到可读写目录，并对本地资源进行替换，这样进入游戏中加载的就是新下载的AB包资源。</p><p>更新流程如下：</p><pre><code>   1.  将更新包资源(安装包中的资源)复制到可读写目录下   2.  复制完成开始比对哈希文件,开始更新资源   3.  下载添加资源,替换旧资源,删除原来可读写目录下的无用资源   4.  初始化assetbundle依赖关系   5.  完成整个流程</code></pre><p>更新注意：</p><pre><code>   1.  要有下载失败重试几次机制；   2.  要进行超时检测；   3.  要记录更新日志，例如哪几个资源时整个更新流程失败。</code></pre><h3 id="2-3-1-特点"><a href="#2-3-1-特点" class="headerlink" title="2.3.1 特点"></a>2.3.1 特点</h3><ul><li>是Unity3D定义的一种二进制类型。</li><li>使用WWW类来下载。</li></ul><h3 id="2-3-2-使用方法"><a href="#2-3-2-使用方法" class="headerlink" title="2.3.2 使用方法"></a>2.3.2 使用方法</h3><p>这里就和上面两个不一样了。</p><p>首先我们要把我们的文件Test.xml打成AssetBundle文件，由于本案例AssetBundle的平台选择为Andorid。</p><p>如图，我们创建了一个AssetBundle文件，并命名为TextXML。<br>并且按照二进制文件放入StreamingAssets文件夹中的惯例，将这个AssetBundle文件放入StreamingAssets文件夹。</p><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617175300313.png" srcset="/img/loading.gif" alt="image-20210617175300313"></p><p>下面是从AssetBudle中读取Test.xml的代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> EggToolkit;<br><span class="hljs-keyword">using</span> System.Xml.Linq;<br><span class="hljs-keyword">using</span> System.Xml;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _result;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123;<br>LoadXML();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadXML</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>AssetBundle AssetBundleCsv = <span class="hljs-keyword">new</span> AssetBundle();<br><span class="hljs-comment">//读取放入StreamingAssets文件夹中的bundle文件</span><br><span class="hljs-built_in">string</span> str = Application.streamingAssetsPath + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-string">&quot;TestXML.bundle&quot;</span>;<br>WWW www = <span class="hljs-keyword">new</span> WWW(str);<br>www = WWW.LoadFromCacheOrDownload(str, <span class="hljs-number">0</span>);<br>AssetBundleCsv = www.assetBundle;<br><span class="hljs-built_in">string</span> path = <span class="hljs-string">&quot;Test&quot;</span>;<br>TextAsset test = AssetBundleCsv.Load(path, <span class="hljs-keyword">typeof</span>(TextAsset)) <span class="hljs-keyword">as</span> TextAsset;<br>_result = test.ToString();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-PersistentDataPath"><a href="#2-4-PersistentDataPath" class="headerlink" title="2.4 PersistentDataPath"></a>2.4 PersistentDataPath</h2><p>这个路径下是可读写。<br>而且在IOS上就是应用程序的沙盒，但是在Android可以是程序的沙盒，也可以是sdcard。<br>并且在Android打包的时候，ProjectSetting页面有一个选项Write Access，可以设置它的路径是沙盒还是sdcard。</p><h3 id="2-4-1-特点"><a href="#2-4-1-特点" class="headerlink" title="2.4.1 特点"></a>2.4.1 特点</h3><ul><li>内容可读写，不过只能运行时才能写入或者读取。 <strong>提前将数据存入这个路径是不可行的</strong>。</li><li>无内容限制。你可以从 StreamingAsset 中读取二进制文件或者从 AssetBundle 读取文件来写入 PersistentDataPath 中。</li><li>写下的文件，可以在电脑上查看。同样也可以清掉。</li><li>需要使用WWW类来读取。</li></ul><h3 id="2-4-2-使用方法"><a href="#2-4-2-使用方法" class="headerlink" title="2.4.2 使用方法"></a>2.4.2 使用方法</h3><p>之前我们说过，内容可读写，不过只能运行时才能写入或者读取。 <strong>提前将数据存入这个路径是不可行的</strong>。也就是说，PersistentDataPath是在运行时生成的，例如通过网络下载资源存在放PersistentDataPath中。</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine; <br><span class="hljs-keyword">using</span> System.Collections; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadResources</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123; <br>    <span class="hljs-built_in">string</span> _result; <br>    Start () <br>    &#123;  <br>        StartCoroutine(LoadXML());  <br>    &#125;  <br>    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadXML</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-built_in">string</span> sPath= Application.persistentDataPath + <span class="hljs-string">&quot;/test.xml&quot;</span>; <br>        sPath = <span class="hljs-string">&quot;file://&quot;</span> + sPath; WWW www = <span class="hljs-keyword">new</span> WWW(sPath); <br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> www; <br>        _result = www.text; <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>这加载方式看起来与StreamingAssets很相识，但是注意这里多了行<code>sPath = &quot;file://&quot; + sPath;</code><br>这很重要！！</p><p>想要通过WWW类加载PersistentDataPath必须使用**file://**协议实现加载。</p><h1 id="3-各平台下的资源路径"><a href="#3-各平台下的资源路径" class="headerlink" title="3. 各平台下的资源路径"></a>3. 各平台下的资源路径</h1><p>想读取文件就必须找到文件所在的目录，我们先来了解一下Unity下各个资源路径的特点和在各平台下资源路径的存放位置吧。</p><h2 id="3-1-Unity3D中的资源路径"><a href="#3-1-Unity3D中的资源路径" class="headerlink" title="3.1 Unity3D中的资源路径"></a>3.1 Unity3D中的资源路径</h2><table><thead><tr><th align="left">路径属性</th><th align="left">路径说明</th></tr></thead><tbody><tr><td align="left">Application.dataPath</td><td align="left">此属性用于返回程序的数据文件所在文件夹的路径。例如在Editor中就是Assets了。</td></tr><tr><td align="left">Application.streamingAssetsPath</td><td align="left">此属性用于返回流数据的缓存目录，返回路径为相对路径，适合设置一些外部数据文件的路径。放在Unity工程StreamingAssets文件夹中的资源发布后都可以通过这个路径读取出来。</td></tr><tr><td align="left">Application.persistentDataPath</td><td align="left">此属性用于返回一个持久化数据存储目录的路径，可以在此路径下存储一些持久化的数据文件。</td></tr><tr><td align="left">Application.temporaryCachePath</td><td align="left">此属性用于返回一个临时数据的缓存目录。</td></tr></tbody></table><h2 id="3-2-android平台"><a href="#3-2-android平台" class="headerlink" title="3.2 android平台"></a>3.2 android平台</h2><table><thead><tr><th align="left">路径属性</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left">Application.dataPath</td><td align="left">/data/app/xxx.xxx.xxx.apk</td></tr><tr><td align="left">Application.streamingAssetsPath</td><td align="left">jar:file:///data/app/xxx.xxx.xxx.apk/!/assets</td></tr><tr><td align="left">Application.persistentDataPath</td><td align="left">/data/data/xxx.xxx.xxx/files</td></tr><tr><td align="left">Application.temporaryCachePath</td><td align="left">/data/data/xxx.xxx.xxx/cache</td></tr></tbody></table><h2 id="3-3-ios平台"><a href="#3-3-ios平台" class="headerlink" title="3.3 ios平台"></a>3.3 ios平台</h2><table><thead><tr><th align="left">路径属性</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left">Application.dataPath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data</td></tr><tr><td align="left">Application.streamingAssetsPath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw</td></tr><tr><td align="left">Application.persistentDataPath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents</td></tr><tr><td align="left">Application.temporaryCachePath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches</td></tr></tbody></table><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1><p>本文90%的内容都是参考：<br><a href="http://www.tuicool.com/articles/qMNnmm6">http://www.tuicool.com/articles/qMNnmm6</a></p><p><a href="https://blog.csdn.net/jfy307596479/article/details/84975736">https://blog.csdn.net/jfy307596479/article/details/84975736</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>资源处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGUI详解-画布</title>
    <link href="/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/"/>
    <url>/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h1><ul><li><p>UI组件</p><ul><li><p><a href="https://mycroftcooper.github.io/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/">画布</a></p></li><li><p><a href="">图片</a></p></li><li><p>文本</p></li><li><p>按钮</p></li><li><p>单选框</p></li><li><p>滑动条</p></li><li><p>滚动条</p></li><li><p>下拉菜单</p></li><li><p>输入框</p></li><li><p>视频播放</p></li></ul></li><li><p>控制组件</p><ul><li>矩形变换组件</li><li>布局元素组件</li><li>布局控制组件</li></ul></li><li><p>UI事件</p></li><li><p>图集</p></li><li><p>渲染顺序</p></li></ul><h1 id="1-画布"><a href="#1-画布" class="headerlink" title="1. 画布"></a>1. 画布</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>画布组件是UI渲染最主要的组件。</p><p>我们可以将画布组件理解成一个容器，其他UI元素都必须填充到该容器中，最终形成我们看到的一个UI界面。</p><p>如果场景中没有画布，那么我们创建任何一个UI元素，都会自动创建画布，并且将新元素置于其下。</p><p>因此可以游戏中用到画布组件的地方均可以作为一个独立的游戏界面。</p><blockquote><p>当容器的渲染属性发生改变时，所有子物体均会受到影响。</p></blockquote><h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><ul><li>只有放在画布组件下的子物体才会参与UI的渲染。</li><li>形状大小取决于屏幕分辨率， 创建出来的画布组件是一个矩形，我们可以修改Game窗口的分辨率选项来修改矩形的大小。<blockquote><p>窗口分辨率默认设置为Free Aspect我们可以把它切换成90像素x1080像素这样具体数值的分辨率，这样我们的界面就不容易易出现变形。</p></blockquote></li><li>子物体的渲染层级取决于UI元素在层次结构中出现的顺序<br>两个UI元素在位置上重叠，层级结构下方的UI元素会遮挡上方的UI元素</li></ul><h2 id="1-3-渲染模式"><a href="#1-3-渲染模式" class="headerlink" title="1.3 渲染模式"></a>1.3 渲染模式</h2><p>三种渲染模式的区别：</p><table><thead><tr><th>渲染模式</th><th>画布对应屏幕</th><th>摄像机</th><th>像素对应</th><th>适合类型</th></tr></thead><tbody><tr><td>Screen Space-Overlay</td><td>是</td><td>不需要</td><td>可选</td><td>2D UI</td></tr><tr><td>Screen Space-Camera</td><td>是</td><td>需要</td><td>可选</td><td>2D UI</td></tr><tr><td>World Space</td><td>否</td><td>需要</td><td>不可选</td><td>3D UI</td></tr></tbody></table><h3 id="1-3-1-覆盖渲染模式"><a href="#1-3-1-覆盖渲染模式" class="headerlink" title="1.3.1 覆盖渲染模式"></a>1.3.1 覆盖渲染模式</h3><p><strong>Screen Space-Overlay</strong>（屏幕控件-覆盖模式）的画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层，或者说画布的画面永远“覆盖”其他普通的3D画面，如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕，如下图效果：</p><p><img src="/images/Unity-UGUI-%E7%94%BB%E5%B8%83/image-20210615154529500.png" srcset="/img/loading.gif" alt="image-20210615154529500"></p><blockquote><p>在此模式下，虽然在Canvas前放置了3D人物，但是在Game窗口中并不能观察到3D人物</p></blockquote><p><strong>Screen Space-Overlay</strong>模式的画布有三个参数：</p><ul><li><strong>Pixel Perfect</strong> 抗锯齿渲染<br>只有RenderMode为Screen类型时才有的选项。<br>使UI元素像素对应，效果就是边缘清晰不模糊。</li><li><strong>Sort Layer</strong> 渲染排序<br>是UGUI专用的设置，用来指示画布的深度。</li><li><strong>TargetDisplay</strong> 显示目标<br>与多屏幕显示相关</li></ul><h3 id="1-3-2-摄像机渲染模式"><a href="#1-3-2-摄像机渲染模式" class="headerlink" title="1.3.2 摄像机渲染模式"></a>1.3.2 摄像机渲染模式</h3><p><strong>Screen Space-Camera</strong>（屏幕空间-摄影机模式）和<strong>Screen Space-Overlay</strong>模式类似，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。</p><p>所不同的是，在该模式下，画布会被放置到摄影机前方。<br>在这种渲染模式下，画布看起来 绘制在一个与摄影机固定距离的平面上。<br>所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。<br>在此模式下，UI元素是由<strong>perspective</strong>也就是视角设定的，视角广度由Filed of View设置。</p><p>这种模式可以用来实现在UI上显示3D模型的需求，比如:<br>很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。<br>通过设置<strong>Screen Space-Camera</strong>模式就可以实现上述的需求，效果如下图所示：<img src="/images/Unity-UGUI-%E7%94%BB%E5%B8%83/image-20210615155308173.png" srcset="/img/loading.gif" alt="image-20210615155308173"></p><p>它比<strong>Screen Space-Overlay</strong>模式的画布多了下面几个参数：</p><ul><li><strong>Render Camera</strong><br>渲染摄像机</li><li><strong>Plane Distance</strong><br>画布距离摄像机的距离</li><li><strong>Sorting Layer</strong><br>是UGUI专用的设置，用来指示画布的深度。<br>可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单-&gt;edit-&gt;Project Settings-&gt;Tags and Layers进入该页面。<br>可以点击“+”添加Layer，或者点击“-”删除Layer。<br>画布所使用的Sorting Layer越排在下面，显示的优先级也就越高。</li><li><strong>Order in Layer</strong><br>在相同的Sort Layer下的画布显示先后顺序。<br>数字越高，显示的优先级也就越高。</li></ul><h3 id="1-3-3-世界空间渲染"><a href="#1-3-3-世界空间渲染" class="headerlink" title="1.3.3 世界空间渲染"></a>1.3.3 世界空间渲染</h3><p>World Space即世界控件模式。<br>在此模式下，画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体。</p><p>画布的尺寸可以通过RectTransform设置，所有的UI元素可能位于普通3D物体的前面或者后面显示。</p><p>当UI为场景的一部分时，可以使用这个模式。</p><p>它有一个单独的参数:</p><ul><li><strong>Event Camera</strong><br>用来指定接受事件的摄像机，可以通过画布上的GraphicRaycaster组件发射射线产生事件。</li></ul><p>这种模式可以用来实现跟随人物移动的血条或者名称，如下图所示：</p><p><img src="/images/Unity-UGUI-%E7%94%BB%E5%B8%83/image-20210615155346268.png" srcset="/img/loading.gif" alt="image-20210615155346268"></p><h2 id="1-4-Canvas-Scale画布缩放组件"><a href="#1-4-Canvas-Scale画布缩放组件" class="headerlink" title="1.4 Canvas Scale画布缩放组件"></a>1.4 Canvas Scale画布缩放组件</h2><h3 id="1-4-1-作用"><a href="#1-4-1-作用" class="headerlink" title="1.4.1 作用"></a>1.4.1 作用</h3><p><strong>Canvas Scalerde</strong>的作用：</p><ul><li>控制整体界面UI元素的大小</li><li>UI界面比例自适应</li></ul><p>Canvas Scale画布缩放组件用于控制整体界面的缩放和画布上UI元素的像素密度。<br>这种缩放影响画布中的所有内容，包括文字大小和图像边框。</p><p>由于游戏会存在不同的分辨率模式，UI需要能在不同的分辨率下保持一个恰当的显示效果。<br>因此，我们需要让UI有一个可以适应的区域范围，比如屏幕由长方形变成正方形时，UI界面不会发生太严重的变形。</p><p>这个时候就需要设置画布缩放组件，以调节我们的UI界面始终保持和屏幕对齐。</p><h3 id="1-4-2-完美像素"><a href="#1-4-2-完美像素" class="headerlink" title="1.4.2 完美像素"></a>1.4.2 完美像素</h3><p><strong>Pixelperfect</strong><br>指一个UI素材本身的像素对应屏幕上一个像素的情况。<br>这种情况下UI素材映射到屏幕上时没有任何拉伸和压缩，这种情况下UI显示效果非常清晰完美。</p><h3 id="1-4-3-缩放组件的渲染模式"><a href="#1-4-3-缩放组件的渲染模式" class="headerlink" title="1.4.3 缩放组件的渲染模式"></a>1.4.3 缩放组件的渲染模式</h3><p>有三种UI缩放渲染模式，每种模式都有其相关参数：</p><ul><li><strong>Constant Pixel Size</strong><br>固定像素尺寸大小<br>不管屏幕尺寸如何变化, UI元素保持相同的像素大小</li><li><strong>Scale With Screen Size</strong><br>随屏幕缩放尺寸<br>使UI随着屏幕大小变化</li><li><strong>Constant Physical Size</strong><br>恒定物理尺寸<br>不管屏幕大小和分辨率如何变化, UI元素保持相同的物理尺寸</li></ul><h3 id="1-4-4-固定像素尺寸大小模式"><a href="#1-4-4-固定像素尺寸大小模式" class="headerlink" title="1.4.4 固定像素尺寸大小模式"></a>1.4.4 固定像素尺寸大小模式</h3><h4 id="1-4-4-1-缩放系数参数"><a href="#1-4-4-1-缩放系数参数" class="headerlink" title="1.4.4.1 缩放系数参数"></a>1.4.4.1 缩放系数参数</h4><p><strong>Scale Factor参数</strong><br>Canvas整体的缩放比例</p><ul><li>在<strong>Screen Space – Overlay</strong> 的情况下默认为1</li><li>在<strong>Screen Space – Camera</strong> 的情况下则不一定为1，会受到渲染UI的摄像机参数影响<blockquote><p>如果为Perspective 相机，会受到 Field Of View影响<br>如果是 Orthographic相机，会受到 Size影响</p></blockquote></li></ul><blockquote><p>默认推荐为1，表示正常大小</p></blockquote><h4 id="1-4-4-2-每单元参考像素大小参数"><a href="#1-4-4-2-每单元参考像素大小参数" class="headerlink" title="1.4.4.2 每单元参考像素大小参数"></a>1.4.4.2 每单元参考像素大小参数</h4><p><strong>ReferencePixelsPerUnit参数</strong></p><p>一般用这个是来缩放图片的，用这个Factor（因子）值我可以一张图实现很多的大小还不失真。<br>这种模式保证了恒定像素的来缩放的。<br>这个对美术来说是个好组建，不用每个大小的都做一张，只要调好Factor因子值就好了。</p><h3 id="1-4-5-随屏幕缩放尺寸模式"><a href="#1-4-5-随屏幕缩放尺寸模式" class="headerlink" title="1.4.5 随屏幕缩放尺寸模式"></a>1.4.5 随屏幕缩放尺寸模式</h3><h4 id="1-4-5-1-参考分辨率"><a href="#1-4-5-1-参考分辨率" class="headerlink" title="1.4.5.1 参考分辨率"></a>1.4.5.1 参考分辨率</h4><p><strong>Reference Resolution参数</strong><br>参照当前UI布局所依据的分辨率，随屏幕分辨率的变化而变化。</p><blockquote><p>游戏运行的最理想分辨率，就是你做游戏时采用的分辨率</p></blockquote><h4 id="1-4-5-2-屏幕匹配模式参数"><a href="#1-4-5-2-屏幕匹配模式参数" class="headerlink" title="1.4.5.2 屏幕匹配模式参数"></a>1.4.5.2 屏幕匹配模式参数</h4><p><strong>Screen Match Mode参数</strong><br>一共有以下三种屏幕匹配模式：</p><h5 id="1-4-5-2-1-匹配宽高模式"><a href="#1-4-5-2-1-匹配宽高模式" class="headerlink" title="1.4.5.2.1 匹配宽高模式"></a>1.4.5.2.1 匹配宽高模式</h5><p><strong>Match Width Or Height模式</strong><br>参考宽，或者高，或者两者来布局画布<br>一个滑条，拉在最左时是Width ，最右时是Height，中间则是按比例混合。</p><ul><li>当处于最左边时，屏幕高度对于UI大小完全没有任何影响，只有宽度会对UI大小产生影响。<br>假设宽度为Reference Resolution宽度的x倍，则UI整体缩放为Reference Resolution状态下的x倍。<br>也就是说只有宽度等于Reference Resolution宽度时，才能做到pixel perfect，否则像素就会有拉伸</li><li>当处于最右边时，与上述情况正好相反，决定整体缩放值的是高度，而宽度则没有任何影响</li><li>处于中间某处时，对上述两者的影响进行权重加成</li></ul><blockquote><p>一般来说：</p><ul><li><p>手机适配用高度适配</p></li><li><p>PC适配用宽度适配</p></li></ul><p>自适应并不是一定要适应全屏，它只会找一个最合适的匹配模式来显示。</p></blockquote><h5 id="1-4-5-2-2-扩展模式"><a href="#1-4-5-2-2-扩展模式" class="headerlink" title="1.4.5.2.2 扩展模式"></a>1.4.5.2.2 扩展模式</h5><p><strong>Expand模式</strong><br>当屏幕分辨率大于参考分辨率时，选择变化较小的一个方向（横向还是纵向），作为放大Canvas Scale的标准，另一方向上的变化则是在整体缩放以后再进行补偿性的变化。<br>此举旨在减少扩大分辨率时由于非等比扩大而对UI整体布局造成影响。<br>适合制作较小标准尺寸，扩充到较大屏幕。</p><p>例如：<br>假设Reference Resolution为800*600，Canvas Scale为(1,1,1)。<br>如果实际分辨率为800*800,那么Canvas Scale还保持为(1,1,1)因为宽度没有发生变化，只是单纯的高度增加了200。<br>所以势必对布局造成一定得影响。</p><p>1000*600的情况也是一样，Canvas Scale没有变化，只是单纯宽度增加了200。</p><p>但如果实际分辨率变为1000*800,那么Canvas Scale就变成(1.25,1.25,1.25)。<br>因为宽度是参考分辨率宽度的1.25倍，高度是1.33倍，那么取较小的1.25。 </p><p>这个1.25倍的意义是：<br>整体Canvas渲染放大1.25倍，横向或纵向的变化超过了1.25倍，则靠拉伸Canvas来变化，此时因为这部分变化，可能会对布局产生一些相对较小的影响，例如相对位置、某些元素的长宽比。</p><h5 id="1-4-5-2-3-收缩模式"><a href="#1-4-5-2-3-收缩模式" class="headerlink" title="1.4.5.2.3 收缩模式"></a>1.4.5.2.3 收缩模式</h5><p><strong>Shrink模式</strong><br>和Expand类似，但是更适合于缩小的情形。<br>它会在屏幕尺寸缩小时，通过缩小CanvasScale尽量减少由于非等比缩小对布局产生的影响。<br>按照影响较小的一个方向缩小的比例去缩小CanvasScale，然后再通过变形调整另外一个方向。</p><h3 id="1-4-6-恒定物理尺寸模式"><a href="#1-4-6-恒定物理尺寸模式" class="headerlink" title="1.4.6 恒定物理尺寸模式"></a>1.4.6 恒定物理尺寸模式</h3><p><strong>Contant Physical Size 恒定物理尺寸模式</strong>和Constant Pixel Size类似，但是只能通过RectTransform来改变大小。</p><p>很少用到，就略述了。</p><p><strong>参数表</strong></p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>物理单位</td><td>指定位置和大小的物理单位</td></tr><tr><td>Fallback Screen DPI</td><td>屏幕DPI未知时采用的DPI</td></tr><tr><td>默认屏幕DPI</td><td>每英寸像素数，用于具有“每单位像素数”属性的sprites ,该属性与“每单位参考像素数”匹配</td></tr><tr><td>每单位像素数</td><td>如果一个sprite具有“每单位像素数”属性,它的DPI会匹配”默认的spriteDPI”设置</td></tr></tbody></table><h1 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h1><p><a href="https://www.cnblogs.com/crazytomato/p/7832838.html">https://www.cnblogs.com/crazytomato/p/7832838.html</a></p><p><a href="https://www.cnblogs.com/morning-lee/p/7135782.html">https://www.cnblogs.com/morning-lee/p/7135782.html</a></p><p><a href="https://www.cnblogs.com/msxh/p/6337338.html">https://www.cnblogs.com/msxh/p/6337338.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>UGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>UGUI</tag>
      
      <tag>画布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程基本知识</title>
    <link href="/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1进程-线程"><a href="#1-1进程-线程" class="headerlink" title="1.1进程/线程"></a>1.1进程/线程</h2><h3 id="1-1-1-进程"><a href="#1-1-1-进程" class="headerlink" title="1.1.1 进程"></a>1.1.1 进程</h3><p>进程指一个应用程序所运行的操作系统单元，它是操作系统环境中的基本成分、是系统进行资源分配的基本单位。</p><p>进程是执行程序的实例。<br>当运行一个应用程序后，就生成了一个进程，这个进程拥有自己的独立内存空间。<br>每一个进程对应一个活动的程序，当进程激活时，操作系统就将系统的资源包括内存、I/O和CPU等分配给它，使它执行。</p><ul><li><p>进程在运行时创建的资源随着进程的终止而死亡。</p></li><li><p>进程间获得专用数据或内存的唯一途径就是通过协议来共享内存块，这是一种协作策略。</p></li><li><p>一个进程可以创建多个线程及子进程（启动外部程序）。</p></li><li><p>一个进程内部的线程可以共享该进程所分配的资源。</p></li></ul><p>由于进程之间的切换非常消耗资源和时间，为了提高操作系统的并发性，提高CPU的利用率，在进程下面又加入了线程的概念。<br>线程的创建与撤销、线程之间的切换所占用的资源比进程少很多。</p><h3 id="1-1-2-线程"><a href="#1-1-2-线程" class="headerlink" title="1.1.2 线程"></a>1.1.2 线程</h3><p>进程可以分为若干个独立执行流（路径），这些执行流被称为线程。</p><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>线程是进程的一个实体，是CPU调度和分配时间的基本单位。</p><p>线程基本不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同一进程的其它线程共享进程所拥有的全部资源。<br>所以线程间共享内存空间很容易做到，多线程协作也很容易和便捷。</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程间可以并发执行。</p><p>线程提供了多任务处理的能力。</p><h3 id="1-1-3-线程与进程的异同"><a href="#1-1-3-线程与进程的异同" class="headerlink" title="1.1.3  线程与进程的异同"></a>1.1.3  线程与进程的异同</h3><ul><li><p>地址空间：</p><ul><li><p>进程拥有自己独立的内存地址空间；</p></li><li><p>线程共享进程的地址空间；</p><blockquote><p>换句话说就是进程间彼此是完全隔绝的，同一进程的所有线程共享(堆heap)内存；</p></blockquote></li></ul></li><li><p>资源拥有：</p><ul><li>进程是资源分配和拥有的单位</li><li>同一进程内的线程共享进程的资源；</li></ul></li><li><p>系统粒度：</p><ul><li>进程是分配资源的基本单位</li><li>线程则是系统（处理器）调度的基本单位；</li></ul></li><li><p>执行过程：</p><ul><li>每个独立的进程都有一个程序运行的入口、顺序执行序列和程序的出口；</li><li>线程不能独立执行，必须依存于进程中；</li></ul></li><li><p>系统开销：</p><p>创建或撤销进程时，系统都要为之分配或回收资源（如内存空间、IO设备）<br>进程间的切换也要消耗远大于线程切换的开销。</p></li></ul><p>二者均可并发执行。</p><p>一个程序至少有一个进程，一个进程至少有一个线程（主线程）。<br>主线程以函数地址的形式，如Main或WinMain函数，提供程序的启动点，当主线程终止时，进程也随之终止。<br>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</p><h2 id="1-2-并发-并行"><a href="#1-2-并发-并行" class="headerlink" title="1.2 并发/并行"></a>1.2 并发/并行</h2><p>在单CPU系统中，系统调度在某一刻只能让一个线程运行，虽然这种调度机制有多种形式（时分/频分），但无论如何，要通过不断切换需要运行的线程，这种运行模式称为并发（Concurrent）。</p><p>而在多CPU系统中，可以让两个以上的线程同时运行，这种运行模式称为并行（Parallel）。</p><h2 id="1-3-同步-异步操作"><a href="#1-3-同步-异步操作" class="headerlink" title="1.3 同步/异步操作"></a>1.3 同步/异步操作</h2><h3 id="1-3-1-同步与异步的定义"><a href="#1-3-1-同步与异步的定义" class="headerlink" title="1.3.1 同步与异步的定义"></a>1.3.1 同步与异步的定义</h3><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p><ul><li><p>同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。</p></li><li><p>异步，和同步相反 调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回掉函数来处理这个调用。</p></li></ul><p>所有的程序最终都会由计算机硬件来执行，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。<br>这些无须消耗CPU时间的I/O操作是异步操作的硬件基础。<br>硬盘、光驱、网卡、声卡、显卡都具有DMA功能。</p><p>DMA（DirectMemory Access）是直接内存访问的意思，它是不经过CPU而直接进行内存数据存储的数据交换模式。</p><p>I/O操作包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。</p><p>异步操作可达到避免调用线程堵塞的目的，从而提高软件的可响应性。</p><h3 id="1-3-2-同步与异步的对比"><a href="#1-3-2-同步与异步的对比" class="headerlink" title="1.3.2 同步与异步的对比"></a>1.3.2 同步与异步的对比</h3><p>线程不是一个计算机的硬件功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。</p><p>异步模式无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必共享变量，减少了死锁的可能。</p><p>不过，编写异步操作的复杂程度比较高，程序主要使用回调方式进行处理，与人的思维方式有出入，而且难以调试。</p><p>计算密集型工作使用多线程（如图形处理、算法）；IO密集型工作使用异步机制。</p><h2 id="1-4-任务管理器"><a href="#1-4-任务管理器" class="headerlink" title="1.4 任务管理器"></a>1.4 任务管理器</h2><p>映射名称列：<br>进程并不拥有独立于其所属实例的映射名称；</p><blockquote><p>如果运行5个Notepad拷贝，你会看到5个称为Notepad.exe的进程；</p></blockquote><p>它们是根据进程ID进行区分的，该进程ID是由系统维护，并可以循环使用。</p><p>CPU列：<br>它是进程中线程所占用的CPU时间百分比</p><p>每个任务管理器中的进程，其实内部都包含若干个线程，每个时间点都是某个程序进程中的某个线程在运行。</p><h2 id="1-5-线程是如何工作的"><a href="#1-5-线程是如何工作的" class="headerlink" title="1.5 线程是如何工作的"></a>1.5 线程是如何工作的</h2><p>线程被一个线程协调程序管理着——一个CLR委托给操作系统的函数。<br>线程协调程序确保将所有活动的线程被分配适当的执行时间；<br>并且那些等待或阻止的线程——比如说在排它锁中、或在用户输入——都是不消耗CPU时间的。</p><p>在单核处理器的电脑中，线程协调程序完成一个时间片之后迅速地在活动的线程之间进行切换执行。<br>这就导致“波涛汹涌”的行为，例如在第一个例子，每次重复的X 或 Y 块相当于分给线程的时间片。<br>在Windows XP中时间片通常在10毫秒内选择要比CPU开销在处理线程切换的时候的消耗大的多。(即通常在几微秒区间)</p><p>在多核的电脑中，多线程被实现成混合时间片和真实的并发——不同的线程在不同的CPU上运行。<br>但这仍然会出现一些时间切片,因为操作系统的服务线程、以及一些其他的应用程序都会争夺对CPU的使用权。</p><p>线程由于外部因素（比如时间片）被中断被称为被抢占，在大多数情况下,一个线程在被抢占的那一刻就失去了对它的控制权。</p><h2 id="1-6-线程安全"><a href="#1-6-线程安全" class="headerlink" title="1.6 线程安全"></a>1.6 线程安全</h2><p>当使用线程（Thread）时，程序员必须注意同步处理的问题</p><p>理论上每个Thread都是独立运行的个体，由CLR来主导排程，视Thread的优先权的设置，每个Thread会分到特定的运行时间，当某个Thread的运行时间用完时，CLR就会强制将运行权由该Thread取回，转交给下个Thread<br>这也就意味着Thread本身无法得知自己何时会丧失运行权，所以会发生所谓的race condition（竞速状态）。</p><p>当两个线程争夺一个锁的时候（在这个例子里是locker），一个线程等待，或者说被阻止到那个锁变的可用。<br>在这种情况下，就确保了在同一时刻只有一个线程能进入临界区，所以”Done”只被打印了1次。代码以如此方式在不确定的多线程环境中被叫做线程安全。</p><p>临时暂停，或阻止是多线程的协同工作，同步活动的本质特征。<br>等待一个排它锁被释放是一个线程被阻止的原因，另一个原因是线程想要暂停或Sleep一段时间：</p><p>Thread.Sleep (TimeSpan.FromSeconds (30));  // 阻止30秒</p><p>一个线程也可以使用它的Join方法来等待另一个线程结束：</p><p>Threadt = new Thread(Go);  // 假设Go是某个静态方法</p><p>t.Start();</p><p>t.Join();  // 等待（阻止）直到线程t结束</p><h1 id="2-使用多线程的情况分析"><a href="#2-使用多线程的情况分析" class="headerlink" title="2. 使用多线程的情况分析"></a>2. 使用多线程的情况分析</h1><h2 id="2-1-为什么要使用多线程"><a href="#2-1-为什么要使用多线程" class="headerlink" title="2.1 为什么要使用多线程"></a>2.1 为什么要使用多线程</h2><ul><li>并发需要<br>在C/S或B/S模式下的服务端需要处理来自不同终端的并发请求，使用单线程是不可思议的。</li><li>提高应用程序的响应速度<br>当一个耗时的操作进行时，当前程序都会等待这个操作结束<br>此时程序不会响应键盘、鼠标、菜单等操作，程序处于假死状态；<br>使用多线程可将耗时长的操作（Time Consuming）置于一个新的线程，此时程序仍能响应用户的其它操作</li><li>提高CPU利用率<br>在多CPU体系中，操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li><li>改善程序结构<br>一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分<br>这样的程序会利于理解和修改。</li><li>花销小、切换快<br>线程间的切换时间很小，可以忽略不计</li><li>方便的通信机制<br>线程间共享内存，互相间交换数据很简单。</li></ul><p>多线程的意义在于<br>一个应用程序中，有多个执行部分可以同时执行：<br>一个线程可以在后台读取数据，而另一个线程可以在前台展现已读取的数据。</p><p>C#支持通过多线程并行地执行代码，一个线程有它独立的执行路径，能够与其它的线程同时地运行。<br>一个C#程序开始于一个单线程，这个单线程是被CLR和操作系统（也称为“主线程”）自动创建的，并具有多线程创建额外的线程。</p><h2 id="2-2-何时使用多线程"><a href="#2-2-何时使用多线程" class="headerlink" title="2.2 何时使用多线程"></a>2.2 何时使用多线程</h2><p>多线程程序一般被用来在后台执行耗时的任务：主线程保持运行，而工作线程执行后台工作。</p><ul><li><p>对于Windows Forms程序来说，如果主线程执行了一个冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应，进入假死的状态，可能导致用户强制结束程序进程而出现错误。<br>有鉴于此，应该在主线程运行一个耗时任务时另外添加一个工作线程，同时在主线程上有一个友好的提示“处理中…”，允许继续接收事件（比如响应鼠标、键盘操作）。<br>同时程序还应该实现“取消”功能，允许取消/结束当前工作线程。<br>BackgroundWorker类就提供这一功能。</p></li><li><p>在没有用户界面的程序里，比如说WindowsService中使用多线程特别的有意义。<br>当一个任务有潜在的耗时（在等待被请求方的响应——比如应用服务器，数据库服务器），用工作线程完成任务意味着主线程可以在发送请求后立即做其它的事情。</p></li><li><p>另一个多线程的用途是在需要完成一个复杂的计算工作时,它会在多核的电脑上运行得更快，如果工作量被多个线程分开的话（C#中可使用Environment.ProcessorCount属性来侦测处理芯片的数量）。</p></li></ul><p>远程服务器，或WebServices或ASP.NET程序将别无选择，必须使用多线程；<br>一个单线程的ASP.NET Web Service是不可想象的；<br>幸运的是，应用服务器中多线程是相当普遍的；<br>唯一值得关心的是提供适当锁机制的静态变量问题。</p><h2 id="2-3-何时不用多线程"><a href="#2-3-何时不用多线程" class="headerlink" title="2.3 何时不用多线程"></a>2.3 何时不用多线程</h2><p>多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂<br>拥有多线程本身并不复杂，复杂是的线程的交互作用<br>无论交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的Bugs。<br>因此，要么多线程的交互设计简单一些，要么就根本不使用多线程，除非你有强烈的重写和调试欲望。</p><p>当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。<br>在某些情况下，太多的I/O操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务快的多。</p><h1 id="3-C-中的线程"><a href="#3-C-中的线程" class="headerlink" title="3. C#中的线程"></a>3. C#中的线程</h1><h2 id="3-1-程序域"><a href="#3-1-程序域" class="headerlink" title="3.1 程序域"></a>3.1 程序域</h2><p>在.Net中Process由AppDomain对象所取代。</p><p>虽然AppDomain在CLR中被视为Process的替代品，但实际上AppDomain跟Process是属于主从关系的，AppDomain被放置在一个Process中，<br>每个Process可以拥有多个AppDomain，<br>每个AppDomain又可拥有多个Thread对象。</p><p>Process、AppDomain、Thread的关系如下图所示：</p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/image-20210528201620106.png" srcset="/img/loading.gif" alt="进程、域、线程关系图"></p><p>AppDomain定义了一些事件供程序员使用。</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>AssemblyLoad</td><td>触发于AppDomain载入一个Assembly时</td></tr><tr><td>DomainUnLoad</td><td>触发于AppDomain卸载时，也就是Unload函数被调用或是该AppDomain被消灭前</td></tr><tr><td>ProcessExit</td><td>当默认的AppDomain被卸载时触发，多半是应用程序退出时</td></tr></tbody></table><p>各AppDomain间互不影响。</p><h2 id="3-2-C-中实现线程的方法"><a href="#3-2-C-中实现线程的方法" class="headerlink" title="3.2 C#中实现线程的方法"></a>3.2 C#中实现线程的方法</h2><p>一个C#程序成为多线程可以通过2种方式来实现：</p><ul><li><p>明确地创建和运行多线程</p></li><li><p>使用.NET Framework中封装了多线程的类<br>比如:</p><ul><li><p>BackgroundWorker类</p></li><li><p>线程池</p></li><li><p>Threading Timer</p></li></ul></li></ul><p>更多C#中实现线程的方法请看<br><a href="https://mycroftcooper.github.io/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/">C#中实现线程的方法</a></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>计算机基本知识</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#多线程</title>
    <link href="/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在学习本篇文章前你需要学习的相关知识：<br><a href="https://mycroftcooper.github.io/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">线程基本知识</a></p><p>此篇文章简单总结了C#中主要的多线程实现方法，包括：</p><ul><li>Thread<br>线程</li><li>ThreadPool<br>线程池</li><li>Parallel</li><li>Task<br>任务</li><li>BackgroundWorker组件</li></ul><h1 id="2-Thread类"><a href="#2-Thread类" class="headerlink" title="2. Thread类"></a>2. Thread类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li><p>使用Thread类通过ThreadStart（无参数）或ParameterizedThreadStart（一个输入参数）类型的委托创建一个Thread对象，开启一个新线程，执行该委托传递的任务，此时线程尚未处于运行状态。</p></li><li><p>调用Start()函数启动线程，当前线程继续执行。</p></li><li><p>调用Join()函数可以阻塞当前线程，直到调用Join()的线程终止。</p></li><li><p>调用Abort()方法，如需中止线程，在调用该方法的线程上抛出ThreadAbortException异常，以结束该线程</p></li><li><p>可以通过Thread.ResetAbort()方法阻止线程的中止。</p></li></ul><h2 id="2-1-属性表"><a href="#2-1-属性表" class="headerlink" title="2.1 属性表"></a>2.1 属性表</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Name</td><td>属性，获取或设置线程的名称</td></tr><tr><td>Priority</td><td>属性，获取或设置线程的优先级</td></tr><tr><td>ThreadState</td><td>属性，获取线程当前的状态</td></tr><tr><td>IsAlive</td><td>属性，获取当前线程是否处于启动状态</td></tr><tr><td>IsBackground</td><td>属性，获取或设置值，表示该线程是否为后台线程</td></tr><tr><td>CurrentThread</td><td>属性，获取当前正在运行的线程</td></tr></tbody></table><h2 id="2-2-方法表"><a href="#2-2-方法表" class="headerlink" title="2.2 方法表"></a>2.2 方法表</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Start()</td><td>方法，启动线程</td></tr><tr><td>Sleep(int millisecondsTimout)</td><td>方法，将当前线程暂停指定的毫秒数</td></tr><tr><td>Suspend()</td><td>方法，挂起当前线程（已经被弃用）</td></tr><tr><td>Join()</td><td>方法，阻塞调用线程，直到某个线程终止为止</td></tr><tr><td>Interrupt()</td><td>方法，中断当前线程</td></tr><tr><td>Resume()</td><td>方法，继续已经挂起的线程（已经被弃用）</td></tr><tr><td>Abort()</td><td>方法，终止线程（已经被弃用）</td></tr></tbody></table><h2 id="2-3-开启线程"><a href="#2-3-开启线程" class="headerlink" title="2.3 开启线程"></a>2.3 开启线程</h2><p>首先用new申请Thread对象，然后对象调用Start()方法启用线程。</p><p>代码如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Thread.CurrentThread.ManagedThreadId获取当前线程的ID，便于管理。</p></blockquote><p>用Lambda表达式代替函数调用，也能达到相同的效果</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>        &#125;);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-传递参数"><a href="#2-4-传递参数" class="headerlink" title="2.4 传递参数"></a>2.4 传递参数</h2><p>有两种为线程传递参数的方法：</p><ul><li><p>Start()函数传参法</p></li><li><p>对象成员方法传参法</p></li><li><p>匿名方法传参法</p><h3 id="2-4-1-Start-函数传参"><a href="#2-4-1-Start-函数传参" class="headerlink" title="2.4.1 Start()函数传参"></a>2.4.1 Start()函数传参</h3></li></ul><p>为某方法创建新线程后，在使用Start()方法启动线程时传递该方法需要的参数。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> name</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + name);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start(<span class="hljs-string">&quot;April&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-1-对象传递"><a href="#2-4-1-对象传递" class="headerlink" title="2.4.1 对象传递"></a>2.4.1 对象传递</h3><p>初始化一个对象，然后用对象的方法初始化Thread，这样该线程就可以使用这个对象的所有成员。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Download</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> Id;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> Name;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Download</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, <span class="hljs-built_in">string</span> name</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Id = id;<br>            Name = name;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownloadFile</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + <span class="hljs-string">&quot;ID: &quot;</span> + Id + <span class="hljs-string">&quot; Name: &quot;</span> + Name);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);              <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Download download = <span class="hljs-keyword">new</span> Download(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;人民日报&quot;</span>);<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(download.DownloadFile);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-5-匿名方法"><a href="#2-4-5-匿名方法" class="headerlink" title="2.4.5 匿名方法"></a>2.4.5 匿名方法</h3><p>需要接收多个参数的解决方案是使用一个匿名方法调用，方法如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (<span class="hljs-string">&quot;Hello&quot;</span>); &#125;);<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure><p>它的优点是目标方法（这里是WriteText），可以接收任意数量的参数，并且没有装箱操作。</p><p>不过这需要将一个外部变量放入到匿名方法中，如下示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">voidMain</span>(<span class="hljs-params"></span>)</span> &#123;<br>stringtext = <span class="hljs-string">&quot;Before&quot;</span>;<br><br>Threadt = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (text); &#125;);<br><br>text = <span class="hljs-string">&quot;After&quot;</span>;<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是:<br>当外部变量的值被修改，匿名方法可能进行无意的互动，导致一些古怪的现象。<br>一旦线程开始运行，外部变量最好被处理成只读的——除非有人愿意使用适当的锁。</p></blockquote><h2 id="2-5-线程命名"><a href="#2-5-线程命名" class="headerlink" title="2.5 线程命名"></a>2.5 线程命名</h2><p>线程可以通过它的Name属性进行命名，这非常有利于调试：<br>可以用Console.WriteLine打印出线程的名字<br>Microsoft Visual Studio可以将线程的名字显示在调试工具栏的位置上。</p><p>线程的名字可以在被任何时间设置——但只能设置一次，重命名会引发异常。</p><p>程序的主线程也可以被命名，下面例子里主线程通过CurrentThread命名：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#">Class ThreadNaming &#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread.CurrentThread.Name= <span class="hljs-string">&quot;main&quot;</span>;<br><br>Thread worker = <span class="hljs-keyword">new</span> Thread(Go);<br><br>worker.Name= <span class="hljs-string">&quot;worker&quot;</span>;<br><br>worker.Start();<br><br>Go();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Go</span>(<span class="hljs-params"></span>)</span> &#123;<br>Console.WriteLine (<span class="hljs-string">&quot;Hello from &quot;</span>+ Thread.CurrentThread.Name);<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><p>Hellofrom main</p><p>Hellofrom worker</p><h2 id="2-6-前台线程和后台线程"><a href="#2-6-前台线程和后台线程" class="headerlink" title="2.6 前台线程和后台线程"></a>2.6 前台线程和后台线程</h2><ul><li>前台线程(用户界面线程)<br>只要存在有一个前台线程在运行，应用程序就在运行<br>通常用来处理用户的输入并响应各种事件和消息</li><li>后台线程(工作线程)<br>应用程序关闭时，如果后台线程没有执行完，会被强制性的关闭<br>用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等</li></ul><p>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-built_in">string</span>[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//设为后台线程</span><br>        thread.IsBackground = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上例中，thread被设置为后台线程。<br>Main执行完后，没有前台线程了，应用程序就结束，虽然后台线程thread此时尚未执行完，也被终止。</p><blockquote><p>改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。</p></blockquote><p>拥有一个后台工作线程是有益的，<br>最直接的理由是当提到结束程序它总是可能有最后的发言权。<br>交织以不会消亡的前台线程，保证程序的正常退出。</p><p>抛弃一个前台工作线程是尤为险恶的，尤其对Windows Forms程序，<br>因为程序直到主线程结束时才退出（至少对用户来说），但是它的进程仍然运行着。<br>在Windows任务管理器它将从应用程序栏消失不见，但却可以在进程栏找到它。<br>除非用户找到并结束它，它将继续消耗资源，并可能阻止一个新的实例的运行从开始或影响它的特性。</p><p>对于程序失败退出的普遍原因就是存在“被忘记”的前台线程。</p><table><thead><tr><th>线程类型</th><th>动作</th><th>结束</th><th>后续处理</th></tr></thead><tbody><tr><td>前台线程</td><td>主程序关闭</td><td>否</td><td>显示关闭线程/杀掉当前进程</td></tr><tr><td>后台线程</td><td>主程序关闭</td><td>是</td><td>无</td></tr></tbody></table><h2 id="2-7-注意事项"><a href="#2-7-注意事项" class="headerlink" title="2.7 注意事项"></a>2.7 注意事项</h2><ul><li><p>Thread类创建的线程默认为前台线程，可以通过IsBackground属性设置其为前台或后台线程。</p><blockquote><p>用Thread类创建的线程是前台线程，线程池中的线程总是后台线程</p></blockquote></li><li><p>可以通过Priority属性设置线程的优先级。</p></li><li><p>线程内部可以通过try catch捕获该异常，在catch模块中进行一些必要的处理<br>如释放持有的锁和文件资源等</p></li><li><p>慎重使用Abort()方法<br>如果在当前线程中抛出该异常，其结果是可预测的<br>但是对于其他线程，它会中断任何正在执行的代码，有可能中断静态对象的生成，造成不可预测的结果。</p></li></ul><h1 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>ThreadPool类维护一个线程的列表，提供给用户以执行不同的小任务，减少频繁创建线程的开销。<br>该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</p><p>线程池其实就是一个存放线程对象的“池子(pool)”，他提供了一些基本方法，如：设置pool中最小/最大线程数量、把要执行的方法排入队列等等。ThreadPool是一个静态类，因此可以直接使用，不用创建对象。</p><h2 id="3-2-线程池的优点"><a href="#3-2-线程池的优点" class="headerlink" title="3.2 线程池的优点"></a>3.2 线程池的优点</h2><p>每新建一个线程都需要占用内存空间和其他资源<br>而新建了那么多线程，有很多在休眠，或者在等待资源释放；<br>又有许多线程只是周期性的做一些小工作，如刷新数据等等，太浪费了，划不来。<br>实际编程中大量线程突发，然后在短时间内结束的情况很少见。</p><p>于是，就提出了线程池的概念。</p><p>线程池中的线程执行完指定的方法后并不会自动消除，而是以挂起状态返回线程池，如果应用程序再次向线程池发出请求，那么处以挂起状态的线程就会被激活并执行任务，而不会创建新线程，这就节约了很多开销。<br>只有当线程数达到最大线程数量，系统才会自动销毁线程。</p><p>因此，使用线程池可以避免大量的创建和销毁的开支，具有更好的性能和稳定性，其次，开发人员把线程交给系统管理，可以集中精力处理其他任务。</p><h2 id="3-3-线程池的使用"><a href="#3-3-线程池的使用" class="headerlink" title="3.3 线程池的使用"></a>3.3 线程池的使用</h2><ul><li><p>设置线程池最大最小：<br><strong>ThreadPool.SetMaxThreads (int workerThreads,int completionPortThreads)</strong><br>设置可以同时处于活动状态的线程池的请求数目。<br>所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。<br>还可以设置最小线程数。</p></li><li><p>将任务添加进线程池:<br><strong>ThreadPool.QueueUserWorkItem(new WaitCallback(方法名));**或<br>**ThreadPool.QueueUserWorkItem(new WaitCallback(方法名), 参数);</strong></p></li></ul><p>但是线程池的使用也有一些限制：</p><ul><li>线程池中的线程均为后台线程，并且不能修改为前台线程</li><li>不能给入池的线程设置优先级或名称</li><li>对于COM对象，入池的所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA）  线程</li><li>入池的线程只适合时间较短的任务，如果线程需要长时间运行，应使用Thread类创建线程或使用Task的LongRunning选项</li><li>.Net下线程池最小默认允许4个工作线程，最大允许2048个工作线程。<br>并发线程启动后，瞬间会启动4个线程。<br>而剩下的会依据环境每0.5秒或者1秒启动一个。<br>如果同时运行的线程达到Max工作线程，那么剩下的就会挂起<br>直到线程池中的线程有空闲得了，才会去执行。</li></ul><h1 id="4-Parallel类"><a href="#4-Parallel类" class="headerlink" title="4.  Parallel类"></a>4.  Parallel类</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>整理自<a href="https://blog.csdn.net/honantic/article/details/46876871">https://blog.csdn.net/honantic/article/details/46876871</a></p><p>Parallel和Task类都位于System.Threading.Task命名空间中，是对Thread和ThreadPool类更高级的抽象。</p><p>Parrallel类有For()、ForEach()、Invoke()三个方法</p><ul><li><p>Invoke()<br>实现任务并行性<br>允许同时调用不同的方法，</p></li><li><p>Parallel.For()和 Parallel.ForEach()<br>实现数据并行性<br>在每次迭代中调用相同的代码</p></li></ul><h2 id="4-2-常用方法"><a href="#4-2-常用方法" class="headerlink" title="4.2 常用方法"></a>4.2 常用方法</h2><h3 id="4-2-1-Parallel-For"><a href="#4-2-1-Parallel-For" class="headerlink" title="4.2.1 Parallel.For()"></a>4.2.1 Parallel.For()</h3><p>Parallel.For()方法类似于 C#的 for循环语旬,也是多次执行一个任务。<br>使用Parallel.For()方法,可以并行运行迭代。 </p><p>迭代的顺序没有定义，不能保证。</p><p>在For()方法中：</p><ul><li>前两个参数定义了循环的开头和结束。示例从0迭代到 9。</li><li>第 3个参数是一个Action<int>委托<br>是要并行运行迭代的方法</li><li>整数参数是循环的迭代次数,该参数被传递给Action<int>委托引用的方法。</li><li>Parallel.For()方法的返回类型是ParalleLoopResult结构,它提供了循环是否结束的信息。</li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    ParallelLoopResult result = Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, i =&gt;<br>    &#123;<br>        Console.WriteLine<br>        (<span class="hljs-string">&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;</span>, i, Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Console.WriteLine(<span class="hljs-string">&quot;Is completed: &#123;0&#125;&quot;</span>, result.IsCompleted);<br><br>    <span class="hljs-comment">//i: 0, thread id: 9</span><br>    <span class="hljs-comment">//i: 2, thread id: 10</span><br>    <span class="hljs-comment">//i: 1, thread id: 9</span><br>    <span class="hljs-comment">//i: 3, thread id: 10</span><br>    <span class="hljs-comment">//i: 4, thread id: 9</span><br>    <span class="hljs-comment">//i: 6, thread id: 11</span><br>    <span class="hljs-comment">//i: 7, thread id: 10</span><br>    <span class="hljs-comment">//i: 5, thread id: 9</span><br>    <span class="hljs-comment">//i: 8, thread id: 12</span><br>    <span class="hljs-comment">//i: 9, thread id: 11</span><br>    <span class="hljs-comment">//Is completed: True</span><br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><p>同For()循环类似，Parallel.For()方法也可以中断循环的执行。</p><p>Parallel.For()方法的一个重载版本接受第3个Action&lt;int, ParallelLoopState&gt;类型的参数。<br>使用这些参数定义一个方法,就可以调用ParalleLoopState的Break()或Stop()方法,以影响循环的结果。</p><blockquote><p>注意,迭代的顺序没有定义</p></blockquote><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tsx">public static void Main()<br>&#123;<br>    ParallelLoopResult result &#x3D; Parallel.For(0, 100, (i, state) &#x3D;&gt;<br>    &#123;<br>        Console.WriteLine(&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;, i, Thread.CurrentThread.ManagedThreadId);<br><br>        if (i &gt; 10)<br>            state.Break();<br><br>        Thread.Sleep(10);<br>    &#125;);<br><br>    Console.WriteLine(&quot;Is completed: &#123;0&#125;&quot;, result.IsCompleted);<br>    Console.WriteLine(&quot;Lowest break iteration: &#123;0&#125;&quot;, result.LowestBreakIteration);<br><br>    &#x2F;&#x2F;i: 0, thread id: 10<br>    &#x2F;&#x2F;i: 25, thread id: 6<br>    &#x2F;&#x2F;i: 1, thread id: 10<br>    &#x2F;&#x2F;i: 2, thread id: 10<br>    &#x2F;&#x2F;i: 3, thread id: 10<br>    &#x2F;&#x2F;i: 4, thread id: 10<br>    &#x2F;&#x2F;i: 5, thread id: 10<br>    &#x2F;&#x2F;i: 6, thread id: 10<br>    &#x2F;&#x2F;i: 7, thread id: 10<br>    &#x2F;&#x2F;i: 8, thread id: 10<br>    &#x2F;&#x2F;i: 9, thread id: 10<br>    &#x2F;&#x2F;i: 10, thread id: 10<br>    &#x2F;&#x2F;i: 11, thread id: 10<br>    &#x2F;&#x2F;Is completed: False<br>    &#x2F;&#x2F;Lowest break iteration: 11<br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-Parallel-For-lt-TLocal-gt"><a href="#4-2-2-Parallel-For-lt-TLocal-gt" class="headerlink" title="4.2.2 Parallel.For &lt; TLocal &gt;"></a>4.2.2 Parallel.For &lt; TLocal &gt;</h3><p>Parallel.For()方法可能使用几个线程来执行循环 。</p><p>如果需要对每个线程进行初始化,就可以使用Parallel.For<TLocal>方法。<br>除了from和to对应的值之外,For()方法的泛型版本还接受3个委托参数:</p><ul><li><p>第一个参数的类型是Func&lt; TLocal &gt;<br>因为这里的例子对于TLocal使用字符串,所以该方法需要定义为Func&lt; string &gt;,即返回string的方法。<br>这个方法仅对于用于执行迭代的每个线程调用一次</p></li><li><p>第二个委托参数为循环体定义了委托<br>在示例中,该参数的类型是Func&lt;int, ParallelLoopState, string, string&gt;。<br>其中第一个参数是循环迭代,第二个参数 ParallelLoopstate允许停止循环,如前所述 。<br>循环体方法通过第3个参数接收从init方法返回的值,循环体方法还需要返回一个值,其类型是用泛型for参数定义的。</p></li><li><p>For()方法的最后一个参数指定一个委托Action&lt; TLocal &gt;;在该示例中,接收一个字符串。<br>这个方法仅对于每个线程调用一次,这是一个线程退出方法。</p></li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">Parallel.For&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>,() =&gt;<br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;init thread &#123;0&#125;,\t task &#123;1&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;t&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);<br>                &#125;,<br>            (i, pls, str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;body i &#123;0&#125; \t str &#123;1&#125; \t thread &#123;2&#125; \t task &#123;3&#125;&quot;</span>, i, str, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                Thread.Sleep(<span class="hljs-number">10</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;i \t&#123;0&#125;&quot;</span>, i);<br>            &#125;,<br>            (str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;finally\t &#123;0&#125;&quot;</span>, str);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><p><strong>Parallel.For<TLocal> 方法 (Int32, Int32, Func<TLocal>, Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;, Action<TLocal>)</strong></p><p>参数表：</p><table><thead><tr><th>参数名</th><th>数据类型</th><th>作用</th></tr></thead><tbody><tr><td></td><td>TLoca</td><td>线程本地数据的类型</td></tr><tr><td>fromInclusive</td><td>System.Int32</td><td>开始索引（含）</td></tr><tr><td>toExclusive</td><td>System.Int32</td><td>结束索引（不含）</td></tr><tr><td>localInit</td><td>System.Func<TLocal></td><td>用于返回每个任务的本地数据的初始状态的函数委托</td></tr><tr><td>body</td><td>System.Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;</td><td>将为每个迭代调用一次的委托</td></tr><tr><td>localFinally</td><td>System.Action<TLocal></td><td>用于对每个任务的本地状态执行一个最终操作的委托</td></tr><tr><td>返回值</td><td>System.Threading.Tasks.ParallelLoopResult</td><td></td></tr></tbody></table><p>在迭代范围 (fromInclusive，toExclusive) ，为每个值调用一次body 委托。<br>为它提供以下参数：</p><ul><li>迭代次数 (Int32)</li><li>可用来提前退出循环的ParallelLoopState实例</li><li>可以在同一线程上执行的迭代之间共享的某些本地状态。</li></ul><p>对于参与循环执行的每个任务调用 localInit 委托一次，并返回每个任务的初始本地状态。<br>这些初始状态传递给第一个在该任务上 调用的 body。<br>然后，每个后续正文调用返回可能修改过的状态值，传递到下一个正文调用。<br>最后，每个任务上的最后正文调用返回传递给 localFinally 委托的状态值。<br>每个任务调用 localFinally 委托一次，以对每个任务的本地状态执行最终操作。<br>此委托可以被多个任务同步调用；<br>因此您必须同步对任何共享变量的访问。</p><p>Parallel.For方法比在它执行生存期的线程可能使用更多任务，作为现有的任务完成并被新任务替换。<br>这使基础 TaskScheduler 对象有机会添加、更改或移除服务循环的线程。</p><p>如果 fromInclusive 大于或等于 toExclusive，则该方法立即返回，而无需执行任何迭代。</p><h3 id="4-2-3-Parallel-ForEach"><a href="#4-2-3-Parallel-ForEach" class="headerlink" title="4.2.3 Parallel.ForEach()"></a>4.2.3 Parallel.ForEach()</h3><p>Parallel.ForEach()方法遍历实现了IEnumerable的集合,其方式类似于foreach语句,但以异步方式遍历。<br>这里也没有确定遍历顺序。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s) =&gt;<br>            &#123;<br>                Console.WriteLine(s);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><p>中断循环<br>如果需要中断循环,就可以使用ForEach()方法的重载版本和ParallelLoopState参数。其方式与前面的For()方法相同。<br>ForEach()方法的一个重载版本也可以用于访问索引器,从而获得迭代次数<br>如下所示:　</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s, pls, l) =&gt;<br>             &#123;<br>                 Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;\t&#123;1&#125;&quot;</span>, s, l);<br>                 <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">10</span>)<br>                 &#123;<br>                     pls.Break();<br>                 &#125;<br>             &#125;);<br>            Console.WriteLine(<span class="hljs-string">&quot;Lowest break iteration: &#123;0&#125;&quot;</span>, result.LowestBreakIteration);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><h3 id="4-2-4-Parallel-Invoke"><a href="#4-2-4-Parallel-Invoke" class="headerlink" title="4.2.4 Parallel.Invoke()"></a>4.2.4 Parallel.Invoke()</h3><p>如果多个任务应并行运行,就可以使用Parallel.Invoke()方法。<br>Parallel.Invoke()方法允许传递一个Action委托数组,在其中可以指定应运行的方法。<br>示例代码传递了要并行调用的Foo()和Bar()方法:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Foo, Bar);<br>    Console.ReadKey();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Foo&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Bar&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如需同时执行多个不同的任务，可以使用Parallel.Invoke()方法，它允许传递一个Action委托数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Func1, Func2, Func3);<br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Task类"><a href="#5-Task类" class="headerlink" title="5. Task类"></a>5. Task类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>相比于Thread类，Task类为控制线程提供了更大的灵活性。</p><ul><li><p>Task类可以获取线程的返回值</p></li><li><p>可以定义连续的任务：在一个任务结束结束后开启下一个任务</p></li><li><p>可以在层次结构中安排任务，在父任务中可以创建子任务<br>这样就创建了一种依赖关系，如果父任务被取消，子任务也随之取消</p></li></ul><blockquote><p>注意：<br>Task类默认使用线程池中的线程，如果该任务需长期运行，应使用TaskCreationOptions.LongRunning属性告诉任务管理器创建一个新的线程，而不是使用线程池中的线程。</p></blockquote><h2 id="5-2-任务Task和线程Thread的区别："><a href="#5-2-任务Task和线程Thread的区别：" class="headerlink" title="5.2 任务Task和线程Thread的区别："></a>5.2 任务Task和线程Thread的区别：</h2><ul><li>任务是架构在线程之上的<br>也就是说任务最终还是要<strong>抛给线程</strong>去执行。</li><li><strong>任务跟线程不是一对一的关系</strong><br>比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。</li><li>Task和Thread一样，位于System.Threading命名空间下!</li></ul><h2 id="5-3-Task的生存周期与状态"><a href="#5-3-Task的生存周期与状态" class="headerlink" title="5.3 Task的生存周期与状态"></a>5.3 Task的生存周期与状态</h2><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Created</td><td>表示默认初始化任务，但是“工厂创建的”实例直接跳过。</td></tr><tr><td>WaitingToRun</td><td>这种状态表示等待任务调度器分配线程给任务执行。</td></tr><tr><td>RanToCompletion</td><td>任务执行完毕。</td></tr></tbody></table><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//查看Task中的状态</span><br>   <span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>         &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Begin&quot;</span>);<br>            System.Threading.Thread.Sleep(<span class="hljs-number">2000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;Finish&quot;</span>);<br>         &#125;);<br>         Console.WriteLine(<span class="hljs-string">&quot;Before start:&quot;</span> + task1.Status);<br>         task1.Start();<br>         Console.WriteLine(<span class="hljs-string">&quot;After start:&quot;</span> + task1.Status);<br>         task1.Wait();<br>         Console.WriteLine(<span class="hljs-string">&quot;After Finish:&quot;</span> + task1.Status);<br></code></pre></td></tr></table></figure><h2 id="5-4-Task的使用方法"><a href="#5-4-Task的使用方法" class="headerlink" title="5.4 Task的使用方法"></a>5.4 Task的使用方法</h2><h3 id="5-4-1-启动任务"><a href="#5-4-1-启动任务" class="headerlink" title="5.4.1 启动任务"></a>5.4.1 启动任务</h3><p>以下程序演示了几种通过Task类启动任务的方式：</p><ul><li><p>实例化后手动start()</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>    &#123;<br>       <span class="hljs-comment">//TODO you code</span><br>    &#125;);<br>   task1.Start();<br></code></pre></td></tr></table></figure></li><li><p>使用Task工厂对象创建新任务并执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>工厂创建，直接执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadExample</span><br> &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>     &#123;<br>         TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>         Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br><br>         Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br><br>         Task t3 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task constructor and start&quot;</span>);<br>         t3.Start();<br><br>         <span class="hljs-comment">//需要.NetFramework 4.5以上</span><br>         <span class="hljs-keyword">var</span> t4 = Task.Run(() =&gt; TaskMethod.DoTask(<span class="hljs-string">&quot;using Run method&quot;</span>));<br><br>         Console.ReadKey();<br>     &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">TaskMethod</span><br> &#123;<br>     <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> taskLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> msg</span>)</span><br><span class="hljs-function"></span>     &#123;<br>         <span class="hljs-keyword">lock</span> (taskLock)<br>         &#123;<br>             Console.WriteLine(msg);<br>             Console.WriteLine(<span class="hljs-string">&quot;Task id:&#123;0&#125;, Thread id :&#123;1&#125;&quot;</span>,<br>                            Task.CurrentId == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;no task&quot;</span> : Task.CurrentId.ToString(),<br>                            Thread.CurrentThread.ManagedThreadId);<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-2-任务控制"><a href="#5-4-2-任务控制" class="headerlink" title="5.4.2 任务控制"></a>5.4.2 任务控制</h3><h4 id="5-4-2-1-Task-Wait"><a href="#5-4-2-1-Task-Wait" class="headerlink" title="5.4.2.1 Task.Wait()"></a>5.4.2.1 Task.Wait()</h4><p>就是等待任务执行（task1）完成，task1的状态变为Completed。</p><h4 id="5-4-2-2-Task-WaitAll"><a href="#5-4-2-2-Task-WaitAll" class="headerlink" title="5.4.2.2 Task.WaitAll()"></a>5.4.2.2 Task.WaitAll()</h4><p>等待所有的任务都执行完成：<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAll(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;All task finished!&quot;</span>);<br></code></pre></td></tr></table></figure><p>即当task,task2,task3…N全部任务都执行完成之后才会往下执行代码（打印出：“All task finished!”）</p><h4 id="5-4-2-3-Task-WaitAny"><a href="#5-4-2-3-Task-WaitAny" class="headerlink" title="5.4.2.3 Task.WaitAny()"></a>5.4.2.3 Task.WaitAny()</h4><p>同Task.WaitAll，等待任何一个任务完成就继续向下执行，将上面的代码WaitAll替换为WaitAny</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAny(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;Any task finished!&quot;</span>);<br></code></pre></td></tr></table></figure><p> 即当task,task2,task3…N任意一个任务都执行完成之后就会往下执行代码（打印出：” Any task finished!”）</p><h4 id="5-4-2-4-Task-ContinueWith"><a href="#5-4-2-4-Task-ContinueWith" class="headerlink" title="5.4.2.4 Task.ContinueWith()"></a>5.4.2.4 Task.ContinueWith()</h4><p>在第一个Task完成后自动启动下一个Task，实现Task的延续，编写如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>    Task t1 = tf.StartNew(()=&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务1\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t2 = t1.ContinueWith((t) =&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务2\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t3 = t2.ContinueWith(<span class="hljs-built_in">delegate</span>(Task t) <br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务3\r\n&quot;</span>);<br>    &#125;, TaskContinuationOptions.OnlyOnRanToCompletion);<br><br>    Console.ReadKey(); <br>&#125;<br>    <span class="hljs-comment">//执行结果</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//Current Task id = 1</span><br>    <span class="hljs-comment">//执行任务1</span><br><br>    <span class="hljs-comment">//Last Task id = 1</span><br>    <span class="hljs-comment">//Current Task id = 2</span><br>    <span class="hljs-comment">//执行任务2</span><br><br>    <span class="hljs-comment">//Last Task id = 2</span><br>    <span class="hljs-comment">//Current Task id = 3</span><br>    <span class="hljs-comment">//执行任务3</span><br></code></pre></td></tr></table></figure><p>从执行结果可以看出，任务1，2，3被顺序执行，同时通过 TaskContinuationOptions 还可以指定何种情况下继续执行该任务，常用的值包括OnlyOnFaulted, OnlyOnCanceled, NotOnFaulted, NotOnCanceled等。如将上例中的OnlyOnRanToCompletion改为OnlyOnFaulted，任务2结束之后，任务3将不被执行。</p><p>对于ContinueWith()的使用，MSDN演示了更加优雅的“流式”调用方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)  </span><br><span class="hljs-function"></span>&#123;  <br>   <span class="hljs-keyword">var</span> backgroundScheduler = TaskScheduler.Default;  <br>   <span class="hljs-keyword">var</span> uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  <br>   Task.Factory.StartNew(<span class="hljs-built_in">delegate</span> &#123; DoBackgroundComputation(); &#125;,  <br>                         backgroundScheduler).  <br>   ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUI(); &#125;, uiScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; DoAnotherBackgroundComputation(); &#125;,  <br>                             backgroundScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUIAgain(); &#125;, uiScheduler);  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="5-4-2-5-RunSynchronously"><a href="#5-4-2-5-RunSynchronously" class="headerlink" title="5.4.2.5 RunSynchronously()"></a>5.4.2.5 RunSynchronously()</h4><p>用于实现同步调用，直接在当前线程上调用该任务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskMethod.DoTask(<span class="hljs-string">&quot;Just Main thread&quot;</span>);<br>    Task t1 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using Run Sync&quot;</span>);<br>    t1.RunSynchronously();<br>    <span class="hljs-comment">//输出结果</span><br>    <span class="hljs-comment">//Just Main thread</span><br>    <span class="hljs-comment">//Task id: no task, Thread id: 9</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//using Run Sync</span><br>    <span class="hljs-comment">//Task id:1, Thread id :9</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-3-任务取消"><a href="#5-4-3-任务取消" class="headerlink" title="5.4.3 任务取消"></a>5.4.3 任务取消</h3><p>当我们启动了一个task,出现异常或者用户点击取消等等，我们可以取消这个任务。</p><p>我们通过cancellation的tokens来取消一个Task。<br>在很多Task的Body里面包含循环，我们可以在轮询的时候判断IsCancellationRequested属性是否为True<br>如果是True的话就return或者抛出异常，抛出异常后面再说，因为还没有说异常处理的东西。</p><p>下面在代码中看下如何实现任务的取消，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#">　　　　<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br><span class="hljs-keyword">var</span> token = tokenSource.Token;<br><span class="hljs-keyword">var</span> task = Task.Factory.StartNew(() =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>    &#123;<br>        System.Threading.Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">if</span> (token.IsCancellationRequested)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Abort mission success!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;, token);<br>token.Register(() =&gt;<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>&#125;);<br>Console.WriteLine(<span class="hljs-string">&quot;Press enter to cancel task...&quot;</span>);<br>Console.ReadKey();<br>tokenSource.Cancel();<span class="hljs-number">123456789101112131415161718192021</span><br></code></pre></td></tr></table></figure><p>这里开启了一个Task,并给token注册了一个方法，输出一条信息，然后执行ReadKey开始等待用户输入，用户点击回车后，执行tokenSource.Cancel方法，取消任务。</p><blockquote><p>注意：<br>因为任务通常运行以异步方式在线程池线程上，创建并启动任务的线程将继续执行，一旦该任务已实例化。<br>在某些情况下，当调用线程的主应用程序线程，该应用程序可能会终止之前任何任务实际开始执行。<br>其他情况下，应用程序的逻辑可能需要调用线程继续执行，仅当一个或多个任务执行完毕。<br>您可以同步调用线程的执行，以及异步任务它启动通过调用 Wait 方法来等待要完成的一个或多个任务。<br>若要等待完成一项任务，可以调用其 Task.Wait 方法。<br>调用 Wait 方法将一直阻塞调用线程直到单一类实例都已完成执行。</p></blockquote><h3 id="5-4-4-接收任务的返回值"><a href="#5-4-4-接收任务的返回值" class="headerlink" title="5.4.4 接收任务的返回值"></a>5.4.4 接收任务的返回值</h3><p>对于任务有返回值的情况，可使用Task<TResult>泛型类，TResult定义了返回值的类型，以下代码演示了调用返回int值的任务的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">var</span> t5 = <span class="hljs-keyword">new</span> Task&lt;<span class="hljs-built_in">int</span>&gt;(TaskWithResult, Tuple.Create&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    t5.Start();<br>    t5.Wait();<br>    Console.WriteLine(<span class="hljs-string">&quot;adder results: &#123;0&#125;&quot;</span>, t5.Result);<br><br>    Console.ReadKey(); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">TaskWithResult</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> o</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; adder = (Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;)o;<br>    <span class="hljs-keyword">return</span> adder.Item1 + adder.Item2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-任务的层次结构"><a href="#5-5-任务的层次结构" class="headerlink" title="5.5 任务的层次结构"></a>5.5 任务的层次结构</h2><p>如果在一个Task内部创建了另一个任务，这两者间就存在父/子的层次结构，当父任务被取消时，子任务也会被取消。</p><p>如果不希望使用该层次结构，可在创建子任务时选择TaskCreationOptions.DetachedFromParent。</p><h1 id="6-BackgroundWorker控件"><a href="#6-BackgroundWorker控件" class="headerlink" title="6. BackgroundWorker控件"></a>6. BackgroundWorker控件</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>C#提供了BackgroundWorker控件帮助用户更简单、安全地实现多线程运算。</p><p>该控件提供了DoWork, ProgressChanged 和 RunWorkerCompleted事件<br>为DoWork添加事件处理函数，再调用RunWorkerAsync()方法，即可创建一个新的线程执行DoWork任务</p><p>ProgressChanged和RunWorkerCompleted事件均在UI线程中执行，添加相应的处理函数，即可完成任务线程与UI线程间的交互，可用于显示任务的执行状态（完成百分比）、执行结果等。</p><p>同时，该控件还提供了CancleAsync()方法，以中断线程的执行<br>需注意的是，调用该方法后，只是将控件的CancellationPending属性置True，用户需在程序执行过程中查询该属性以判定是否应中断线程。</p><p>具体用法可参考MSDN：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker?view=netframework-4.7.2">BackgroundWorker用法范例</a><br>可以看的出来，BackgroundWorker组件提供了一种执行异步操作（后台线程）的同时，并且还能妥妥的显示操作进度的解决方案。</p><h2 id="6-2-属性表"><a href="#6-2-属性表" class="headerlink" title="6.2 属性表"></a>6.2 属性表</h2><h3 id="6-2-1-WorkerReportsProgress"><a href="#6-2-1-WorkerReportsProgress" class="headerlink" title="6.2.1 WorkerReportsProgress"></a>6.2.1 WorkerReportsProgress</h3><p>bool类型，指示BackgroundWorker是否可以报告进度更新。</p><ul><li>True时，可以成功调用ReportProgress方法</li><li>否则将引发InvalidOperationException异常</li></ul><p>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> BackgroundWorker bgWorker = <span class="hljs-keyword">new</span> BackgroundWorker();<br>bgWorker.WorkerReportsProgress = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-2-WorkerSupportsCancellation"><a href="#6-2-2-WorkerSupportsCancellation" class="headerlink" title="6.2.2 WorkerSupportsCancellation"></a>6.2.2 WorkerSupportsCancellation</h3><p>bool类型，指示BackgroundWorker是否支持异步取消操作</p><ul><li><p>True时，将可以成功调用CancelAsync方法</p></li><li><p>否则将引发InvalidOperationException异<br>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">bgWorker.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-3-CancellationPending"><a href="#6-2-3-CancellationPending" class="headerlink" title="6.2.3 CancellationPending"></a>6.2.3 CancellationPending</h3><p>bool类型，指示应用程序是否已请求取消后台操作。<br>此属性通常放在用户执行的异步操作内部，用来判断用户是否取消执行异步操作。<br>当执行BackgroundWorker.CancelAsync()方法时，该属性值将变为True。<br>用法：</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在DoWork中键入如下代码</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (bgWorker.CancellationPending)<br>      &#123;<br>          e.Cancel = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>          bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>          System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>      &#125;<br>  &#125;   <br></code></pre></td></tr></table></figure><h3 id="6-2-4-IsBusy"><a href="#6-2-4-IsBusy" class="headerlink" title="6.2.4 IsBusy"></a>6.2.4 IsBusy</h3><p>bool类型，指示BackgroundWorker是否正在执行一个异步操作。<br>此属性通常放在BackgroundWorker.RunWorkerAsync()方法之前，避免多次调用RunWorkerAsync()方法引发异常。<br>当执行BackgroundWorker.RunWorkerAsync()方法是，该属性值将变为True。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//防止重复执行异步操作引发错误</span><br> <span class="hljs-keyword">if</span> (bgWorker.IsBusy)<br>     <span class="hljs-keyword">return</span>;<br> bgWorker.RunWorkerAsync();<br></code></pre></td></tr></table></figure><h2 id="6-3-方法表"><a href="#6-3-方法表" class="headerlink" title="6.3 方法表"></a>6.3 方法表</h2><h3 id="6-3-1-RunWorkerAsync"><a href="#6-3-1-RunWorkerAsync" class="headerlink" title="6.3.1 RunWorkerAsync()"></a>6.3.1 RunWorkerAsync()</h3><p>开始执行一个后台操作。</p><p>调用该方法后，将触发BackgroundWorker.DoWork事件，并以异步的方式执行DoWork事件中的代码。<br>该方法还有一个带参数的重载方法：RunWorkerAsync(Object)。<br>该方法允许传递一个Object类型的参数到后台操作中，并且可以通过DoWork事件的DoWorkEventArgs.Argument属性将该参数提取出来。</p><blockquote><p>注：当BackgroundWorker的IsBusy属性为True时，调用该方法将引发InvalidOperationException异常。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在启动异步操作的地方键入代码</span><br>bgWorker.RunWorkerAsync(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="6-3-2-ReportProgress-Int-percentProgress"><a href="#6-3-2-ReportProgress-Int-percentProgress" class="headerlink" title="6.3.2 ReportProgress(Int percentProgress)"></a>6.3.2 ReportProgress(Int percentProgress)</h3><p>报告操作进度。</p><p>调用该方法后，将触发BackgroundWorker. ProgressChanged事件。<br>另外，该方法包含了一个int类型的参数percentProgress，用来表示当前异步操作所执行的进度百分比。</p><p>该方法还有一个重载方法：ReportProgress(Int percentProgress, Object userState)。<br>允许传递一个Object类型的状态对象到 ProgressChanged事件中<br>并且可以通过ProgressChanged事件的ProgressChangedEventArgs.UserState属性取得参数值。</p><blockquote><p>注：调用该方法之前需确保WorkerReportsProgress属性值为True，否则将引发InvalidOperationException异常。</p></blockquote><p>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>&#123;c<br>    <span class="hljs-comment">//向ProgressChanged报告进度</span><br>    bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>    System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-3-CancelAsync"><a href="#6-3-3-CancelAsync" class="headerlink" title="6.3.3 CancelAsync()"></a>6.3.3 CancelAsync()</h3><p>请求取消当前正在执行的异步操作。</p><p>调用该方法将使BackgroundWorker.CancellationPending属性设置为True。<br>但需要注意的是，并非每次调用CancelAsync()都能确保异步操作，CancelAsync()通常不适用于取消一个紧密执行的操作，更适用于在循环体中执行。<br>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在需要执行取消操作的地方键入以下代码</span><br>bgWorker.CancelAsync();<br></code></pre></td></tr></table></figure><h2 id="6-4-事件表"><a href="#6-4-事件表" class="headerlink" title="6.4 事件表"></a>6.4 事件表</h2><h3 id="6-4-1-DoWork"><a href="#6-4-1-DoWork" class="headerlink" title="6.4.1 DoWork"></a>6.4.1 DoWork</h3><p>用于承载异步操作。当调用BackgroundWorker.RunWorkerAsync()时触发。</p><p>需要注意的是：<br>由于DoWork事件内部的代码运行在非UI线程之上，所以在DoWork事件内部应避免于用户界面交互，<br>而于用户界面交互的操作应放置在ProgressChanged和RunWorkerCompleted事件中。</p><h3 id="6-4-2-ProgressChanged"><a href="#6-4-2-ProgressChanged" class="headerlink" title="6.4.2 ProgressChanged"></a>6.4.2 ProgressChanged</h3><p>当调用BackgroundWorker.ReportProgress(int percentProgress)方式时触发该事件。<br>该事件的ProgressChangedEventArgs.ProgressPercentage属性可以接收来自ReportProgress方法传递的percentProgress参数值,ProgressChangedEventArgs.UserState属性可以接收来自ReportProgress方法传递的userState参数。</p><h3 id="6-4-3-RunWorkerCompleted"><a href="#6-4-3-RunWorkerCompleted" class="headerlink" title="6.4.3 RunWorkerCompleted"></a>6.4.3 RunWorkerCompleted</h3><p>异步操作完成或取消时执行的操作，当调用DoWork事件执行完成时触发。</p><p>该事件的RunWorkerCompletedEventArgs参数包含三个常用的属性Error,Cancelled,Result。其中，Error表示在执行异步操作期间发生的错误；Cancelled用于判断用户是否取消了异步操作；Result属性接收来自DoWork事件的DoWorkEventArgs参数的Result属性值，可用于传递异步操作的执行结果。</p><h2 id="6-3-案例"><a href="#6-3-案例" class="headerlink" title="6.3 案例"></a>6.3 案例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.ComponentModel;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br> <br><span class="hljs-keyword">namespace</span> <span class="hljs-title">bcworker</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br>        <span class="hljs-comment">//后台工作</span><br>        <span class="hljs-keyword">private</span> BackgroundWorker bw = <span class="hljs-keyword">new</span> BackgroundWorker();<br> <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>            <span class="hljs-comment">//后台工作初始化</span><br>            bw.WorkerReportsProgress = <span class="hljs-literal">true</span>;<span class="hljs-comment">//报告进度</span><br>            bw.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<span class="hljs-comment">//支持取消</span><br>            bw.DoWork += <span class="hljs-keyword">new</span> DoWorkEventHandler(bgWorker_DoWork);<span class="hljs-comment">//开始工作</span><br>            bw.ProgressChanged += <span class="hljs-keyword">new</span> ProgressChangedEventHandler(bgWorker_ProgessChanged);<span class="hljs-comment">//进度改变事件</span><br>            bw.RunWorkerCompleted += <span class="hljs-keyword">new</span> RunWorkerCompletedEventHandler(bgWorker_WorkerCompleted);<span class="hljs-comment">//进度完成事件</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnStart_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//后台工作运行中，避免重入</span><br>            <span class="hljs-keyword">if</span> (bw.IsBusy) <span class="hljs-keyword">return</span>;<br>            bw.RunWorkerAsync(<span class="hljs-string">&quot;参数&quot;</span>);<span class="hljs-comment">//触发DoWork事件并异步执行，IsBusy置为True</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作将异步执行</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_DoWork</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, DoWorkEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.Argument == &quot;参数&quot;;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>            &#123;<br> <br>                <span class="hljs-keyword">if</span> (bw.CancellationPending)<br>                &#123;<span class="hljs-comment">//用户取消了工作</span><br>                    e.Cancel = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    bw.ReportProgress(i, <span class="hljs-string">&quot;Working&quot;</span>);<span class="hljs-comment">//报告进度，触发ProgressChanged事件</span><br>                    Thread.Sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//模拟工作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//进度改变事件</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_ProgessChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, ProgressChangedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.UserState==&quot;Working&quot;</span><br>            progressBar1.Value = e.ProgressPercentage;<span class="hljs-comment">//取得进度更新控件，不用Invoke了</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作执行完毕,IsBusy置为False</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_WorkerCompleted</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//e.Error == null 是否发生错误</span><br>            <span class="hljs-comment">//e.Cancelled 完成是由于取消还是正常完成</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span> (bw.IsBusy) bw.CancelAsync();<span class="hljs-comment">//设置CancellationPending属性为True</span><br>        &#125;<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InvalidOperationException</title>
    <link href="/2021/05/23/InvalidOperationException/"/>
    <url>/2021/05/23/InvalidOperationException/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是InvalidOperationException"><a href="#1-什么是InvalidOperationException" class="headerlink" title="1. 什么是InvalidOperationException"></a>1. 什么是InvalidOperationException</h1><p>操作无效异常。当方法调用对对象的当前状态无效时引发的异常。</p><h1 id="2-继承树"><a href="#2-继承树" class="headerlink" title="2. 继承树"></a>2. 继承树</h1><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.object?view=netframework-4.8">Object</a></p><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.exception?view=netframework-4.8">Exception</a></p><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.systemexception?view=netframework-4.8">SystemException</a></p><p>InvalidOperationException</p><h1 id="3-详细说明"><a href="#3-详细说明" class="headerlink" title="3. 详细说明"></a>3. 详细说明</h1><p>如果调用方法失败是由无效参数以外的其他原因导致的,则使用该异常。<br>通常, 当对象的状态不支持方法调用时, 将引发此异常。<br>例如, 以下方法或原因会引发异常nvalidOperationException:</p><ul><li>IEnumerator.MoveNext如果在创建枚举器后修改集合的对象,。</li><li>ResourceSet.GetString如果在执行方法调用前关闭资源集,。</li><li>XContainer.Add如果要添加的对象将导致结构不正确的 XML 文档,。</li><li>尝试从非主线程或 UI 线程的线程操作 UI 的方法。</li><li>从非 UI 线程更新 UI 线程</li><li>在循环访问集合时更改集合</li><li>对其对象无法进行比较的数组或集合进行排序</li><li>将为 null <T>转换为其基础类型</li><li>对空集合调用 system.exception 方法</li><li>对没有一个元素的序列调用 SingleOrDefault 或可枚举的。</li><li>动态跨应用程序域字段访问</li></ul><p>由于InvalidOperationException异常可以在多种情况下引发，因此读取由message属性返回的异常消息非常重要。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#BUG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>C#BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#序列化</title>
    <link href="/2021/05/23/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2021/05/23/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是序列化"><a href="#1-1-什么是序列化" class="headerlink" title="1.1 什么是序列化"></a>1.1 什么是序列化</h2><p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。<br>在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p><h2 id="1-2-序列化的目的"><a href="#1-2-序列化的目的" class="headerlink" title="1.2 序列化的目的"></a>1.2 序列化的目的</h2><p>1、方便对象长久存储</p><p>2、方便对象传输</p><p>3、使程序更具维护性</p><h2 id="1-3-序列化操作"><a href="#1-3-序列化操作" class="headerlink" title="1.3 序列化操作"></a>1.3 序列化操作</h2><ul><li><p>序列化<br>将对象转换为字符串或二进制数据，以便存储或传输</p></li><li><p>反序列化<br>将字符串或二进制数据还原成对象</p></li><li><p>无序列化<br>标明对象的属性中哪些属性不需要序列化<br><img src="../images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523182615355.png" srcset="/img/loading.gif" alt="image-20210523182615355"></p></li></ul><h2 id="1-4-常用的序列化格式"><a href="#1-4-常用的序列化格式" class="headerlink" title="1.4 常用的序列化格式"></a>1.4 常用的序列化格式</h2><ul><li><p>Binary(二进制)</p><ul><li>protocol buffer</li></ul></li><li><p>XML</p></li><li><p>JSON(最先进，最推荐)</p><blockquote><p><a href="https://www.bejson.com/">在线JSON格式化校验</a></p></blockquote></li></ul><p>性能指标：Binary&gt;JSON&gt;XML</p><h1 id="2-Binary序列化"><a href="#2-Binary序列化" class="headerlink" title="2. Binary序列化"></a>2. Binary序列化</h1><p>略，求求你，用json吧！</p><p><strong>protocol buffer</strong>是Google的一种<strong>独立和轻量级</strong>的数据交换格式。以<strong>二进制结构</strong>进行存储。</p><h1 id="3-XML序列化"><a href="#3-XML序列化" class="headerlink" title="3. XML序列化"></a>3. XML序列化</h1><p>略，求求你，用json吧！</p><p><strong>XML</strong> 指可扩展标记语言（e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage）。是一种<strong>通用和重量级</strong>的数据交换格式。以<strong>文本结构</strong>存储。</p><p>格式很像HTML</p><h1 id="4-JSON序列化"><a href="#4-JSON序列化" class="headerlink" title="4. JSON序列化"></a>4. JSON序列化</h1><h2 id="4-1-JSON简介"><a href="#4-1-JSON简介" class="headerlink" title="4.1 JSON简介"></a>4.1 JSON简介</h2><p><strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JSON">JSON</a></strong>(<strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">J</a></strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">ava</a><strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">S</a></strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">cript</a> <strong>O</strong>bject <strong>N</strong>otation, JS 对象简谱) 是一种<strong>通用和轻量级</strong>的数据交换格式。以<strong>文本结构</strong>存储，它是完全独立于语言的。</p><h3 id="4-1-1-支持的数据结构"><a href="#4-1-1-支持的数据结构" class="headerlink" title="4.1.1 支持的数据结构"></a>4.1.1 支持的数据结构</h3><p>Json支持下面两种数据结构：</p><ul><li>键值对的集合–各种不同的编程语言，都支持这种数据结构；</li><li>有序的列表类型值的集合–这其中包含数组，集合，矢量，或者序列，等等。</li></ul><h3 id="4-1-2-表现形式"><a href="#4-1-2-表现形式" class="headerlink" title="4.1.2 表现形式"></a>4.1.2 表现形式</h3><h4 id="4-1-2-1-对象"><a href="#4-1-2-1-对象" class="headerlink" title="4.1.2.1 对象"></a>4.1.2.1 对象</h4><p>一个没有顺序的“键/值”,一个对象以花括号“{”开始，并以花括号”}”结束，在每一个“键”的后面，有一个冒号，并且使用逗号来分隔多个键值对。</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var user =  &#123;``&quot;name&quot;``:``&quot;Manas&quot;``,``&quot;gender&quot;``:``&quot;Male&quot;``,``&quot;birthday&quot;``:``&quot;1987-8-8&quot;``&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-2-数组"><a href="#4-1-1-2-数组" class="headerlink" title="4.1.1.2 数组"></a>4.1.1.2 数组</h4><p>设置值的顺序，一个数组以中括号”[“开始,并以中括号”]”结束，并且所有的值使用逗号分隔</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var userlist = [&#123;``&quot;user&quot;``:&#123;``&quot;name&quot;``:``&quot;Manas&quot;``,``&quot;gender&quot;``:``&quot;Male&quot;``,``&quot;birthday&quot;``:``&quot;1987-8-8&quot;``&#125;&#125;, ``&#123;``&quot;user&quot;``:&#123;``&quot;name&quot;``:``&quot;Mohapatra&quot;``,``&quot;Male&quot;``:``&quot;Female&quot;``,``&quot;birthday&quot;``:``&quot;1987-7-7&quot;``&#125;&#125;]<br></code></pre></td></tr></table></figure><h4 id="4-1-1-3-字符串"><a href="#4-1-1-3-字符串" class="headerlink" title="4.1.1.3 字符串"></a>4.1.1.3 字符串</h4><p>任意数量的Unicode字符，使用引号做标记，并使用反斜杠来分隔。</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var userlist = ``&quot;&#123;\&quot;ID\&quot;:1,\&quot;Name\&quot;:\&quot;Manas\&quot;,\&quot;Address\&quot;:\&quot;India\&quot;&#125;&quot;<br></code></pre></td></tr></table></figure><h2 id="4-2-C-使用JSON序列化"><a href="#4-2-C-使用JSON序列化" class="headerlink" title="4.2 C#使用JSON序列化"></a>4.2 C#使用JSON序列化</h2><p><strong>序列化和反序列化有三种方式：</strong></p><ol><li><p>使用<code>JavaScriptSerializer</code>类</p></li><li><p>使用<code>DataContractJsonSerializer</code>类</p></li><li><p>使用JSON.NET类库</p></li></ol><blockquote><p>第三种最好，求求你直接看第三种吧</p></blockquote><h3 id="4-2-1-使用JavaScriptSerializer类"><a href="#4-2-1-使用JavaScriptSerializer类" class="headerlink" title="4.2.1 使用JavaScriptSerializer类"></a>4.2.1 使用JavaScriptSerializer类</h3><p><code>DataContractJsonSerializer</code>类帮助我们序列化和反序列化Json，他在程序集<code> System.Runtime.Serialization.dll</code>下的<code>System.Runtime.Serialization.Json</code>命名空间里。</p><p><strong>首先，这里，我新建一个控制台的程序，新建一个类Student</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Runtime.Serialization;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">JsonSerializerAndDeSerializer</span><br>&#123;<br> [<span class="hljs-meta">DataContract</span>]<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br> &#123;<br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Sex &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>上面的Student实体中的契约 [DataMember]，[DataContract]，是使用<code>DataContractJsonSerializer</code>序列化和反序列化必须要加的，对于其他两种方式不必加，也可以的。</p><p><strong>我们程序的代码：</strong></p><p>要先引用程序集，在引入这个命名空间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//使用DataContractJsonSerializer方式需要引入的命名空间，在System.Runtime.Serialization.dll.中</span><br><span class="hljs-keyword">using</span> System.Runtime.Serialization.Json;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 1.DataContractJsonSerializer方式序列化和反序列化</span><br>   Student stu = <span class="hljs-keyword">new</span> Student()<br>    &#123;<br>     ID = <span class="hljs-number">1</span>,<br>     Name = <span class="hljs-string">&quot;曹操&quot;</span>,<br>     Sex = <span class="hljs-string">&quot;男&quot;</span>,<br>     Age = <span class="hljs-number">1000</span><br>    &#125;;<br>   <span class="hljs-comment">//序列化</span><br>   DataContractJsonSerializer js = <span class="hljs-keyword">new</span> DataContractJsonSerializer(<span class="hljs-keyword">typeof</span>(Student));<br>   MemoryStream msObj = <span class="hljs-keyword">new</span> MemoryStream();<br>   <span class="hljs-comment">//将序列化之后的Json格式数据写入流中</span><br>   js.WriteObject(msObj, stu);<br>   msObj.Position = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">//从0这个位置开始读取流中的数据</span><br>   StreamReader sr = <span class="hljs-keyword">new</span> StreamReader(msObj, Encoding.UTF8);<br>   <span class="hljs-built_in">string</span> json = sr.ReadToEnd();<br>   sr.Close();<br>   msObj.Close();<br>   Console.WriteLine(json);<br><br>   <span class="hljs-comment">//反序列化</span><br>   <span class="hljs-built_in">string</span> toDes = json;<br>   <span class="hljs-comment">//string to = &quot;&#123;\&quot;ID\&quot;:\&quot;1\&quot;,\&quot;Name\&quot;:\&quot;曹操\&quot;,\&quot;Sex\&quot;:\&quot;男\&quot;,\&quot;Age\&quot;:\&quot;1230\&quot;&#125;&quot;;</span><br>   <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> ms = <span class="hljs-keyword">new</span> MemoryStream(Encoding.Unicode.GetBytes(toDes)))<br>   &#123;<br>    DataContractJsonSerializer deseralizer = <span class="hljs-keyword">new</span> DataContractJsonSerializer(<span class="hljs-keyword">typeof</span>(Student));<br>    Student model = (Student)deseralizer.ReadObject(ms);<span class="hljs-comment">// //反序列化ReadObject</span><br>    Console.WriteLine(<span class="hljs-string">&quot;ID=&quot;</span> + model.ID);<br>    Console.WriteLine(<span class="hljs-string">&quot;Name=&quot;</span> + model.Name);<br>    Console.WriteLine(<span class="hljs-string">&quot;Age=&quot;</span> + model.Age);<br>    Console.WriteLine(<span class="hljs-string">&quot;Sex=&quot;</span> + model.Sex);<br>   &#125;<br>   Console.ReadKey(); <br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><p>运行之后结果是：</p><p><img src="/images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181440077.png" srcset="/img/loading.gif" alt="image-20210523181440077"></p><h3 id="4-2-2-使用JavaScriptJsonSerializer类"><a href="#4-2-2-使用JavaScriptJsonSerializer类" class="headerlink" title="4.2.2 使用JavaScriptJsonSerializer类"></a>4.2.2 使用JavaScriptJsonSerializer类</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-comment">//使用JavaScriptSerializer方式需要引入的命名空间，这个在程序集System.Web.Extensions.dll.中</span><br><span class="hljs-keyword">using</span> System.Web.Script.Serialization;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 2.JavaScriptSerializer方式实现序列化和反序列化</span><br>   Student stu = <span class="hljs-keyword">new</span> Student()<br>    &#123;<br>     ID = <span class="hljs-number">1</span>,<br>     Name = <span class="hljs-string">&quot;关羽&quot;</span>,<br>     Age = <span class="hljs-number">2000</span>,<br>     Sex = <span class="hljs-string">&quot;男&quot;</span><br>    &#125;;<br><br>   JavaScriptSerializer js = <span class="hljs-keyword">new</span> JavaScriptSerializer();<br>   <span class="hljs-built_in">string</span> jsonData = js.Serialize(stu);<span class="hljs-comment">//序列化</span><br>   Console.WriteLine(jsonData);<br><br><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span>/反序列化方式一：</span><br>   <span class="hljs-built_in">string</span> desJson = jsonData;<br>   <span class="hljs-comment">//Student model = js.Deserialize&lt;Student&gt;(desJson);// //反序列化</span><br>   <span class="hljs-comment">//string message = string.Format(&quot;ID=&#123;0&#125;,Name=&#123;1&#125;,Age=&#123;2&#125;,Sex=&#123;3&#125;&quot;, model.ID, model.Name, model.Age, model.Sex);</span><br>   <span class="hljs-comment">//Console.WriteLine(message);</span><br>   <span class="hljs-comment">//Console.ReadKey(); </span><br><br><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span>/反序列化方式2</span><br>   <span class="hljs-built_in">dynamic</span> modelDy = js.Deserialize&lt;<span class="hljs-built_in">dynamic</span>&gt;(desJson); <span class="hljs-comment">//反序列化</span><br>   <span class="hljs-built_in">string</span> messageDy = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;动态的反序列化,ID=&#123;0&#125;,Name=&#123;1&#125;,Age=&#123;2&#125;,Sex=&#123;3&#125;&quot;</span>,<br>    modelDy[<span class="hljs-string">&quot;ID&quot;</span>], modelDy[<span class="hljs-string">&quot;Name&quot;</span>], modelDy[<span class="hljs-string">&quot;Age&quot;</span>], modelDy[<span class="hljs-string">&quot;Sex&quot;</span>]);<span class="hljs-comment">//这里要使用索引取值，不能使用对象.属性</span><br>   Console.WriteLine(messageDy);<br>   Console.ReadKey(); <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span> </span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181633952.png" srcset="/img/loading.gif" alt="image-20210523181633952"></p><h3 id="4-2-3-使用JSON-NET类库-推荐"><a href="#4-2-3-使用JSON-NET类库-推荐" class="headerlink" title="4.2.3 使用JSON.NET类库(推荐)"></a>4.2.3 使用JSON.NET类库(推荐)</h3><p>首先在NuGet上下载Json.NET类库。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//使用Json.NET类库需要引入的命名空间</span><br><span class="hljs-keyword">using</span> Newtonsoft.Json;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 3.Json.NET序列化</span><br>   List&lt;Student&gt; lstStuModel = <span class="hljs-keyword">new</span> List&lt;Student&gt;() <br>   &#123;<br>   <br>   <span class="hljs-keyword">new</span> Student()&#123;ID=<span class="hljs-number">1</span>,Name=<span class="hljs-string">&quot;张飞&quot;</span>,Age=<span class="hljs-number">250</span>,Sex=<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>   <span class="hljs-keyword">new</span> Student()&#123;ID=<span class="hljs-number">2</span>,Name=<span class="hljs-string">&quot;潘金莲&quot;</span>,Age=<span class="hljs-number">300</span>,Sex=<span class="hljs-string">&quot;女&quot;</span>&#125;<br>   &#125;;<br><br>   <span class="hljs-comment">//Json.NET序列化</span><br>   <span class="hljs-built_in">string</span> jsonData = JsonConvert.SerializeObject(lstStuModel);<br><br>   Console.WriteLine(jsonData);<br>   Console.ReadKey();<br><br><br>   <span class="hljs-comment">//Json.NET反序列化</span><br>   <span class="hljs-built_in">string</span> json = <span class="hljs-string">@&quot;&#123; &#x27;Name&#x27;:&#x27;C#&#x27;,&#x27;Age&#x27;:&#x27;3000&#x27;,&#x27;ID&#x27;:&#x27;1&#x27;,&#x27;Sex&#x27;:&#x27;女&#x27;&#125;&quot;</span>;<br>   Student descJsonStu = JsonConvert.DeserializeObject&lt;Student&gt;(json);<span class="hljs-comment">//反序列化</span><br>   Console.WriteLine(<span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;反序列化： ID=&#123;0&#125;,Name=&#123;1&#125;,Sex=&#123;2&#125;,Sex=&#123;3&#125;&quot;</span>, descJsonStu.ID, descJsonStu.Name, descJsonStu.Age, descJsonStu.Sex));<br>   Console.ReadKey(); <br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/C%E4%BA%95%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181908106.png" srcset="/img/loading.gif" alt="image-20210523181908106"></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader的形式</title>
    <link href="/2021/05/23/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/"/>
    <url>/2021/05/23/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>UnityShader最重要的任务是：指定各种着色器所需的代码</p><p>而代码的编写形式有以下三种</p><h1 id="2-长子：顶点-片元着色器"><a href="#2-长子：顶点-片元着色器" class="headerlink" title="2. 长子：顶点/片元着色器"></a>2. 长子：顶点/片元着色器</h1><p>在Unity中我们可以使用<strong>CG/HLSL语言</strong>来编写**顶点/片元着色器(Vertex/Fragment Shader)**。<br>它更复杂也更灵活。</p><p>它写在Pass语句块内，格式如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">Shader <span class="hljs-string">&quot;Unlit/MyFirstShader&quot;</span><br>&#123;<br>Properties<br>&#123;<br>_Color(<span class="hljs-string">&quot;Color&quot;</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>&#125;<br><br>SubShader<br>&#123;<br>Pass<br>&#123;<br><span class="hljs-built_in">CGPROGRAM</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span><br><br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>#pragma是Unity内置的编绎指令用的命令<br>在Pass中我们就利用此命令来声明所需要的顶点着色器与片元着色器。</p><ul><li><p>#pragma vertexName<br>定义顶点着色器为*name,*通常情况下会起名为vert。</p></li><li><p>#pragma fragmentName<br>定义片元着色器为*name,*通常情况下会起名为frag。</p></li></ul><h2 id="2-1-顶点着色器"><a href="#2-1-顶点着色器" class="headerlink" title="2.1 顶点着色器"></a>2.1 顶点着色器</h2><p>顶点着色器就是处理顶点的着色器，每个顶点都会执行一次顶点着色器。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">float4 <span class="hljs-title">vert</span><span class="hljs-params">(float4 vertex:POSITION)</span>:SV_POSITION</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> UnityObjectToClipPos(vertex);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/image-20210523163930947.png" srcset="/img/loading.gif" alt="image-20210523163930947"></p><p>首先呢，我们先来解释下顶点这个函数的结构。</p><ol><li>顶点着色器函数的名称，在上面我们已经指定了顶点着色器的名称就是vert，所以这里我们必须要用vert作为名称。</li><li>其中float4 vertex是我们自己定义的一个四维向量，名字叫vertex（名字我们可以随便起），仅仅定义一个四维向量并不能使它拥有我们模型的顶点信息，所以这里我们需要为它指定一个语义——POSITION，POSITION就是代表着模型的顶点位置信息。此时变量vertex就表示着我们模型的顶点位置。</li><li>在顶色着色器中最主要的事情就是将顶点从模型坐标转换到裁剪坐标（将模型显示在二维显示器上时需要做的一些矩阵转换）。<br>不会矩阵转换怎么办，没关系，Unity已经为我们准备好现成的命令了，只需调用UnityObjectToClipPos即可，后面括号中加上我们的顶点位置变量就可以了。</li><li>在后面片断着色器中我们需要顶点着色器中的输出结果，所以3中需要加上return来将转换后的顶点返回，float4就是用来定义我们返回的是四维向量。</li><li>经过变换后返回的顶点位置，我们也需要利用语义来标记一下，以便片元着色器可以知道哪个是从顶点着色器输出过来的顶点位置信息。所以我们在函数的后面加上: SV_POSITION。</li></ol><blockquote><p>简单地说：<br>POSITION语义是用于顶点着色器，用来指定模型的顶点位置，是在变换前的顶点的本地空间坐标。<br>SV_POSITION语义则用于像素着色器，用来标识经过顶点着色器变换之后的顶点坐标。</p><p>在顶点着色器中处理顶点时，我们首先需要获取到模型的顶点数据（比如顶点位置、法线信息、顶点颜色等等），那么这些数据都是直接存储在模型中的，我们在Shader中只需要通过标识语义就可以自动获得。</p></blockquote><p>此时我们的Shader还不能正常编译，因为了除了顶点着色器外，还们需要一个片断着色器。</p><h2 id="2-2-片元着色器"><a href="#2-2-片元着色器" class="headerlink" title="2.2 片元着色器"></a>2.2 片元着色器</h2><p>片元着色器也被称作像素着色器，主要是处理最终显示在屏幕上的像素结果。</p><p>经过顶点着色器的处理，我们已经得到了最终显示在屏幕上的顶点矩阵，内部会自动进行插值计算，以获得当前模型的所有片元像素，然后每个像素都会执行一次片元着色器，得到最终每个像素的颜色值。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">fixed4 _Color;<br><span class="hljs-function">fixed4 <span class="hljs-title">frag</span> <span class="hljs-params">()</span> : SV_Target</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _Color;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/image-20210523164629339.png" srcset="/img/loading.gif" alt="image-20210523164629339"></p><ol><li><p>片断着色器的函数名，其中()中是空的，因为在这个简单的示例中我们并不需要额外的数据传过来，所以暂时为空。</p></li><li><p>在Cg/HLSL中使用Properties中的变量前还需要在Cg/HLSL中再重新声明一次，名称要求一致。<br>这是死规则，我们只能按照要求来执行。<br>float、half、fixed，这三都是浮点数的表示，只是分别对应的精度不一样，主要用此可以进行更进一步的优化。</p></li><li><p>直接返回_Color,也就是直接返回我们在材质面板中定义的颜色，这也是我们这个小例子想要的效果。</p></li><li><p>返回的值是个四维向量，我们用float4来表示，如果想优化的话就用fixed4来表示，精度问题，这里不是重点。</p></li><li><p>SV_TARGET是系统值，表示该函数返回的是用于下一个阶段输出的颜色值，也就是我们最终输出到显示器上的值。</p></li></ol><h2 id="2-3-最终代码"><a href="#2-3-最终代码" class="headerlink" title="2.3 最终代码"></a>2.3 最终代码</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs text">Shader &quot;Unlit/MyFirstShader&quot;<br>&#123;<br>Properties<br>&#123;<br>_Color(&quot;Color&quot;, Color) = (1,1,1,1)<br>&#125;<br><br>SubShader<br>&#123;<br>Pass<br>&#123;<br>CGPROGRAM<br>#pragma vertex vert<br>#pragma fragment frag<br><br>fixed4 _Color;<br><br>float4 vert ( float4 vertex : POSITION ) : SV_POSITION<br>&#123;<br>return UnityObjectToClipPos(vertex);<br>&#125;<br><br>fixed4 frag () : SV_Target<br>&#123;<br>return _Color;<br>&#125;<br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们已经可以正常编译并实时更换颜色得到反馈了。</p><h2 id="2-4-注意"><a href="#2-4-注意" class="headerlink" title="2.4 注意"></a>2.4 注意</h2><p>顶点着色器与片断着色器的执行并不是1:1的</p><p>例如:<br>一个三角面片，只有三个顶点，顶点着色器只需执行3次，而片断着色器由最终的像素数来决定，执行几百上千都是很正常的。</p><p>所以从性能的角度来考虑，我们要尽量把计算放在顶点着色器中去执行。<br>其次在片断着色器中也要尽量的简化算法，节省开支。</p><h1 id="3-宠儿：表面着色器"><a href="#3-宠儿：表面着色器" class="headerlink" title="3. 宠儿：表面着色器"></a>3. 宠儿：表面着色器</h1><p>表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型。</p><p>特点是：</p><ul><li><p>代码量少，使用方便简单</p></li><li><p>渲染代价大</p></li></ul><p>实际上，表面着色器在运行时会被Unity编译成对应的顶点/片元着色器。<br>我们可以理解为表面着色器是Unity对顶点/片元着色器的封装抽象。</p><p>一个非常简单的表面着色器示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Custom/simple surface Shader&quot;</span> <br>&#123;<br>SubShader<br>&#123;<br>Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span> = <span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>CGPROGRAM<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> surface surf Lambert</span><br>struct Input <br>&#123;<br>float4 color : COLOR;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> </span><br><span class="hljs-function"></span>&#123;<br>o.Albedo = <span class="hljs-number">1</span>;<br>&#125;<br>ENDCG<br>&#125;<br>Fallback <span class="hljs-string">&quot;Di ffuse&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>从上述程序中可以看出，表面着色器被定义在SubShader语义块(而非Pass语义块)中的CGPROGRAM和ENDCG之间。<br>因为表面着色器不需要开发者关心使用多少个Pass每个如何渲染等问题，Unity 会在背后为我们做好这些事情。</p><blockquote><p>注意：<br>这里的Cg/HLSL是Unity经封装后提供的，它的语法和标准的CgHLSL语法几乎一样， 但还是有细微的不同<br>例如有些原生的函数和用法Unity并没有提供支持。</p></blockquote><h1 id="4-孤儿：固定函数着色器"><a href="#4-孤儿：固定函数着色器" class="headerlink" title="4. 孤儿：固定函数着色器"></a>4. 孤儿：固定函数着色器</h1><p>上述两种UnityShader形式都使用了可编程管线，而对于一些不支持可编程管线的旧设备，就需要用**固定函数着色器(Fixed Function Shader)**。</p><p>这种着色器往往只能完成非常简单的效果。</p><p>固定函数着色器的代码被定义在Pass语句块中，且只是用ShaderLab的语法，不支持Cg/HLSL。</p><p>因为时代变了，现在大多数GPU都支持可编程管线，所以固定函数着色器成了孤儿。<br>实际上，固定函数着色器在运行时会被Unity编译成对应的顶点/片元着色器，因此真正的固定函数着色器已经不存在了。</p><blockquote><p>所以就略过吧，别学，没用的。</p></blockquote><h1 id="5-着色器的选择"><a href="#5-着色器的选择" class="headerlink" title="5. 着色器的选择"></a>5. 着色器的选择</h1><ul><li>除非你有非常明确的需求必须要使用固定函数着色器<br>例如需要在非常旧的设备上运行你的游戏(这些设备非常少见)<br>否则<strong>不要使用固定函数着色器</strong></li><li>如果你想和<strong>各种光源</strong>打交道<br>使用表面着色器<br>但需要小心它在<strong>移动平台的性能表现</strong></li><li>如果你使用的<strong>光照数目非常少</strong><br>使用顶点/片元着色器</li><li>如果你有<strong>很多自定义的渲染效果</strong><br>请选择顶点/片元着色器</li></ul><blockquote><p>其它两种着色器在编译时都会编译成顶点/片选着色器<br>因此从本质上来讲，Unity中只存在顶点/片选着色器</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader的结构</title>
    <link href="/2021/05/23/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <url>/2021/05/23/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是shader"><a href="#1-1-什么是shader" class="headerlink" title="1.1 什么是shader"></a>1.1 什么是shader</h2><p>Shader的中文翻译是着色器，是一类面对GPU编程语言的总称。<br>Shader其实就是一段代码，这段代码的作用是告诉GPU具体怎样去绘制模型的每一个顶点的颜色以及最终每一个像素点的颜色。</p><p>更具体的讲：</p><ul><li>GPU流水线上–些可高度编程的阶段,而由着色器编译出来的最终代码是会在GPU.上运行的(对于固定管线的渲染来说，着色器有时等同于–些特定的渲染设置);</li><li>有一些特定类型的着色器，如顶点着色器、片元着色器等;</li><li>依靠着色器我们可以控制流水线中的渲染细节,例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</li></ul><h2 id="1-2-shader语言有哪些"><a href="#1-2-shader语言有哪些" class="headerlink" title="1.2 shader语言有哪些"></a>1.2 shader语言有哪些</h2><p>既然Shader是一段代码，那必然要用一种语言来书写它，目前主流的有三种语言：</p><ul><li>基于OpenGL<br>OpenGL Shading Language，简称GLSL。</li><li>基于DirectX<br>High Level Shading Language,简称HLSL。</li><li>基于NVIDIA<br>C for Graphic，简称Cg语言。</li></ul><p>GLSL与HLSL分别是基于OpenGL和Direct3D的接口，两者不能混用。</p><p>而Cg语言是用于图形的C语言。<br>这其实说明了当时设计人员的一个初衷，就是<strong>让基于图形硬件的编程变得和C语言编程一样方便，自由</strong>。<br>正如C++和 Java的语法是基于C的，Cg语言本身也是基于C语言的。<br>如果您使用过C、C++、Java其中任意一个，那么Cg的语法也是比较容易掌握的。<br>Cg语言极力保留了C语言的大部分语义，力图让开发人员从硬件细节中解脱出来，Cg同时拥有高级语言的好处，如代码的易重用性，可读性高等。</p><blockquote><p>Cg语言是Microsoft和NVIDIA相互协作在标准硬件光照语言的语法和语义上达成了一致。<br>所以，HLSL和Cg其实是同一种语言。</p></blockquote><h2 id="1-3-什么是UnityShader"><a href="#1-3-什么是UnityShader" class="headerlink" title="1.3 什么是UnityShader"></a>1.3 什么是UnityShader</h2><p>Unity Shader严格来说并不是传统上的Shader,而是Unity自身封装后的一种便于书写的Shader，又称为ShaderLab。</p><p><img src="/images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/image-20210523140053736.png" srcset="/img/loading.gif" alt="UnityShader是封装"></p><p>其实在Unity中反而一切变的简单起来了，我们只需关心如何去这实现我们想要的效果就好了，其余的事情全部交给Unity来自动处理。<br>因为我们在Unity中编写的Shader最终会根据不同的平台来编绎成不同的着色器语言。</p><p>官方建议使用Cg/HLSL来编写ShaderLab，因为Cg/HLSL有更好的跨平台性。</p><h1 id="2-UnityShader的结构"><a href="#2-UnityShader的结构" class="headerlink" title="2. UnityShader的结构"></a>2. UnityShader的结构</h1><p>一段完整UnityShader代码的结构应该如下面的例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Shader">Shader &quot;Path&#x2F;ShaderName&quot;<br>&#123;<br>Properties<br>&#123;<br><br>&#125;<br>SubShader<br>&#123;<br>Pass<br>&#123;<br><br>&#125;<br>&#125;<br>FallBack &quot;Diffuse&quot;<br>CustomEditor &quot;EditorName&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>从整体来看的话，大致是这样的一个框架结构：</p><p><strong>Shader “name” { [Properties] SubShaders [FallBack] [CustomEditor] }</strong></p><blockquote><p>[]方括号表示可选</p></blockquote><p>可以拆分成以下几个大部分：</p><ul><li>Shader “name”</li><li>Properties</li><li>SubShaders</li><li>FallBack</li><li>CustomEditor</li></ul><h2 id="2-1-Shader-“name”-路径名称"><a href="#2-1-Shader-“name”-路径名称" class="headerlink" title="2.1 Shader “name”-路径名称"></a>2.1 Shader “name”-路径名称</h2><p>每个Unity Shader文件的第一行都需要通过Shader语句来指定该Unity Shader 的名字。<br>当为材质选择使用的UnityShader时,这些名称就会出现在材质面板的下拉列表里。</p><p>通过在字符串中添加斜杠(“/”)， 可以控制UnityShader在材质面板中出现的位置<br>例如:<code>Shader &quot;Custom/ MyShader&quot; &#123;...&#125;</code><br>那么这个UnityShader在材质面板中的位置就是:Shader -&gt; Custom -&gt; MyShader</p><blockquote><p>如果我们把路径名称放在Hidden下面的话<br>比如：<code>Shader &quot;Hidden/TA/MyFirstShader&quot;</code><br>则表示在材质面板中隐藏此Shader,你将无法通过材质下拉列表中找到它。<br>这在做一些不需暴露的Shader时很有用处，可以使Shader下拉列表更精简整洁。</p></blockquote><blockquote><p>而Shader文件的名称，也就是我们在Project面板中的资源文件的名称，是可以与Shader内部的路径名称不一样的，这点与C#是不同的。<br>在定义内部路径名称时，建议统一规划下，不要Shader过多后导致很混乱，不便于美术去使用。</p></blockquote><h2 id="2-2-Properties-属性"><a href="#2-2-Properties-属性" class="headerlink" title="2.2 Properties-属性"></a>2.2 Properties-属性</h2><p>Properties是UnityShader与材质的桥梁，语句块中的属性会出现在材质面板。</p><p>格式如下：<br><code>[Attribute]_Name (&quot;Display Name&quot;,Type) = Default Value</code></p><h3 id="2-2-1-Attribute"><a href="#2-2-1-Attribute" class="headerlink" title="2.2.1 Attribute"></a>2.2.1 Attribute</h3><p>属性标记，说白了就是Unity内置的几个属性标记关键字，用于对当前这条属性进行一些特殊的处理，在下面会进行详细介绍。</p><blockquote><p>此标记不是必选项，可以不添加，同时一条属性上也可以有多条属性标记。</p></blockquote><h3 id="2-2-2-Name"><a href="#2-2-2-Name" class="headerlink" title="2.2.2 _Name"></a>2.2.2 _Name</h3><p>属性的名称，也就是变量名。<br>在Shader的CG代码中就是通过这个名称来调用此属性内容的，在外部利用脚本调用时也是这个名称，所以一定要用英文。</p><p><strong>在名称前一定要加上下划线，否则会出现编绎错误！</strong></p><blockquote><p>关于此变量名，有一点很重要！<br>如果此Shader有FallBack的话，一定要将此Shader中的变量名与FallBack中的变量名保持一致，否则会出现FallBack后原有的属性值获取不到的情况<br>切记！</p></blockquote><h3 id="2-2-3-Display-Name"><a href="#2-2-3-Display-Name" class="headerlink" title="2.2.3 Display Name"></a>2.2.3 Display Name</h3><p>显示在材质面板上的名称，主要起到说明解释的作用，可用中文</p><blockquote><p>（正式项目中建议最好还是用英文）</p></blockquote><h3 id="2-2-4-Type"><a href="#2-2-4-Type" class="headerlink" title="2.2.4 Type"></a>2.2.4 Type</h3><p>属性的类型，常用的有以下几种：</p><table><thead><tr><th>属性类型</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>Int</td><td>整数</td><td>_Int(“我是Int”, Int) = 1</td></tr><tr><td>Float</td><td>浮点数(小数)</td><td>_Float(“我是Float”, Float) = 0.5</td></tr><tr><td>Range</td><td>有范围的浮点数(使用滑块)</td><td>_Float(“我是Float”, Range( 0 , 1)) = 0.5</td></tr><tr><td>PowerSlider</td><td>有曲度变化的Range(非线性滑块)</td><td>[PowerSlider(3)]_Float(“我是Float”, Range( 0 , 1)) = 0.5</td></tr><tr><td>IntRange</td><td>向下取整(使用滑块)</td><td>[IntRange]_Float(“我是Float”, Range( 0 , 1)) = 1</td></tr><tr><td>Toggle</td><td>一个checkbook，选中为1，不选为0</td><td>[Toggle]_Float(“我是Float”, Range( 0 , 1)) = 1</td></tr><tr><td>Enum</td><td>枚举(下拉列表)</td><td>[Enum(UnityEngine.Rendering.CullMode)]_Float(“我是Float”, Float) = 1</td></tr><tr><td>Color</td><td>RGBA颜色</td><td>_Color(“我是Color”, Color) = (1,1,1,1)</td></tr><tr><td>HDR</td><td>带亮度的颜色</td><td>[HDR]_Color(“Color”, Color) = (1,1,0,1)</td></tr><tr><td>Vector</td><td>四维向量</td><td>_Vector(“我是Vector”, Vector) = (0,0,0,0)</td></tr><tr><td>2D</td><td>2D纹理</td><td>_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>NoScaleOffset</td><td>没有Tiling (贴图重复度)与Offset (贴图偏移值)的2D纹理</td><td>[NoScaleOffset]_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>Normal</td><td>法线贴图</td><td>[Normal]_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>3D</td><td>3D纹理</td><td>_MainTex(“我是3D纹理”, 3d) = “” {}</td></tr><tr><td>Cube</td><td>立方体纹理</td><td>_MainTex(“我是Cube纹理”, CUBE) = “” {}</td></tr></tbody></table><blockquote><p>其他属性类型</p><p><strong>[Header]</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">Properties<br>&#123;<br>[Header(This is Header )]_Int(&quot;我是Int&quot;, Int) = 1<br>_Float(&quot;我是Float&quot;, Range( 0 , 1)) = 1<br>&#125;<br></code></pre></td></tr></table></figure><p>在材质面板上进行标注，通常用作分类组别用，注意只支持英文、数字、空格以及下划线。</p><p><strong>[HideInInspector]</strong><br>在材质面板中隐藏此条属性，在不希望暴露某条属性时可以快速将其隐藏。</p></blockquote><h3 id="2-2-5-Default-Value"><a href="#2-2-5-Default-Value" class="headerlink" title="2.2.5 Default Value"></a>2.2.5 Default Value</h3><p>默认值。<br>当第一次指定此Shader时，或者在材质面板上执行Reset时，属性的值会自动恢复到默认值。</p><ul><li><p>Int、 Float、 Range<br>其默认值就是一个单独的数字;</p></li><li><p>Color和Vector<br>默认值是用圆括号包围的一个四维向量;</p></li><li><p>2D、Cube、 3D这3种纹理类型<br>默认值的定义稍微复杂，它们的默认值是通过一个字符串 后跟一个花括号来指定的。</p><ul><li>字符串要么是空的，要么是内置的纹理名称<br>如“white”“black” “gray”或者“bump”。 </li></ul></li></ul><blockquote><p>花括号的用处原本是用于指定一些纹理属性的。<br>例如在Unity 5.0以前的版本中，我们可以通过TexGenCubeReflect、TexGen CubeNormal等选项来控制固定管线的纹理坐标的生成。<br>但在Unity 5.0以后的版本中，这些选项被移除了，如果我们需要类似的功能，就需要自己在顶点着色器中编写计算相应纹理坐标的代码。</p></blockquote><h3 id="2-2-6-案例"><a href="#2-2-6-案例" class="headerlink" title="2.2.6 案例"></a>2.2.6 案例</h3><p>下面的代码给出了一个展示所有属性类型的例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php">Properties<br>&#123;<br><span class="hljs-comment">//Numbers and Sliders</span><br>_Int (<span class="hljs-string">&quot;Int&quot;</span>， <span class="hljs-keyword">Int</span>) = <span class="hljs-number">2</span><br><span class="hljs-keyword">Float</span> (<span class="hljs-string">&quot;Float&quot;</span>, <span class="hljs-keyword">Float</span>) = <span class="hljs-number">1.5</span><br>_Range (<span class="hljs-string">&quot;Range&quot;</span> ,Range(<span class="hljs-number">0.0</span>, <span class="hljs-number">5.0</span>)) = <span class="hljs-number">3.0</span><br><br>   <span class="hljs-comment">// Colors and Vectors .</span><br>Color (<span class="hljs-string">&quot;Color&quot;</span>, color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>_Vector (<span class="hljs-string">&quot;Vector&quot;</span>, Vector) = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// Textures</span><br><span class="hljs-number">2</span>D (<span class="hljs-string">&quot;2D&quot;</span>， <span class="hljs-number">2</span>D) =”<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">Cube (&quot;</span>Cube<span class="hljs-string">&quot;, Cube) = &quot;</span>white<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">_3D (&quot;</span><span class="hljs-number">3</span>D<span class="hljs-string">&quot;, 3D) = &quot;</span>black<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>下图是该案例在属性面板中的显示：</p><p><img src="/images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/03B62754D758D194E8F6A1E8F9704AD1.jpg" srcset="/img/loading.gif" alt="属性面板"></p><h2 id="2-3-SubShaders-子着色器"><a href="#2-3-SubShaders-子着色器" class="headerlink" title="2.3 SubShaders-子着色器"></a>2.3 SubShaders-子着色器</h2><p>每个Shader中都可以包含多个SubShader，不可以没有，必须至少有一个。</p><p>Shader的核心算法实现就是在SubShader中来实现的。</p><p>在加载Shader时，Unity将遍历所有SubShader列表，并最终选择用户机器支持的第一个。</p><p>作用：<br>我们都知道不同的硬件性能是不一样的，游戏内通常把机器配置分为高中低三种，假如我们做了一个效果很好的Shader，但只能在高配机上有较好的性能表现，中低端就显的太费性能，SubShader在这时就可以派上用场了，我们可以在这个Shader内做三个SubShader，分别对应于高中低不同的配置。</p><p>SubShaders语句块中包含的定义通常如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">SubShader<br>&#123;<br>[Tags]<span class="hljs-regexp">//</span>可选的<br>[RenderSetup]<span class="hljs-regexp">//</span>可选的<br>Pass<br>&#123;<br>...<br>&#125;<br><span class="hljs-regexp">//</span>可有多个Pass<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可见，SubShader语句块由以下三个部分组成</p><ul><li><p>Tags 标签</p></li><li><p>RenderSetup状态</p></li><li><p>Pass</p></li></ul><h3 id="2-3-1-Tags-标签"><a href="#2-3-1-Tags-标签" class="headerlink" title="2.3.1 Tags 标签"></a>2.3.1 Tags 标签</h3><p>标签(Tags) 是一个键值对(Key/Value Pair),它的键和值都是字符串类型。<br>这些键值对是SubShader和渲染引擎之间的沟通桥梁。<br>它们用来告诉Unity的渲染引擎:我希望怎样以及何时渲染这个对象。</p><p>标签的结构如下:<br><code>Tags &#123;&quot;TagNamo1&quot;=&quot;Value1&quot; &quot;TagNamo2&quot;=&quot;Value2&quot;&#125;</code></p><p><img src="images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/image-20210523155428768.png" srcset="/img/loading.gif" alt="标签"></p><blockquote><p>注意:<br>上述标签仅可以在SubShader中声明，而不可以在Pass块中声明。<br>Pass块虽然也可以定义标签，但这些标签是不同于SubShader的标签类型。这是我们下面将要讲到的。</p></blockquote><h3 id="2-3-2-RenderSetup-状态"><a href="#2-3-2-RenderSetup-状态" class="headerlink" title="2.3.2 RenderSetup 状态"></a>2.3.2 RenderSetup 状态</h3><p>ShaderLab提供了一系列渲染状态的设置指令， 这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等。</p><p>下表给出了ShaderLab中常见的渲染状态设置选项。</p><table><thead><tr><th>状态名称</th><th>设置指令</th><th>解释</th></tr></thead><tbody><tr><td>Cull</td><td>Cull Back |Front |Off</td><td>设置剔除模式:剔除背面/正面/关闭剔除</td></tr><tr><td>ZTest</td><td>ZTest Less Greater |LEqual |GEqual I Equal |NotEqual |Always</td><td>设置深度测试时使用的函数</td></tr><tr><td>ZWrite</td><td>ZWrite On |Off</td><td>开启/关闭深度写入</td></tr><tr><td>Blend</td><td>Blend SrcFactor DstFactor</td><td>开启并设置混合模式</td></tr></tbody></table><p>当在SubShader块中设置了上述渲染状态时，将会应用到所有的Pass。<br>如果我们不想这样，可以在Pass语义块中单独进行上面的设置。</p><h3 id="2-3-3-Pass语句块"><a href="#2-3-3-Pass语句块" class="headerlink" title="2.3.3 Pass语句块"></a>2.3.3 Pass语句块</h3><h4 id="2-3-3-1-Pass的结构"><a href="#2-3-3-1-Pass的结构" class="headerlink" title="2.3.3.1 Pass的结构"></a>2.3.3.1 Pass的结构</h4><p>Pass语句块的格式如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Pass<br>&#123;<br><span class="hljs-string">[Name]</span><br><span class="hljs-string">[Tags]</span><br><span class="hljs-string">[RenderSetup]</span><br><br><span class="hljs-comment">//code</span><br>CGPROGRAM<br>...<br>ENDCG<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>[Name]<br>规定该Pass的名称，如<code>Name &quot;MyPassName&quot;</code><br>通过名称可以使用UsePass直接调用其它UnityShader中的Pass，如：<code>UsePase &quot;MyShader/MYPASSNAME&quot;</code></p><blockquote><p>使用UsePage指令时必须使用大写形式的名字</p></blockquote></li><li><p>[Tags]标签</p><p>用于告诉渲染引擎如何渲染物体<br>暂略，没看懂</p></li><li><p>[RenderSetup] 状态<br>与SubShader中的相同</p></li><li><p>CGPROGRAM-ENDCG<br>CG代码段</p></li></ul><h4 id="2-3-3-2-Pass的分类"><a href="#2-3-3-2-Pass的分类" class="headerlink" title="2.3.3.2 Pass的分类"></a>2.3.3.2 Pass的分类</h4><ul><li>Pass<br>普通的Pass</li><li>UsePass<br>复用其它UnityShader中的Pass</li><li>GrabPass<br>抓取屏幕，将结果存在一张纹理中以便后续的Pass处理</li></ul><h2 id="2-4-FallBack指令"><a href="#2-4-FallBack指令" class="headerlink" title="2.4 FallBack指令"></a>2.4 FallBack指令</h2><p>当我们写的Shader在一些机器上不支持时（最终显示成粉红色），只要添加了FallBack，并在双引号内写上了其它Shader的有效路径名称，那么在碰到不支持的硬件时这个Shader就会自动切换成FallBack内的Shader。</p><p>如果FallBack内的Shader也不支持呢，那就继续从FallBack内的Shader中再找FallBack……</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">FallBack <span class="hljs-string">&quot;name&quot;</span><br><span class="hljs-regexp">//</span>或者<br>FallBack Off<span class="hljs-regexp">//</span>关闭fallback功能<br></code></pre></td></tr></table></figure><blockquote><p>FallBack会影响阴影的投射<br>在渲染阴影纹理时，Unity 会在每个Unity Shader中寻找一个阴影投射的Pass。<br>通常情况下，我们不需要自己专门实现一个Pass。<br>这是因为Fallback使用的内置Shader中包含了这样一个通用的Pass。<br>因此，为每个Unity Shader正确设置Fallback是非常重要的。</p></blockquote><h2 id="2-5-CustomEditor-自定义面板编辑器"><a href="#2-5-CustomEditor-自定义面板编辑器" class="headerlink" title="2.5 CustomEditor-自定义面板编辑器"></a>2.5 CustomEditor-自定义面板编辑器</h2><p>自定义界面，也就是说我们可以通过这个功能来自由定义材质面板的显示结果，它可以改写Properties中定义的显示方式。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#is与as</title>
    <link href="/2021/05/16/is%E4%B8%8Eas/"/>
    <url>/2021/05/16/is%E4%B8%8Eas/</url>
    
    <content type="html"><![CDATA[<h1 id="1-C-类型的转换"><a href="#1-C-类型的转换" class="headerlink" title="1. C#类型的转换"></a>1. C#类型的转换</h1><p>在c#中类型的转换分两种：显式和隐式，基本的规则如下：</p><ul><li>基类对象转化为子类对象，必须显式转换，规则：(类型名) 对象。</li><li>值类型和引用类型的转换采用装箱(boxing)或拆箱(unboxing).</li><li>子类转化为基类对象。</li><li>基本类型互相之间转化可以用Covent类来实现。</li><li>字符串类型转换为对应的基本类型用Parse方法，除了String类型外其他的类型都可以用Parse方法。</li><li>用GetType可以取得对象的精确类型。</li><li>子类转化为基类，采用隐式转换。</li></ul><h1 id="2-C-中的is"><a href="#2-C-中的is" class="headerlink" title="2. C#中的is"></a>2. C#中的is</h1><p>检查一个对象是否兼容于其他指定的类型,并返回一个Bool值,如果一个对象是某个类型或是其父类型的话就返回为true，否则的话就会返回为false。永远不会抛出异常<br>如果对象引用为null，那么is操作符总是返回为false，因为没有对象可以检查其类型。</p><p>　　代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>　　<span class="hljs-keyword">if</span> (o <span class="hljs-keyword">is</span> Label)<br>　　&#123;<br>  　 Label lb = (Label)o;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换成功&quot;</span>);<br>　　&#125;<br>　　<span class="hljs-keyword">else</span><br>　　&#123;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换失败&quot;</span>);  <br>　　&#125;<br></code></pre></td></tr></table></figure><h1 id="3-C-中as的转换规则"><a href="#3-C-中as的转换规则" class="headerlink" title="3. C#中as的转换规则"></a>3. C#中as的转换规则</h1><ul><li>检查对象类型的兼容性，并返回转换结果，如果不兼容则返回null；</li><li>不会抛出异常；</li><li>如果结果判断为空，则强制执行类型转换将抛出NullReferenceException异常；</li><li>用as来进行类型转换的时候，所要转换的对象类型必须是目标类型或者转换目标类型的派生类型</li></ul><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();  <br>　　Label lb = o <span class="hljs-keyword">as</span> Label;  <br>　　<span class="hljs-keyword">if</span> (lb == <span class="hljs-literal">null</span>)<br>　　&#123;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换失败&quot;</span>);<br>　　&#125;<br>　　<span class="hljs-keyword">else</span><br>　　&#123;   <br>  　 Response.Write(<span class="hljs-string">&quot;类型转换成功&quot;</span>); <br>　　&#125;<br></code></pre></td></tr></table></figure><p>使用as操作符有如下几点限制</p><p>第一个就是，不用在类型之间进行类型转化，即如下编写就会出现编译错误。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">NewType newValue = <span class="hljs-keyword">new</span> NewType();<br>NewType1 newValue = newValue <span class="hljs-keyword">as</span> NewType1;<br></code></pre></td></tr></table></figure><p>第二个就是，不能应用在值类型数据，即不能如下写（也会出现编译错误）。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> objTest = <span class="hljs-number">11</span>;<br><span class="hljs-built_in">int</span> nValue = objTest <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>;<br></code></pre></td></tr></table></figure><h1 id="4-as与is的区别"><a href="#4-as与is的区别" class="headerlink" title="4. as与is的区别"></a>4. as与is的区别</h1><ul><li><p>AS在转换的同事兼判断兼容性<br>如果无法进行转换，则 as 返回 null（没有产生新的对象）而不是引发异常。<br>有了AS我想以后就不要再用try-catch来做类型转换的判断了。<br>因此as转换成功要判断是否为null。</p></li><li><p>AS是引用类型类型的转换或者装箱转换，不能用与值类型的转换<br>如果是值类型只能结合is来强制转换</p></li><li><p>IS只是做类型兼容判断，并不执行真正的类型转换<br>返回true或false，不会返回null，对象为null也会返回false。</p></li><li><p>AS模式的效率要比IS模式的高<br>因为借助IS进行类型转换的化，需要执行两次类型兼容检查。<br>而AS只需要做一次类型兼容，一次null检查，null检查要比类型兼容检查快。</p></li></ul><h1 id="5-int-，Int32-Parse-，Convert-ToInt32-的区别"><a href="#5-int-，Int32-Parse-，Convert-ToInt32-的区别" class="headerlink" title="5. (int)，Int32.Parse()，Convert.ToInt32()的区别"></a>5. (int)，Int32.Parse()，Convert.ToInt32()的区别</h1><ul><li>(int)转换：<br>用在数值范围大的类型转换成数值范围小的类型时使用<br>但是如果被转换的数值大于或者小于数值范围，则得到一个错误的结果<br>利用这种转换方式不能将string转换成int，会报错。</li><li>Int32.Parse()转换：<br>在符合数字格式的string到int类型转换过程中使用，并可以对错误的string数字格式的抛出相应的异常。</li><li>Convert.ToInt32()转换：<br>使用这种转换，所提供的字符串必须是数值的有效表达方式，该数还必须不是溢出的数。否则抛出异常。</li></ul><h1 id="6-常用类型转换"><a href="#6-常用类型转换" class="headerlink" title="6. 常用类型转换"></a>6. 常用类型转换</h1><ul><li><p>Object =&gt; 已知引用类型<br>使用as操作符来完成</p></li><li><p>Object =&gt; 已知值类型<br>先使用is操作符来进行判断，再用类型强转方式进行转换</p></li><li><p>已知引用类型之间转换<br>首先需要相应类型提供转换函数，再用类型强转方式进行转换</p></li><li><p>已知值类型之间转换<br>最好使用系统提供的Convert类所涉及的静态方法</p></li></ul><p>希望本文所述对大家的C#程序设计有所帮助。</p><p>转载自：<a href="http://www.jb51.net/article/56657.htm%E3%80%82">http://www.jb51.net/article/56657.htm。</a></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-资源与样式</title>
    <link href="/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/"/>
    <url>/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-资源"><a href="#1-资源" class="headerlink" title="1.资源"></a>1.资源</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>WPF资源系统是一种保管一系列有用对象（如常用的画刷、样式和模板）的简单方法，从而使您可以更容易地重用这些对象。<br>每个元素都有Resources属性，该属性存储了一个资源字典集合（它是ResourceDictionary类的实例）。<br>资源集合可包含任意类型的对象，根据字符串编写索引。</p><h2 id="1-2-写法"><a href="#1-2-写法" class="headerlink" title="1.2 写法"></a>1.2 写法</h2><ul><li><p>Window的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Window&gt;</span><br>   <span class="hljs-section">&lt;Window.Resources&gt;</span><br>   <span class="hljs-section">&lt;/Window.Resources&gt;</span><br><span class="hljs-section">&lt;/Window&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Control的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Control&gt;</span><br>      <span class="hljs-section">&lt;Control.Resources&gt;</span><br>       <span class="hljs-section">&lt;/Control.Resources&gt;</span><br><span class="hljs-section">&lt;/Control&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-样式"><a href="#2-样式" class="headerlink" title="2. 样式"></a>2. 样式</h1></li></ul><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>样式是修改View（窗体、控件）样式的主要手段，主要作用更改控件的外观以及增强用户体验。</p><h2 id="2-2-样式的属性"><a href="#2-2-样式的属性" class="headerlink" title="2.2 样式的属性"></a>2.2 样式的属性</h2><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>Setterts</td><td>设置属性值以及自动关联事件处理程序的Setter对象或EventSetter对象的集合是Style类中最重要的属性，但并非唯一属性。</td></tr><tr><td>Triggers</td><td>继承自TriggerBase类能自动改变样式设置的对象集合。例如，当另一个属性改变时，或者当发生某个时间时，可以修改样式。</td></tr><tr><td>Resources</td><td>希望用于样式的资源集合。</td></tr><tr><td>BasedOn</td><td>通过该属性可创建继承自其它样式设置的更具体的样式</td></tr><tr><td>TargetType</td><td>该属性标识应用样式的元素类型。通过该属性可创建只影响特定类型元素的设置器，还可以创建能够为恰当的元素类型自动起作用的设置器</td></tr></tbody></table><h2 id="2-3-如何关联样式"><a href="#2-3-如何关联样式" class="headerlink" title="2.3 如何关联样式"></a>2.3 如何关联样式</h2><ul><li>DynamicResource（动态资源）<br><code> &lt;Button Style=&quot;&#123;StaticResource BtnStyle&#125;&quot; /&gt;</code></li><li>StaticResource（静态资源）<br><code>&lt;Button Style=&quot;&#123;DynamicResource BtnStyle&#125;&quot; /&gt;</code></li></ul><blockquote><p>二者区别<br>静态资源在第一次编译后即确定其对象或值，之后不能对其进行修改。<br>动态资源在运行时决定，当运行过程中真正需要时，才到资源目标中查找其值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>样式</tag>
      
      <tag>资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataResult与DataTable类</title>
    <link href="/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/"/>
    <url>/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>DataTable和DataSet可以看做是数据容器，比如你查询数据库后得到一些结果，可以放到这种容器里。</p><p>那你可能要问：我不用这种容器，自己读到变量或数组里也一样可以存起来啊，为什么用容器？</p><p>原因是，这种容器的功能比较强大，除了可以存数据，还可以有更大用途。</p><p>举例：<br>在一个c/s结构的桌面数据库系统里，你可以把前面存放查询结果的容器里的数据显示到你客户端界面上，用户在界面上对数据进行添加、删除、修改，你可以把用户的操作更新到容器。<br>等用户操作完毕了，要求更新，然后你才把容器整个的数据变化更新到中心数据库。</p><blockquote><p>这样做的好处是什么？<br>就是减少了数据库操作，客户端速度提高了，数据库压力减小了。</p></blockquote><p> DataSet可以比作一个内存中的数据库，DataTable是一个内存中的数据表，DataSet里可以存储多个DataTable。</p><h1 id="2-DataTable"><a href="#2-DataTable" class="headerlink" title="2. DataTable"></a>2. DataTable</h1><h2 id="2-1-类成员"><a href="#2-1-类成员" class="headerlink" title="2.1 类成员"></a>2.1 类成员</h2><h3 id="2-1-1-构造函数"><a href="#2-1-1-构造函数" class="headerlink" title="2.1.1 构造函数"></a>2.1.1 构造函数</h3><table><thead><tr><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td>DataTable()</td><td>不带参数初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName)</td><td>用指定的表名初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName, string tableNamespace)</td><td>用指定的表名和命名空间初始化DataTable类的新实例</td></tr></tbody></table><h3 id="2-1-2-常用属性"><a href="#2-1-2-常用属性" class="headerlink" title="2.1.2 常用属性"></a>2.1.2 常用属性</h3><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>CaseSensitive</td><td>指示表中的字符串比较是否区分大小写</td></tr><tr><td>ChildRelations</td><td>获取此DataTable 的子关系的集合</td></tr><tr><td>Columns</td><td>获取属于该表的列的集合</td></tr><tr><td>Constraints</td><td>获取由该表维护的约束的集合</td></tr><tr><td>DataSet</td><td>获取此表所属的DataSet</td></tr><tr><td>DefaultView</td><td>获取可能包括筛选视图或游标位置的表的自定义视图</td></tr><tr><td>HasErrors</td><td>获取一个值，该值指示该表所属的DataSet 的任何表的任何行中是否有错误</td></tr><tr><td>MinimumCapacity</td><td>获取或设置该表最初的起始大小。该表中行的最初起始大小。默认值为 50</td></tr><tr><td>Rows</td><td>获取属于该表的行的集合</td></tr><tr><td>TableName</td><td>获取或设置DataTable 的名称</td></tr></tbody></table><h3 id="2-1-3-常用方法"><a href="#2-1-3-常用方法" class="headerlink" title="2.1.3 常用方法"></a>2.1.3 常用方法</h3><table><thead><tr><th>方法名</th><th>含义</th></tr></thead><tbody><tr><td>AcceptChanges()</td><td>提交自上次调用AcceptChanges() 以来对该表进行的所有更改</td></tr><tr><td>BeginInit()</td><td>开始初始化在窗体上使用或由另一个组件使用的DataTable。初始化发生在运行时</td></tr><tr><td>Clear()</td><td>清除所有数据的DataTable</td></tr><tr><td>Clone()</td><td>克隆DataTable 的结构，包括所有DataTable 架构和约束</td></tr><tr><td>EndInit()</td><td>结束在窗体上使用或由另一个组件使用的DataTable 的初始化。初始化发生在运行时</td></tr><tr><td>ImportRow(DataRow row)</td><td>将DataRow 复制到DataTable 中，保留任何属性设置以及初始值和当前值</td></tr><tr><td>Merge(DataTable table)</td><td>将指定的DataTable 与当前的DataTable 合并</td></tr><tr><td>NewRow()</td><td>创建与该表具有相同架构的新DataRow</td></tr></tbody></table><h2 id="2-2-使用技巧"><a href="#2-2-使用技巧" class="headerlink" title="2.2 使用技巧"></a>2.2 使用技巧</h2><h3 id="2-2-1-创建表"><a href="#2-2-1-创建表" class="headerlink" title="2.2.1 创建表"></a>2.2.1 创建表</h3><p><code>DataTable dt = new DataTable(&quot;Table_AX&quot;); </code></p><h3 id="2-2-2-添加列属性"><a href="#2-2-2-添加列属性" class="headerlink" title="2.2.2 添加列属性"></a>2.2.2 添加列属性</h3><p>方法1：<br><code>dt.Columns.Add(&quot;column0&quot;, System.Type.GetType(&quot;System.String&quot;));</code><br>方法2：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataColumn dc = <span class="hljs-keyword">new</span> DataColumn(<span class="hljs-string">&quot;column1&quot;</span>, System.Type.GetType(<span class="hljs-string">&quot;System.Boolean&quot;</span>));<br>dt.Columns.Add(dc); <br></code></pre></td></tr></table></figure><h3 id="2-2-3-添加数据行"><a href="#2-2-3-添加数据行" class="headerlink" title="2.2.3 添加数据行"></a>2.2.3 添加数据行</h3><p>初始化行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr = dt.NewRow();<br>dr[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AX&quot;</span>;<br>dr[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">true</span>;<br>dt.Rows.Add(dr);<br></code></pre></td></tr></table></figure><p>空行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr1 = dt.NewRow();<br>dt.Rows.Add(dr1);    <br></code></pre></td></tr></table></figure><h3 id="2-2-4-选择数据行"><a href="#2-2-4-选择数据行" class="headerlink" title="2.2.4 选择数据行"></a>2.2.4 选择数据行</h3><p>选择表中所有第0列属性为’AX’的数据行<br><code>DataRow[] drss = dt.Select(&quot;column0 = &#39;AX&#39;&quot;);</code></p><blockquote><p>空属性时用<strong>is null</strong><br>例：<code> DataRow[] drs = dt.Select(&quot;column1 is null&quot;);</code></p></blockquote><h3 id="2-2-5-复制表-包括数据"><a href="#2-2-5-复制表-包括数据" class="headerlink" title="2.2.5 复制表(包括数据)"></a>2.2.5 复制表(包括数据)</h3><p><code>DataTable dtNew = dt.Copy();</code></p><h3 id="2-2-6-复制表-仅结构"><a href="#2-2-6-复制表-仅结构" class="headerlink" title="2.2.6 复制表(仅结构)"></a>2.2.6 复制表(仅结构)</h3><p><code>DataTable dtOnlyScheme = dt.Clone(); </code></p><h3 id="2-2-7-数据行操作"><a href="#2-2-7-数据行操作" class="headerlink" title="2.2.7 数据行操作"></a>2.2.7 数据行操作</h3><ul><li><p>方法一</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow drOperate = dt.Rows[<span class="hljs-number">0</span>];<br>drOperate[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">drOperate[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法三</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法四</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; <br></code></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>  <span class="hljs-keyword">foreach</span> (DataColumn column <span class="hljs-keyword">in</span> dt.Columns) <br>  &#123; <br> Console.WriteLine(row[column]); <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>row[column] 中的column是检索出来的表个列名。</p><p>如果想把某列的值拼接字符串，那就去掉内层循环就行了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">StringBuilder mailList = <span class="hljs-keyword">new</span> StringBuilder(); <br><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>   mailList.Append(row[<span class="hljs-string">&quot;Email&quot;</span>]); <br>   mailList.Append(<span class="hljs-string">&quot;;&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-8-复制数据行到当前数据表"><a href="#2-2-8-复制数据行到当前数据表" class="headerlink" title="2.2.8 复制数据行到当前数据表"></a>2.2.8 复制数据行到当前数据表</h3></li></ul><p><code>dtOnlyScheme.Rows.Add(dt.Rows[0].ItemArray); </code></p><h3 id="2-2-9-转换为字符串"><a href="#2-2-9-转换为字符串" class="headerlink" title="2.2.9 转换为字符串"></a>2.2.9 转换为字符串</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">System.IO.StringWriter sw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>System.Xml.XmlTextWriter xw = <span class="hljs-keyword">new</span> System.Xml.XmlTextWriter(sw);<br>dt.WriteXml(xw);<br><span class="hljs-built_in">string</span> s = sw.ToString();<br></code></pre></td></tr></table></figure><h3 id="2-2-10-筛选数据表"><a href="#2-2-10-筛选数据表" class="headerlink" title="2.2.10 筛选数据表"></a>2.2.10 筛选数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 &lt;&gt; true&quot;</span>;<br>dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 = true&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-11-行排序"><a href="#2-2-11-行排序" class="headerlink" title="2.2.11 行排序"></a>2.2.11 行排序</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.Sort = <span class="hljs-string">&quot;ID ,Name ASC&quot;</span>;<br>dt=dt.DefaultView.ToTable();   <br></code></pre></td></tr></table></figure><h3 id="2-2-12-绑定数据表"><a href="#2-2-12-绑定数据表" class="headerlink" title="2.2.12 绑定数据表"></a>2.2.12 绑定数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">gvTestDataTable.DataSource = dt;<br>gvTestDataTable.DataBind();<br></code></pre></td></tr></table></figure><blockquote><p>绑定的其实是DefaultView</p></blockquote><h3 id="2-2-13-判断一个字符串是否为数据表的列名"><a href="#2-2-13-判断一个字符串是否为数据表的列名" class="headerlink" title="2.2.13 判断一个字符串是否为数据表的列名"></a>2.2.13 判断一个字符串是否为数据表的列名</h3><p><code>dtInfo.Columns.Contains(&quot;AX&quot;);</code></p><h3 id="2-2-14-序列化"><a href="#2-2-14-序列化" class="headerlink" title="2.2.14 序列化"></a>2.2.14 序列化</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataTable convert to XML <span class="hljs-keyword">and</span> XML convert to DataTable<br>     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Page_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>     &#123;<br>       DataTable dt_AX = <span class="hljs-keyword">new</span> DataTable();<br>       <span class="hljs-comment">//dt_AX.Columns.Add(&quot;Sex&quot;, typeof(System.Boolean));</span><br>       <span class="hljs-comment">//DataRow dr = dt_AX.NewRow();</span><br>       <span class="hljs-comment">//dr[&quot;Sex&quot;] = true;</span><br>       <span class="hljs-comment">//dt_AX.Rows.Add(dr);</span><br>       <span class="hljs-built_in">string</span> xml=ConvertBetweenDataTableAndXML_AX(dt_AX);<br>       DataTable dt = ConvertBetweenDataTableAndXML_AX(xml);<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params">DataTable dtNeedCoveret</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextWriter tw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>       <span class="hljs-comment">//if TableName is empty, WriteXml() will throw Exception.         </span><br><br>dtNeedCoveret.TableName=dtNeedCoveret.TableName.Length==<span class="hljs-number">0</span>?<span class="hljs-string">&quot;Table_AX&quot;</span>:dtNeedCoveret.TableName;<br>       dtNeedCoveret.WriteXml(tw);<br>       dtNeedCoveret.WriteXmlSchema(tw);<br>       <span class="hljs-keyword">return</span> tw.ToString();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> DataTable <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> xml</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextReader trDataTable = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(<span class="hljs-number">0</span>, xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       System.IO.TextReader trSchema = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       DataTable dtReturn = <span class="hljs-keyword">new</span> DataTable();<br>       dtReturn.ReadXmlSchema(trSchema);<br>       dtReturn.ReadXml(trDataTable);<br>       <span class="hljs-keyword">return</span> dtReturn;<br>    &#125;<br> dt.Compute(<span class="hljs-string">&quot;sum(SaleNum)&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>) ; <br><span class="hljs-comment">// 对列SaleNum 汇总支持所以sql 聚合函数 如：sum(),count(),avg()等等。。。  </span><br><br>linq<br><br><span class="hljs-keyword">var</span> productNames = <span class="hljs-keyword">from</span> products <span class="hljs-keyword">in</span> dt.AsEnumerable() <span class="hljs-keyword">select</span> products.Field&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;ProductName&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
      <tag>C#常用类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-MVVC</title>
    <link href="/2021/04/24/WPF-MVVC/"/>
    <url>/2021/04/24/WPF-MVVC/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MVVM是一种开发模式，是一种开发标准。<br>在WPF中应用到MVVM是非常常见的，MVVM全称为Model、View、ViewModel。</p><p>开发模式有</p><ul><li><p>MVC<br>模型-视图-控制器</p></li><li><p>MVP<br>模型-视图-演示者</p></li><li><p>MVVM<br>模型-视图-视图模型</p></li></ul><p>MVP, MVVM都是由MVC衍生出。<br>所有这些设计模式大体上都有助于开发松散组合、易于测试和维护的应用程序。</p><p><a href="https://www.php.cn/faq/417265.html">开发模式</a></p><p><img src="/images/WPF-MVVC/image-20210424155250844.png" srcset="/img/loading.gif" alt="image-20210424155250844"></p><h1 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h1><ul><li>View<br>代表窗体、控件等可视化资源</li><li>ViewModel<br>代表View的业务处理类，<br>将获取到的数据处理好与View进行关联绑定</li><li>Model<br>通常代表数据模型，它将支持ViewModel中所使用的到的<br>还有一种用法就是在Model里完成业务逻辑的编写ViewModel只需要写出关联逻辑代码，具体的使用方式视情况而定。</li></ul><p><img src="/images/WPF-MVVC/image-20210424154619430.png" srcset="/img/loading.gif" alt="image-20210424154619430"></p><h1 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h1><ul><li>优点<br>前后端逻辑分离，解耦，代码配置灵活，易维护，为数据驱动奠定基础。</li><li>缺点<br>开发耗时较长，对于新手掌握起来略微有难度。<br>基于MVVM再实现绑定难度会有一个小幅度的提升。<br>需多实践积累经验即可。</li></ul><h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4. 文件管理"></a>4. 文件管理</h1><p><img src="/images/WPF-MVVC/image-20210424154830937.png" srcset="/img/loading.gif" alt="image-20210424154830937"></p><p>如图所示</p><ul><li><p>请将与页面可视化相关的xaml文件放于Views文件夹下</p></li><li><p>请将页面逻辑交互相关的cs文件放于ViewModels文件夹下</p></li><li><p>请将数据处理，事务实现相关的cs文件放于Models文件夹下</p></li></ul><blockquote><p>.MainWindow稍微特殊点<br>因为它是主窗体作为整个程序的起始点，它可以单独放在外面</p></blockquote><blockquote><p>App.xaml是程序启动配置文件<br>如果需要更换起始运行窗体则需要修改StartupUri=“xxxView.xaml”即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>MVVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-依赖属性</title>
    <link href="/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>依赖属性就是一种自己可以没有值，并且可以通过绑定从其他数据源获取值。<br>依赖属性可支持WPF中的样式设置、数据绑定、继承、动画及默认值。</p><p>将所有的属性都设置为依赖属性并不总是正确的解决方案，具体取决于其应用场景。<br>有时，使用私有字段实现属性的典型方法便能满足要求。</p><p>MSDN中给出了下面几种应用依赖属性的场景：</p><ol><li><p>希望可在样式中设置属性。</p></li><li><p>希望属性支持数据绑定。</p></li><li><p>希望可使用动态资源引用设置属性。</p></li><li><p>希望从元素树中的父元素自动继承属性值。</p></li><li><p>希望属性可进行动画处理。</p></li><li><p>希望属性系统在属性系统、环境或用户执行的操作或者读取并使用样式更改了属性以前的值时报告。</p></li><li><p>希望使用已建立的、WPF 进程也使用的元数据约定，例如报告更改属性值时是否要求布局系统重新编写元素的可视化对象。</p><blockquote><p>总结自<a href="https://www.cnblogs.com/dotnet261010/p/6286475.html">https://www.cnblogs.com/dotnet261010/p/6286475.html</a></p></blockquote></li></ol><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><h2 id="2-1-属性变更通知"><a href="#2-1-属性变更通知" class="headerlink" title="2.1 属性变更通知"></a>2.1 属性变更通知</h2><p>无论什么时候，只要依赖属性的值发生改变，wpf就会自动根据属性的元数据触发一系列的动作，这些动作可以重新呈现UI元素，也可以更新当前的布局，刷新数据绑定等等。<br>这种变更的通知最有趣的特点之一就是属性触发器，它可以在属性值改变的时候，执行一系列自定义的动作，而不需要更改任何其他的代码来实现。通过下面的示例来演示属性变更通知</p><p>示例：当鼠标移动到Button按钮上面时，文字的前景色变为红色，离开时变为默认颜色黑色，采用传统方式和依赖属性两种方式实现：</p><h3 id="2-1-1-使用传统方式实现"><a href="#2-1-1-使用传统方式实现" class="headerlink" title="2.1.1 使用传统方式实现"></a>2.1.1 使用传统方式实现</h3><p>在Button按钮上定义MouseEnter和MouseLeave两个事件，分别处理鼠标移动到按钮上面和离开，</p><p>XAML界面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span>              <br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">MouseEnter</span>=<span class="hljs-string">&quot;Button_MouseEnter&quot;</span> <span class="hljs-attr">MouseLeave</span>=<span class="hljs-string">&quot;Button_MouseLeave&quot;</span> &gt;</span>鼠标移动到上面，前景色变为红色<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>        <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>C#后台代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Collections.Generic;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Linq;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Text;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Threading.Tasks;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Controls;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Data;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Documents;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.<span class="hljs-keyword">Input</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Navigation;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Shapes;<br> <br>namespace WpfDemo<br>&#123;<br>     // MainWindow.xaml 的交互逻辑<br>     <span class="hljs-built_in">public</span> partial <span class="hljs-keyword">class</span> MainWindow : <span class="hljs-keyword">Window</span><br>     &#123;<br>        <span class="hljs-built_in">public</span> MainWindow()<br>         &#123;<br>             InitializeComponent();<br>         &#125;<br>          // 鼠标移动到按钮上面<br>          // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>          // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseEnter(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Red;<br>             &#125;<br>        &#125;<br>         // 鼠标离开按钮<br>        // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>         // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseLeave(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Black;<br>             &#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-2-使用依赖属性实现"><a href="#2-1-2-使用依赖属性实现" class="headerlink" title="2.1.2 使用依赖属性实现"></a>2.1.2 使用依赖属性实现</h3><p>XAML界面代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">&lt;</span><span class="hljs-variable">Window</span> <span class="hljs-variable">x</span><span class="hljs-operator">:</span><span class="hljs-variable">Class</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">:</span><span class="hljs-variable">x</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br>        <span class="hljs-variable">Title</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;237&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;525&quot;</span> <span class="hljs-variable">WindowStartupLocation</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;CenterScreen&quot;</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Grid</span> <span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;30&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span><span class="hljs-operator">&gt;</span>鼠标移动到上面，前景色变为红色<br>            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span> <span class="hljs-variable">TargetType</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Button&quot;</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Trigger</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;IsMouseOver&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span><span class="hljs-operator">&gt;</span><br>                            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Setter</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Foreground&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Red&quot;</span><span class="hljs-operator">&gt;&lt;/</span><span class="hljs-built_in">Setter</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Trigger</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>           <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Grid</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;/</span><span class="hljs-variable">Window</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>使用上面的两种方式都可以实现Button按钮的前景色改变，效果如下：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230351681-1555534511.png" srcset="/img/loading.gif" alt="img"></p><p>在判断属性IsMouseOver的值为false的时候，自动将Foreground的值改为之前的值，因此就不需要写IsMouseOver的值为false的时候，将Foreground的值改为Black。</p><h2 id="2-2-属性值继承"><a href="#2-2-属性值继承" class="headerlink" title="2.2 属性值继承"></a>2.2 属性值继承</h2><p>是指属性值自顶向下沿着元素树进行传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;依赖属性&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我使用的是继承的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span>我使用的是自己的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>界面运行效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230206494-1555380756.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-3-节省内存空间"><a href="#2-3-节省内存空间" class="headerlink" title="2.3 节省内存空间"></a>2.3 节省内存空间</h2><p>依赖属性和CLR属性在内存的使用上是截然不同的，每个CLR属性都包含一个非static的字段。<br>因此当我们实例化一个类型的时候，就会创建该类型所拥有的所有CLR属性。<br>也就是说一个对象所占用的内存在调用new操作进行实例化的时候就已经决定了。</p><p>而wpf允许对象在创建的时候并不包含用于存储数据的空间，只保留在需要用到数据的时候能够获得该默认值，即用其他对象数据或者实时分配空间的能力。</p><h1 id="３-如何自定义依赖属性"><a href="#３-如何自定义依赖属性" class="headerlink" title="３. 如何自定义依赖属性"></a>３. 如何自定义依赖属性</h1><h2 id="3-1-声明依赖属性变量"><a href="#3-1-声明依赖属性变量" class="headerlink" title="3.1 声明依赖属性变量"></a>3.1 声明依赖属性变量</h2><p>依赖属性的声明都是通过public static来公开一个静态变量，变量的类型必须是DependencyProperty</p><h2 id="3-2-在属性系统中进行注册"><a href="#3-2-在属性系统中进行注册" class="headerlink" title="3.2 在属性系统中进行注册"></a>3.2 在属性系统中进行注册</h2><p>使用DependencyProperty.Register方法来注册依赖属性，或者是使用DependencyProperty.RegisterReadOnly方法来注册</p><h2 id="3-3-使用-NET属性包装依赖属性"><a href="#3-3-使用-NET属性包装依赖属性" class="headerlink" title="3.3 使用.NET属性包装依赖属性"></a>3.3 使用.NET属性包装依赖属性</h2><p>在类上实现属性时，只要该类派生自 DependencyObject，便可以选择使用 DependencyProperty 标识符来标示属性，从而将其设置为依赖属性。</p><p>其语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DependencyProperty TextProperty;<br>        TextProperty =<br>        DependencyProperty.Register(<span class="hljs-string">&quot;Text&quot;</span>, <span class="hljs-comment">//属性名称</span><br>        <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-comment">//属性类型</span><br>        <span class="hljs-keyword">typeof</span>(TestDependencyPropertyWindow), <span class="hljs-comment">//该属性所有者，即将该属性注册到那个类上</span><br>        <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">//属性默认值</span><br>         <br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Text<br> &#123;<br>    <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(TextProperty); &#125;<br>    <span class="hljs-keyword">set</span> &#123; SetValue(TextProperty, <span class="hljs-keyword">value</span>); &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p> 示例：自定义一个依赖属性，界面包括一个TextBox和TextBlock，TextBlock上面字体的前景色随TextBox里面输入的颜色而改变，如果TextBox里面输入的值可以转换成颜色，TextBlock字体的前景色会显示输入的颜色值，如果不能转换，显示默认的前景色。</p><ul><li>1、在当前项目里面添加一个WPF版的用户控件，命名为“MyDependencyProperty”，在MyDependencyProperty.xaml.cs文件里面自定义一个依赖属性：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Windows;<br><span class="hljs-keyword">using</span> System.Windows.Controls;<br><span class="hljs-keyword">using</span> System.Windows.Data;<br><span class="hljs-keyword">using</span> System.Windows.Documents;<br><span class="hljs-keyword">using</span> System.Windows.Input;<br><span class="hljs-keyword">using</span> System.Windows.Media;<br><span class="hljs-keyword">using</span> System.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> System.Windows.Navigation;<br><span class="hljs-keyword">using</span> System.Windows.Shapes;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">WpfDemo</span><br>&#123;<br>    <span class="hljs-comment">// MyDependencyProperty.xaml 的交互逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDependencyProperty</span> : <span class="hljs-title">UserControl</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-comment">//1、声明依赖属性变量</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyColorProperty;<br><br>        <span class="hljs-comment">//2、在属性系统中进行注册</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            MyColorProperty = DependencyProperty.Register(<span class="hljs-string">&quot;MyColor&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-keyword">typeof</span>(MyDependencyProperty),<br>                <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;Red&quot;</span>, (s, e) =&gt; <br>                &#123;<br>                    <span class="hljs-keyword">var</span> mdp = s <span class="hljs-keyword">as</span> MyDependencyProperty;<br>                    <span class="hljs-keyword">if</span> (mdp != <span class="hljs-literal">null</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">try</span><br>                        &#123;<br>                           <span class="hljs-keyword">var</span> color = (Color)ColorConverter.ConvertFromString(e.NewValue.ToString());<br>                            mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(color);<br>                        &#125;<br>                        catch<br>                        &#123;<br>                           mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(Colors.Black);<br>                        &#125;<br>                    &#125;<br>                <br>                &#125;));<br>        &#125;<br><br>        <span class="hljs-comment">//3、使用.NET属性包装依赖属性:属性名称与注册时候的名称必须一致，</span><br>       <span class="hljs-comment">//即属性名MyColor对应注册时的MyColor</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> MyColor <br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>               <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(MyColorProperty);<br>          &#125;<br>           <span class="hljs-keyword">set</span><br>            &#123;<br>               SetValue(MyColorProperty, <span class="hljs-keyword">value</span>);<br>            &#125;<br>        &#125;                    <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速定义依赖属性的快捷方式：</p><p>输入propdp，连续按两下Tab健，自动生成定义依赖属性的语法。</p><p>和输入cw连续按两下Tab健，自动生成Console.Write()一样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty<br>        &#123;<br>            <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)GetValue(MyPropertyProperty); &#125;<br>            <span class="hljs-keyword">set</span> &#123; SetValue(MyPropertyProperty, <span class="hljs-keyword">value</span>); &#125;<br>        &#125;<br><br>       <span class="hljs-comment">// Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc...</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyPropertyProperty =<br>           DependencyProperty.Register(<span class="hljs-string">&quot;MyProperty&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>), <span class="hljs-keyword">typeof</span>(ownerclass), <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><ul><li>2、在MyDependencyProperty.xaml里面添加一个TextBlock</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MyDependencyProperty&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:mc</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:d</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">mc:Ignorable</span>=<span class="hljs-string">&quot;d&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">d:DesignHeight</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">d:DesignWidth</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我是自定义的依赖属性<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>3、在MainWindow.xaml里面引用新创建的用户控件，并添加一个TextBox，用于输入颜色值，并将自定义的依赖属性MyColor绑定到TextBox</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span></span><br><span class="xml">         xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="xml">         xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;       </span><br><span class="xml">        xmlns:p=&quot;clr-namespace:WpfDemo&quot;</span><br><span class="xml">         Title=&quot;依赖属性&quot; Height=&quot;237&quot; Width=&quot;525&quot; WindowStartupLocation=&quot;CenterScreen&quot;&gt;</span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">TextBox</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;tbColor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextBox</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">p:MyDependencyProperty</span> <span class="hljs-attr">MyColor</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;Binding Path=Text,ElementName=tbColor&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p:MyDependencyProperty</span>&gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span>        </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在设计界面显示的效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115122217947-1972572422.png" srcset="/img/loading.gif" alt="img"></p><p>4、程序运行效果：</p><p>在TextBox里面输入正确的颜色值，前景色会显示为当前输入的颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121945931-691430131.png" srcset="/img/loading.gif" alt="img"></p><p>在TextBox里面输入错误的颜色值，前景色会显示为默认颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121956713-612253816.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>依赖属性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-命令</title>
    <link href="/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>命令有许多可变的部分组成，但它们都具有以下4个重要元素：</p><ul><li>命令<br>命令表示应用程序任务，并且跟踪任务是否能够被执行。<br>然而，命令实际上不包含执行应用程序任务的代码。</li><li>命令绑定<br>每个命令绑定针对用户界面的具体元素，将命令连接到相关的应用程序逻辑。<br>这种分解的设计是非常重要的，因为单个命令可用于应用程序中的多个地方，并且在每个地方具有不同的意义。<br>为处理这一问题，需要将同一命令与不同的命令绑定。</li><li>命令源<br>命令源触发命令。<br>例如，button就是命令源。<br>单击它们都会执行绑定命令。</li><li>命令目标<br>命令目标是在其中执行命令的元素。</li></ul><p><img src="/images/WPF-%E5%91%BD%E4%BB%A4/image-20210424153346796.png" srcset="/img/loading.gif" alt="image-20210424153346796"></p><h1 id="2-如何实现一个命令"><a href="#2-如何实现一个命令" class="headerlink" title="2.如何实现一个命令"></a>2.如何实现一个命令</h1><p>WPF命令的核心是System.Windows.Input.ICommand接口，该接口定义了命令的工作原理。<br>该接口包含两个方法和一个事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICommand</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">CanExecute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-keyword">event</span> EventHandler CanExecuteChanged;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>Execute</td><td>将包含引用程序任务逻辑</td></tr><tr><td>CanExecute</td><td>返回命令的状态。可用为true，不可用为false；</td></tr><tr><td>CanExecuteChanged</td><td>当命令状态改变是引发该事件。对于使用命令的任何控件，这是指示信号，表示他们应当调用</td></tr></tbody></table><blockquote><p>Execute和CanExecute方法都接受一个附加的对象参数，可使用该对象传递所需的任何附加信息。</p></blockquote><blockquote><p>CanExecute方法检查命令的状态。<br>通过使用该事件，当命令可用时，命令源（如button）可自动启用自身；<br>当命令不可用时，禁用自身。</p></blockquote><h1 id="3-如何让控件支持命令"><a href="#3-如何让控件支持命令" class="headerlink" title="3. 如何让控件支持命令"></a>3. 如何让控件支持命令</h1><p>支持命令的实现是在“命令源”这个环节实现ICommandSource。</p><p>ICommandSource接口定义了三个属性:</p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>Command</td><td>指向连接的命令，这是唯一必须的细节</td></tr><tr><td>CommandParameter</td><td>提供其他希望随命令发送的数据</td></tr><tr><td>CommandTarget</td><td>确定将在其中执行命令的元素</td></tr></tbody></table><blockquote><p>不是每个控件都直接支持command绑定的<br>需要将他们关联到实现了ICommandSource接口的控件<br>其中包括继承自ButtonBase类的控件（button和Checkbox等）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-布局</title>
    <link href="/2021/04/24/WPF-%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/24/WPF-%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>又称容器，面板。<br>在WPF中是最基础也是最重要的一环，它直接决定你界面的样子。掌握熟练度决定它的美观度和可交互性。</p><p>WPF与JavaSwing的布局(容器)有相似之处但又不完全相同。</p><p>WPF的面板主要有6个：</p><ul><li><p>Grid（网格面板）</p></li><li><p>StackPanel(栈面板)</p></li><li><p>Canvas（画布）</p></li><li><p>WrapPanel（环绕面板）</p></li><li><p>DockPanel（停靠面板）</p></li><li><p>UniformGrid(均布网格)</p></li></ul><p>其中前三个最为常用。</p><h1 id="2-Gird-布局"><a href="#2-Gird-布局" class="headerlink" title="2. Gird 布局"></a>2. Gird 布局</h1><p>可以理解为一个表格，类似于HTML中的Table标签。</p><p>它是由行和列组成。</p><h2 id="2-1-标签"><a href="#2-1-标签" class="headerlink" title="2.1 标签"></a>2.1 标签</h2><ul><li><p><code>&lt;Grid&gt;&lt;/Grid&gt;</code><br>该标签对内写入表格内容</p></li><li><p><code>&lt;Grid.RowDefinitions&gt;</code><br>该标签内写入<code>&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</code>标签对<br>用于定义Gird布局中有几行</p></li><li><p><code>&lt;Grid.ColumnDefinitions&gt;</code><br>该标签内写入<code>&lt;ColumnDefinition&gt;&lt;/ColumnDefinition&gt;</code>标签对<br>用于定义Gird布局中有几列</p></li></ul><h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><ul><li><p>Grid.Column<br>当前元素在Gird布局中的第几列</p></li><li><p>Grid.Row<br>当前元素在Gird布局中的第几行</p><blockquote><p>都从0开始数，且该属性写在元素标签内</p></blockquote></li></ul><h2 id="2-3-案例"><a href="#2-3-案例" class="headerlink" title="2.3 案例"></a>2.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上代码的效果是：</p><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424125742746.png" srcset="/img/loading.gif" alt="Grid布局"></p><h1 id="3-StackPanel-布局"><a href="#3-StackPanel-布局" class="headerlink" title="3 StackPanel 布局"></a>3 StackPanel 布局</h1><p>是一个可以将自身内容横向或纵向排列的容器。</p><h2 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 标签"></a>3.1 标签</h2><ul><li><code>&lt;StackPanel&gt;&lt;/StackPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p><ul><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul></li></ul><blockquote><p>默认情况下：<br>水平排列时，每个元素都与面板一样高；<br>垂直排列时，每个元素都与面板一样宽。<br>如果包含的元素超过了面板空间，它只会截断多出的内容。<br>元素的Margin属性用于使元素之间产生一定得间隔，当元素空间大于其内容的空间时，剩余空间将由HorizontalAlignment和 VerticalAlignment属性来决定如何分配。</p></blockquote><h2 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h2><p>垂直排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Vertical&quot;</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131943534.png" srcset="/img/loading.gif" alt="竖直排列"></p><p>水平排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Horizontal&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131833665.png" srcset="/img/loading.gif" alt="水平排列"></p><h1 id="4-WrapPanel-布局"><a href="#4-WrapPanel-布局" class="headerlink" title="4. WrapPanel 布局"></a>4. WrapPanel 布局</h1><p>WrapPanel面板以一行或者一列的形式来布置控件，当一行（列）放满之后自动转到下一行（列）。</p><blockquote><p>除了自动换行外，基本与StackPanel相同</p></blockquote><h2 id="4-1-标签"><a href="#4-1-标签" class="headerlink" title="4.1 标签"></a>4.1 标签</h2><ul><li><code>&lt;WrapPanel&gt;&lt;/WrapPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="4-2-属性"><a href="#4-2-属性" class="headerlink" title="4.2 属性"></a>4.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p></li><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul><h1 id="5-Canvas-布局"><a href="#5-Canvas-布局" class="headerlink" title="5 Canvas 布局"></a>5 Canvas 布局</h1><p>它比较特殊。它属于“任意布局”的一种概念，就是你拖控件到UI上的时候你把它放在哪里它就在那里了。</p><h2 id="5-1-标签"><a href="#5-1-标签" class="headerlink" title="5.1 标签"></a>5.1 标签</h2><ul><li><code>&lt;Canvas&gt;&lt;/Canvas&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="5-2-属性"><a href="#5-2-属性" class="headerlink" title="5.2 属性"></a>5.2 属性</h2><ul><li>Canvas.Top<br>设置元素距Canvas顶部的距离</li><li>Canvas.Bottom<br>设置元素距Canvas底部的距离</li><li>Canvas.Left<br>设置元素距Canvas左边界的距离</li><li>Canvas.Right<br>设置元素距Canvas右边界的距离</li></ul><blockquote><p>当同时设置left和right,top和bottom,以left和top为准</p></blockquote><h2 id="5-3-案例"><a href="#5-3-案例" class="headerlink" title="5.3 案例"></a>5.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Canvas</span> <span class="hljs-attr">Background</span>=<span class="hljs-string">&quot;LightBlue&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Top</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Top=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Bottom</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Bottom=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Left</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Left=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Right</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Right=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Canvas</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-控件</title>
    <link href="/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/"/>
    <url>/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul><li>常用控件表</li></ul><table><thead><tr><th>控件名</th><th>作用</th></tr></thead><tbody><tr><td>Label</td><td>一般用户描述性文字显示</td></tr><tr><td>TextBlock</td><td>只读的文本框，无法进行编辑，比较适合显示文本，该文本内容不允许编辑的情况</td></tr><tr><td>TextBox</td><td>支持编辑的基本控件</td></tr><tr><td>PassWordBox</td><td>一般用于用户输入验证或者注册时使用</td></tr><tr><td>DataGrid</td><td>列表数据显示控件</td></tr><tr><td>ListView</td><td>一般ListView都可以用DataGrid替代</td></tr><tr><td>ListBox</td><td>下拉列表级控件</td></tr><tr><td>GroupBox</td><td>用于组织页面相关元素放到一起，方便用户使用等方面提供帮助。</td></tr><tr><td>RichTextBox</td><td>支持富文本和简单文本等，可以实现出类似Word的那样的效果。</td></tr><tr><td>MediaElement</td><td>对媒体文件的操作和访问</td></tr><tr><td>Menu</td><td>菜单栏方式的多级菜单的管理和操作</td></tr><tr><td>TabControl</td><td>分页标签</td></tr></tbody></table><p><img src="/images/WPF-%E6%8E%A7%E4%BB%B6/image-20210424140413545.png" srcset="/img/loading.gif" alt="image-20210424140413545"></p><ul><li>控件的基础属性<br>宽、高、背景色、字体颜色、字体大小、禁用、启用、显示、隐藏等</li><li>控件显示的值内容<br>Content、Text、Value等</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>控件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-绑定</title>
    <link href="/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/"/>
    <url>/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p> 绑定顾名思义，是将我们获取到的数据和UI上的控件绑定起来利用数据的变化来更新界面所看到的内容。</p><p>绑定的五个步骤:</p><ul><li>1.绑定目标 </li><li>2.绑定属性 </li><li>3.绑定模式 </li><li>4.绑定数据源 </li><li>5.关联资源</li></ul><h1 id="2-绑定步骤"><a href="#2-绑定步骤" class="headerlink" title="2. 绑定步骤"></a>2. 绑定步骤</h1><h2 id="2-1-绑定目标"><a href="#2-1-绑定目标" class="headerlink" title="2.1 绑定目标"></a>2.1 绑定目标</h2><p>绑定目标很好理解，其实就是你要操作绑定的控件。例如：Button，TextBox。</p><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot;&gt;&lt;/TextBox&gt;</code></p><p><img src="D:\码田\项目\MyBlog\source\images\WPF-绑定\image-20210424143754327.png" srcset="/img/loading.gif" alt="image-20210424143754327"></p><h2 id="2-2绑定属性（依赖项属性）"><a href="#2-2绑定属性（依赖项属性）" class="headerlink" title="2.2绑定属性（依赖项属性）"></a>2.2绑定属性（依赖项属性）</h2><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot; Text=&quot;&#123;Bingding Name&#125;&quot;&gt;&lt;/TextBox&gt;</code></p><ul><li>Text绑定属性</li><li>Bingding 绑定关键字</li><li>Name你要绑定的数据源的变量名</li></ul><h2 id="2-3-绑定模式"><a href="#2-3-绑定模式" class="headerlink" title="2.3 绑定模式"></a>2.3 绑定模式</h2><table><thead><tr><th>模式名称</th><th>含义</th></tr></thead><tbody><tr><td>TwoWay</td><td>无论是目标属性还是源属性，只要发生了更改，就会更新目标属性或源属性</td></tr><tr><td>OneWay</td><td>仅当源属性发生更改时更新目标属性</td></tr><tr><td>OneTime</td><td>仅当应用程序启动时或 DataContext 进行更改时更新目标属性</td></tr><tr><td>OneWayToSource</td><td>在目标属性更改时更新源属性</td></tr><tr><td>Default</td><td>模式根据实际情况来定，如果是可编辑的就是TwoWay,只读的就是OneWay</td></tr></tbody></table><h2 id="2-4-绑定数据源"><a href="#2-4-绑定数据源" class="headerlink" title="2.4 绑定数据源"></a>2.4 绑定数据源</h2><p>一般来说可以是单个变量（int , double,string）、也可以是一个数据集（List）。根据需求和场景去定义。</p><h2 id="2-5-关联资源-DataContext"><a href="#2-5-关联资源-DataContext" class="headerlink" title="2.5 关联资源 DataContext"></a>2.5 关联资源 DataContext</h2><p>在每一个窗体中，都有一个DataContext ，它是一个object类型主要用来存储绑定资源。</p><h1 id="3-绑定和窗体xaml-cs操作的区别"><a href="#3-绑定和窗体xaml-cs操作的区别" class="headerlink" title="3. 绑定和窗体xaml.cs操作的区别"></a>3. 绑定和窗体xaml.cs操作的区别</h1><p>区别在于，窗体后台文件直接访问控件的操作是事件驱动，如果没有事件的存在是改变不了界面的。</p><p>绑定操作，是以数据本身的变化来通知界面显示改变的。</p><p>UI代码和逻辑代码实现前后端分离。</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>绑定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF快速入门</title>
    <link href="/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>整理自B站视频教程:<a href="https://www.bilibili.com/video/BV19K411M72o?p=1">https://www.bilibili.com/video/BV19K411M72o?p=1</a></p><h2 id="1-1-什么是WPF"><a href="#1-1-什么是WPF" class="headerlink" title="1.1 什么是WPF"></a>1.1 什么是WPF</h2><p>WPF全称Windows Presentation Foundation，是微软推出的一项基于windows操作系统的.net平台的c/s客户端构建技术。<br>最大的特征就是可以快速构建项目从而达到节约项目成本的目的。<br>在众多中小型企业比较受欢迎。</p><p>该项受欢迎的行业有医疗、工业、金融、硬件、物流、管理系统（ERP）等领域。</p><p>简而言之就是微软基于C#与.NET推出的一个可视化框架。</p><blockquote><p>微软的可视化框架发展路径：<br>MFC-&gt;WinForm-&gt;WPF</p></blockquote><h2 id="1-2-推荐书籍"><a href="#1-2-推荐书籍" class="headerlink" title="1.2 推荐书籍"></a>1.2 推荐书籍</h2><ul><li><p>《WPF编程宝典使用c#2012和.net4.5 第四版》</p></li><li><p>《c#高级编程》</p></li><li><p>《CLR Via C#》</p></li></ul><h2 id="1-3-前置知识体系"><a href="#1-3-前置知识体系" class="headerlink" title="1.3 前置知识体系"></a>1.3 前置知识体系</h2><ul><li><p>C#</p></li><li><p>学习过至少一种可视化框架或web框架</p></li></ul><h1 id="2-学习目录索引"><a href="#2-学习目录索引" class="headerlink" title="2 学习目录索引"></a>2 学习目录索引</h1><ul><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%B8%83%E5%B1%80/">布局(Pannel)</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/">控件</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/">依赖属性</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/">绑定</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/">命令</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-MVVC/">MVVM</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p><p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。<br>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。<br>这种方式简化了在复杂环境下的配置管理。</p><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><ul><li><p>单例类只能有一个实例</p></li><li><p>单例类必须自己创建自己的唯一实例</p></li><li><p>单例类必须给所有其他对象提供这一实例</p></li></ul><h2 id="2-1-优缺点"><a href="#2-1-优缺点" class="headerlink" title="2.1 优缺点"></a>2.1 优缺点</h2><h3 id="2-1-1-优点"><a href="#2-1-1-优点" class="headerlink" title="2.1.1 优点"></a>2.1.1 优点</h3><ul><li><p>在内存中只有一个对象，节省内存空间；</p></li><li><p>避免频繁的创建销毁对象，可以提高性能；</p></li><li><p>避免对共享资源的多重占用，简化访问；</p></li><li><p>为整个系统提供一个全局访问点。</p></li></ul><h3 id="2-1-2-缺点"><a href="#2-1-2-缺点" class="headerlink" title="2.1.2 缺点"></a>2.1.2 缺点</h3><ul><li><p>不适用于变化频繁的对象；</p></li><li><p>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</p></li><li><p>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</p></li></ul><h2 id="2-2-适用场景"><a href="#2-2-适用场景" class="headerlink" title="2.2 适用场景"></a>2.2 适用场景</h2><ul><li>需要生成唯一序列的环境</li><li>需要频繁实例化然后销毁的对象</li><li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象</li><li>方便资源相互通信的环境</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" alt="单例模式"></p><h1 id="4-实现步骤"><a href="#4-实现步骤" class="headerlink" title="4. 实现步骤"></a>4. 实现步骤</h1><ol><li>将该类的构造方法定义为私有方法：<br>这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</li><li>在该类内提供一个静态方法：<br>当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li></ol><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将为一个网站设计一个用于连接数据库的数据库连接池，它基于JDBC，并且要求具有以下几个功能：</p><ul><li>连接池内有数量可定的已连接对象随时供取用</li><li>当连接池内的连接对象不够时可生成新的对象取用</li><li>当连接操作完毕后，可将连接对象放回连接池</li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p>使用单例模式实现连接池：</p><ol><li><p>将该类的构造方法定义为私有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在该类内提供一个静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>   &#125;<br></code></pre></td></tr></table></figure><p>使用线性表存储连接对象，实现对连接对象操作的各个方法。</p></li></ol><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> EXP6;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;<br>    <span class="hljs-comment">//数据库地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String url;<br>    <span class="hljs-comment">//取得用户</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String user;<br>    <span class="hljs-comment">//登录密码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String password;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Connection&gt; connections;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConnectionPool connectionPool;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(String url,String user,String password)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.url=url;<span class="hljs-keyword">this</span>.user=user;<span class="hljs-keyword">this</span>.password=password;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">(String url,String user,String password)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool(url,user,password);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)<br>            &#123;<br>                connections.add(DriverManager.getConnection(url,user,password));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(connections.size()==<span class="hljs-number">0</span>) addConnection(<span class="hljs-number">1</span>);<br>        Connection t=connections.getFirst();<br>        connections.removeFirst();<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseConnection</span><span class="hljs-params">(Connection c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (c.isClosed()) connections.add(c);<br>                <span class="hljs-keyword">else</span> addConnection(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-进阶写法"><a href="#6-进阶写法" class="headerlink" title="6. 进阶写法"></a>6. 进阶写法</h1><h2 id="6-1-懒汉式-线程不安全"><a href="#6-1-懒汉式-线程不安全" class="headerlink" title="6.1 懒汉式(线程不安全)"></a>6.1 懒汉式(线程不安全)</h2><p>懒汉式其实是一种比较形象的称谓。<br>既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作。<br>因此在装载对象的时候不创建对象实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> (<span class="hljs-params"></span>)</span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         instance = <span class="hljs-keyword">new</span> Singleton();<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。<br>当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。<br>也就是说在多线程下不能正常工作。</p><h2 id="6-2-懒汉式-线程安全"><a href="#6-2-懒汉式-线程安全" class="headerlink" title="6.2 懒汉式(线程安全)"></a>6.2 懒汉式(线程安全)</h2><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。<br>因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。<br>这就引出了双重检验锁。</p><h2 id="6-3-双重检验锁"><a href="#6-3-双重检验锁" class="headerlink" title="6.3 双重检验锁"></a>6.3 双重检验锁</h2><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。<br>程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。<br>为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <span class="hljs-comment">//Single Checked</span><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                 <span class="hljs-comment">//Double Checked</span><br>                instance = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很完美，很可惜，它是有问题:<br>主要在于instance = new Singleton()这句，这<strong>并非是一个原子操作</strong>，事实上在 JVM 中这句话大概做了下面 3 件事情:</p><ul><li><p>给 instance 分配内存</p></li><li><p>调用 Singleton 的构造函数来初始化成员变量</p></li><li><p>将instance对象指向分配的内存空间<br>（执行完这步 instance 就为非 null 了）</p></li></ul><p>但是在 JVM 的即时编译器中存在指令重排序的优化。</p><p>也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。<br>如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance; <span class="hljs-comment">//声明成 volatile</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;       <br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。<br>但其实是不对的。</p><p><strong>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。</strong></p><p>也就是说，<strong>在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前</strong>。<br>比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</p><p>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。<br>这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p><h2 id="6-4-饿汉式-static-final-field"><a href="#6-4-饿汉式-static-final-field" class="headerlink" title="6.4 饿汉式 static final field"></a>6.4 饿汉式 static final field</h2><p>饿汉式其实是一种比较形象的称谓。<br>既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。</p><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-comment">//类加载时就初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点是它不是一种懒加载模式（lazy initialization），<strong>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。</strong></p><blockquote><p>饿汉式的创建方式在一些场景中将无法使用：<br>譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p></blockquote><h2 id="6-5-静态内部类-static-nested-class"><a href="#6-5-静态内部类-static-nested-class" class="headerlink" title="6.5 静态内部类 static nested class"></a>6.5 静态内部类 static nested class</h2><p>这种方法也是《Effective Java》上所推荐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE; <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法仍然使用JVM本身机制保证了线程安全问题。<br>由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，**第一次调用getInstance()时将加载内部类SingletonHolder **，在该内部类中定义了一个static类型的变量INSTANCE ，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><h2 id="6-6-枚举-Enum"><a href="#6-6-枚举-Enum" class="headerlink" title="6.6 枚举 Enum"></a>6.6 枚举 Enum</h2><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EasySingleton</span></span>&#123;<br>    <span class="hljs-type">INSTANCE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>我们可以总结出，要想实现效率高的线程安全的单例，我们必须注意以下两点：</p><ul><li><strong>尽量减少同步块的作用域</strong></li><li><strong>尽量使用细粒度的锁</strong></li></ul><p>一般来说，单例模式有五种写法：<br><strong>懒汉、饿汉、双重检验锁、静态内部类、枚举</strong><br>上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。</p><p>一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。<br>如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p><p>参考：<br><a href="https://www.jianshu.com/p/650593e69f59">https://www.jianshu.com/p/650593e69f59</a><br><a href="https://www.cnblogs.com/xuwendong/p/9633985.html">https://www.cnblogs.com/xuwendong/p/9633985.html</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket原理</title>
    <link href="/2021/04/07/Socket%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/07/Socket%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Socket"><a href="#1-什么是Socket" class="headerlink" title="1. 什么是Socket"></a>1. 什么是Socket</h1><h2 id="1-1-网络中进程之间如何通信"><a href="#1-1-网络中进程之间如何通信" class="headerlink" title="1.1 网络中进程之间如何通信"></a>1.1 网络中进程之间如何通信</h2><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信。</p><p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！<br>在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p><p>其实TCP/IP协议族已经帮我们解决了这个问题：<br>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><p>使用TCP/IP协议的应用程序通常采用应用编程接口：<br>UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。</p><p>就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。</p><h2 id="1-2-什么是TCP-IP、UDP"><a href="#1-2-什么是TCP-IP、UDP" class="headerlink" title="1.2 什么是TCP/IP、UDP"></a>1.2 什么是TCP/IP、UDP</h2><ul><li><p>TCP/IP（Transmission Control Protocol/Internet Protocol）<br>即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。</p></li><li><p>UDP（User Data Protocol，用户数据报协议）<br>是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p></li></ul><p>这里有一张图，表明了这些协议的关系。</p><p>​          <img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154451958.png" srcset="/img/loading.gif" alt="img">                              </p><h2 id="1-3-什么是Socket"><a href="#1-3-什么是Socket" class="headerlink" title="1.3 什么是Socket"></a>1.3 什么是Socket</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。<br>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p><blockquote><h3 id="socket一词的起源"><a href="#socket一词的起源" class="headerlink" title="socket一词的起源"></a>socket一词的起源</h3><p>在组网领域的首次使用是在1970年2月12日发布的文献<a href="http://datatracker.ietf.org/doc/rfc33/">IETF RFC33</a>中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p></blockquote><h2 id="1-4-Socket在哪里"><a href="#1-4-Socket在哪里" class="headerlink" title="1.4 Socket在哪里"></a>1.4 Socket在哪里</h2><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154523875.png" srcset="/img/loading.gif" alt="img"></p><h1 id="2-Socket的使用"><a href="#2-Socket的使用" class="headerlink" title="2. Socket的使用"></a>2. Socket的使用</h1><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154556909.png" srcset="/img/loading.gif" alt="img">   </p><ul><li>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。</li><li>在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。</li><li>客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</li></ul><h2 id="2-1-socket的基本操作"><a href="#2-1-socket的基本操作" class="headerlink" title="2.1 socket的基本操作"></a>2.1 socket的基本操作</h2><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。<br>下面以TCP为例，介绍几个基本的socket接口函数。</p><h3 id="2-1-1-socket-函数"><a href="#2-1-1-socket-函数" class="headerlink" title="2.1.1 socket()函数"></a>2.1.1 socket()函数</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> socket(<span class="hljs-type">int</span> <span class="hljs-keyword">domain</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">type</span>, <span class="hljs-type">int</span> protocol);<br></code></pre></td></tr></table></figure><p>socket函数对应于普通文件的打开操作。<br>普通文件的打开操作返回一个文件描述字，而**socket()**用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。<br>这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。<br>创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：<br>即协议域，又称为协议族（family）。<br>常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。<br>协议族决定了socket的地址类型，在通信中必须采用对应的地址。<br>如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：<br>指定socket类型。<br>常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li><li>protocol：<br>故名思意，就是指定协议。<br>常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等<br>它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li></ul><blockquote><p>注意：<br>并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。<br>当protocol为0时，会自动选择type类型对应的默认协议。</p></blockquote><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h3 id="2-1-2-bind-函数"><a href="#2-1-2-bind-函数" class="headerlink" title="2.1.2 bind()函数"></a>2.1.2 bind()函数</h3><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。<br>例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ul><li><p>sockfd：<br>即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。<br>bind()函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：<br>一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。<br>这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-keyword">sa_family_t</span>    sin_family; <br>    <span class="hljs-keyword">in_port_t</span>      sin_port;   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>   <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span>       s_addr;     <br>&#125;;<br></code></pre></td></tr></table></figure><p>ipv6对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span>     sin6_family;    <br>    <span class="hljs-keyword">in_port_t</span>       sin6_port;      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_flowinfo;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span>      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_scope_id;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> &#123;</span> <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   s6_addr[<span class="hljs-number">16</span>];    <br>&#125;;<br></code></pre></td></tr></table></figure><p>Unix域对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_PATH_MAX    108</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span> sun_family;                <br>    <span class="hljs-keyword">char</span>        sun_path[UNIX_PATH_MAX];   <br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>addrlen：对应的是地址的长度。</p></li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务。<br>客户就可以通过它来接连服务器；</p><p>而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。</p><p>这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p><blockquote><h3 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h3><p><strong>主机字节序</strong>就是我们平常说的大端和小端模式：<br>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。<br>引用标准的Big-Endian和Little-Endian的定义如下：</p><p>　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><p>　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p><strong>网络字节序</strong>：<br>4个字节的32 bit值以下面的次序传输：<br>首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。<br>这种传输次序称作大端字节序。<br><strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong><br>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p><p>所以： 在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。<br>由于 这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再 赋给socket。</p></blockquote><h3 id="2-1-3-listen-、connect-函数"><a href="#2-1-3-listen-、connect-函数" class="headerlink" title="2.1.3 listen()、connect()函数"></a>2.1.3 listen()、connect()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。<br>客户端通过调用connect函数来建立与TCP服务器的连接。</p><h3 id="2-1-4-accept-函数"><a href="#2-1-4-accept-函数" class="headerlink" title="2.1.4 accept()函数"></a>2.1.4 accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。<br>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。<br>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。<br>之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><blockquote><p>注意：<br>accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。<br>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。<br>内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p></blockquote><h3 id="2-1-5-read-、write-等函数"><a href="#2-1-5-read-、write-等函数" class="headerlink" title="2.1.5 read()、write()等函数"></a>2.1.5 read()、write()等函数</h3><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。</p><p>可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。</p><p>它们的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">const</span> struct sockaddr *dest_addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">                 struct sockaddr *src_addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>read函数<br>负责从fd中读取内容<br>当读成功时，read返回实际所读的字节数</p><ul><li>返回的值是0表示已经读到文件的结束了</li><li>返回的值小于0表示出现了错误。<ul><li>如果错误为EINTR说明读是由中断引起的</li><li>如果是ECONNREST表示网络连接出了问题。</li></ul></li></ul></li><li><p>write函数<br>将buf中的nbytes字节内容写入文件描述符fd。</p><ul><li><p>成功时返回写的字节数</p></li><li><p>失败时返回-1，并设置errno变量</p></li><li><p>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</p><ul><li><p>1)write的返回值大于0，表示写了部分或者是 全部的数据。</p></li><li><p>2)返回的值小于0，此时出现了错误。</p></li></ul><p>我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。<br>如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。</p></li></ul></li></ul><p>其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。</p><h3 id="2-1-6-close-函数"><a href="#2-1-6-close-函数" class="headerlink" title="2.1.6 close()函数"></a>2.1.6 close()函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。<br>该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><blockquote><p>注意：<br>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p></blockquote><h2 id="2-2-socket中TCP的三次握手建立连接详解"><a href="#2-2-socket中TCP的三次握手建立连接详解" class="headerlink" title="2.2 socket中TCP的三次握手建立连接详解"></a>2.2 socket中TCP的三次握手建立连接详解</h2><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><p>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0NzYyODYucG5n" srcset="/img/loading.gif" alt="image"></p><p>图1、socket中发送的TCP三次握手</p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><blockquote><p>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</p></blockquote><h2 id="2-3-socket中TCP的四次握手释放连接详解"><a href="#2-3-socket中TCP的四次握手释放连接详解" class="headerlink" title="2.3 socket中TCP的四次握手释放连接详解"></a>2.3 socket中TCP的四次握手释放连接详解</h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0OTQ2OTMucG5n" srcset="/img/loading.gif" alt="image"></p><p>图2、socket中发送的TCP四次握手</p><p>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p>这样每个方向上都有一个FIN和ACK。</p><p>6.下面给出实现的一个实例</p><p>首先，先给出实现的截图</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718155008892.png" srcset="/img/loading.gif" alt="img"></p><p>服务器端代码如下：</p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET sListen = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>//用来指定套接字使用的地址格式，通常使用AF_INET</li><li>//指定套接字的类型，若是SOCK_DGRAM，则用的是udp不可靠传输</li><li>//配合type参数使用，指定使用的协议类型（当指定套接字类型后，可以设置为0，因为默认为UDP或TCP）</li><li>if(sListen == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 填充sockaddr_in结构 ,是个结构体</li><li>sockaddr_in sin;</li><li>sin.sin_family = AF_INET;</li><li>sin.sin_port = htons(4567); //1024 ~ 49151：普通用户注册的端口号</li><li>sin.sin_addr.S_un.S_addr = INADDR_ANY;</li><li>// 绑定这个套节字到一个本地地址</li><li>if(::bind(sListen, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed bind() \n”);</li><li>return 0;</li><li>}</li><li>// 进入监听模式</li><li>//2指的是，监听队列中允许保持的尚未处理的最大连接数</li><li>if(::listen(sListen, 2) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed listen() \n”);</li><li>return 0;</li><li>}</li><li>// 循环接受客户的连接请求</li><li>sockaddr_in remoteAddr;</li><li>int nAddrLen = sizeof(remoteAddr);</li><li>SOCKET sClient = 0;</li><li>char szText[] = “ TCP Server Demo! \r\n”;</li><li>while(sClient==0)</li><li>{</li><li>// 接受一个新连接</li><li>//（(SOCKADDR*)&amp;remoteAddr）一个指向sockaddr_in结构的指针，用于获取对方地址</li><li>sClient = ::accept(sListen, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrLen);</li><li>if(sClient == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed accept()”);</li><li>}</li><li>printf(“接受到一个连接：%s \r\n”, inet_ntoa(remoteAddr.sin_addr));</li><li>continue ;</li><li>}</li><li>while(TRUE)</li><li>{</li><li>// 向客户端发送数据</li><li>gets(szText) ;</li><li>::send(sClient, szText, strlen(szText), 0);</li><li>// 从客户端接收数据</li><li>char buff[256] ;</li><li>int nRecv = ::recv(sClient, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“ 接收到数据：%s\n”, buff);</li><li>}</li><li>}</li><li>// 关闭同客户端的连接</li><li>::closesocket(sClient);</li><li>// 关闭监听套节字</li><li>::closesocket(sListen);</li><li>return 0;</li><li>}</li></ol><p>客户端代码：</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET s = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>if(s == INVALID_SOCKET)</li><li>{</li><li>printf(“ Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 也可以在这里调用bind函数绑定一个本地地址</li><li>// 否则系统将会自动安排</li><li>// 填写远程地址信息</li><li>sockaddr_in servAddr;</li><li>servAddr.sin_family = AF_INET;</li><li>servAddr.sin_port = htons(4567);</li><li>// 注意，这里要填写服务器程序（TCPServer程序）所在机器的IP地址</li><li>// 如果你的计算机没有联网，直接使用127.0.0.1即可</li><li>servAddr.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1”);</li><li>if(::connect(s, (sockaddr*)&amp;servAddr, sizeof(servAddr)) == -1)</li><li>{</li><li>printf(“ Failed connect() \n”);</li><li>return 0;</li><li>}</li><li>char buff[256];</li><li>char szText[256] ;</li><li>while(TRUE)</li><li>{</li><li>//从服务器端接收数据</li><li>int nRecv = ::recv(s, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“接收到数据：%s\n”, buff);</li><li>}</li><li>// 向服务器端发送数据</li><li>gets(szText) ;</li><li>szText[255] = ‘\0’;</li><li>::send(s, szText, strlen(szText), 0) ;</li><li>}</li><li>// 关闭套节字</li><li>::closesocket(s);</li><li>return 0;</li><li>}</li></ol><p>封装的InitSock.h</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include</li><li>#include</li><li>#include</li><li>#include</li><li>#pragma comment(lib, “WS2_32”) // 链接到WS2_32.lib</li><li>class CInitSock</li><li>{</li><li>public:</li><li>CInitSock(BYTE minorVer = 2, BYTE majorVer = 2)</li><li>{</li><li>// 初始化WS2_32.dll</li><li>WSADATA wsaData;</li><li>WORD sockVersion = MAKEWORD(minorVer, majorVer);</li><li>if(::WSAStartup(sockVersion, &amp;wsaData) != 0)</li><li>{</li><li>exit(0);</li><li>}</li><li>}</li><li>~CInitSock()</li><li>{</li><li>::WSACleanup();</li><li>}</li><li>};</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-输入操作</title>
    <link href="/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>输入操作是游戏的基础操作之一。</p><p>Unity支持的操作方式：</p><ul><li>鼠标、键盘，小键盘(PC)</li><li>手柄(主机)</li><li>触屏操作、重力传感器、手势（移动平台）</li><li>VR，AR</li><li>麦克风，摄像头</li></ul><h1 id="2-虚拟输入轴-Virtual-axes"><a href="#2-虚拟输入轴-Virtual-axes" class="headerlink" title="2. 虚拟输入轴(Virtual axes)"></a>2. 虚拟输入轴(Virtual axes)</h1><p>虚拟控制轴将不同的输入设备(比如键盘或摇杆的按键)都归纳到一个统一的虚拟控制系统中。<br>(比如键盘的w、S键以及手柄摇杆的上下运动默认都统一映射到竖直(Verica)输入轴上)<br>这样就屏蔽了不同设备之间的差异，让开发者可以用一套非常简单的输入逻辑，同时兼容多种输入设备。</p><p>使用**输入管理器(Input Manager)**可以查看、修改或增删虚拟轴。</p><p>现代的游戏中往往允许玩家在游戏中自定义按键，所以使用Unity的输入管理器就更为重要要了。<br>通过一层虚拟轴间接操作，可以避免在代码中直接写死操作按钮，而且还能通过动态修改虚拟轴的设置来改变键位的功能。</p><p>关于虚拟输入轴，还有一些需要知道的内容：</p><ol><li><p>脚本可以直接通过虚拟轴的名称读取那个轴的输入状态。</p></li><li><p>创建Unity工程时，默认创建了以下虚拟轴:</p><ul><li><p>横向输入和纵向输入被映射在键盘的W、A、S、 D键以及方向键上</p></li><li><p>Fire1、 Fire2、 Fire3这三个按钮映射到了鼠标的左、中、右键以及键盘的Ctrl. AIt等键位上</p></li><li><p>鼠标移动可以模拟摇杆输入(和鼠标光标在屏幕上的位置无关)，且被映射在专门的鼠标偏移轴上</p></li><li><p>其他常用虚拟轴，例如跳跃(Jump) 、确认(Submit) 和取消(Cancel) </p><h2 id="2-1-添加和编辑虚拟输入轴"><a href="#2-1-添加和编辑虚拟输入轴" class="headerlink" title="2.1 添加和编辑虚拟输入轴"></a>2.1 添加和编辑虚拟输入轴</h2></li></ul></li></ol><p>要添加新的虚拟输入轴，只需要单击主菜单的Edit &gt; Projet Setings &gt; Input 选项，单击路街检视窗口中会显示一个输入管理器，在里面就可以修改或添加虚拟轴了。</p><blockquote><p>注意:<br>虚拟轴具有正、负两个方向。英文记作Positive和Negative.。<br>某些相反的动作可以只用一个轴来表示。<br>比如，如果摇杆向上为正，那么向下就是同一个轴的负方向。</p></blockquote><p>每个虚拟轴可以映射两个按键，第二个按键作为备用，功能一样，备用的英文为Alterative。</p><h2 id="2-2-虚拟输入轴属性表"><a href="#2-2-虚拟输入轴属性表" class="headerlink" title="2.2 虚拟输入轴属性表"></a>2.2 虚拟输入轴属性表</h2><p>下表是虚拟输入轴的属性表：</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>Name</td><td>轴的名字。在脚本中用这个名字来访问这个轴</td></tr><tr><td>Descriptive Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(正方向)</td></tr><tr><td>Descriptive Negative Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(负方向)</td></tr><tr><td>Ncgative Button</td><td>该轴的负方向，用于绑定某个按键</td></tr><tr><td>Positive Button</td><td>该轴的正方向，用于绑定某个按键</td></tr><tr><td>Alt Negative Button</td><td>该轴的负方向，用于绑定某个备用按键</td></tr><tr><td>Alt Positive Button</td><td>该轴的正方向，用于绑定某个备用按键</td></tr><tr><td>Gravity</td><td>轴回中的力度</td></tr><tr><td>Dead</td><td>轴的死区</td></tr><tr><td>Sensitivity</td><td>敏感度</td></tr><tr><td>Snap</td><td>保持式按键。比如按住下方向键，则一直保持下的状态，直到再次按上方向键</td></tr><tr><td>Invert</td><td>如果勾选，则交换正负方向</td></tr><tr><td>Type</td><td>控制该虚拟轴的类型， 比如手柄、键盘是两种不同的类型</td></tr><tr><td>Axis</td><td>很多手柄的输入不是按钮式的，这时就不能配置到Button里面，而是要配置到这里。可以理解为实际的操作轴</td></tr><tr><td>Joy Num</td><td>当有多个控制器时，要填写控制器的编号</td></tr></tbody></table><p>上表中的Gravity、Dead 等属性需要解释一下。</p><h3 id="2-2-1-Gravity"><a href="#2-2-1-Gravity" class="headerlink" title="2.2.1 Gravity"></a>2.2.1 Gravity</h3><p>现代游戏的方向输入和早期游戏的方向输入不太一样。<br>早期游戏中，上、中、下都是离散的状态，可以直接用1、0、-1来表示。<br>而现代游戏输入往往具有中间状态，比如0、0.35、 0.5、0.7、1, 是带有多级梯度的。<br>比如轻推摇杆代表走路，推到底就是跑步。<br>所以现代游戏的输入默认都是采用多梯度的模式。</p><p>虽然键盘没有多级输入的功能，但Unity依然会模拟这个功能，也就是说当你按住W键时，这个轴的值会以很快的速度逐渐从0增加到1。</p><p>所以，上表中Gravity和Sensitivity的含义就不难理解了，它们影响着虚拟轴从1到0、从0到1的速度以及敏感度。</p><blockquote><p>具体调试方法这里不再介绍，建议使用默认值</p></blockquote><h3 id="2-2-2-Dead"><a href="#2-2-2-Dead" class="headerlink" title="2.2.2 Dead"></a>2.2.2 Dead</h3><p>还有死区需要单独说明。</p><p>由于实体手柄、摇杆会有一些误差，比如，手柄放着不动时，某些手柄的输出值可能会在0.05 和0.08之间浮动。这个误差有必要在程序中排除。<br>所以Unity设计了死区的功能，在该值范围内的抖动被忽略为0,这样就可以过滤掉输入设备的误差。</p><h2 id="2-3-在脚本中处理输入"><a href="#2-3-在脚本中处理输入" class="headerlink" title="2.3 在脚本中处理输入"></a>2.3 在脚本中处理输入</h2><p>读取输入轴的方法很简单，代码如下:</p><p><code>float value = Input.GetAxis (&quot;Horizontal&quot;);</code></p><p>得到的值的范围为-1~1,默认位置为0。<br>这个读取虚拟轴的方法与具体控制器是键盘还是手柄无关。</p><blockquote><p>如果用鼠标控制虚拟轴，就有可能由于移动过快导致值超出-1~1的范围。</p></blockquote><blockquote><p>注意:<br>可以创建多个相同名字的虚拟轴。<br>Unity 可以同时管理多个同名的轴，最终结果以变化最大的轴为准。<br>这样做的原因是很多游戏可以同时用多种设备进行操作。<br>比如PC游戏可以用键盘、鼠标或手柄进行操作，手机游戏可以用重力感应器或手柄进行操作。<br>这种设计有助于用户在多种操作设备之间切换，且在脚本中不用去关心这一点。</p></blockquote><h2 id="2-4-按键名称"><a href="#2-4-按键名称" class="headerlink" title="2.4 按键名称"></a>2.4 按键名称</h2><p>要映射按键到轴上，需要在正方向输入框或者负方向输入框中输入正确的按键名称。<br>按键名称的规则和例子如下。</p><ul><li><p>常规按键: A、B、……</p></li><li><p>数字键: 1、2、……</p></li><li><p>方向键: Up、 Down、 Left、 Right…..</p></li><li><p>小键盘键: [1]、 [2]、 [3]、 [+]、 [equals]…..</p></li><li><p>修饰键: Right+Shift、 Lef+Shift、Right+Ctrl、Left+Ctrl、Right+Alt、Left+Alt、Right+Cmd、Left+Cmd….</p></li><li><p>鼠标按钮: mouse 0、mouse 1、mouse2 …..</p></li><li><p>手柄按钮(不指定具体的手柄序号) : joystick button 0、joystick button 1…..</p></li><li><p>手柄按钮(指定具体的手柄序号): joystick 1 button 0、joystick 1 button 1……</p></li><li><p>特殊键: Backspace、 Tab、 Retur、 Escape、 Space、 Delete、 Enter、 Insert、 Home、Page Up…..</p></li><li><p>功能键: FI、F2、…..</p><blockquote><p>可以使用<strong>KeyCode枚举类</strong>型来指定案件，与用字符串的效果一致</p></blockquote></li></ul><h1 id="3-在PC端输入"><a href="#3-在PC端输入" class="headerlink" title="3. 在PC端输入"></a>3. 在PC端输入</h1><p>unity为开发者提供了input库，来支持键盘事件，鼠标事件以及触摸事件。</p><h2 id="3-1-键盘事件"><a href="#3-1-键盘事件" class="headerlink" title="3.1 键盘事件"></a>3.1 键盘事件</h2><p>一般的PC键盘有104个不同的按键，在程序中通过监听这些按键事件，从而进一步执行逻辑操作。<br>如：射击游戏中，W表示前进，S表示后退，A表示左移，D表示右移。</p><h3 id="3-1-1-按下事件"><a href="#3-1-1-按下事件" class="headerlink" title="3.1.1 按下事件"></a>3.1.1 按下事件</h3><p>在脚本中，用<strong>input.GetKeyDown( )方法</strong>将按键值作为参数，监听此按键是否被按下。<br>按下返回true，否者返回false。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了W键&quot;</span>);  <br>            &#125;  <br><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了空格键&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-2-抬起事件"><a href="#3-1-2-抬起事件" class="headerlink" title="3.1.2 抬起事件"></a>3.1.2 抬起事件</h3><p>抬起事件完全依赖于按下事件，因为只有按下才有抬起。</p><p>我们用<strong>Input.GetKeyUp( )方法</strong>监听抬起事件<br>按键抬起后，返回true，否则返回false。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.W))  <br>           &#123;  <br>               Debug.Log(<span class="hljs-string">&quot;您抬起了W键&quot;</span>);  <br>           &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-3-长按事件"><a href="#3-1-3-长按事件" class="headerlink" title="3.1.3 长按事件"></a>3.1.3 长按事件</h3><p>长按事件是监听某一按键是否处于一直按下的状态<br>通过**Input.GetKey( )**来判断键盘中某一按键是否被一直按着。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKey (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//记录按下的帧数  </span><br>                keyFrame++;  <br>                Debug.Log(<span class="hljs-string">&quot;A连按:&quot;</span> + keyFrame+<span class="hljs-string">&quot;帧&quot;</span>);  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//抬起后清空帧数  </span><br>                keyFrame=<span class="hljs-number">0</span>;  <br>                Debug.Log(<span class="hljs-string">&quot;A按键抬起&quot;</span>);  <br>            &#125;     <br></code></pre></td></tr></table></figure><h3 id="3-1-4-任意键事件"><a href="#3-1-4-任意键事件" class="headerlink" title="3.1.4 任意键事件"></a>3.1.4 任意键事件</h3><p>在程序中还可以监听按键中的任意按键是否被按下</p><p>常见于加载完游戏后，按任意键进入。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span>(Input.anyKeyDown)  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;任意键被按下&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-4实例——组合按键"><a href="#3-1-4实例——组合按键" class="headerlink" title="3.1.4实例——组合按键"></a>3.1.4实例——组合按键</h3><p>在经典的格斗游戏中，会有组合键发出牛逼的大招，而这个功能的事件思路其实不难：<br>在玩家按下某一键后，便开始时间记数，在某一时间内按出所需要的键便发出大招。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs c#">    <span class="hljs-keyword">using</span> UnityEngine;  <br>    <span class="hljs-keyword">using</span> System.Collections.Generic;  <br>    <span class="hljs-keyword">using</span> System;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Script_07_05</span> : <span class="hljs-title">MonoBehaviour</span>   <br>    &#123;  <br>        <span class="hljs-comment">//方向键上的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageUp;  <br>        <span class="hljs-comment">//方向键下的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageDown;  <br>        <span class="hljs-comment">//方向键左的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageLeft;  <br>        <span class="hljs-comment">//方向键右的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageRight;  <br>        <span class="hljs-comment">//按键成功的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageSuccess; <br>        <br>        <span class="hljs-comment">//自定义方向键的储存值  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_UP = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_DOWN = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_LEFT = <span class="hljs-number">2</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_RIGHT = <span class="hljs-number">3</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_FIRT = <span class="hljs-number">4</span>;  <br>        <br>        <span class="hljs-comment">//连续按键的事件限制  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> FRAME_COUNT = <span class="hljs-number">100</span>;  <br><br>        <span class="hljs-comment">//仓库中储存技能的数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_SIZE = <span class="hljs-number">3</span>;  <br><br>        <span class="hljs-comment">//每组技能的按键数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_COUNT = <span class="hljs-number">5</span>;  <br><br>        <span class="hljs-comment">//技能仓库  </span><br>        <span class="hljs-built_in">int</span>[,] Sample =   <br>        &#123;  <br>            <span class="hljs-comment">//下 + 前 + 下 + 前 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_RIGHT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 前 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 后 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_LEFT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>        &#125;;  <br>        <span class="hljs-comment">//记录当前按下按键的键值  </span><br>        <span class="hljs-built_in">int</span>  currentkeyCode =<span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//标志是否开启监听按键  </span><br>        <span class="hljs-built_in">bool</span> startFrame = <span class="hljs-literal">false</span>;  <br>        <span class="hljs-comment">//记录当前开启监听到现在的时间  </span><br>        <span class="hljs-built_in">int</span>  currentFrame = <span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//保存一段时间内玩家输入的按键组合  </span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; playerSample;  <br>        <span class="hljs-comment">//标志完成操作  </span><br>        <span class="hljs-built_in">bool</span> isSuccess= <span class="hljs-literal">false</span>;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//初始话按键组合链表  </span><br>            playerSample  = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();  <br>        &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获得按键组合链表中储存按键的数量  </span><br>            <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>            <span class="hljs-comment">//遍历该按键组合链表  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; size; i++)  <br>            &#123;  <br>                <span class="hljs-comment">//将按下按键对应的图片显示在屏幕中  </span><br>                <span class="hljs-built_in">int</span> key = playerSample[i];  <br>                Texture temp = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">switch</span>(key)  <br>                &#123;  <br>                    <span class="hljs-keyword">case</span> KEY_UP:  <br>                        temp = imageUp;  <br>                        <span class="hljs-keyword">break</span>;  <br>                    <span class="hljs-keyword">case</span> KEY_DOWN:<br>                        temp = imageDown;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_LEFT:<br>                        temp = imageLeft;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_RIGHT:<br>                        temp = imageRight;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp != <span class="hljs-literal">null</span>)  <br>                &#123;<br>                    GUILayout.Label(temp);  <br>                &#125;  <br>            &#125;<br>            <span class="hljs-keyword">if</span>(isSuccess)<br>            &#123;<br>                <span class="hljs-comment">//显示成功贴图</span><br>                GUILayout.Label(imageSuccess);<br>            &#125;<br>            <span class="hljs-comment">//默认提示信息</span><br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键1：下、前、下、前、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、前、下、后、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、后、下、后、拳&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//更新按键</span><br>            UpdateKey();<br>            <span class="hljs-keyword">if</span>(Input.anyKeyDown)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(isSuccess)<br>                &#123;<br>                    <span class="hljs-comment">//按键成功后重置</span><br>                    isSuccess = <span class="hljs-literal">false</span>;<br>                    Reset();<br>                &#125;<br>                <span class="hljs-keyword">if</span>(!startFrame)<br>                &#123;<br>                    <span class="hljs-comment">//启动时间计数器</span><br>                    startFrame = <span class="hljs-literal">true</span>;<br>                &#125;  <br>                <span class="hljs-comment">//将按键值添加如链表中  </span><br>                playerSample.Add(currentkeyCode);  <br>                <span class="hljs-comment">//遍历链表  </span><br>                <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>                <span class="hljs-keyword">if</span>(size == SAMPLE_COUNT)  <br>                &#123;  <br>                    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; SAMPLE_SIZE; i++)  <br>                    &#123;  <br>                        <span class="hljs-built_in">int</span> SuccessCount = <span class="hljs-number">0</span>;  <br>                        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j&lt; SAMPLE_COUNT; j++)  <br>                        &#123;  <br>                            <span class="hljs-built_in">int</span> temp = playerSample[j];  <br>                            <span class="hljs-keyword">if</span>(temp== Sample[i,j])<br>                            &#123;  <br>                                SuccessCount++;  <br>                            &#125;  <br>                        &#125;  <br><span class="hljs-comment">//玩家按下的组合按键与仓库中的按键组合相同表示释放技能成功</span><br>                        <span class="hljs-keyword">if</span>(SuccessCount ==SAMPLE_COUNT)  <br>                        &#123;  <br>                            isSuccess = <span class="hljs-literal">true</span>;  <br>                            <span class="hljs-keyword">break</span>;  <br>                        &#125;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(startFrame)  <br>            &#123;  <br>                <span class="hljs-comment">//计数器++  </span><br>                currentFrame++;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(currentFrame &gt;= FRAME_COUNT)  <br>            &#123; <br>                <span class="hljs-comment">//计数器超时  </span><br>                <span class="hljs-keyword">if</span>(!isSuccess)  <br>                &#123;  <br>                    Reset();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>         <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span> (<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>         &#123;  <br>            <span class="hljs-comment">//重置按键相关信息  </span><br>            currentFrame = <span class="hljs-number">0</span>;  <br>            startFrame = <span class="hljs-literal">false</span>;  <br>            playerSample.Clear();  <br>         &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateKey</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获取当前键盘的按键信息  </span><br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                currentkeyCode = KEY_UP;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.S))  <br>            &#123;  <br>                currentkeyCode = KEY_DOWN;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.A))  <br>            &#123;  <br>                currentkeyCode = KEY_LEFT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.D))  <br>            &#123;  <br>                currentkeyCode = KEY_RIGHT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>               currentkeyCode = KEY_FIRT;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>按s,d,s,d,空格：<img src="./images/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/20160426162352358.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="3-2-鼠标事件"><a href="#3-2-鼠标事件" class="headerlink" title="3.2 鼠标事件"></a>3.2 鼠标事件</h2><p>和键盘事件一样，鼠标一般只有3个按键，左键、右键和中键。</p><p>具体如下：</p><h3 id="3-2-1-按下事件"><a href="#3-2-1-按下事件" class="headerlink" title="3.2.1 按下事件"></a>3.2.1 按下事件</h3><p><code>Input.GetMouseButtonDown()</code><br>来判断鼠标哪个按键被按下：</p><ul><li>返回值为0代表鼠标左键被按下</li><li>返回值为1代表鼠标右键被按下</li><li>返回值为2代表鼠标中键被按下</li></ul><h3 id="3-2-2-抬起事件"><a href="#3-2-2-抬起事件" class="headerlink" title="3.2.2 抬起事件"></a>3.2.2 抬起事件</h3><p><code>Input.GetMouseButtonUp()</code><br>方法监听鼠标按键的抬起事件</p><h3 id="3-2-3-长按事件"><a href="#3-2-3-长按事件" class="headerlink" title="3.2.3 长按事件"></a>3.2.3 长按事件</h3><p><code>Input.GetMouseButton()</code></p><p>监听鼠标某个按键是否一直处于按下状态</p><h1 id="4-在移动端输入"><a href="#4-在移动端输入" class="headerlink" title="4. 在移动端输入"></a>4. 在移动端输入</h1><p>对于移动设备来说，Ioput类还提供了触屏、加速度计以及访问地理位置的功能。<br>此外，移动设备上还经常会用到虚拟键盘，即在屏幕上操作的键盘，Uity中也有相应的访问方法。</p><p>本小节专门讨论移动设备特有的输入方式。</p><h2 id="4-1-多点触摸"><a href="#4-1-多点触摸" class="headerlink" title="4.1 多点触摸"></a>4.1 多点触摸</h2><p>iPhone、iPad、安卓等设备提供同时捕捉多个手指触摸操作的功能，通常可以处理最多5根手指同时触摸屏幕的情况。<br>通过访问Input.touches属性，可以以数组的方式处理多个手指当前的位置等信息。</p><p>安卓设备上多点触摸的规范相对灵活，不同的设备能捕捉的多点触摸操作的数量不尽相同。</p><ul><li><p>较老的设备可能只支持1到2个点同时触摸</p></li><li><p>新设备可能会支持5个点同时触摸</p></li></ul><p>每一个手指的触摸信息以Input.Touch结构体来表示。<br><strong>Input.Touch的属性列表：</strong></p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>fingerld</td><td>该触摸的序号</td></tr><tr><td>position</td><td>触摸在屏幕上的位置</td></tr><tr><td>dcllaPosition</td><td>当前触摸位置和前一个触摸位置的差距</td></tr><tr><td>doltaTime</td><td>最近两次改变触摸位置之间的操作时间的间隔</td></tr><tr><td>tapCount</td><td>IPhone/Ipad设备会记录用户短时间内单击屏幕的次数，它表示用户多次单击操作且没有将手拿开的次数。安卓设备没有这个功能，该值保持为1</td></tr><tr><td>phase</td><td>触摸的阶段。可以用它来判断是刚开始触摸、触摸时移动，还是手指刚刚离开屏幕</td></tr></tbody></table><p>phase的取值是个枚举，枚举值如下：</p><ul><li>Began<br>手指刚接触到屏幕</li><li>Moved<br>手指在屏幕上滑动</li><li>Stationary<br>手指接触到屏幕但还未滑动</li><li>Ended<br>手指离开了屏幕。<br>这个状态代表着一次触摸操作的结束</li><li>Cancceled<br>系统取滑了这次触屏操作。<br>例如当用户拿起手机进行通话，或者触损点多于9个的时候，这次触摸操作就会被取消。<br>这个状态也代表这次触摸操作结束</li></ul><h2 id="4-2-模拟鼠标操作"><a href="#4-2-模拟鼠标操作" class="headerlink" title="4.2 模拟鼠标操作"></a>4.2 模拟鼠标操作</h2><p>绝大部分移动设备可以用触屏模拟鼠标操作。<br>比如使用Input.mousePosition属性不仅可以获得鼠标光标的位置，也可以获得移动设备上触摸的位置。<br>这个功能的原理不难理解，毕竟触屏可以支持多点触摸，而鼠标则是单点操作，这个功能属于向下兼容。</p><p>在移动平台的游戏的开发阶段可以暂时用鼠标操作代替触屏操作，但是稍后应当修改为触屏专用的方式，因为操作手感和功能会有很大区别。</p><h2 id="4-3-加速度计"><a href="#4-3-加速度计" class="headerlink" title="4.3 加速度计"></a>4.3 加速度计</h2><p>当移动设备移动时，内置的加速度计会持续报告当前加速度的值，这个值是一个三维向量，因为物体的运动是任意方向的。<br>这个数值和重力加速度的表示方法类似：</p><ul><li><p>在某个轴方向上，1.0代表该轴具有+1.0g的加速度</p></li><li><p>而负值则代表该轴具有相反方向的加速度。</p></li></ul><p>正常竖直持手机(Home键在下方)时：</p><ul><li><p>X轴的正方向朝右</p></li><li><p>Y轴的正方向朝上</p></li><li><p>Z轴的正方向从手机指向用户</p></li></ul><p>通过Input.aceleation属性可以直接访问加速度计当前的数值。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>输入操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>观察者模式是一种对象行为模式。<br>在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。</p><p>它定义对象间的一种一对多的依赖关系：<br>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>主体是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅并接收通知。</p><p>观察者模式（Observer）完美的将观察者和被观察的对象分离开。<br>观察者模式被广泛应用于软件界面元素之间的交互，在业务对象之间的交互、权限管理等方面。</p><blockquote><p>此种模式通常被用来实现事件处理系统</p></blockquote><p>别名：</p><ul><li>发布-订阅(Publish/Subscribe)模式</li><li>模型-视图(Model/View)模式</li><li>源-监听器(Source/Listener)模式</li><li>从属者(Dependents)模式</li></ul><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>交互对象之间尽量采用低耦合设计</li><li>封装代码中经常变化的数据</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/3985563-8f775c097136a39d.png" srcset="/img/loading.gif" alt="img"></p><p>观察者模式所涉及的角色有：</p><ul><li><p><strong>抽象主题(Subject)角色：</strong><br>抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。<br>抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p></li><li><p><strong>具体主题(ConcreteSubject)角色：</strong><br>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。<br>具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p></li><li><p><strong>抽象观察者(Observer)角色：</strong><br>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p></li><li><p><strong>具体观察者(ConcreteObserver)角色：</strong><br>存储与主题的状态自恰的状态。<br>具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。<br>如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p></li></ul><h1 id="4-推模型与拉模型"><a href="#4-推模型与拉模型" class="headerlink" title="4. 推模型与拉模型"></a>4. 推模型与拉模型</h1><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><h2 id="4-1-推模型"><a href="#4-1-推模型" class="headerlink" title="4.1 推模型"></a>4.1 推模型</h2><p>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><h2 id="4-2-拉模型"><a href="#4-2-拉模型" class="headerlink" title="4.2 拉模型"></a>4.2 拉模型</h2><p>主题对象在通知观察者的时候，只传递少量信息。<br>如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。</p><p>一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><h2 id="4-3-二者比较"><a href="#4-3-二者比较" class="headerlink" title="4.3 二者比较"></a>4.3 二者比较</h2><ul><li><ul><li><p>推模型是假定主题对象知道观察者需要的数据</p></li><li><p>拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值</p></li></ul></li><li><ul><li><p>推模型可能会使得观察者对象难以复用<br>因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况<br>这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者</p></li><li><p>拉模型就不会造成这样的情况<br>因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p></li></ul></li></ul><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将设计一个气象监测应用，它要求具备以下几个功能：</p><ul><li><p>可以从气象站更新：温度，湿度，气压三项数据</p></li><li><p>可以给用户用多种视图展示数据：<br>初始三种视图：目前状况，天气统计，天气预报<br>可以随时增加新的视图</p></li><li><p>用户视图更新有两种方式：</p><ul><li><p>系统按事件自动更新数据同时更新视图</p></li><li><p>用户主动请求更新数据与视图</p></li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%A4%A9%E6%B0%94%E7%9B%91%E6%B5%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="天气监测应用设计类图"></p></li></ul><p>从上图可以分析出各个类在观察者模式中他们的角色：</p><ul><li><p>抽象主题(Subject)角色：Subject</p></li><li><p>具体主题(ConcreteSubject)角色：WeatherData</p></li><li><p>抽象观察者(Observer)角色：Observer</p></li><li><p>具体观察者(ConcreteObserver)角色：StatisticsDisplay;ThirdPartDisplay;ForecastDisplay;</p></li></ul><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><h3 id="5-3-1-抽象主题编写"><a href="#5-3-1-抽象主题编写" class="headerlink" title="5.3.1 抽象主题编写"></a>5.3.1 抽象主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//添加观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//移除观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//广播</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-抽象观察者编写"><a href="#5-3-2-抽象观察者编写" class="headerlink" title="5.3.2 抽象观察者编写"></a>5.3.2 抽象观察者编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span>;<span class="hljs-comment">//广播更新的数据(推模型)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//观察者申请数据更新(拉模型)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-具体主题编写"><a href="#5-3-3-具体主题编写" class="headerlink" title="5.3.3 具体主题编写"></a>5.3.3 具体主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherData</span>:<span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Data<br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> temperature;<span class="hljs-comment">//温度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> humidity;<span class="hljs-comment">//湿度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> pressure;<span class="hljs-comment">//气压</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> Data data;<br>    List&lt;Observer&gt; listeners;<span class="hljs-comment">//订阅的观察者名单</span><br>    <span class="hljs-keyword">public</span> Data Datas &#123; <span class="hljs-keyword">get</span> =&gt; data;&#125;<span class="hljs-comment">//用于实现拉模式的get属性</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherData</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123; <br>        listeners = <span class="hljs-keyword">new</span> List&lt;Observer&gt;();<br>        measurementsChanged();<br>        data = <span class="hljs-keyword">new</span> Data();<br>    &#125;<br>    <span class="hljs-comment">//对Subject接口的实现</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Add(a);<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Remove(a);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Observer i <span class="hljs-keyword">in</span> listeners)<br>        &#123;<br>            i.update(data);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//更新天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        getRandomDate();<br>        notifyObserver();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getRandomDate</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//随机产生天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        data.humidity = random.NextDouble();<br>      data.temperature=random.Next(<span class="hljs-number">-40</span>,<span class="hljs-number">40</span>)+random.NextDouble();<br>        data.pressure = random.Next(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)+random.NextDouble();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-4-具体观察者编写"><a href="#5-3-4-具体观察者编写" class="headerlink" title="5.3.4 具体观察者编写"></a>5.3.4 具体观察者编写</h3><p>显示模式的接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">DisplayElement</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>三种显示模式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentConditionsDisplay</span>:<span class="hljs-title">Observer</span>,<span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示当前观测值</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    <span class="hljs-keyword">private</span> Data d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CurrentConditionsDisplay</span>(<span class="hljs-params">Subject x</span>) </span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = x; <br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;---当前天气---&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;当前温度:&quot;</span> + d.temperature.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前气压:&quot;</span> <br>        + d.pressure.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前湿度:&quot;</span>+d.humidity.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StatisticsDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示统计最大最小平均值</span><br>&#123;<br>    Subject weatherData;<br>    <span class="hljs-keyword">private</span> Queue&lt;Data&gt; dates;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StatisticsDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>        dates = <span class="hljs-keyword">new</span> Queue&lt;Data&gt;();<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span>(dates.Count== <span class="hljs-number">3</span>)dates.Dequeue();<br>        dates.Enqueue(x);<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>=&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Double[] average = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">foreach</span> (Data i <span class="hljs-keyword">in</span> dates)<br>        &#123;<br>            average[<span class="hljs-number">0</span>] += i.temperature;<br>            average[<span class="hljs-number">1</span>] += i.pressure;<br>            average[<span class="hljs-number">2</span>] += i.humidity;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;***天气统计***&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;最高温度:&quot;</span> + dates.Max(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低温度:&quot;</span> + dates.Min(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均温度:&quot;</span> +<br>        (average[<span class="hljs-number">0</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高气压:&quot;</span> + dates.Max(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <br>        <span class="hljs-string">&quot;\t最低气压:&quot;</span> + dates.Min(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均气压:&quot;</span> +<br>        (average[<span class="hljs-number">1</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高湿度:&quot;</span> + dates.Max(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低湿度:&quot;</span> + dates.Min(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均湿度:&quot;</span> +<br>        (average[<span class="hljs-number">2</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ForecastDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示天气预报</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    Data d;<br>    String weather;<br>    <span class="hljs-built_in">double</span> t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForecastDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data data</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = data;<br>        <span class="hljs-keyword">if</span> (d.humidity &gt; <span class="hljs-number">0.5</span> &amp;&amp; d.pressure &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(d.temperature&lt;<span class="hljs-number">1</span>) weather = <span class="hljs-string">&quot;雪&quot;</span>;<br>                <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;雨&quot;</span>;<br>            &#125;<br>        <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;晴&quot;</span>;<br>        t = d.temperature;<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;===天气预报===&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;今日天气:&quot;</span> + weather + <span class="hljs-string">&quot;\t 温度:&quot;</span> + t.ToString(<span class="hljs-string">&quot;F2&quot;</span>)+<span class="hljs-string">&quot;\n&quot;</span>); ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-5-测试"><a href="#5-3-5-测试" class="headerlink" title="5.3.5 测试"></a>5.3.5 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    WeatherData weatherData = <span class="hljs-keyword">new</span> WeatherData();<br>    CurrentConditionsDisplay s1 = <span class="hljs-keyword">new</span> CurrentConditionsDisplay(weatherData);<br>    StatisticsDisplay s2 = <span class="hljs-keyword">new</span> StatisticsDisplay(weatherData);<br>    ForecastDisplay s3 = <span class="hljs-keyword">new</span> ForecastDisplay(weatherData);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>    &#123;<br>        weatherData.measurementsChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210325114238949.png" srcset="/img/loading.gif" alt="测试结果"></p><h1 id="6-java中的观察者模式类"><a href="#6-java中的观察者模式类" class="headerlink" title="6. java中的观察者模式类"></a>6. java中的观察者模式类</h1><blockquote><p>略 <a href="https://www.jianshu.com/p/fc4554cda68d">https://www.jianshu.com/p/fc4554cda68d</a></p></blockquote><h1 id="8-C-中实现观察者模式的方法"><a href="#8-C-中实现观察者模式的方法" class="headerlink" title="8. C#中实现观察者模式的方法"></a>8. C#中实现观察者模式的方法</h1><p>整理自：<a href="https://www.jb51.net/article/63077.htm">https://www.jb51.net/article/63077.htm</a></p><h2 id="8-1-利用事件"><a href="#8-1-利用事件" class="headerlink" title="8.1 利用事件"></a>8.1 利用事件</h2><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a></p></blockquote><p>我们将上面讲的天气数据监测应用改成用C#事件实现的观察者模式</p><ol><li><p>在WeatherData类中声明委托与事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WeatherdateUpdate</span>(<span class="hljs-params">Data data</span>)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> WeatherdateUpdate updata;<br></code></pre></td></tr></table></figure></li><li><p>在WeatherData类中编写事件触发函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyByEvent</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span>(updata!=<span class="hljs-literal">null</span>)<br>            &#123;<br>                updata(data);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>在三个具体观察者中编写事件处理函数并在构造函数中订阅到事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//写在构造函数里</span><br>WeatherData.updata += update;<span class="hljs-comment">//事件订阅</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)<span class="hljs-comment">//事件处理</span></span><br><span class="hljs-function"></span>        &#123;<br>            d = x; <br>            display();<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>触发事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            getRandomDate();<br>            <span class="hljs-comment">//notifyObserver();</span><br>            notifyByEvent();<br>        &#125;<br></code></pre></td></tr></table></figure><p>运行输出结果与用接口实现的效果完全相同。</p></li></ol><h2 id="8-2-利用IObservable和IObserver实现"><a href="#8-2-利用IObservable和IObserver实现" class="headerlink" title="8.2 利用IObservable和IObserver实现"></a>8.2 利用IObservable<out T>和IObserver<in T>实现</h2><p>与java中类似，略</p><h2 id="8-3-利用Action函数式"><a href="#8-3-利用Action函数式" class="headerlink" title="8.3 利用Action函数式"></a>8.3 利用Action函数式</h2><p>略</p><h1 id="7-优缺点"><a href="#7-优缺点" class="headerlink" title="7. 优缺点"></a>7. 优缺点</h1><h2 id="7-1-优点"><a href="#7-1-优点" class="headerlink" title="7.1 优点"></a>7.1 优点</h2><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</li><li>目标与观察者之间建立了一套触发机制。</li></ul><h2 id="7-2-缺点"><a href="#7-2-缺点" class="headerlink" title="7.2 缺点"></a>7.2 缺点</h2><ul><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>观察者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>策略模式属于对象的行为模式。<br>其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。<br>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><ul><li><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>找出项目中不稳定的代码（可能需要改动的地方），把它们独立出来，不要把它们和其它稳定的代码混在一起</li><li>针对接口编程而不是针对实现编程</li><li>多用组合少用继承</li></ul></li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p>策略模式是对算法的包装，是把调用算法的责任（行为）和算法本身（行为实现）分割开来，委派给不同的对象管理。</p><p>策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。下面就以一个示意性的实现讲解策略模式实例的结构。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-b97fa59581b3c88c.png" srcset="/img/loading.gif" alt="img"></p><p>这个模式涉及到三个角色：</p><ul><li>环境(Context)角色：<br>持有一个Strategy的引用，即具有复杂多变行为的对象。</li><li>抽象策略(Strategy)角色：<br>这是一个抽象角色，通常由一个接口或抽象类实现。<br>此角色给出所有的具体策略类所需的接口。</li><li>具体策略(ConcreteStrategy)角色：<br>包装了相关的算法或行为。</li></ul><h1 id="4-模式案例"><a href="#4-模式案例" class="headerlink" title="4. 模式案例"></a>4. 模式案例</h1><h2 id="4-1-案例描述"><a href="#4-1-案例描述" class="headerlink" title="4.1 案例描述"></a>4.1 案例描述</h2><p>你将设计一个ARPG文字冒险小游戏，你需要设计以下内容：</p><ul><li>四个角色：<br>女王Queen；国王King；骑士Knight；巨魔Troll；</li><li>四种武器：<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；</li></ul><p>每个角色一次只能使用一种武器，但是在游戏的过程中可以切换武器。</p><p>让他们相互攻击，直到有人胜出。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/423180E36C6DA4925016AA187CA09C05-1616508222683.jpg" srcset="/img/loading.gif" alt="423180E36C6DA4925016AA187CA09C05"></p><p>由上图可以看出类的结构为<br>女王Queen；国王King；骑士Knight；巨魔Troll；继承于Character。<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；实现了WeaponBehavior接口。</p><p>由此可以分析出在策略模式中他们的角色：</p><ul><li>环境(Context)角色：Character</li><li>抽象策略(Strategy)角色：WeaponBehavior</li><li>具体策略(ConcreteStrategy)角色：<br>KnifeBehavior，BowAndArrowBehavior，AxeBehavior，SwordBehavior</li></ul><h2 id="4-3-代码编写"><a href="#4-3-代码编写" class="headerlink" title="4.3 代码编写"></a>4.3 代码编写</h2><h3 id="4-3-1-环境角色编写"><a href="#4-3-1-环境角色编写" class="headerlink" title="4.3.1 环境角色编写"></a>4.3.1 环境角色编写</h3><p>编写所有角色的基类Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> hp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> energy;<br>    WeaponBehavior weapon;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span> =&gt; name; <span class="hljs-keyword">set</span> =&gt; name = <span class="hljs-keyword">value</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Hp &#123; <span class="hljs-keyword">get</span> =&gt; hp; <span class="hljs-keyword">set</span> =&gt; hp = <span class="hljs-keyword">value</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Energy &#123; <span class="hljs-keyword">get</span> =&gt; energy; <span class="hljs-keyword">set</span> =&gt; energy = <span class="hljs-keyword">value</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name,<span class="hljs-built_in">int</span> hp,<span class="hljs-built_in">int</span> energy</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.hp = hp;<br>        <span class="hljs-keyword">this</span>.energy = energy;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeapon</span>(<span class="hljs-params">WeaponBehavior weapon</span>)<span class="hljs-comment">//设置武器</span></span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.weapon = weapon;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">fight</span>(<span class="hljs-params">Character A</span>)<span class="hljs-comment">//攻击！</span></span><br><span class="hljs-function"></span>    &#123;<br>        weapon.useWeapon(<span class="hljs-keyword">this</span>,A);<br>        <span class="hljs-keyword">if</span> (A.Hp &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            Console.WriteLine(A.Name + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;杀死了&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showState</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//显示状态</span></span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(Name+<span class="hljs-string">&quot;:血量 &quot;</span>+ hp+<span class="hljs-string">&quot;精力 &quot;</span>+energy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写四种角色类继承Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Queen</span>:<span class="hljs-title">Character</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Queen</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">10</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> KnifeBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">King</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">King</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">5</span>, <span class="hljs-number">20</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Knight</span> : <span class="hljs-title">Character</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Knight</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">20</span>, <span class="hljs-number">10</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Troll</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Troll</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">15</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> AexBehavior());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-抽象策略角色编写"><a href="#4-3-2-抽象策略角色编写" class="headerlink" title="4.3.2 抽象策略角色编写"></a>4.3.2 抽象策略角色编写</h3><p>编写武器行为接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A,Character B</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-具体策略角色编写"><a href="#4-3-3-具体策略角色编写" class="headerlink" title="4.3.3 具体策略角色编写"></a>4.3.3 具体策略角色编写</h3><p>编写具体的武器行为，实现接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">KnifeBehavior</span>:<span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name+<span class="hljs-string">&quot;对&quot;</span>+B.Name+<span class="hljs-string">&quot;使用了 匕首 刺杀&quot;</span>);<br>        B.Hp--;<br>        A.Energy --;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BowandArrowBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;射了一箭&quot;</span>);<br>        B.Hp--;<br>        A.Energy--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AexBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 斧头 劈砍&quot;</span>);<br>        B.Hp-=<span class="hljs-number">3</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy-=<span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SwordBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 直剑 挥击&quot;</span>);<br>        B.Hp -= <span class="hljs-number">5</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy -= <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-测试"><a href="#4-3-4-测试" class="headerlink" title="4.3.4 测试"></a>4.3.4 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();<br>    List&lt;Character&gt; c = <span class="hljs-keyword">new</span> List&lt;Character&gt;(<span class="hljs-number">4</span>);<span class="hljs-comment">//将各种角色类都装箱成Character</span><br>    c.Add(<span class="hljs-keyword">new</span> King(<span class="hljs-string">&quot;大清皇帝&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Troll(<span class="hljs-string">&quot;林登万&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Knight(<span class="hljs-string">&quot;堂吉诃德&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Queen(<span class="hljs-string">&quot;玛丽&quot;</span>));<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (c.Count != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">int</span> a, b;<br>        a = random.Next(<span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">//随机选取两人PK，直到剩下最后一位角色活着</span><br>        <span class="hljs-keyword">while</span> ((b = random.Next(<span class="hljs-number">0</span>, i)) == a)<br>        &#123;<br>            b = random.Next(<span class="hljs-number">0</span>, i);<br>        &#125;<br>        c[a].showState();<br>        c[b].showState();<br>        <span class="hljs-keyword">if</span> (c[a].fight(c[b]))<br>        &#123;<br>            c.RemoveAt(b);<br>            i--;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//每回合恢复体力</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;c.Count;j++)<br>        &#123;<br>            c[j].Energy++;<br>        &#125;<br>    &#125;<br>    Console.WriteLine(<span class="hljs-string">&quot;胜者是:&quot;</span> + c[<span class="hljs-number">0</span>].Name + <span class="hljs-string">&quot;!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这次中世纪文字吃鸡的结果是：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95.png" srcset="/img/loading.gif" alt="策略模式测试"></p><h1 id="5-对策略模式的深入认识"><a href="#5-对策略模式的深入认识" class="headerlink" title="5.对策略模式的深入认识"></a>5.对策略模式的深入认识</h1><h2 id="5-1-策略模式对多态的使用"><a href="#5-1-策略模式对多态的使用" class="headerlink" title="5.1 策略模式对多态的使用"></a>5.1 策略模式对多态的使用</h2><p> 　通过让环境类持有一个抽象策略类（超类）的引用，在生成环境类实例对象时，让该引用指向具体的策略子类。再对应的方法调用中，就会通过Java的多态，调用对应策略子类的方法。从而可以相互替换，不需要修改环境类内部的实现。同时，在有新的需求的情况下，也只需要修改策略类即可，降低与环境类之间的耦合度。</p><h2 id="5-2-策略模式的重心"><a href="#5-2-策略模式的重心" class="headerlink" title="5.2 策略模式的重心"></a>5.2 策略模式的重心</h2><p>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p><h2 id="5-3算法的平等性"><a href="#5-3算法的平等性" class="headerlink" title="5.3算法的平等性"></a>5.3算法的平等性</h2><p>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p><p>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。</p><h2 id="5-4-运行时策略的唯一性"><a href="#5-4-运行时策略的唯一性" class="headerlink" title="5.4 运行时策略的唯一性"></a>5.4 运行时策略的唯一性</h2><p>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p><h2 id="5-5-公有的行为"><a href="#5-5-公有的行为" class="headerlink" title="5.5 公有的行为"></a>5.5 公有的行为</h2><p>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p><p>这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-398483227b01f042.png" srcset="/img/loading.gif" alt="img"></p><h1 id="6-策略模式的优缺点"><a href="#6-策略模式的优缺点" class="headerlink" title="6. 策略模式的优缺点"></a>6. 策略模式的优缺点</h1><h2 id="6-1-相较于纯继承的优点"><a href="#6-1-相较于纯继承的优点" class="headerlink" title="6.1 相较于纯继承的优点"></a>6.1 相较于纯继承的优点</h2><ul><li><p>代码复用度高，子类中几乎没有重复</p></li><li><p>很容易知道该类的全部策略（算法）</p></li><li><p>在运行时可以更容易的更改策略</p></li><li><p>改动时不会牵一发而动全身，代码耦合度低</p></li></ul><h2 id="6-2-策略模式的优点"><a href="#6-2-策略模式的优点" class="headerlink" title="6.2 策略模式的优点"></a>6.2 策略模式的优点</h2><ul><li>策略模式提供了管理相关的算法族的办法。<br>策略类的等级结构定义了一个算法或行为族。<br>恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。<br>多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li></ul><h2 id="6-3策略模式的缺点"><a href="#6-3策略模式的缺点" class="headerlink" title="6.3策略模式的缺点"></a>6.3策略模式的缺点</h2><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<br>这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p></li><li><p>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p></li></ul><p>总结自：</p><ul><li>《设计模式HeadFirst》</li><li><a href="https://www.jianshu.com/p/7fa8ad000a97">https://www.jianshu.com/p/7fa8ad000a97</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>设计模式</tag>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的标签 层级 静态物体 预制体</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-标签"><a href="#1-标签" class="headerlink" title="1. 标签"></a>1. 标签</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>标签(Tag)是一个可以标记在游戏物体上的记号，它一般是一个简单的单词。<br>比如：你可以为游戏人物添加一个Player标签，并为敌人角色添加一个Encemy 标签，还可以为地图上的道具添加一个Collectable标签。</p><p>在脚本中查找和指定物体时，使用标签是一种非常好的方法。<br>这种方法可以避免总是采用某个公开变量的方式来指定游戏物体，那样还需要通过拖曳的操作才能给变量赋初值。通过标签来查找物体可以简化编辑工作。</p><p>标签还特别适合用在处理碰撞的时候，当游戏人物与其他物体发生碰撞时，你可以通过判断碰到的物体是敌人、道具还是其他东西，来进行下一步处理。</p><h2 id="1-2-Unity预制标签"><a href="#1-2-Unity预制标签" class="headerlink" title="1.2. Unity预制标签"></a>1.2. Unity预制标签</h2><p>Uniy预置了一些常用的标签， 在标签管理器中你不能修改下面这些预置的标签：</p><table><thead><tr><th>标签名</th><th>含义</th></tr></thead><tbody><tr><td>Untagged</td><td>没有标签</td></tr><tr><td>Respawn</td><td>出生</td></tr><tr><td>Finish</td><td>完成</td></tr><tr><td>EditorOnly</td><td>编辑器专用</td></tr><tr><td>MainCamera</td><td>主摄像机</td></tr><tr><td>Player</td><td>玩家</td></tr><tr><td>GameController</td><td>游戏控制器</td></tr></tbody></table><h2 id="1-3-创建新标签"><a href="#1-3-创建新标签" class="headerlink" title="1.3. 创建新标签"></a>1.3. 创建新标签</h2><p>要创建一个新的标签，需要在标签下拉菜单中选择Add Tag,之后检视窗口会切换到标签与层级管理器(Tag and Layer Manager)。</p><blockquote><p>注意:标签一旦创建就不可以再被修改，只能删除并重新创建。</p></blockquote><h2 id="1-4-为物体设置标签"><a href="#1-4-为物体设置标签" class="headerlink" title="1.4. 为物体设置标签"></a>1.4. 为物体设置标签</h2><p>检视窗口的上方显示了标签(Tg)和层级(Layer) 的下拉菜单。</p><p>在标装的下技菜单中单击任意.个标签名称，就可以为物体指定该标签了</p><h2 id="1-5-使用标签查找游戏物体"><a href="#1-5-使用标签查找游戏物体" class="headerlink" title="1.5. 使用标签查找游戏物体"></a>1.5. 使用标签查找游戏物体</h2><blockquote><p>略，详见<a href="https://mycroftcooper.github.io/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/">在脚本中访问其他物体2.3</a></p></blockquote><h2 id="1-6-小提示"><a href="#1-6-小提示" class="headerlink" title="1.6. 小提示"></a>1.6. 小提示</h2><ul><li>一个游戏物体只能被指定一个标签</li><li>可以用任意一个单词作为标签的名称<br>甚至可以用一个很长的词组作为名称<br>但是那样非会不太方便，比如在界面中看不到完整的名字</li></ul><h1 id="2-层级"><a href="#2-层级" class="headerlink" title="2. 层级"></a>2. 层级</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>层级最有用、最常用的地方有：</p><ul><li>用来让摄像机仅渲染场景中的一部分物体</li><li>还可以让灯光只照亮一部分物体。</li><li>用来在进行碰撞检测、射线检测时，从而只让某些物体发生碰撞，让另一些物体不发生碰撞。</li></ul><h2 id="2-2-新建层级"><a href="#2-2-新建层级" class="headerlink" title="2.2 新建层级"></a>2.2 新建层级</h2><p>单击主菜单的Edit &gt; Project Settings &gt; Tagsand Layers选项，会在检视窗口中打开层级和标签窗口。<br>这步操作和之前介绍标签时的操作完全一样， 不同的是，在学习标签时我们展开了标签菜单，这里我们要展开层级菜单。<br>将新的层级User Layer8命名为Player,就建立了一个新的Player层级，序号为8.</p><h2 id="2-3-只渲染场景的一部分"><a href="#2-3-只渲染场景的一部分" class="headerlink" title="2.3 只渲染场景的一部分"></a>2.3 只渲染场景的一部分</h2><p>层级配合摄像机的剔除遮眾Culling Mas)使用，就可以有选择性地显示某些层级的物体，而不渲染另一些层级的物体。</p><p>要做到这一点， 只需要在摄像机中选中需要渲染的层级即可。<br>单击摄像机的剔除遮罩下拉菜单，打钩的层就是要显示的层。</p><blockquote><p>注意: Unity 中有很多类似这样的下拉菜单，菜单的最上面两项是特殊的：<br>单击Noting时，所有选项都会被取消勾选，表示全部不选<br>单击Everyhing 时，则所有选项都会被勾选。<br>使用这两个快捷选项有助于快速选中必要的层。<br>比如说，要仅选中Ul层和Player层，就可以先选择Nothing,然后再单独勾选UI层和Player层即可.</p></blockquote><blockquote><p>UI系统如果采用屏幕空间画布，则不会受摄像机别除遮罩的影响。</p></blockquote><h2 id="2-5-选择性的射线检测"><a href="#2-5-选择性的射线检测" class="headerlink" title="2.5 选择性的射线检测"></a>2.5 选择性的射线检测</h2><p>使用层级可以让射线检测忽略某些碰撞体，这种效果也是用“层级”和“遮罩”这两个概念来设置的。</p><p>例如，有时需要发射条射线， 仅和Player 层的物体发生碰撞， 而忽略其他层的物体。<br>Physics.Racast方法用来发射一条射线， 它可以带有一个叫作layerMask 的参数，layerMask是一个利用位标记作为遮罩的参数。</p><blockquote><p>用位(bit)作为标记是二进制相关的一种方法<br>原理是int型的变量由32个位组成，每个位的值只能是0或1<br>因此可以根据某个位是0还是1来选中或者忽略某一层</p></blockquote><ul><li>如果layerMask所有的位都是1,那么就会和所有的层发生碰撞。</li><li>如果layerMask等于0，那么它就不会和任何层、任何物体发生碰撞。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//将1左移8位</span><br><span class="hljs-built_in">int</span> layerMask =<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br><span class="hljs-comment">//将layerMask设置为只有从右数第8位是1,其他位是0，则只会和Layer 8 Player层发生碰撞</span><br><span class="hljs-keyword">if</span> (Physics .Raycast (transform.position, Vector3. forward, Mathf. Infinity, layerMask))<br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;The ray hit the player&quot;</span>) ;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是玩家的游戏人物射击发出的检测射线，就恰恰相反，需要和除玩家的游戏人物以外的所有物体发生碰撞，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//将1左移8位</span><br>    <span class="hljs-built_in">int</span> layerMask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">//按位取反，所有值为0的位变为1,值为1的位变为0</span><br>    layerMask = ~ layerMask;<br>    RaycastHit hit;<br>    <span class="hljs-comment">//发射射线，Debug. DrawRay用于画出辅助框线</span><br>    <span class="hljs-keyword">if</span> (Physics.Raycast(transform.position,traform.TransformDirection(Vector3.forward),<br>                        <span class="hljs-keyword">out</span> hit, Mathf.Infinity,layerMask))<br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<br>                      hit.distance,Color.yellow);<br>        Debug. Log(<span class="hljs-string">&quot;Did Hit&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<span class="hljs-number">1000</span><br>                      Color.white) ;<br>        Debug.Log(<span class="hljs-string">&quot;Did not Hit&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在调用Raycast方法时省略layerMask参数，则默认除了Ignore Raycast这层不会被碰撞，其他层都可能发生碰撞。</p><p>使用lgnore Raycast层可以专门指定某些物体不受射线检测碰撞。</p><blockquote><p>序号为31的最后一层是特别的，编辑器把它作为预览使用，开发者不要使用这一层，会造成冲突</p></blockquote><h1 id="3-静态物体"><a href="#3-静态物体" class="headerlink" title="3. 静态物体"></a>3. 静态物体</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>如果引擎事先知道了某一个物体在游戏进行中是否会移动，那么就可以针对性地应用一系列优化策略。</p><p>如果一个物体是静态的，即不会移动的，那么引擎就可以假定它不会受到任何其他物体或者事件的影响，从而预先计算好物体的信息。<br>比如说，渲染器可以将场景中许多静态物体台并为一个整体，这样就可以通过一次渲染就将它们全部处理完毕，这种做法也被称为批量渲染。</p><p>在检视窗口中，每个游戏物体名称的右侧都有一一个静态(Static) 复选框以及一个菜单，它用来指定物体是否是静态的，且可以进一步指定物体 在某些子系统中是否是静态的，还可以独立地设置游戏物体在每个子系统中是否是静态的，这样就可以对物体进行非常细致的优化。</p><p>下图是静态标记菜单，可以有针对性地设置物体在每个子系统中是否是静态的。</p><h2 id="3-2-子系统的静态特性内容"><a href="#3-2-子系统的静态特性内容" class="headerlink" title="3.2 子系统的静态特性内容"></a>3.2 子系统的静态特性内容</h2><p>静态菜单中的Everyhing和Nothing选项分别用于同时启用或禁用物体在所有子系统中的静态特性以便优化。</p><p>这些子系统包含如下内容：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Lightmap Static</td><td>场景中的高级光照特性</td></tr><tr><td>Occluder Static</td><td>根据物体在特定摄像机下的可见性，进行渲染优化</td></tr><tr><td>Batching Static</td><td>将多个物体合并为一个整体进行渲染</td></tr><tr><td>Navigation Static</td><td>在寻路系统中，将此物体作为静态的障碍物</td></tr><tr><td>Off Mesh Link Generation</td><td>寻路系统中的网格链接</td></tr><tr><td>Reflection Probe Static</td><td>反射探针优化</td></tr></tbody></table><p>某些子系统与内部渲染方式有较大关联，可以在相关文档中阅读它们的细节。</p><h1 id="4-预制体"><a href="#4-预制体" class="headerlink" title="4.预制体"></a>4.预制体</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>在场景中创建物体、添加组件并设置合适参数的操作一开始会令人觉得方便， 但是当场影的用到大量同样的NPC、障碍物或机关时，创建以及设置属性的操作就会带来巨大的麻烦。<br>复制这些物体看似可以解决问题，但是由于这些物体都是独立的，所以还是需要一个一个单独体改它们。</p><p>所以，Unity 提供了预制体这个概念。<br>它允许事先保存一个游戏物体，包括该物体上挂载的组件与设置的参数。<br>这样预制体就可以成为模板，可以用这个模板在场景中创建物体。</p><p>预制体具有以下两个优点</p><ul><li><p>对预制体文件的任何修改可以立即影响所有相关联的物体</p></li><li><p>每个物体还可以重载(override)一些些组件和参数， 以实现与模板有所区别的设置</p></li></ul><blockquote><p>注意:<br>当你拖曳一个资源文件(比如一个模型)到场景中时，Unity 会自动创建一个新的游戏物体，原始资源的修改也会影响到这些相关的游戏物体。<br>这种物体看起来像是预制体，但是和预制体是完全不同的，所以不适用下面介绍的预制体的特性。<br>这种“引用关系”仅仅是与预制体有相似之处。</p></blockquote><h2 id="4-2-使用预制体"><a href="#4-2-使用预制体" class="headerlink" title="4.2 使用预制体"></a>4.2 使用预制体</h2><p>创建预制体有两种常用方法: </p><ul><li>方法一:<br>在工程窗口中的某个文件夹内单击右键，选择Create&gt; Prefab创建一个空白预制体，然后将场景中制作好的某个游戏物体拖曳到空白预制体上。</li><li>方法二:<br>直接将某个游戏物体从场景拖曳到文件夹中。<br>在创建好预制体以后，将另一个游戏物体拖曳到预制体文件上，系统会提示是否替换预制体。</li></ul><blockquote><p>预制体是一个后缀为 .prefab的资源文件。<br>在层级视图中，所有与预制体关联的游戏物体的名称，都会以蓝色显示(普通物体的名称是以黑色显示的)</p></blockquote><blockquote><p>编辑器会用粗体字来显示游戏物体中与预制体不一样的独特属性</p></blockquote><h2 id="4-3-通过游戏物体实例修改预制体"><a href="#4-3-通过游戏物体实例修改预制体" class="headerlink" title="4.3 通过游戏物体实例修改预制体"></a>4.3 通过游戏物体实例修改预制体</h2><p>与预制体关联的游戏物体，会在检视窗口的上方多出三个按钮:</p><ul><li><p>选择( Select)<br>选中与物体相关联的那个预制体，单击后，在工程窗口中会高亮显示该预制体。<br>这有助于迅速找到相关的预制体。</p></li><li><p>回滚(Revert)<br>将游戏物体修改过的组件和属性恢复到和预制体一致。<br>这个功能用于试验性地修改某些参数以后，将物体恢复到原始状态。</p></li><li><p>应用(Apply)<br>将本物体上修改的那些组件和参数写回到原始的预制体中(但是变换组件的位置信息不会写回预制体)。<br>这有助于通过任何一个物体修改预制体，有时会非常方便，特别是在某些预制体只有一个实例的时候。</p></li></ul><h2 id="４-4-预制体实例化"><a href="#４-4-预制体实例化" class="headerlink" title="４.4 预制体实例化"></a>４.4 预制体实例化</h2><p>使用<strong>Instantiate函数</strong></p><p>Instantiate函数实例化是将传入对象的所有子物体和子组件完全复制，成为一个新的对象。<br>这个新的对象拥有与源对象完全一样的东西，包括坐标值等。</p><h3 id="4-4-1-参数"><a href="#4-4-1-参数" class="headerlink" title="4.4.1 参数"></a>4.4.1 参数</h3><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>original</td><td>用来做复制操作的对像物体，源对象</td></tr><tr><td>position</td><td>实例化的对象的位置坐标</td></tr><tr><td>rotation</td><td>实例化的对象的旋转坐标（旋转四元数）</td></tr><tr><td>parent</td><td>实例化对象的父对象，在完成实例化函数处理后，实例化对象将是父对象的子对象</td></tr><tr><td>instantiateWorldSpace</td><td>为TRUE，表示实例化对象相对于世界坐标系的位置（是位置，不是坐标值，比如实例化前在Canvas左上角，实例化后还在左上角）不变，相对于父对象的坐标值变了<br />为false，表示实例化对象相对于父对象的坐标值不变，但在世界坐标系中的位置变了。</td></tr></tbody></table><p><a href="https://blog.csdn.net/qq_29413829/article/details/78934579">https://blog.csdn.net/qq_29413829/article/details/78934579</a></p><h3 id="4-4-2-重载"><a href="#4-4-2-重载" class="headerlink" title="4.4.2 重载"></a>4.4.2 重载</h3><p>![Instantiate函数](./images/Unity中的标签 层级 静态物体/20171229171822891)</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>Unity基础</tag>
      
      <tag>标签</tag>
      
      <tag>层级</tag>
      
      <tag>静态物体</tag>
      
      <tag>预制体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的事件</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity在C#Event特性的基础上进行了改良，Event只能用于纯代码编程，而UnityEvent可以和UnityEditor配合使用提高效率。</p><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a>！</p></blockquote><h1 id="2-Unity事件的改良"><a href="#2-Unity事件的改良" class="headerlink" title="2. Unity事件的改良"></a>2. Unity事件的改良</h1><p>在C#事件中我们举的例子中，可以看出.Net框架下的事件存在以下几个问题：</p><ul><li>订阅的时机受限<br>你必须在事件触发前完成事件的订阅<br>事件处理程序将收不到订阅前的事件动态</li><li>不方便管理<br>想要查看所有订阅事件的对象，我们就得查找项目中所有对事件的引用，然后再把每个对象的文件打开，可以说是非常麻烦了</li></ul><p>为了避免上述的缺点，Unity使用Serializable（序列化）让用户可以在Editor中直接绑定所有对象的调用，即一目了然又不用担心把握不准订阅的时机，这就是<strong>UnityEvent</strong>。</p><h1 id="3-UnityEvent类"><a href="#3-UnityEvent类" class="headerlink" title="3. UnityEvent类"></a>3. UnityEvent类</h1><p><strong>UnityEvent</strong> 可添加到任何 <strong>MonoBehaviour</strong>，并从标准 .net 委托之类的代码中执行。当 <strong>UnityEvent</strong>添加到 <strong>MonoBehaviour</strong>时，它会出现在 <strong>Inspector</strong> 中，并可添加持久回调。</p><h2 id="3-1-方法"><a href="#3-1-方法" class="headerlink" title="3.1 方法"></a>3.1 方法</h2><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>AddListener</td><td>将一个非持久性侦听器添加到UnityEvent</td></tr><tr><td>Invoke</td><td>调用所有已注册的回调（运行时和持久的）</td></tr><tr><td>RemoveListener</td><td>从UnityEvent中删除一个非持久性侦听器</td></tr></tbody></table><h2 id="3-2-继承的成员"><a href="#3-2-继承的成员" class="headerlink" title="3.2 继承的成员"></a>3.2 继承的成员</h2><p>普通方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetPersistentEventCount</td><td>获取已注册的持久性侦听器的数量</td></tr><tr><td>GetPersistentMethodName</td><td>获取索引为index的侦听器的目标方法名称</td></tr><tr><td>GetPersistentTarget</td><td>在索引index处获取侦听器的目标组件</td></tr><tr><td>RemoveAllListeners</td><td>从事件中删除所有侦听器</td></tr><tr><td>SetPersistentListenerState</td><td>修改持久侦听器的执行状态</td></tr></tbody></table><p>静态方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetValidMethodInfo</td><td>给定对象，函数名称和参数类型列表；找到匹配的方法</td></tr></tbody></table><h2 id="3-3-UnityEvent的使用"><a href="#3-3-UnityEvent的使用" class="headerlink" title="3.3 UnityEvent的使用"></a>3.3 UnityEvent的使用</h2><p>要在 Editor 中配置回调，需执行以下几个步骤：</p><ol><li>确保脚本导入/使用 <code>UnityEngine.Events</code>。</li><li>选择 + 图标为回调添加字段</li><li>选择要接收回调的 UnityEngine.Object（可使用对象选择器进行选择）</li><li>选择要调用的函数</li><li>可为事件添加多个回调</li></ol><p>在 <strong>Inspector</strong> 中配置 <strong>UnityEvent</strong> 时，支持两种类型的函数调用：</p><ul><li>静态。<br>静态调用是预配置的调用，具有在 UI 中设置的预配置值。<br>这意味着，在调用回调时，使用已在 UI 中输入的参数调用目标函数。</li><li>动态。<br>使用从代码发送的参数调用动态调用，并与正在调用的 UnityEvent 类型相关。<br>UI 会过滤回调，仅显示对 UnityEvent 有效的动态调用。</li></ul><h2 id="3-4-UnityEvent的多态（派生自定义事件）"><a href="#3-4-UnityEvent的多态（派生自定义事件）" class="headerlink" title="3.4 UnityEvent的多态（派生自定义事件）"></a>3.4 UnityEvent的多态（派生自定义事件）</h2><p>默认情况下，<strong>Monobehaviour</strong> 中的 UnityEvent 动态绑定到 void 函数。</p><p>但不一定非得如此，<strong>UnityEvent</strong> 的子类支持绑定到最多包含 4 个参数的函数。</p><p>为此，您可以定义一个支持多个参数的自定义 <strong>UnityEvent</strong> 类。</p><p>此定义十分简单：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringEvent</span> : <span class="hljs-title">UnityEvent</span> &lt;<span class="hljs-title">string</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>订阅时订阅此派生类的实例而不是基类 <strong>UnityEvent</strong>，即可回调时传递各种参数。</p><p>然后，可通过调用**Invoke()**函数来对其进行调用。</p><blockquote><p>UnityEvent 可在其通用定义中定义最多 4 个参数。</p></blockquote><h2 id="3-5-使用案例："><a href="#3-5-使用案例：" class="headerlink" title="3.5 使用案例："></a>3.5 使用案例：</h2><p>将C#事件中的用例代码改写成Unity引擎内继承于<strong>UnityEvent</strong>的脚本：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Events;<br><br><span class="hljs-comment">//使用Serializable序列化IdolEvent, 否则无法在Editor中显示</span><br>[<span class="hljs-meta">System.Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IdolEvent</span> : <span class="hljs-title">UnityEvent</span>&lt;<span class="hljs-title">string</span>&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">//public delegate void IdolBehaviour(string behaviour);</span><br>    <span class="hljs-comment">//public event IdolBehaviour IdolDoSomethingHandler;</span><br>    <span class="hljs-keyword">public</span> IdolEvent idolEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (idolEvent == <span class="hljs-literal">null</span>)<br>        &#123;<br>            idolEvent = <span class="hljs-keyword">new</span> IdolEvent();<br>        &#125;<br>        idolEvent.Invoke(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将三个脚本绑定在三个GameObject上，此时两个粉丝还未实现订阅。和Event不同，UnityEvent在序列化后可以在Editor上显示，并且可以在Editor上设置好需要执行的函数</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315164014120.png" srcset="/img/loading.gif" alt="image-20210315164014120"></p><p>运行</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315160434052.png" srcset="/img/loading.gif" alt="image-20210315160434052"></p><p>除此之外，UnityEvent依然提供和C# Event 类似的运行时绑定的功能，不过不同的是，UnityEvent是一个对象，向其绑定函数是通过AddListener()方法实现的。以SubscriberB为例，我们可以在代码中实现同等效果的绑定：</p><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">public</span> Idol myIdol;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        myIdol.idolEvent.AddListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        myIdol.idolEvent.RemoveListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于UnityEvent是一个对象，所以自然可以允许我们通过继承实现自己的Event，实际上Unity中包括Button在内的许多UI组件的点击事件都是通过继承自UnityEvent来复写的。<br>可访问性(public/private)决定了UnityEvent的默认值，当可访问性为public时，默认会为其分配空间(new UnityEvent())；当可访问性为private时，默认UnityEvent为null，需要在Start()中为其分配内存。</p></blockquote><h1 id="4-EventSystem"><a href="#4-EventSystem" class="headerlink" title="4. EventSystem"></a>4. EventSystem</h1><p>EventSystem在Unity中是一个看起来像是专门服务于UGUI系统的组件。<br>每当在场景里创建UGUI对象时，Unity编辑器都会自动产生一个EventSystem对象放在场景中，与之相对应的也有一个Canvas对象，这两个对象就组成了UGUI系统的基础。<br>所有开发人员能看到和能用到的UGUI功能都依附于这两个对象。</p><h2 id="4-1-UGUI中的EventSystem"><a href="#4-1-UGUI中的EventSystem" class="headerlink" title="4.1 UGUI中的EventSystem"></a>4.1 UGUI中的EventSystem</h2><p>使用<strong>UGUI</strong>制作游戏界面时，<strong>EventSystem</strong>的作用就像是一个专为<strong>UGUI</strong>设计好的消息中心，它管理着所有能参与消息处理的<strong>UGUI</strong>组件，包括但不仅限于<strong>Panel</strong>，<strong>Image</strong>，<strong>Button</strong>等。</p><p>如果在<strong>Unity</strong>创建好<strong>EventSystem</strong>之后观察该对象上附带的组件可以看到，至少有两个组件会被自动添加</p><ul><li><p><strong>EventSystem组件</strong>，也就是消息机制的核心；</p></li><li><p><strong>StandaloneInputModule组件</strong>，这个是负责产生输入的组件。<br>StandaloneInputModule本身是个继承自BaseInputModule的实现类，而类似的实现类Unity中还有另外几个，甚至用户也能自定义一个实现类用于事件处理。</p></li></ul><p>看起来这个系统似乎缺少一个部分，就是怎么确定某个事件是发给谁的。<br>因此为了确定操作对象究竟是哪个，一个必不可少的步骤就是检测。</p><p>在GUI之外的游戏场景编辑中，要感知当前鼠标对准的物体是哪个，最常用的方法就是射线检测了：<br>从摄像机对着鼠标指向的方向发出射线，通过碰撞来检测目标。</p><p>这个方案简单实用，可以说在游戏中随处可见，而UGUI所使用的机制也就是这一套射线检测，只不过射线的发射和碰撞处理都被隐藏在了组件之中。</p><p>所以，缺失的部分就是射线检测模块，这个模块不在EventSystem上，而是在Canvas上挂着。<br>这很好理解，Canvas是所有UGUI组件的根对象，所以由他来负责射线处理是相当正常的解决方案，至于射线到底碰到了谁，UGUI组件自然有射线接收反馈来确定。</p><p>Canvas上挂载的组件叫做GraphicRaycaster，它实际上是BaseRaycaster的实现类，专门负责Canvas之下的图形对象的射线检测与计算问题。</p><p>至此，UGUI中的情况就比较清晰了：</p><ul><li><p><strong>EventSystem对象</strong><br>负责管理所有事件相关对象<br>该对象下挂载了EventSystem组件和StandaloneInputModule组件，前者为管理脚本，后者为输入模块</p></li><li><p><strong>Canvas对象</strong><br>下挂载了GraphicRaycaster负责处理射线相关运算<br>用户的操作都会通过射线检测来映射到UGUI组件上，InputModule将用户的操作转化为射线检测，Raycaster则找到目标对象并通知EventSystem，最后EventSystem发送事件让目标对象进行响应</p><p>如下图所示：</p><img src="/images/Unity中的事件/UGUI结构.png" srcset="/img/loading.gif" alt="UGUI结构"  /></li></ul><h3 id="4-1-1-事件响应"><a href="#4-1-1-事件响应" class="headerlink" title="4.1.1 事件响应"></a>4.1.1 事件响应</h3><p>UGUI的事件响应处理有多种方式，这里我们介绍两种常用方法</p><h4 id="4-1-1-1-实现特定接口处理事件响应"><a href="#4-1-1-1-实现特定接口处理事件响应" class="headerlink" title="4.1.1.1 实现特定接口处理事件响应"></a>4.1.1.1 实现特定接口处理事件响应</h4><p>由于Canvas挂载了GraphicRaycaster组件，因此在Canvas对象之下的所有GUI对象都可以通过挂载脚本并且实现一些和事件相关的接口来处理事件，比如常见的IPointerClickHandler接口就是用于处理点击事件的接口。</p><p>可以实现的接口列表大概如下所示：</p><table><thead><tr><th>接口名</th><th>作用</th></tr></thead><tbody><tr><td>IPointerEnterHandler - OnPointerEnter</td><td>当光标进入对象时调用</td></tr><tr><td>IPointerExitHandler - OnPointerExit</td><td>当光标退出对象时调用</td></tr><tr><td>IPointerDownHandler - OnPointerDown</td><td>在对象上按下指针时调用</td></tr><tr><td>IPointerUpHandler - OnPointerUp</td><td>松开鼠标时调用（在指针正在点击的游戏对象上调用）</td></tr><tr><td>IPointerClickHandler - OnPointerClick</td><td>在同一对象上按下再松开指针时调用</td></tr><tr><td>IInitializePotentialDragHandler - OnInitializePotentialDrag</td><td>在找到拖动目标时调用，可用于初始化值</td></tr><tr><td>IBeginDragHandler - OnBeginDrag</td><td>即将开始拖动时在拖动对象上调用</td></tr><tr><td>IDragHandler - OnDrag</td><td>发生拖动时在拖动对象上调用</td></tr><tr><td>IEndDragHandler - OnEndDrag</td><td>拖动完成时在拖动对象上调用</td></tr><tr><td>IDropHandler - OnDrop</td><td>在拖动目标对象上调用</td></tr><tr><td>IScrollHandler - OnScroll</td><td>当鼠标滚轮滚动时调用</td></tr><tr><td>IUpdateSelectedHandler - OnUpdateSelected</td><td>每次勾选时在选定对象上调用</td></tr><tr><td>ISelectHandler - OnSelect</td><td>当对象成为选定对象时调用</td></tr><tr><td>IDeselectHandler - OnDeselect</td><td>取消选择选定对象时调用</td></tr><tr><td>IMoveHandler - OnMove</td><td>发生移动事件（上、下、左、右等）时调用</td></tr><tr><td>ISubmitHandler - OnSubmit</td><td>按下 Submit 按钮时调用</td></tr><tr><td>ICancelHandler - OnCancel</td><td>按下 Cancel 按钮时调用</td></tr></tbody></table><p>只要在挂载的脚本中实现所需要的接口，对应的事件回调也就可以执行了。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EventTest</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerClickHandler</span>, <span class="hljs-title">IDragHandler</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span> <br>&#123;<br>    <span class="hljs-comment">// Execute every update when dragging</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-comment">// quick down and up will perform click</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerClick</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer down</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer up</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Use this for initialization</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Update is called once per frame</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-2-利用EventTrigger组件处理事件响应"><a href="#4-1-1-2-利用EventTrigger组件处理事件响应" class="headerlink" title="4.1.1.2  利用EventTrigger组件处理事件响应"></a>4.1.1.2  利用EventTrigger组件处理事件响应</h4><p>EventTrigger组件是一个通用的事件触发器，它可以用来管理单个组件上的所有可能触发的事件。<br>其使用方法有两种：</p><ul><li><p>编辑器设定方法</p><p>指定组件上添加EventTrigger组件，然后为它添加触发事件类型，再为指定类型添加回调方法。</p></li></ul><p>这种做法的操作很简单，而且灵活性也相当高，想要跨脚本调用方法只需要鼠标拖一拖点一点就好。<br>但是这样在编辑器中设定事件回调会在项目变大时造成比较严重的管理障碍，尤其是当绑定了EventTrigger以及回调指向的物体有修改或者删除情况时，所造成的引用缺失需要花费更多的时间进行处理。</p><blockquote><p>略</p></blockquote><ul><li>动态设定方法</li></ul><p>想要更好地管理大量的事件触发和回调处理，可以尝试采用动态设置的方案。<br>所谓动态设置其实就是在代码中设置EventTrigger来处理事件回调，方法也很简单</p><blockquote><p>略</p></blockquote><h2 id="4-2-场景中的EventSystem"><a href="#4-2-场景中的EventSystem" class="headerlink" title="4.2 场景中的EventSystem"></a>4.2 场景中的EventSystem</h2><p>EventSystem也能在一般的场景中使用。<br>如果没有实现自己的事件系统而又需要一些回调处理的方案的话，可以试着直接将EventSystem应用到一般的游戏场景中。<br>要这样使用EventSystem的话，核心在于前文提到过的事件系统三大部分：</p><ul><li>EventSystem</li><li>InputModule</li><li>Raycaster。</li></ul><p>通过考察三者各自的作用可知，EventSystem和InputModule都和EventSystem对象紧密结合，而唯有Raycaster是孤零零地在Canvas对象上处理所有Canvas内部的射线检测。</p><p>那么想要借助EventSystem的能力来处理场景中的事件传递，肯定不能去动EventSystem对象，毕竟这是建立事件系统时自动创建的对象，不用说一定是要用到的。<br>那么就只剩下Raycaster了，这个组件在Canvas上挂载，用于处理射线检测，那么如果想要在场景里进行射线检测，应该把组件挂到哪里呢？</p><p>一般而言，摄像机是一个不错的选择，因为通常来说游戏大部分时候都只有一个摄像机，而且基本上可以操作的界面也只隶属于一个摄像机，因此将Raycaster挂载到游戏的主摄像机上就是个很自然的考虑了。<br>​ 而Unity编辑器提供的Raycaster一共有三种</p><ul><li>GraphicRaycaster 界面射线处理器，用于Canvas</li><li>Physics2DRaycaster 2D场景射线处理器，用于2D场景</li><li>PhysicsRaycaster 3D场景射线处理器，用于3D场景</li></ul><p>因此要用到的就是后两种了，根据当前场景的特点选择相应的Raycaster并挂载到主摄像机上即可，剩下的就和UGUI中很像了。</p><p>不过需要注意的是，在UGUI中想要让组件可以响应事件必须将组件的RaycasterTarget属性勾选上，而场景中则要在需要响应事件的对象上挂载碰撞器，满足需求的任何碰撞器都可以。<br>然后就和前文讲的一样，实现对应接口或者添加EventTrigger组件来实现各种事件回调。</p><p>使用这样的方案实现的回调，其传递的数据PointerEventData中包含的位置参数还是屏幕位置，而且跟像素相关，以屏幕左下角为原点的坐标。<br>如果希望获取触发事件时的世界坐标，则需要用到PointerEventData类中的pointerCurrentRaycast成员，该成员表示了射线检测的结果，因此其中包含碰撞点的世界坐标。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>底层机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>Unity底层机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#委托</title>
    <link href="/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/"/>
    <url>/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>委托(delegate)是一种存储函数引用的类型。<br>委托是C#的一个语言级特性，而在Java语言中没有直接的对应，但是java利用反射即可实现委托。</p><p>委托最重要的用途在事件和事件处理时才能解释清楚，但这里也将介绍有关委托的许多内容。</p><p>委托是一种数据类型，和类是同级别的，我们可以将delegate与class类比：</p><ul><li>class里存放的是一系列方法，属性，字段，事件，索引。</li><li>delegate里存放的是一系列具有相同类型参数和返回回类型的方法的地址的地址。<br>可以看作为储存方法的载体。</li></ul><p>有了引用函数的变量后，就可以执行无法用其他方式完成的操作。<br>例如，可以把委托变量作为参数传递给-一个函数，这样，该函数就可以使用委托调用它引用的任何函数，而且在运行之前不必知道调用的是哪个函数。下面的示例使用委托访问两个函数中的一个。</p><blockquote><p><a href="https://baike.baidu.com/item/c%23%E5%A7%94%E6%89%98/6916387?fr=aladdin">委托百度百科</a>上看的最明白</p></blockquote><h1 id="2-委托的声明"><a href="#2-委托的声明" class="headerlink" title="2. 委托的声明"></a>2. 委托的声明</h1><p><strong>delegate &lt;函数返回类型&gt; 委托名（函数参数）</strong>   </p><p><strong>例：</strong> <code>public delegate void myDelegate(string name);</code></p><h1 id="3-委托的实例化"><a href="#3-委托的实例化" class="headerlink" title="3. 委托的实例化"></a>3. 委托的实例化</h1><ul><li><strong>&lt;委托名&gt;实例化名= new &lt;委托名&gt;（注册函数）</strong></li></ul><p>例 : <code> myDelegate delegateinstance = new myDelegate(method);</code></p><blockquote><p>注意：注册函数不包含参数，或者可以直接将一个注册函数赋值给委托</p></blockquote><ul><li>匿名方法实例化委托</li></ul><p>​        <strong>&lt;委托类型&gt; &lt;实例化名&gt;=delegate(&lt;函数参数&gt;){函数体}</strong></p><ul><li>使用lamda表达式实例化委托</li></ul><p>实例化例子如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>   <br>&#123;     <br>    <span class="hljs-comment">//声明委托     </span><br>    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)     </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-comment">//实例化委托 </span><br>        <span class="hljs-comment">//1、使用new关键字       </span><br>        MyDelegate _myDelegate = <span class="hljs-keyword">new</span> MyDelegate(GetSum);<br>        <span class="hljs-comment">//2、使用匿名方法       </span><br>        MyDelegate myDelegate = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y)&#123;<span class="hljs-keyword">return</span> x + y;&#125;;<br>        <span class="hljs-comment">//3、使用Lambda表达式       </span><br>        MyDelegate myDelegateLambda = (<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) =&gt; &#123; <span class="hljs-keyword">return</span> x + y; &#125;;  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)     </span><br><span class="hljs-function"></span>    &#123;       <br>        <span class="hljs-keyword">return</span> x + y;     <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-多播委托"><a href="#4-多播委托" class="headerlink" title="4.多播委托"></a>4.多播委托</h1><p>实例化委托时必须将一个匹配函数注册到委托上来实例化一个委托对象，但是一个实例化委托不仅可以注册一个函数还可以注册多个函数。注册多个函数后，在执行委托的时候会根据注册函数的注册先后顺序依次执行每一个注册函数。</p><ul><li><p>多播委托实际上形成委托链 </p><p>函数注册委托的原型：</p><p>​            <strong>&lt;委托类型&gt; &lt;实例化名&gt;+=或者-=new &lt;委托类型&gt;(&lt;注册函数&gt;)</strong><br>如果在委托注册了多个函数后，如果委托有返回值，那么调用委托时，返回的将是最后一个注册函数的返回值。</p><blockquote><p>注意：委托必须先实例化以后，才能使用+=注册其他方法。如果对注册了函数的委托实例从新使用=号赋值，相当于是重新实例化了委托，之前在上面注册的函数和委托实例之间也不再产生任何关系。</p></blockquote></li></ul><blockquote><p>多播委托不支持返回值，也不支持数据引用，是单向广播</p></blockquote><h1 id="5-泛型委托"><a href="#5-泛型委托" class="headerlink" title="5.泛型委托"></a>5.泛型委托</h1><p>委托也支持泛型的使用<br>泛型委托原型：</p><ul><li><strong>delegate <T1> &lt;委托名&gt;&lt;T1,T2,T3…&gt; (T1 t1,T2 t2,T3 t3…)</strong></li></ul><h2 id="5-1-内置泛型委托"><a href="#5-1-内置泛型委托" class="headerlink" title="5.1 内置泛型委托"></a>5.1 内置泛型委托</h2><p>delegate      void   Action&lt;T1，T2，T3&gt;    泛型委托是可以达到16个参数的无返回值委托<br>delegate  Tresult Fun&lt;T1,T2,Tresult&gt;    Fun是内置泛型委托，具有返回值<br>delegate bool Predicate<T>(T obj)    内置泛型委托，返回bool值</p><h1 id="6-委托的清空"><a href="#6-委托的清空" class="headerlink" title="6. 委托的清空"></a>6. 委托的清空</h1><ol><li>在类中申明清空委托方法，依次循环去除委托引用。方法如下：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>&#123;<br>    <span class="hljs-keyword">public</span> DelegateMethod OnDelegate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearDelegate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.OnDelegate != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">this</span>.OnDelegate -= <span class="hljs-keyword">this</span>.OnDelegate;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>如果在类中没有申明清空委托的方法，我们可以利用GetInvocationList查询出委托引用，然后进行去除。</p><p>方法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">TestDelegate test = <span class="hljs-keyword">new</span> TestDelegate();<br><span class="hljs-keyword">if</span> (test.OnDelegate != <span class="hljs-literal">null</span>)<br>&#123;<br>  System.Delegate[] dels = test.OnDelegate.GetInvocationList();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; dels.Length; i++)<br>  &#123;<br>     test.OnDelegate -= dels[i] <span class="hljs-keyword">as</span> DelegateMethod;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-委托的应用"><a href="#7-委托的应用" class="headerlink" title="7.委托的应用"></a>7.委托的应用</h1></li></ol><ul><li>高内聚低耦合</li><li>用于事件系统</li><li>用于设计模式——观察者模式开发</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#事件</title>
    <link href="/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>C#事件的核心思想是基于windows消息处理机制的，只是封装的更好，让开发者无须知道底层的消息处理机制，就可以开发出强大的基于事件的应用程序来。</p><p>关于事件，比较形象的比喻就是广播者和订阅者。事件执行时会广播给订阅他函数，告诉每个函数该运行了，但不管函数的实现细节。</p><p>事件类似于异常，因为它们都由对象引发(抛出)，并且都可以通过我们提供的代码来处理。<br>但它们也有个重要区别：事件并没有与tny. catch类似的结构来处理事件，你必须订阅(Subseribe)它们。</p><p>订阅一个事件的含义是提供代码，在事件发生时执行这些代码，它们称为事件处理程序。</p><p>单个事件可供多个处理程序订阅，在该事件发生时，这些处理程序都会被调用，事件处理程序可以在引发事件的类中，也可以在其他类中。</p><p>事件处理程序本身都是简单方法。对事件处理方法的唯一限制是它必须匹配事件所要求的返回类型和参数，这个限制是事件定义的一部分，由一个委托指定。</p><blockquote><p>学习事件前请先学习<br><a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/">委托</a></p></blockquote><h1 id="2-事件与委托的关系与区别"><a href="#2-事件与委托的关系与区别" class="headerlink" title="2. 事件与委托的关系与区别"></a>2. 事件与委托的关系与区别</h1><p><strong>事件Event</strong>是在<strong>多播委托multicast delegate</strong>的基础上演变而来。</p><ul><li>event是升级版delegate，用event实现的功能用delegate同样可以实现。</li><li>event较之delegate具有继承方面的安全性。<br>用event，别的类只能订阅/取消订阅，如果用一个 public delegate成员变量，别的类可以调用或者覆盖我们的delegate变量。</li><li>一般来说，如果你要创建一个包含多个类的动态体系，使用event而不是delegate。</li></ul><h1 id="3-使用事件的优点"><a href="#3-使用事件的优点" class="headerlink" title="3. 使用事件的优点"></a>3. 使用事件的优点</h1><p>在以往我们编程时，往往采用等待机制，为了等待某件事情的发生，需要不断地检测某些判断变量，而引入事件编程后，大大简化了这种过程：</p><ul><li><p>可以很方便地确定程序执行顺序。</p></li><li><p>当事件驱动程序等待事件时，它不占用很多资源。<br>事件驱动程序与过程式程序最大的不同就在于，程序不再不停地检查输入设备，而是呆着不动，等待消息的到来,每个输入的消息会被排进队列，等待程序处理它。<br>如果没有消息在等待，则程序会把控制交回给操作系统，以运行其他程序。</p></li><li><p>简化了编程。<br>操作系统只是简单地将消息传送给对象，由对象的事件驱动程序确定事件的处理方法。<br>操作系统不必知道程序的内部工作机制，只是需要知道如何与对象进行对话，也就是如何传递消息。</p></li><li><p>在事件源和事件接收器之间启用非常小的耦合。<br>这两个组件可能不会由同一个组织编写，甚至可能会通过完全不同的计划进行更新。</p></li><li><p>订阅事件并从同一事件取消订阅应该非常简单。</p></li><li><p>事件源应支持多个事件订阅服务器。<br>它还应支持不附加任何事件订阅服务器。</p></li></ul><h1 id="4-使用事件需要的步骤"><a href="#4-使用事件需要的步骤" class="headerlink" title="4. 使用事件需要的步骤"></a>4. 使用事件需要的步骤</h1><p>我们编写一个偶像搞事事件来描述使用事件的步骤。</p><p>代码与步骤如下：</p><h2 id="4-1-创建一个委托"><a href="#4-1-创建一个委托" class="headerlink" title="4.1 创建一个委托"></a>4.1 创建一个委托</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像行为委托，参数是行为字符串，返回值为空</p></blockquote><h2 id="4-2-将委托与已有或自定义事件关联"><a href="#4-2-将委托与已有或自定义事件关联" class="headerlink" title="4.2 将委托与已有或自定义事件关联"></a>4.2 将委托与已有或自定义事件关联</h2><p>.Net类库中的很多事件都是已经定制好的，所以他们也就有相应的一个委托，在编写关联事件处理程序——也就是当有事件发生时我们要执行的方法的时候我们需要和这个委托有相同的签名</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像搞事事件，与IdolBehaviour偶像行为委托关联</p></blockquote><h2 id="4-3-编写事件处理程序"><a href="#4-3-编写事件处理程序" class="headerlink" title="4.3 编写事件处理程序"></a>4.3 编写事件处理程序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>&#125;<br><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>的两个事件处理程序函数</p></blockquote><h2 id="4-4-生成委托实例"><a href="#4-4-生成委托实例" class="headerlink" title="4.4 生成委托实例"></a>4.4 生成委托实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br>IdolBehaviour myIdolBehaviour=<span class="hljs-keyword">new</span> IdolBehaviour();<br></code></pre></td></tr></table></figure><blockquote><p>这步可以省略<br>我们在声明event delegate时并没有给它分配内存，使用时直接赋值或添加即可</p></blockquote><h2 id="4-5-订阅事件"><a href="#4-5-订阅事件" class="headerlink" title="4.5 订阅事件"></a>4.5 订阅事件</h2><p>把这个委托实例添加到产生事件对象的事件列表中去，这个过程又叫订阅事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += LikeIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= LikeIdol;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-comment">//OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += HateIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= HateIdol;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>中用于事件订阅</p></blockquote><h2 id="4-6-事件触发"><a href="#4-6-事件触发" class="headerlink" title="4.6 事件触发"></a>4.6 事件触发</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>&#123;<br>    IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>别编写在<strong>Idol.cs</strong>中需要触发事件的地方，Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</p></blockquote><h2 id="4-7-代码汇总"><a href="#4-7-代码汇总" class="headerlink" title="4.7 代码汇总"></a>4.7 代码汇总</h2><p>结果以上6个步骤后，一个自定义事件就完成了，代码汇总如下：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>        &#123;<br>            IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-事件产生和实现的流程"><a href="#5-事件产生和实现的流程" class="headerlink" title="5.事件产生和实现的流程"></a>5.事件产生和实现的流程</h1><ol><li><p>定义A为产生事件的实例，a为A产生的一个事件</p></li><li><p>定义B为接收事件的实例，b为处理事件的方法</p></li><li><p>A由于用户(程序编写者或程序使用者)或者系统产生一个a事件(例如点击一个Button，产生一个Click事件)</p></li><li><p>A通过事件列表中的委托对象将这个事件通知给B</p></li><li><p>B接到一个事件通知(实际是B.b利用委托来实现事件的接收)</p></li><li><p>调用B.b方法完成事件处理</p></li></ol><h1 id="6-参考网站"><a href="#6-参考网站" class="headerlink" title="6. 参考网站"></a>6. 参考网站</h1><ul><li><a href="https://www.jb51.net/article/133032.htm">https://www.jb51.net/article/133032.htm</a></li><li> <a href="https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/">https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#高级特性</tag>
      
      <tag>C#</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的事件函数</title>
    <link href="/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity中的脚本组织不像传统的游戏循环，有一个持续进行的主循环并在循环体中处理游戏逻辑。</p><p>相对的，Unity 会在特定的事件发生时，调用脚本中特定的函数，然后执行逻辑的任务就交给了该脚本函数，函数执行完毕后，执行的权力重新还给Unty。</p><p>这些特定的函数通常被称为事件函数，因为是在特定事件发生时由引擎层调用的。</p><h1 id="2-必然事件"><a href="#2-必然事件" class="headerlink" title="2.必然事件"></a>2.必然事件</h1><table><thead><tr><th>事件函数</th><th>作用</th></tr></thead><tbody><tr><td>Awake</td><td>脚本实例被创建时调用（用于游戏对象的初始化，注意Awake的执行早于所有脚本的Start函数）</td></tr><tr><td>Start</td><td>Update函数第一次运行之前调用（用于游戏对象的初始化）</td></tr><tr><td>Reset</td><td>用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个最常用的默认值。</td></tr><tr><td>Update</td><td>每帧调用一次（用于更新游戏场景和状态）</td></tr><tr><td>FixedUpdate</td><td>每个固定物理时间间隔调用一次（用于物理引擎的参数更新）</td></tr><tr><td>LateUpdate</td><td>每帧调用一次，在Update之后（用于更新游戏场景和状态，和相机有关的更新一般放在这里）</td></tr></tbody></table><h2 id="2-1-Updata与FixedUpdate的区别"><a href="#2-1-Updata与FixedUpdate的区别" class="headerlink" title="2.1 Updata与FixedUpdate的区别"></a>2.1 Updata与FixedUpdate的区别</h2><ul><li><p>FixedUpdate</p><p>物理更新的事件函数，物理引擎也会按照物理帧更新，机制和<strong>Update函数</strong>类似，但是更新的时机完全不同。</p><p>它在每一次物理更新时被调用。</p></li><li><p>Updata</p><p>帧更新函数，每帧调用一次。</p></li></ul><blockquote><p>要认识到，物理更新的频率和时机与Update函数是相对独立的。尽可能在FixedUpdate函数中进行物理相关的操作，在Update函数中进行其他操作，只有选择正确的函数才能让游戏效果尽可能准确。</p></blockquote><h3 id="2-1-1-帧率"><a href="#2-1-1-帧率" class="headerlink" title="2.1.1 帧率"></a>2.1.1 帧率</h3><p>每一帧所经历的时间并不是一个固定值，所以通过<strong>Updata函数</strong>控制物体移动的速度将不会是稳定的。</p><p>主要是因为硬件负载的原因，引擎默认会按照每秒60帧运行游戏，但是当负载增大时，帧率可能会下降，无法达到60帧，这时可能就只有30帧，帧率降低了一半，每帧的时间增加了一倍。物体的运动由于帧率降低而变慢了。实践中一般不允许这种情况的发生。</p><p>解决方案是将两帧之间的间隔<strong>Time.deltaTime</strong>考虑进去。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleScript</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> distancePerSecond;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        transform.Translate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>，distancePerSecond*Time.deltaTime);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:通过乘以Time.deltaTime的运算，物体的移动不再以“每帧距离”为准，而变成了“每秒距离”。</p><p>物体移动的距离将根据每帧时间的长短而变化，从而在时间上看起来移动是匀速的。</p></blockquote><h3 id="2-1-2-物理帧率"><a href="#2-1-2-物理帧率" class="headerlink" title="2.1.2 物理帧率"></a>2.1.2 物理帧率</h3><p>与主更新函数Update不同，Unity的物理系统必须以固定的时间间隔工作，因为只有固定的时间间隔才能保证物理模拟的准确性。就算当前负载很高、帧率很低，Unity也会尽可能保证物理刷新的频率，因为如果物理刷新帧率无法保证，就可能出现不可预料的计算结果。</p><p>在主菜单的工程选项的TimeManager中可以修改物理更新的时间间隔。<br>在脚本中使用Time. fixedDeltaTime可以获得物理更新间隔。</p><p>较小的物理更新间隔会带来更高的更新频率，更准确、更细腻的运算结果，但是也会极大地增加硬件负担。<br>fixedDeltaTime 的默认值为0.02，当对物理运算的准确性非常在意时，可以考虑适当减小这个值。</p><h1 id="3-事件响应函数"><a href="#3-事件响应函数" class="headerlink" title="3. 事件响应函数"></a>3. 事件响应函数</h1><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>OnMouseEnter</td><td>鼠标移入GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseOver</td><td>鼠标停留在GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseExit</td><td>鼠标移出GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseDown</td><td>鼠标在GUI控件或者碰撞体上按下时调用</td></tr><tr><td>OnMouseUp</td><td>鼠标按键释放时调用</td></tr><tr><td>OnTriggerEnter</td><td>与其他碰撞体进入触发器时调用</td></tr><tr><td>OnTriggerExit</td><td>与其他碰撞体离开触发器时调用</td></tr><tr><td>OnTriggerStay</td><td>当其他碰撞体停留在触发器时调用</td></tr><tr><td>OnCollisionEnter</td><td>当碰撞体或者刚体与其他碰撞体或者刚体接触时调用</td></tr><tr><td>OnCollisionExit</td><td>当碰撞体或者刚体与其他碰撞体或者刚体停止接触时调用</td></tr><tr><td>OnCollisionStay</td><td>当碰撞体或者刚体与其他碰撞体或者刚体保持接触时调用</td></tr><tr><td>OnControllerColliderHit</td><td>当控制器移动时与碰撞体发生碰撞时调用</td></tr><tr><td>OnDestroy</td><td>脚本销毁时调用</td></tr><tr><td>OnGUI</td><td>渲染GUI和处理GUI消息时调用</td></tr><tr><td>OnBecameVisible</td><td>对于任意一个相机可见时调用</td></tr><tr><td>OnBecameInVisible</td><td>对于任意一个相机不可见时调用</td></tr><tr><td>OnEnable</td><td>对象启用或者激活时调用</td></tr><tr><td>OnDisable</td><td>对象禁用或者取消激活时调用</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameObject类</title>
    <link href="/2021/03/20/GameObject%E7%B1%BB/"/>
    <url>/2021/03/20/GameObject%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>GameObject 类是Unity场景中所有实体的基类。</p><p>一个GameObject对象通常由多个组件component组成，且至少含有一个transform组件。</p><p>详细可见<a href="https://blog.csdn.net/a1256242238/article/details/73189101">https://blog.csdn.net/a1256242238/article/details/73189101</a></p><h1 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h1><ul><li><p><code>public GameObject();</code></p></li><li><p><code>public GameObject(string name);</code></p></li><li><p><code>public GameObject(string name,params Type[] components);</code></p></li></ul><h1 id="3-常用成员变量"><a href="#3-常用成员变量" class="headerlink" title="3. 常用成员变量"></a>3. 常用成员变量</h1><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>继承于父类Object，对象的名称</td></tr><tr><td>tag</td><td>游戏对象的标签tag</td></tr><tr><td>layer</td><td>游戏对象所在的层layer，范围为[0…31]</td></tr><tr><td>activeSelf</td><td>游戏对象自身的激活状态</td></tr><tr><td>transform</td><td>游戏对象上的Transform组件，设置对象位置、旋转、缩放</td></tr><tr><td>rigidbody</td><td>游戏对象上的Rigidbody组件，设置物理引擎的刚体属性</td></tr><tr><td>camera</td><td>游戏对象上的Camera组件，设置相机属性</td></tr><tr><td>light</td><td>游戏对象上的Light组件，设置灯光属性</td></tr><tr><td>animation</td><td>游戏对象上的Animation组件，设置动画属性</td></tr><tr><td>renderer</td><td>游戏对象上的Renderer组件，渲染物体模型</td></tr><tr><td>audio</td><td>游戏对象上的AudioSource组件，设置声音属性</td></tr></tbody></table><h1 id="4-常用成员函数"><a href="#4-常用成员函数" class="headerlink" title="4.常用成员函数"></a>4.常用成员函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Find</td><td>静态函数，根据名称查找游戏对象</td></tr><tr><td>FindWithTag</td><td>静态函数，根据标签查找第一个符合条件的游戏对象</td></tr><tr><td>FindGameObjectsWithTag</td><td>静态函数，根据标签查找所有符合条件的游戏对象</td></tr><tr><td>CreatePrimitive</td><td>静态函数，创建一个基本形体的游戏对象（如正方体，球体等）</td></tr><tr><td>SetActive</td><td>激活/取消激活游戏对象</td></tr><tr><td>GetComponent</td><td>获取游戏对象</td></tr><tr><td>GetComponentInChildren</td><td>获取游戏对象或其子对象上指定类型的第一个组件</td></tr><tr><td>GetComponents</td><td>获取游戏对象上指定类型的所有组件</td></tr><tr><td>AddComponent</td><td>为游戏对象添加指定组件</td></tr><tr><td>SendMessage</td><td>调用游戏对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>SendMessageUpwards</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>BroadcastMessage</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>CompareTag</td><td>比较游戏对象的标签</td></tr></tbody></table><h1 id="5-继承自Object类的常用函数"><a href="#5-继承自Object类的常用函数" class="headerlink" title="5. 继承自Object类的常用函数"></a>5. 继承自Object类的常用函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Destroy</td><td>删除一个游戏物体、组件或资源</td></tr><tr><td>DestroyImmediate</td><td>立即销毁物体obj，强烈建议使用Destroy替代</td></tr><tr><td>Instantiate</td><td>克隆原始物体，并返回克隆的物体</td></tr><tr><td>DontDestroyOnLoad</td><td>加载新场景的时候使目标不被自动销毁</td></tr><tr><td>FindObjectOfType</td><td>返回Type类型第一个激活的加载的物体</td></tr></tbody></table><h2 id="5-1-Instantiate创建物体"><a href="#5-1-Instantiate创建物体" class="headerlink" title="5.1 Instantiate创建物体"></a>5.1 Instantiate创建物体</h2><p><strong>Instantiate函数</strong>专门用来创建一个新的物体，但是要提供一个预制体或者已经存在的游戏物体作为模板。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Gameobject enemy;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//以enemy为模板生成5个敌人</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-number">1</span><span class="hljs-number">-0</span>; <span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>; <span class="hljs-number">1</span>++)<br>    &#123;<br>        Instantiate(enemy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用已经存在的物体作为模板，更常见的方式是使用预制体作为模板。</p><p>创建的物体将会具有和原物体一样的组件、参数。</p><h2 id="5-2-Destroy销毁物体"><a href="#5-2-Destroy销毁物体" class="headerlink" title="5.2 Destroy销毁物体"></a>5.2 Destroy销毁物体</h2><p>可以用Destroy函数来销毁游戏物体或者组件。</p><p>例如，下面的代码会在导弹产生碰撞时销毁该导弹，第二个参数0.5f表示在0.5秒之后才执行销毁动作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span> (<span class="hljs-params">Collision otherobj</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (other0bj.gameObject.tag == <span class="hljs-string">&quot;Missile&quot;</span>)<br>    &#123;<br>        Destroy (gameObject,<span class="hljs-number">0.5f</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:由于销毁游戏物体和销毁脚本都是使用Destoy函数，所以经常 会出现误删除组件的情况。</p><p>如以下代码：</p><p><code>Destroy (this);</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在脚本中访问其他游戏物体</title>
    <link href="/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在实际的游戏开发中，脚本不仅会对当前挂载的物体进行操作，还可能会引用其他物体。<br>例如，正在追逐玩家角色的敌人角色会-直保留着对玩家角色的引用， 以便随时确定玩家角色的位置。<br>访问其他游戏物体的方法非常多，使用非常灵活，可以根据不同的情况采用不同的方式。</p><h1 id="2-常用的4种访问操作"><a href="#2-常用的4种访问操作" class="headerlink" title="2.常用的4种访问操作"></a>2.常用的4种访问操作</h1><h2 id="2-1-用属性查看器指定参数访问"><a href="#2-1-用属性查看器指定参数访问" class="headerlink" title="2.1 用属性查看器指定参数访问"></a>2.1 用属性查看器指定参数访问</h2><p>Unity中获得其他物体最简单、最直接的方式就是为脚本添加一个<code>publi Gamebiet</code>变量，不需要设置初始值。<br>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>player变量会显示在检视窗口中，默认值为空。</p><p>现在将任何物体或预制体拖曳到player变量的文本框中，就为player变量赋予了初始值。之在脚本中就可以随意使用Player这个游戏物体。<br>如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//读取player的位置并设置本物体的位置在它后方</span><br>        transform.position=player.transform.position-Vector3.forward*<span class="hljs-number">10f</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，上面说的引用其他物体时，变量类型不仅可以是<strong>GameObject</strong>或一个组件，也可以将戏物体拖到这个变量上，只要被拖曳的物体确实具有这个组件就可以。</p><p><code>public Transform playerTransform;</code></p><p>简单地说，可以用何一个组件来指代游戏物体本身。<br>这是因为组件实体具有“被游戏物体挂载”这样的性质，所通过一个游戏物体可以获得它上面的任何一个组件，通过任何一个组件也可以获得挂载该组件游戏物体。这个对应关系是明确的，因此上面的变量类型可以是组件类型，也可以将游戏物体直接拖上去。</p><p>用变量将物体联系起来的做法非常有用，特别是这种联系是持续存在、不易变化的。还可用一个数组或者列表来保存多个游戏物体。</p><blockquote><p>如果被引用的物体是游戏运行时才动态添加的，或者被引用的物体会随着游戏进行而变化事先拖曳的方式就不可行了，需要动态指定物体，下面将详细说明。</p></blockquote><h2 id="2-2-用父子关系查找子物体"><a href="#2-2-用父子关系查找子物体" class="headerlink" title="2.2 用父子关系查找子物体"></a>2.2 用父子关系查找子物体</h2><p>有时需要管理一系列同类型的游戏物体，例如一批敌人、一批寻路点、 多个障碍物等。<br>如果这时候需要对这些物体进行统一的管理或操作，就需要在脚本中用数组或容器来管理它们。</p><p>使用属性查看器指定参数访问的方法，可以将每个物体拖动到检视窗口中，但是这样做不仅低效，而且容易误操作，在物体增加、减少时还需要再次手动操作。</p><p>所以，在这种情况下是不合适的，可以用父子关系查找子物体的方法来遍历所有子物体。<br>在具体实现时，要用父物体的变换组件来查找子物体。</p><blockquote><p>物体的父子关系访问的属性都在变换组件中，而不在GameObject对象中</p></blockquote><p>以下是遍历所有子物体的例子:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WaypointManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br><span class="hljs-keyword">public</span> Transform[] waypoints;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>waypoints = <span class="hljs-keyword">new</span> Transform[transform.childCount];<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">foreach</span> (Transform t <span class="hljs-keyword">in</span> transform)<br>&#123;<br>waypoints[i++] = t;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以使用<strong>transform.Find</strong>方法指定查找某个子物体，代码如下。</p><p><code>transform.Find (&quot;Gun&quot;);</code></p><blockquote><p>由于<strong>Find函数</strong>的效率不好估计，可能会遍历所有物体才能查找到指定物体，所以如果可以在<strong>Start函数</strong>中使用，就不要在<strong>Updata函数</strong>中使用。因为<strong>start函数</strong>只执行一次而<strong>updata函数</strong>每帧都会执行。</p></blockquote><h2 id="2-3-用标签或名称查找物体"><a href="#2-3-用标签或名称查找物体" class="headerlink" title="2.3 用标签或名称查找物体"></a>2.3 用标签或名称查找物体</h2><p>使用<strong>GameObject.Find方法</strong>可以通过名称查找游戏物体。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.Find (<span class="hljs-string">&quot;ObjectName&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要用标签查找物体，那么就要用到<strong>GameObject.FindWithTag方法</strong> 或<strong>GameObject.FindGameObjectWithTag方法</strong>。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br>GameObject[] enemies;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.FindWithTag(<span class="hljs-string">&quot;Player&quot;</span>);<br>    enemies =GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;Enemy&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>Unity常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
      <tag>Unity常用操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL语句大全</title>
    <link href="/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/"/>
    <url>/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MYSQL语句大全"><a href="#MYSQL语句大全" class="headerlink" title="MYSQL语句大全"></a>MYSQL语句大全</h1><h2 id="0-相关知识"><a href="#0-相关知识" class="headerlink" title="0 相关知识"></a>0 相关知识</h2><ul><li><p><a href="https://blog.csdn.net/chaoyue1861/article/details/80468773">MYSQL逻辑架构</a></p></li><li><p><a href="https://blog.csdn.net/GitChat/article/details/78787837?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">MYSQL底层原理</a></p></li><li><p><a href="https://blog.csdn.net/m0_38075425/article/details/82256315?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">MySQL底层架构原理，工作流程和存储引擎的数据结构讲解</a></p></li></ul><h2 id="1-用户管理操作"><a href="#1-用户管理操作" class="headerlink" title="1 用户管理操作"></a>1 用户管理操作</h2><h3 id="1-1-添加用户"><a href="#1-1-添加用户" class="headerlink" title="1.1 添加用户"></a>1.1 添加用户</h3><ul><li><code> create user username identified by &#39;password&#39;;</code></li></ul><p>参数：用户名：username 密码：password</p><blockquote><p>用户数据存储在mysql.user表内</p></blockquote><h3 id="1-2-用户授权"><a href="#1-2-用户授权" class="headerlink" title="1.2 用户授权"></a>1.2 用户授权</h3><ul><li><code>grant privilegesCode on dbName.tableName to username@host identified by &#39;password&#39;;</code></li></ul><p>将Dbname数据库的所有操作权限都授权给了用户username。</p><p>参数：</p><p><strong>privilegesCode</strong> 权限类型<br>常用的权限类型</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>all privileges</td><td>所有权限</td></tr><tr><td>select</td><td>读取权限</td></tr><tr><td>delete</td><td>删除权限</td></tr><tr><td>update</td><td>更新权限</td></tr><tr><td>create</td><td>创建权限</td></tr><tr><td>drop</td><td>删除数据库、数据表权限</td></tr></tbody></table><p><strong>dbName.tableName</strong> 授权的库或特定表</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>授予该数据库服务器所有数据库的权限</td></tr><tr><td>dbName.*</td><td>授予dbName数据库所有表的权限</td></tr><tr><td>dbName.dbTable</td><td>授予数据库dbName中dbTable表的权限</td></tr></tbody></table><p><strong>username@’host’</strong> 授予的用户以及允许该用户登录的IP地址<br>| 参数         | 含义                 |<br>| ————– | ———————- |<br>| localhost | 只允许该用户在本地登录，不能远程登录 |<br>| % | 允许在除本机之外的任何一台机器远程登录 |<br>| 192.168.52.32 | 具体的IP表示只允许该用户从特定IP登录 |</p><ul><li><p><code> flush privileges;</code></p><p>刷新权限变更</p></li><li><p><code> show grants for &#39;username&#39;;</code></p></li></ul><p>查看用户的已有权限</p><blockquote><p>用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush privileges;<br></code></pre></td></tr></table></figure><p>上面的语句将zhangsanDb数据库的所有操作权限都授权给了用户zhangsan</p></blockquote><ul><li><p><code>REVOKE DELETE ON *.* FROM &#39;test&#39;@&#39;localhost&#39;;</code> </p><p>取消该用户的删除权限</p></li></ul><blockquote><p>用户权限数据存储在mysql.db表内</p></blockquote><h3 id="1-3-修改密码"><a href="#1-3-修改密码" class="headerlink" title="1.3 修改密码"></a>1.3 修改密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update mysql.user set password &#x3D; password(&#39;newpassword&#39;) where user &#x3D; &#39;username&#39; and host &#x3D; &#39;%&#39;; <br>flush privileges;<br></code></pre></td></tr></table></figure><h3 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a>1.4 删除用户</h3><ul><li><code>drop user zhangsan@&#39;%&#39;;</code></li></ul><h3 id="1-5-常用命令组"><a href="#1-5-常用命令组" class="headerlink" title="1.5 常用命令组"></a>1.5 常用命令组</h3><p><strong>创建用户并授予指定数据库全部权限：适用于Web应用创建MySQL用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user zhangsan identified by &#39;zhangsan&#39;;<br>grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush  privileges;<br></code></pre></td></tr></table></figure><p>创建了用户zhangsan，并将数据库zhangsanDB的所有权限授予zhangsan。如果要使zhangsan可以从本机登录，那么可以多赋予localhost权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;localhost&#39; identified by &#39;zhangsan&#39;;<br></code></pre></td></tr></table></figure><h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2 数据库操作"></a>2 数据库操作</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code> show database;</code></td><td>查看所有的数据库</td></tr><tr><td><code>create database DBname;</code></td><td>创建该数据库</td></tr><tr><td><code>drop DBname;</code></td><td>删除该数据库</td></tr><tr><td><code>use DBname;</code></td><td>使用调用该数据库</td></tr></tbody></table><h2 id="3-表操作"><a href="#3-表操作" class="headerlink" title="3 表操作"></a>3 表操作</h2><h3 id="3-1-表的基础操作"><a href="#3-1-表的基础操作" class="headerlink" title="3.1 表的基础操作"></a>3.1 表的基础操作</h3><ul><li><p><code>show tables;</code><br>查看所有的表</p></li><li><p><code>SHOW TABLE STATUS;</code><br>查看所有的表信息（包括视图）</p></li><li><p><code> create table TBname(mode);</code></p><p>创建一个表</p><blockquote><p>例如<br><code>create table n(id INT, name VARCHAR(10));</code></p></blockquote></li><li><p><code> create table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的表</p></li><li><p><code>create table TBname like TBname;</code><br>新创建的表与一个存在的表的数据结构类似</p></li><li><p><code>create temporay table TBname(mode);</code><br>创建一个临时表</p><blockquote><p>临时表将在你连接MySQL期间存在。当断开连接时，MySQL将自动删除表并释放所用的空间。也可手动删除。</p></blockquote></li></ul><ul><li><p><code>create temporary table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的临时表</p></li><li><p><code> drop table if exists TBname;</code><br>删除一个存在表</p></li><li><pre><code>alter table TBname rename TBname;或rename TBname to TBname;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  更改存在表的名称<br><br>  <br>  <br>- ``` <br>  <span class="hljs-keyword">desc</span> TBname;<br>  describe TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">in</span> TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> TBname;<br>  <span class="hljs-keyword">explain</span> TBname;<br></code></pre></td></tr></table></figure>查看表的结构(以上五条语句效果相同）</code></pre></li><li><p><code> show create table TBname;</code><br>查看表的创建语句</p><h3 id="3-2-表的结构操作"><a href="#3-2-表的结构操作" class="headerlink" title="3.2 表的结构操作"></a>3.2 表的结构操作</h3></li></ul><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td><code> alter table TBname add Fieldname mode;</code></td><td>添加字段</td></tr><tr><td><code>alter table TBname drop Fieldname;</code></td><td>删除字段</td></tr><tr><td><code>alter table TBname change Fieldname mode;</code></td><td>更改字段属性</td></tr><tr><td><code>alter table TBname change Fieldname Fieldname mode;</code></td><td>更改字段名与属性</td></tr></tbody></table><h3 id="3-3-表的数据操作"><a href="#3-3-表的数据操作" class="headerlink" title="3.3 表的数据操作"></a>3.3 表的数据操作</h3><ul><li><p>增加数据</p><p><code>INSERT INTO n VALUES (1, &#39;tom&#39;, &#39;23&#39;), (2, &#39;john&#39;, &#39;22&#39;);</code></p><p><code>INSERT INTO n SELECT * FROM n;</code>  把数据复制一遍重新插入</p></li><li><p>删除数据</p><p><code>DELETE FROM n WHERE id = 2;</code></p></li><li><p>更改数据</p><p><code>UPDATE n SET name = &#39;tom&#39; WHERE id = 2;</code></p></li><li><p>数据查找</p><p><code>SELECT * FROM n WHERE name LIKE &#39;%h%&#39;;</code></p></li><li><p>数据排序(反序)</p><p><code>SELECT * FROM n ORDER BY name, id DESC ;</code></p></li></ul><blockquote><p>增删改查请看：<a href="https://www.cnblogs.com/heyangblog/p/7624645.html">https://www.cnblogs.com/heyangblog/p/7624645.html</a></p></blockquote><h2 id="4-键"><a href="#4-键" class="headerlink" title="4 键"></a>4 键</h2><h3 id="4-1-添加主键"><a href="#4-1-添加主键" class="headerlink" title="4.1 添加主键"></a>4.1 添加主键</h3><ul><li><p><code>ALTER TABLE TBname ADD PRIMARY KEY (id);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT pk_n PRIMARY KEY (id);</code>  </p><p>添加主键的同时自定义键名</p></li></ul><h3 id="4-2-删除主键"><a href="#4-2-删除主键" class="headerlink" title="4.2 删除主键"></a>4.2 删除主键</h3><ul><li><code> ALTER TABLE TBname DROP PRIMARY KEY ;</code></li></ul><h3 id="4-3-添加外键"><a href="#4-3-添加外键" class="headerlink" title="4.3 添加外键"></a>4.3 添加外键</h3><ul><li><p><code>ALTER TABLE TBname ADD FOREIGN KEY (id) REFERENCES TBname(id);</code>   </p><p>自动生成键名m_ibfk_1</p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES TBname(id); </code>  </p><p>使用定义的键名fk_id</p></li></ul><h3 id="4-4-删除外键"><a href="#4-4-删除外键" class="headerlink" title="4.4 删除外键"></a>4.4 删除外键</h3><ul><li>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</li></ul><h3 id="4-5-修改外键"><a href="#4-5-修改外键" class="headerlink" title="4.5 修改外键"></a>4.5 修改外键</h3><ul><li><p>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</p><p>ADD CONSTRAINT fk_id2 FOREIGN KEY (id) REFERENCES TBname(id); </p><p>删除之后从新建</p></li></ul><h3 id="4-6-添加唯一键"><a href="#4-6-添加唯一键" class="headerlink" title="4.6 添加唯一键"></a>4.6 添加唯一键</h3><ul><li><p><code> ALTER TABLE TBname ADD UNIQUE (name);</code></p></li><li><p><code> ALTER TABLE TBname ADD UNIQUE u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD UNIQUE INDEX u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT u_name UNIQUE (name);</code></p></li><li><p><code>CREATE UNIQUE INDEX u_name ON TBname(name);</code></p></li></ul><h3 id="4-7-添加索引"><a href="#4-7-添加索引" class="headerlink" title="4.7 添加索引"></a>4.7 添加索引</h3><ul><li><p><code>ALTER TABLE TBname ADD INDEX (age);</code></p></li><li><p><code>ALTER TABLE TBname ADD INDEX i_age (age);</code></p></li><li><p><code>CREATE INDEX i_age ON TBname(age);</code></p></li></ul><h3 id="4-8-删除索引或唯一键"><a href="#4-8-删除索引或唯一键" class="headerlink" title="4.8 删除索引或唯一键"></a>4.8 删除索引或唯一键</h3><ul><li><p><code>DROP INDEX u_name ON n;</code></p></li><li><p><code>DROP INDEX i_age ON n;</code></p></li></ul><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5 视图"></a>5 视图</h2><h3 id="5-1-创建视图"><a href="#5-1-创建视图" class="headerlink" title="5.1 创建视图"></a>5.1 创建视图</h3><ul><li><p><code>CREATE VIEW v AS SELECT id, name FROM n;</code></p></li><li><p><code>CREATE VIEW v(id, name) AS SELECT id, name FROM n;</code></p></li></ul><h3 id="5-2查看视图"><a href="#5-2查看视图" class="headerlink" title="5.2查看视图"></a>5.2查看视图</h3><ul><li><p><code>SELECT * FROM v;</code></p></li><li><p><code>DESC v;</code></p></li></ul><blockquote><p>与表操作类似</p></blockquote><h3 id="5-3查看创建视图语句"><a href="#5-3查看创建视图语句" class="headerlink" title="5.3查看创建视图语句"></a>5.3查看创建视图语句</h3><ul><li><code>SHOW CREATE VIEW v;</code></li></ul><h3 id="5-4-更改视图"><a href="#5-4-更改视图" class="headerlink" title="5.4 更改视图"></a>5.4 更改视图</h3><ul><li><p><code>CREATE OR REPLACE VIEW v AS SELECT name, age FROM n;</code></p></li><li><p><code>ALTER VIEW v AS SELECT name FROM n ;</code></p></li></ul><h3 id="5-5-删除视图"><a href="#5-5-删除视图" class="headerlink" title="5.5 删除视图"></a>5.5 删除视图</h3><ul><li><code>DROP VIEW IF EXISTS v;</code></li></ul><h2 id="6-联接"><a href="#6-联接" class="headerlink" title="6 联接"></a>6 联接</h2><h3 id="6-1-内联接"><a href="#6-1-内联接" class="headerlink" title="6.1 内联接"></a>6.1 内联接</h3><ul><li><code>SELECT * FROM m INNER JOIN n ON m.id = n.id;</code></li></ul><h3 id="6-2-外连接"><a href="#6-2-外连接" class="headerlink" title="6.2 外连接"></a>6.2 外连接</h3><ul><li><code>SELECT * FROM m LEFT JOIN n ON m.id = n.id;</code>左外连接</li><li><code>SELECT * FROM m RIGHT JOIN n ON m.id = n.id;</code>右外连接</li></ul><h3 id="6-3-交叉联接"><a href="#6-3-交叉联接" class="headerlink" title="6.3 交叉联接"></a>6.3 交叉联接</h3><ul><li><p><code>SELECT * FROM m CROSS JOIN n;</code>  标准写法</p></li><li><p><code>SELECT * FROM m, n;</code></p></li></ul><h3 id="6-4-类似全连接full-join的联接用法"><a href="#6-4-类似全连接full-join的联接用法" class="headerlink" title="6.4 类似全连接full join的联接用法"></a>6.4 类似全连接full join的联接用法</h3><ul><li><pre><code>SELECT id,name FROM mUNIONSELECT id,name FROM n;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs sql">## <span class="hljs-number">7</span> 函数<br><br>### <span class="hljs-number">7.1</span> 聚合函数<br><br><span class="hljs-operator">|</span> 语句                               <span class="hljs-operator">|</span> 含义   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">---------------------------------- | ------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(id) <span class="hljs-keyword">AS</span> total <span class="hljs-keyword">FROM</span> n;  <span class="hljs-operator">|</span> 总数   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 总和   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 平均值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">max</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最大值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最小值 <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.2</span> 数学函数<br><br><span class="hljs-operator">|</span> 语句                              <span class="hljs-operator">|</span> 含义                                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">--------------------------------- | ------------------------------------------------------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">abs</span>(<span class="hljs-number">-5</span>);                   <span class="hljs-operator">|</span> 绝对值                                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> bin(<span class="hljs-number">15</span>), oct(<span class="hljs-number">15</span>), hex(<span class="hljs-number">15</span>); <span class="hljs-operator">|</span> 二进制，八进制，十六进制                               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> pi();                      <span class="hljs-operator">|</span> 圆周率<span class="hljs-number">3.141593</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">5.5</span>);                 <span class="hljs-operator">|</span> 大于x的最小整数值<span class="hljs-number">6</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">5.5</span>);                <span class="hljs-operator">|</span> 小于x的最大整数值<span class="hljs-number">5</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> greatest(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>); <span class="hljs-operator">|</span> 返回集合中最大的值<span class="hljs-number">9</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> least(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);    <span class="hljs-operator">|</span> 返回集合中最小的值<span class="hljs-number">1</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);                  <span class="hljs-operator">|</span> 余数<span class="hljs-number">2</span>                                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand();                    <span class="hljs-operator">|</span> 返回０到１内的随机值，每次不一样                       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 提供一个参数(种子)使RAND()随机数生成器生成一个指定的值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>);          <span class="hljs-operator">|</span> 四舍五入<span class="hljs-number">1415</span>                                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);       <span class="hljs-operator">|</span> 四舍五入三位数<span class="hljs-number">1415.142</span>                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);      <span class="hljs-operator">|</span> 四舍五入整数位数<span class="hljs-number">1420</span>                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);    <span class="hljs-operator">|</span> 截短为<span class="hljs-number">3</span>位小数<span class="hljs-number">1415.141</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);   <span class="hljs-operator">|</span> 截短为<span class="hljs-number">-1</span>位小数<span class="hljs-number">1410</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">-5</span>);                  <span class="hljs-operator">|</span> 符号的值负数<span class="hljs-number">-1</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 符号的值正数<span class="hljs-number">1</span>                                          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">9</span>);                   <span class="hljs-operator">|</span> 平方根<span class="hljs-number">3</span>                                                <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.3</span> 字符串函数<br><br><span class="hljs-operator">|</span> 语句                                        <span class="hljs-operator">|</span> 含义                                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------- | ------------------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>);         <span class="hljs-operator">|</span> 连接字符串<span class="hljs-operator">-</span>apple                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>); <span class="hljs-operator">|</span> 连接用<span class="hljs-string">&#x27;,&#x27;</span>分割字符串<span class="hljs-operator">-</span>a,p,p,le                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">insert</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;IN&#x27;</span>);       <span class="hljs-operator">|</span> 将字符串<span class="hljs-string">&#x27;chinese&#x27;</span>从<span class="hljs-number">3</span>位置开始的<span class="hljs-number">2</span>个字符替换为<span class="hljs-string">&#x27;IN&#x27;</span><span class="hljs-operator">-</span>chINese <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">left</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">4</span>);                  <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>左边的<span class="hljs-number">4</span>个字符<span class="hljs-operator">-</span>chin                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">right</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);                 <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>右边的<span class="hljs-number">3</span>个字符<span class="hljs-operator">-</span>ese                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);             <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的子字符串<span class="hljs-operator">-</span>inese       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">-3</span>);            <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>倒数第三个字符之后的子字符串<span class="hljs-operator">-</span>ese     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);          <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的两个字符<span class="hljs-operator">-</span><span class="hljs-keyword">in</span>          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27; chinese &#x27;</span>);                   <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese&#x27;</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ltrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese &#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rtrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27; chinese&#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> repeat(<span class="hljs-string">&#x27;boy&#x27;</span>, <span class="hljs-number">3</span>);                    <span class="hljs-operator">|</span> 重复字符<span class="hljs-string">&#x27;boy&#x27;</span>三次<span class="hljs-operator">-</span><span class="hljs-string">&#x27;boyboyboy&#x27;</span>                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> reverse(<span class="hljs-string">&#x27;chinese&#x27;</span>);                  <span class="hljs-operator">|</span> 反向排序<span class="hljs-operator">-</span><span class="hljs-string">&#x27;esenihc&#x27;</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> length(<span class="hljs-string">&#x27;chinese&#x27;</span>);                   <span class="hljs-operator">|</span> 返回字符串的长度<span class="hljs-number">-7</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>), <span class="hljs-built_in">lower</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ucase(<span class="hljs-string">&#x27;chINese&#x27;</span>), lcase(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;i&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-3</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;e&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-5</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abd&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数小于第二个返回负数<span class="hljs-operator">-</span> <span class="hljs-number">-1</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abb&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数大于第二个返回正数<span class="hljs-operator">-</span> <span class="hljs-number">1</span>             <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.4</span> 时间函数<br><br><span class="hljs-operator">|</span> 语句                                                         <span class="hljs-operator">|</span> 含义                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------------------------ | -------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">current_date</span>, <span class="hljs-built_in">current_time</span>, now();                    <span class="hljs-operator">|</span> <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span>   <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span>    <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span> <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">hour</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">minute</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">second</span>(<span class="hljs-built_in">current_time</span>); <span class="hljs-operator">|</span> <span class="hljs-number">12</span>  <span class="hljs-number">31</span>   <span class="hljs-number">34</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">year</span>(<span class="hljs-built_in">current_date</span>), <span class="hljs-keyword">month</span>(<span class="hljs-built_in">current_date</span>), week(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">2018</span>    <span class="hljs-number">1</span>   <span class="hljs-number">1</span>                                <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> quarter(<span class="hljs-built_in">current_date</span>);                                <span class="hljs-operator">|</span> <span class="hljs-number">1</span>                                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> monthname(<span class="hljs-built_in">current_date</span>), dayname(<span class="hljs-built_in">current_date</span>);       <span class="hljs-operator">|</span> January  Saturday                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> dayofweek(<span class="hljs-built_in">current_date</span>), dayofmonth(<span class="hljs-built_in">current_date</span>), dayofyear(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">7</span>   <span class="hljs-number">13</span>  <span class="hljs-number">13</span>                                   <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.5</span> 控制流函数<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> if(<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>), if(<span class="hljs-number">3</span><span class="hljs-operator">&lt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>);`    <br><br>  t f<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> ifnull(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;t&#x27;</span>), ifnull(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>);`    <br><br>  t <span class="hljs-number">2</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> isnull(<span class="hljs-number">1</span>), isnull(<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>);`    <br><br>   <span class="hljs-number">0</span> <span class="hljs-number">1</span> 是<span class="hljs-keyword">null</span>返回<span class="hljs-number">1</span>，不是<span class="hljs-keyword">null</span>返回<span class="hljs-number">0</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);`    <br><br>  <span class="hljs-keyword">null</span> a 参数相同或成立返回<span class="hljs-keyword">null</span>，不同或不成立则返回第一个参数<br><br><span class="hljs-operator">-</span> ```<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-number">2</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;first&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;second&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;third&#x27;</span><br>         <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;other&#x27;</span><br>         <span class="hljs-keyword">END</span> ;     <br></code></pre></td></tr></table></figure>second&gt; 这一块不是完全看不懂吗！</code></pre></li></ul><h1 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h1><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td>SELECT database();</td><td>当前数据库名-test</td></tr><tr><td>SELECT connection_id();</td><td>当前用户id-306</td></tr><tr><td>SELECT user();</td><td>当前用户-root@localhost</td></tr><tr><td>SELECT version();</td><td>当前mysql版本</td></tr><tr><td>SELECT found_rows();</td><td>返回上次查询的检索行数</td></tr></tbody></table><h2 id="8-存储过程"><a href="#8-存储过程" class="headerlink" title="8 存储过程"></a>8 存储过程</h2><h3 id="8-1-创建存储过程"><a href="#8-1-创建存储过程" class="headerlink" title="8.1 创建存储过程"></a>8.1 创建存储过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">DELIMITER <span class="hljs-comment">//    # 无参数</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> ;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_2</span><span class="hljs-params">(<span class="hljs-keyword">IN</span> id INT)</span>    # <span class="hljs-title">in</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> <span class="hljs-title">WHERE</span> <span class="hljs-title">a</span> = <span class="hljs-title">id</span>;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_3</span><span class="hljs-params">(<span class="hljs-keyword">OUT</span> sum INT)</span>    # <span class="hljs-title">out</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">sum</span> = <span class="hljs-params">(<span class="hljs-keyword">SELECT</span> count(*)</span> <span class="hljs-title">FROM</span> <span class="hljs-title">test</span>);</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_4</span><span class="hljs-params">(INOUT i INT)</span>    # <span class="hljs-title">inout</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">i</span> = <span class="hljs-title">i</span> + 1;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="8-2-删除存储过程"><a href="#8-2-删除存储过程" class="headerlink" title="8.2 删除存储过程"></a>8.2 删除存储过程</h3><ul><li><code>DROP PROCEDURE IF EXISTS getDates;</code></li></ul><h3 id="8-3-修改存储过程的特性"><a href="#8-3-修改存储过程的特性" class="headerlink" title="8.3 修改存储过程的特性"></a>8.3 修改存储过程的特性</h3><ul><li><code>ALTER PROCEDURE getDates MODIFIES SQL DATA ;</code></li></ul><h3 id="8-4-查看存储过程"><a href="#8-4-查看存储过程" class="headerlink" title="8.4 查看存储过程"></a>8.4 查看存储过程</h3><ul><li><p><code>SHOW PROCEDURE STATUS LIKE &#39;getDates&#39;;</code>    </p><p> 状态</p></li><li><p><code>SHOW CREATE PROCEDURE getDates_3;</code> </p><p> 语句</p></li></ul><h3 id="8-5-调用存储过程"><a href="#8-5-调用存储过程" class="headerlink" title="8.5 调用存储过程"></a>8.5 调用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> getDates();<br><span class="hljs-keyword">CALL</span> getDates_2(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">CALL</span> getDates_3(<span class="hljs-variable">@s</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@s</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">CALL</span> getDates_4(<span class="hljs-variable">@i</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@i</span>;    # <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="9-数据库安全"><a href="#9-数据库安全" class="headerlink" title="9 数据库安全"></a>9 数据库安全</h2><h3 id="9-1-数据库备份"><a href="#9-1-数据库备份" class="headerlink" title="9.1 数据库备份"></a>9.1 数据库备份</h3><ul><li><pre><code>mysqldump -u root -p db_name &gt; file.sqlmysqldump -u root -p db_name table_name &gt; file.sql</code></pre><h3 id="9-2数据库还原"><a href="#9-2数据库还原" class="headerlink" title="9.2数据库还原"></a>9.2数据库还原</h3></li><li><code>mysql -u root -p &lt; C:\file.sql</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>数据库</tag>
      
      <tag>MYSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-排序</title>
    <link href="/2021/03/09/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/03/09/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-题目要求"><a href="#1-题目要求" class="headerlink" title="1.题目要求"></a>1.题目要求</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个无序单链表，实现单链表的排序(按升序排序)。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>说明：本题目包含复杂数据结构ListNode</p><h1 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2.题目分析"></a>2.题目分析</h1><p>该题目主要考察的是排序算法，常用的排序算法可以参考该网站</p><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p><p><img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png" srcset="/img/loading.gif" alt="十种常见排序算法"></p><h1 id="3-解题"><a href="#3-解题" class="headerlink" title="3.解题"></a>3.解题</h1><h2 id="3-1-冒泡排序"><a href="#3-1-冒泡排序" class="headerlink" title="3.1 冒泡排序"></a>3.1 冒泡排序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; head</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; p = head; p.Next != <span class="hljs-literal">null</span>; p = p.Next)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; q = p.Next; q != <span class="hljs-literal">null</span>; q = q.Next)<br>            <span class="hljs-keyword">if</span> (p.Value &gt; p.Next.Value)<br>            &#123;<br>                <span class="hljs-built_in">int</span> t = p.Value;<br>                p.Value = p.Next.Value;<br>                p.Next.Value = t;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-选择排序"><a href="#3-2-选择排序" class="headerlink" title="3.2 选择排序"></a>3.2 选择排序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">selectionSort</span>(<span class="hljs-params">LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; head</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; p = head; p.Next != <span class="hljs-literal">null</span>; p = p.Next)<br>            &#123;<br>                LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; min = <span class="hljs-keyword">new</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">255</span>);<br>                <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; q = p; q.Next != <span class="hljs-literal">null</span>; q = q.Next)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (q.Value &lt; min.Value)<br>                    &#123;<br>                        min = q;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">int</span> t = p.Value;<br>                p.Value = min.Value;<br>                min.Value = t;<br>            &#125;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-插入排序"><a href="#3-3-插入排序" class="headerlink" title="3.3 插入排序"></a>3.3 插入排序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">insertionSort</span>(<span class="hljs-params">LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; head</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">for</span> (LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; p = head.Next; p.Next != <span class="hljs-literal">null</span>; p = p.Next)<br>            &#123;<br>                <span class="hljs-built_in">int</span> t = p.Value;<br>                LinkedListNode&lt;<span class="hljs-built_in">int</span>&gt; q = p.Previous;<br>                <span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">null</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(p.Value&gt;q.Value)<br>                    &#123;<br>                        q.Next.Value= t;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    q.Next.Value = q.Value;<br>                    q = q.Previous;<br>                &#125;                <br>            &#125;<br>                <span class="hljs-keyword">return</span> head;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-希尔排序"><a href="#3-4-希尔排序" class="headerlink" title="3.4 希尔排序"></a>3.4 希尔排序</h2>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序算法</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量基础知识</title>
    <link href="/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在数学中，几何向量（也称为欧几里得向量，通常简称向量、矢量），指具有大小和方向的量。</p><p>向量可以形象化地表示为带箭头的线段。</p><p>箭头所指：代表向量的方向；线段长度：代表向量的大小。</p><p>标量：只有大小,没有方向。</p><h1 id="2-向量的运算"><a href="#2-向量的运算" class="headerlink" title="2. 向量的运算"></a>2. 向量的运算</h1><h2 id="2-1-基础运算"><a href="#2-1-基础运算" class="headerlink" title="2.1 基础运算"></a>2.1 基础运算</h2><table><thead><tr><th>运算</th><th>描述</th></tr></thead><tbody><tr><td>加减</td><td>各个分量分别相加减</td></tr><tr><td>数乘</td><td>向量与标量的乘数，可以对向量的长度进行缩放，如果标量&gt;0，向量的方向不变，如果&lt;0,向量的方向为反方向</td></tr></tbody></table><h2 id="2-2-点乘（点积）"><a href="#2-2-点乘（点积）" class="headerlink" title="2.2 点乘（点积）"></a>2.2 点乘（点积）</h2><p>两个向量点乘得到一个标量 ，数值等于两个向量长度相乘后再乘以二者夹角的余弦值 。<br>如果两个向量a,b均 为单位 向量 ,那么a.b等于向量b在向量a方向上的投影的长度</p><p>点乘后得到的是一个值</p><ul><li><p>若结果 == 0，则 两向量 互垂直 </p></li><li><p>若结果 &lt; 0 ，则 两向量夹角大于90°</p></li><li><p>若结果 &gt;0 ，则两向量夹角小于 90°</p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E4%B9%98.png" srcset="/img/loading.gif" alt="点乘"></p></li></ul><blockquote><p>两个单位向量的点积得到两个向量的夹角的cos值，通过它可以知道两个向量的相似性。</p></blockquote><blockquote><p>利用点积可判断一个多边形是否面向摄像机还是背向摄像机。</p></blockquote><blockquote><p>如果点积越大，说明夹角越小，则物理离光照的轴线越近，光照越强。</p></blockquote><h2 id="2-3-叉乘"><a href="#2-3-叉乘" class="headerlink" title="2.3 叉乘"></a>2.3 叉乘</h2><p>两个向量的叉乘得到一个新的向量，新向量垂直于原来两个向量，并且长度等于原向量长度相乘后再乘以夹角的正弦值，类似左手坐标系Z。</p><p>在Unity3D里面。两个向量的点乘所得到的是两个向量的余弦值，也就是-1 到1之间，0表示垂直，-1表示相反，1表示相同方向。 </p><p>两个向量的叉乘所得到的是两个向量所组成的面的垂直向量，分两个方向。 </p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8F%89%E4%B9%98.png" srcset="/img/loading.gif" alt="叉乘"></p><blockquote><p>简单的说，点乘判断角度，叉乘判断方向。 </p><p>形象的说当一个敌人在你身后的时候，叉乘可以判断你是往左转还是往右转更好的转向敌人，点乘得到你当前的面朝向的方向和你到敌人的方向的所成的角度大小。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>跨专业知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
      <tag>跨专业知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vector3类</title>
    <link href="/2021/02/21/Vector3%E7%B1%BB/"/>
    <url>/2021/02/21/Vector3%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Vector3是结构体,Vector3类在Unity中一般用于表示3D向量和三维坐标点。</p><h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2. 属性"></a>2. 属性</h1><h2 id="2-1静态成员变量"><a href="#2-1静态成员变量" class="headerlink" title="2.1静态成员变量"></a>2.1静态成员变量</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>right</code>（右）</td><td>代表坐标轴（1,0,0）</td></tr><tr><td><code>left</code> （左）</td><td>代表坐标轴（-1,0,0）</td></tr><tr><td><code>up</code>（上）</td><td>代表坐标轴（0,1,0）</td></tr><tr><td><code>down</code>（下）</td><td>代表坐标轴（0,-1,0）</td></tr><tr><td><code>forward</code>  （前）</td><td>代表坐标轴（0,0,1）</td></tr><tr><td><code>back</code>（后）</td><td>代表坐标轴（0,0,-1）</td></tr><tr><td><code>zero</code>（零）</td><td>代表坐标轴（0,0,0）</td></tr><tr><td><code>one</code>（一）</td><td>代表坐标轴（1,1,1）</td></tr></tbody></table><h2 id="2-2-实例成员变量"><a href="#2-2-实例成员变量" class="headerlink" title="2.2 实例成员变量"></a>2.2 实例成员变量</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Magnitude</code></td><td>返回向量的长度，向量的长度是(x<em>x+y</em>y+z*z)的平方根（只读）</td></tr><tr><td><code>Normalized</code></td><td>返回一个归一化的新向量，原向量长度不变</td></tr><tr><td><code>sqrMagnitude</code></td><td>返回向量的长度的平方（只读）</td></tr></tbody></table><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><h2 id="3-1-静态方法"><a href="#3-1-静态方法" class="headerlink" title="3.1 静态方法"></a>3.1 静态方法</h2><table><thead><tr><th>方法名称</th><th>方法体</th><th>描述</th></tr></thead><tbody><tr><td><code>Angle</code></td><td><code>public static float Angle(Vector3 from, Vector3 to);</code></td><td>此方法用于返回向量from和to的夹角，单位为角度，返回值范围为[0,180]，且当from和to中至少有一个为Vector3.zero时，方法返回值为90</td></tr><tr><td><code>ClampMagnitude</code></td><td><code>public static Vector3 ClampMagnitude(Vector3 vector, float maxLength);</code></td><td>此方法用于返回向量vector的一个同方向向量，模长受maxLength限制</td></tr><tr><td><code>Cross</code></td><td><code>public static Vector3 Cross(Vector3 Ihs,Vecxtor3 rhs);</code></td><td>向量叉乘</td></tr><tr><td><code>Dot</code></td><td><code>public static float Dot(Vector3 Ihs, Vector3 rhs);</code></td><td>向量点乘</td></tr><tr><td><code>Lerp</code></td><td><code>public static Vector3 Lerp(Vector3 from, Vector3 to, float t);</code></td><td>参数from为差值起始点坐标，参数to为插值结束点坐标，参数t为插值系数</td></tr><tr><td><code>MoveTowards</code></td><td><code>public static Vector3 MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta);</code></td><td>此方法用于返回一个从参数current到参数target的差值向量</td></tr><tr><td><code>OrthoNormalize</code></td><td><code>public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent);</code></td><td>此方法用于对向量normal进行单位化处理，并对tangent进行正交化处理。即normal变成单位向量，tangent变成与该单位向量垂直的模长为1的向量，且这些向量处于同一平面</td></tr><tr><td><code>OrthoNormalize</code></td><td><code>public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent, ref Vector3 binormal);</code></td><td>此方法用于对向量normal进行单位化处理，并对向量tangent和binormal进行正交化处理，于上面两个参数的重载相同，binormal垂直于normal和tangent组成的平面</td></tr><tr><td><code>Project</code></td><td><code>public static Vector3 Project(Vector3 vector, Vector3 onNormal);</code></td><td>此方法用于返回向量vector在向量onNormal上的投影向量</td></tr><tr><td><code>Reflect</code></td><td><code>public static Vector3 Reflect(Vector3 inDirection, Vector3 inNormal);</code></td><td>参数inDirection为入射向量，inNormal为镜面向量。参数inNormal向量必须为单位向量，否则入射角和反射角不相等。当inNormal取反时，反射向量不受影响</td></tr><tr><td><code>RotateTowards</code></td><td><code>public static Vector3 RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta)</code></td><td>参数current为起始点坐标，参数target为目标点坐标，参数maxRadiansDelta为角度旋转系数，参数maxMagnitudeDelta为模长系数</td></tr><tr><td><code>Scale</code></td><td><code>public static Vector3 Scale(Vector3 a, Vector3 b);</code></td><td>此方法返回向量a和b的乘积</td></tr><tr><td><code>Slerp</code></td><td><code>public static Vector3 Slerp(Vector3 from, Vector3 to, float t);</code></td><td>参数from为插值起始点坐标，参数to为插值结束点坐标，参数t为插值系数。此方法用于返回从参数from点到参数to点的球形差值向量。</td></tr><tr><td><code>SmoothDamp</code></td><td>见下</td><td>见下</td></tr></tbody></table><p> <code>SmoothDamp</code>方法：阻尼运动</p><ul><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime);</code></p></li><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed);</code></p></li><li><p><code>public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed, float maxSpeed);</code></p></li><li><p>参数表</p></li></ul><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td><code>current</code></td><td>起点坐标</td></tr><tr><td><code>target</code></td><td>终点坐标</td></tr><tr><td><code>currentVelocity</code></td><td>当前帧移动向量</td></tr><tr><td><code>smoothTime</code></td><td>接近目标时的阻尼强度</td></tr><tr><td><code>maxSpeed</code></td><td>最大移动速度，默认值为无穷大</td></tr><tr><td><code>deltaTime</code></td><td>控制当前帧实际移动的距离，即为maxSpeed*deltaTime，默认值为Time.deltaTime。</td></tr></tbody></table><h2 id="3-2-实例方法"><a href="#3-2-实例方法" class="headerlink" title="3.2 实例方法"></a>3.2 实例方法</h2><p><code>Scale</code>方法：向量放缩</p><p><code>public void Scale(Vector3 scale);</code></p><p>此方法可以对Vector3实例按参考向量scale进行放缩，即分量依次相乘。</p><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h1><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code></td><td>向量相加</td></tr><tr><td><code>-</code></td><td>向量相减</td></tr><tr><td><code>*</code></td><td>向量乘以标量</td></tr><tr><td><code>/ </code></td><td>向量除以标量</td></tr><tr><td><code>==</code></td><td>若向量相等返回true</td></tr><tr><td><code>!=</code></td><td>若向量不等于则返回true</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vector2类</title>
    <link href="/2021/02/21/Vector2%E7%B1%BB/"/>
    <url>/2021/02/21/Vector2%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Vector2类在Unity中一般用于表示2D向量和二维坐标点。</p><p>例如<a href="https://docs.unity3d.com/530/Documentation/ScriptReference/Mesh.html">Mesh</a>（纹理坐标）或<a href="https://docs.unity3d.com/530/Documentation/ScriptReference/Material.html">Material</a>（纹理偏移）。</p><h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h1><h2 id="2-1-静态属性"><a href="#2-1-静态属性" class="headerlink" title="2.1 静态属性"></a>2.1 静态属性</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><code>down</code></td><td>Vector2（0，-1）的简写</td></tr><tr><td><code>left</code></td><td>Vector2（-1，0）的简写</td></tr><tr><td><code>one</code></td><td>Vector2（1，1）的简写</td></tr><tr><td><code>right</code></td><td>Vector2（1，0）的简写</td></tr><tr><td><code>up</code></td><td>Vector2（0，1）的简写</td></tr><tr><td><code>zero</code></td><td>Vector2（0，0）的简写</td></tr></tbody></table><h2 id="2-2-普通属性"><a href="#2-2-普通属性" class="headerlink" title="2.2 普通属性"></a>2.2 普通属性</h2><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>magnitude</td><td>返回此向量的长度（只读）</td></tr><tr><td>normalized</td><td>返回此向量的归一化（只读）</td></tr><tr><td>sqrMagnitude</td><td>返回此向量的平方长度（只读）</td></tr><tr><td>this[int]</td><td>分别使用[0]或[1]访问x或y分量</td></tr><tr><td><code>x</code></td><td>向量的X分量</td></tr><tr><td><code>y</code></td><td>向量的Y分量</td></tr></tbody></table><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><h2 id="3-1-静态方法"><a href="#3-1-静态方法" class="headerlink" title="3.1 静态方法"></a>3.1 静态方法</h2><table><thead><tr><th>方法名称</th><th>描述</th><th>方法体</th></tr></thead><tbody><tr><td><code>Angle</code></td><td>返回两向量夹角，参数from为起始向量，to为结束向量。此方法用于返回两个Vector2实例的夹角，单位为角度，返回值的取值范围为[0,180]，并且当from和to中至少有一个向量为Vector2.zero的时候返回值为90</td><td><code>public static float Angle(Vector2 from, Vector2 to);</code></td></tr><tr><td><code>ClampMagnitude</code></td><td>此方法用于返回向量的长度，且最大不超过maxLength</td><td><code>public static Vector2 ClampMagnitude(Vector2 vector, float maxLength);</code></td></tr><tr><td><code>Distance</code></td><td>返回两个向量间的距离</td><td></td></tr><tr><td><code>Dot</code></td><td>返回两个向量的点积</td><td></td></tr><tr><td><code>Lerp</code></td><td>向量差值，参数from为插值的起始向量，参数to为插值的结束向量，参数t为插值系数</td><td><code>public static Vector2 Lerp(Vector from, Vector2 to, float t);</code></td></tr><tr><td><code>LerpUnclamped</code></td><td>返回向量在向量a和b之间线性插值t</td><td></td></tr><tr><td><code>Max</code></td><td>返回由两个向量的最大分量组成的向量</td><td></td></tr><tr><td><code>Min</code></td><td>返回由两个向量的最小分量构成的向量</td><td></td></tr><tr><td><code>MoveTowards</code></td><td>向量差值，参数current为移动起始点坐标，参数target为移动目标点，参数maxDistanceDelta为移动的参考系数。</td><td><code>public static Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta);</code></td></tr><tr><td><code>Reflect</code></td><td>返回从法线定义的向量上反射向量</td><td></td></tr><tr><td><code>Scale</code></td><td>向量放缩，此方法用于返回向量a按向量b进行放缩后的值，即向量a，b的乘积</td><td></td></tr><tr><td><code>SmoothDamp</code></td><td>无法理解</td><td></td></tr></tbody></table><blockquote><p><a href="https://blog.csdn.net/andyhebear/article/details/51818534">MoveTowards、Lerp、Slerp三个函数的解析</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/e5b06b7be721">差值函数Lerp和SmoothDamp的解析</a></p></blockquote><h2 id="3-2-公有方法"><a href="#3-2-公有方法" class="headerlink" title="3.2 公有方法"></a>3.2 公有方法</h2><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Normalize</code></td><td>单位化Vector2实例。此方法改变了原始向量，无返回值。实例属性normalized与此方法功能相同，但使用属性normalized来单位化向量时，不改变原始向量值，且有返回值。</td></tr><tr><td><code>Set</code></td><td>设置向量的x,y值</td></tr><tr><td><code>ToString</code></td><td>返回字符串</td></tr></tbody></table><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h1><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>-</code></td><td>向量相减</td></tr><tr><td><code>!=</code></td><td>向量不同，则返回true</td></tr><tr><td><code>*</code></td><td>向量乘以数字</td></tr><tr><td><code>/</code></td><td>向量除以数字</td></tr><tr><td><code>+</code></td><td>向量相加</td></tr><tr><td><code>=</code></td><td>向量相等，则返回true</td></tr><tr><td><code>Vector2</code></td><td>将Vector3转换为Vector2</td></tr><tr><td><code>Vector3</code></td><td>将Vector2转换为Vector3</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transform类</title>
    <link href="/2021/02/19/Transform%E7%B1%BB/"/>
    <url>/2021/02/19/Transform%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><strong>Transform</strong>组件是Unity3D的重点之一，主要用于控制物体的旋转、移动、缩放。</p><p><strong>Unity</strong>规定所有游戏物体都必须<strong>有且只有一个</strong>变换组件(<strong>Transform</strong>)且<strong>不能删除</strong>。</p><p>变换组件(<strong>Transform</strong>)实现了Unity的父子关系功能。</p><p>那么接下来我们将详细学习下<strong>Transform</strong>类所包含的成员变量和成员函数。</p><h1 id="2-父子关系"><a href="#2-父子关系" class="headerlink" title="2. 父子关系"></a>2. 父子关系</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>父子关系是Uniy中重要的基本概念之一。<br>当一个物体是另一个物体的父物体时，子物体会严格地随着父物体起移动、 旋转、缩放。<br>可以将父子关系理解为你的手臂与身体的关系，当身体移动时，手臂也定会跟着一 起移动， 且手臂还可以有自己下一级的子物体，比如手掌就是手名臂的子物体、手指是手掌的子物体等。</p><blockquote><p>在unity中带有local字样的属性也就意味着其数值是相对于父物体的。</p></blockquote><h2 id="2-2-底层原理与规则"><a href="#2-2-底层原理与规则" class="headerlink" title="2.2 底层原理与规则"></a>2.2 底层原理与规则</h2><p>规则：</p><ul><li>任何物体都可以有多个子物体，但是每个物体都只能有一个父物体。</li></ul><p>原理：</p><p>这种父子关系组成一个树状的层级结构，最基层的那个物体是唯一不具有父物体的物体，它被称为根节点。</p><p>由于物体的移动、旋转、缩放与父子关系密切相关，且游戏物体和变换组件是一一对应的。所以在Unity中，游戏物体的层级结构完全可以理解为变换组件的层级结构。父子关系的操作在脚本中确实是在变换组件上进行的。<br>子物体的变换组件的参数其实是相对父物体的值，再次考虑之前身体和手臂的例子，无论身体如何移动，手臂和身体的连接处是固定不变的。</p><h2 id="2-3-关于父子物体的一些现象"><a href="#2-3-关于父子物体的一些现象" class="headerlink" title="2.3 关于父子物体的一些现象"></a>2.3 关于父子物体的一些现象</h2><h3 id="2-3-1-position："><a href="#2-3-1-position：" class="headerlink" title="2.3.1 position："></a>2.3.1 position：</h3><ul><li><p>改变父物体的position，父物体连同子物体一起移动；</p></li><li><p>改变子物体的position，父物体不随子物体移动。</p></li><li><p>当子物体的position设置为（0，0，0）时，子物体与父物体中心点重合。</p></li></ul><h3 id="2-3-2-rotation："><a href="#2-3-2-rotation：" class="headerlink" title="2.3.2 rotation："></a>2.3.2 rotation：</h3><p>介绍两个位于unity快捷工具栏右侧的选项：<strong>Pivot</strong>与<strong>Local</strong></p><ul><li><p><strong>Poivt</strong></p><p>用于调节物体轴心点，有两个子选项</p><ul><li><p>Pivot    父物体的中心点</p></li><li><p>Center 当前父子物体的中心点</p></li></ul></li><li><p><strong>Local</strong><br>用于调节当前被选中物体的坐标轴，有两个子选项</p><ul><li><p>Local    自身坐标系</p></li><li><p>World  世界坐标系</p></li></ul></li></ul><h3 id="2-3-3-Scale"><a href="#2-3-3-Scale" class="headerlink" title="2.3.3 Scale:"></a>2.3.3 Scale:</h3><p><strong>子物体的真实缩放比例Scale=子物体Scale比例×父物体Scale比例</strong></p><p>可以通过下述代码在unity脚本中直接查看：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3 _truthScale = <span class="hljs-keyword">this</span>.transform.LossyScale;<span class="hljs-comment">//此属性为只读属性</span><br></code></pre></td></tr></table></figure><h2 id="2-4-坐标系的选择"><a href="#2-4-坐标系的选择" class="headerlink" title="2.4 坐标系的选择"></a>2.4 坐标系的选择</h2><p>局部坐标与世界坐标各有各的适用情况：</p><ul><li><p>在搭建场景时，我们更喜欢使用局部坐标系<br>比如移动一个房屋时，屋子里所有的东西都会跟着一起移动;</p></li><li><p>而在编写游戏逻辑时，更多的时候需要获得物体在空间中的实际位置。<br>比如我们要将摄像机对准人物的眼睛，这时候眼睛和人物的相对坐标就没有太大价值，而应当让摄像机对准眼睛在世界坐标系中的位置。</p></li></ul><p>所以，在脚本系统中，变换组件的大部分操作都提供了两类操作方式，分别是世界坐标系的和局部坐标系的，我们可以根据需求进行使用。</p><h2 id="2-5-关于父子物体使用的小技巧"><a href="#2-5-关于父子物体使用的小技巧" class="headerlink" title="2.5 关于父子物体使用的小技巧"></a>2.5 关于父子物体使用的小技巧</h2><p>在处理美工交过来的模型时，推荐将模型拉入一个空的gameobject，形成父子物体关系，组件只给空的gameobject上。</p><p>这样就可以防止日后更换模型时需要重新上组件的情况。</p><p>空物体通常用来管理和控制多个相互之间无关联的游戏物体。</p><h1 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3. 成员变量"></a>3. 成员变量</h1><table><thead><tr><th>position</th><th>在世界空间坐标transform的位置。</th></tr></thead><tbody><tr><td>localPosition</td><td>相对于父级的变换的位置。  如果该变换没有父级，那么等同于Transform.position。</td></tr><tr><td>eulerAngles</td><td>世界坐标系中的旋转（欧拉角）。</td></tr><tr><td>localEulerAngles</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>right</td><td>世界坐标系中的右方向。  （世界空间坐标变换的红色轴。也就是x轴。）</td></tr><tr><td>up</td><td>世界坐标系中的上方向。  （在世界空间坐标变换的绿色轴。也就是y轴。）</td></tr><tr><td>forward</td><td>世界坐标系中的前方向。  （在世界空间坐标变换的蓝色轴。也就是z轴。）</td></tr><tr><td>rotation</td><td>世界坐标系中的旋转（四元数）。</td></tr><tr><td>localRotation</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>localScale</td><td>相对于父级的缩放比例。</td></tr><tr><td>parent</td><td>父对象Transform组件。</td></tr><tr><td>worldToLocalMatrix</td><td>矩阵变换的点从世界坐标转为自身坐标（只读）。</td></tr><tr><td>localToWorldMatrix</td><td>矩阵变换的点从自身坐标转为世界坐标（只读）。</td></tr><tr><td>root</td><td>对象层级关系中的根对象的Transform组件。</td></tr><tr><td>childCount</td><td>子对象数量。</td></tr><tr><td>lossyScale</td><td>全局缩放比例（只读）。</td></tr></tbody></table><h1 id="4-成员函数"><a href="#4-成员函数" class="headerlink" title="4. 成员函数"></a>4. 成员函数</h1><h2 id="4-1-LookAt函数"><a href="#4-1-LookAt函数" class="headerlink" title="4.1 LookAt函数"></a>4.1 LookAt函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void LookAt(Transform target);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition, Vector3 worldUp = Vector3.up);</td></tr><tr><td>public void  LookAt(Transform target, Vector3 worldUp = Vector3.up);</td></tr></tbody></table><p>旋转物体，使物体的z轴指向<strong>target/worldPosition</strong>，对于<strong>worldUp</strong>的描述是，在完成上面的旋转之后，继续旋转自身，使得当前对象的正y轴朝向与worldUp所指向的朝向一致。</p><p>这里的朝向一致指的是新旋转后的y轴与<strong>worldUp</strong>在该对象初次旋转后的xy平面上的投影向量一致。之所以取投影是因为第一次旋转使物体的z轴指向<strong>target/worldPosition</strong>后，此时的<strong>worldUp</strong>向量可能不在xy平面上，要在z轴指向<strong>target/worldPosition</strong>前提下是y轴朝向与<strong>worldUp</strong>一致，只能取<strong>worldUp</strong>在xy平面上的投影。</p><blockquote><p>注意：使用<strong>worldPosition向量</strong>时要注意方向，一定是<strong>target-transform.position</strong>，顺序反了会使物体背向目标；若使用<strong>Transform</strong>作为参数，则不必注意。默认情况下，<strong>worldUp</strong>是<strong>Vector3.up</strong>（世界坐标系下的y轴）</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-2-Rotate函数"><a href="#4-2-Rotate函数" class="headerlink" title="4.2 Rotate函数"></a>4.2 Rotate函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 eulerAngles);</td></tr><tr><td>public void  Rotate(Vector3 eulerAngles, Space relativeTo = Space.Self);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo =  Space.Self);</td></tr></tbody></table><p>旋转一个欧拉角度，它按照zxy的顺序进行旋转，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 axis, float angle);</td></tr><tr><td>public void  Rotate(Vector3 axis, float angle,Space relativeTo = Space.Self);</td></tr></tbody></table><p>绕axis轴旋转angle角度，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><p><strong>transform.rotation</strong>和<strong>Rotate</strong>有个区别：</p><ul><li><p>Rotate()方法是： 旋转多少度。</p><p>在原有的基础上累加，即旋转了多少角度。  又旋转了多少角度，是在原有的基础上在旋转</p></li><li><p>rotation属性是：  旋转到某个角度，就是是在update中每帧都执行。 </p><p> 但每次旋转到的角度都是5，所以是旋转到5度。一直都是。 </p></li></ul><p>比如你只想让他旋转到多少, 用rotation; 假如想让他一直转,可以用Rotate</p><p>rotation直接改变了数值, 以达到旋转效果</p><p>Rotate应用一个的旋转角度每秒1度慢慢的旋转物体</p><p>当然:rotation()还可以通过插值旋转</p><h2 id="4-3-RotateAround函数"><a href="#4-3-RotateAround函数" class="headerlink" title="4.3 RotateAround函数"></a>4.3 RotateAround函数</h2><p>让物体以某一点为轴心成圆周运动。</p><p><code>public void RotateAround (point : Vector3, axis : Vector3, angle : float) : void</code></p><p>让物体以<strong>point</strong>为中心，绕<strong>axis</strong>为轴向旋转<strong>angle</strong>度。保持原来与<strong>point</strong>的距离。</p><h2 id="4-4-TransformDirection函数"><a href="#4-4-TransformDirection函数" class="headerlink" title="4.4 TransformDirection函数"></a>4.4 TransformDirection函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public Vector3  TransformDirection(Vector3 direction);</td></tr><tr><td>public Vector3  TransformDirection(float x, float y, float z);</td></tr></tbody></table><p>从自身坐标到世界坐标变换方向（这个强调的是方向）这个操作不会受到变换的缩放和位置的影响。</p><p>返回的向量与<strong>direction</strong>有同样的长度。</p><h2 id="4-5-InverseTransformDirection函数"><a href="#4-5-InverseTransformDirection函数" class="headerlink" title="4.5 InverseTransformDirection函数"></a>4.5 InverseTransformDirection函数</h2><table><thead><tr><th>重载的多种函数</th></tr></thead><tbody><tr><td>public Vector3  InverseTransformDirectionTransformDirection (direction : Vector3)  : Vector3</td></tr><tr><td>public Vector3  InverseTransformDirectionTransformDirection (x : float, y : float,  z : float) : Vector3</td></tr></tbody></table><p>与<strong>TransformDirection</strong>相反，从世界坐标转换到自身相对坐标。</p><h2 id="4-6-TransformPoint函数"><a href="#4-6-TransformPoint函数" class="headerlink" title="4.6 TransformPoint函数"></a>4.6 TransformPoint函数</h2><table><thead><tr><th>public Vector3  TransformPoint(Vector3 position);</th></tr></thead><tbody><tr><td>public Vector3  TransformPoint(float x, float y, float z);</td></tr></tbody></table><p>变换位置从自身坐标到世界坐标。</p><p>注意，返回位置受缩放影响</p><h2 id="4-7-InverseTransformPoint函数"><a href="#4-7-InverseTransformPoint函数" class="headerlink" title="4.7 InverseTransformPoint函数"></a>4.7 InverseTransformPoint函数</h2><table><thead><tr><th>public  Vector3 InverseTransformPoint (position : Vector3)  : Vector3</th></tr></thead><tbody><tr><td>public  Vector3 InverseTransformPoint (x : float, y : float, z  : float) : Vector3</td></tr></tbody></table><p>把一个点从时间坐标转换到自身坐标的位置。</p><h2 id="4-8-TransformVector函数"><a href="#4-8-TransformVector函数" class="headerlink" title="4.8 TransformVector函数"></a>4.8 TransformVector函数</h2><table><thead><tr><th>public Vector3  TransformVector(Vector3 vector);</th></tr></thead><tbody><tr><td>public Vector3  TransformVector(float x, float y, float z);</td></tr></tbody></table><p>变换一个向量从局部坐标空间到世界坐标空间。</p><p>这个操作不受变换位置的影响，但是受缩放的影响</p><h2 id="4-9-Translate函数"><a href="#4-9-Translate函数" class="headerlink" title="4.9 Translate函数"></a>4.9 Translate函数</h2><table><thead><tr><th>public void  Translate(Vector3 translation);</th></tr></thead><tbody><tr><td>public void  Translate(Vector3 translation, Space relativeTo = Space.Self);</td></tr></tbody></table><p>沿着<strong>translation</strong>方向移动<strong>translation</strong>向量长度的距离。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(float x, float y, float z);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Space relativeTo = Space.Self);</td></tr></tbody></table><p>移动变换由x沿着x轴，y沿着y轴，z沿着z轴。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(Vector3 translation, Transform relativeTo);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Transform relativeTo);</td></tr></tbody></table><p>第一个参数的解释跟前面的一样，重点在移动<strong>relativeTo</strong>，解释为被应用相对于（relativeTo :Transform）的自身坐标系统。</p><p>日光相对于为<strong>null</strong>，则移动被应用相对于世界坐标系统</p><p>例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//相对于摄像机每秒1单位向右移动物体</span><br><br>transform.Translate(Vector3.right * Time.deltaTime, Camera.main.transform);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-10-DetachChildren函数"><a href="#4-10-DetachChildren函数" class="headerlink" title="4.10 DetachChildren函数"></a>4.10 DetachChildren函数</h2><p><code>public void DetachChildren () : void</code></p><p>把自身所有的子物体的父物体都设成世界，也就是跟自己的所有子物体接触父子关系。</p><h2 id="4-11-Find-函数"><a href="#4-11-Find-函数" class="headerlink" title="4.11 Find 函数"></a>4.11 <strong>Find</strong> <strong>函数</strong></h2><p><code>public Transform Find (name : string) : Transform</code></p><p>找到一个名字是name的物体并返回</p><p>如果没有找到则返回null。如果字符串被/隔离，函数则会像文件路径一样逐级下查。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// The magical rotating finger</span><br><br><span class="hljs-function">function <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>aFinger = transform.Find(<span class="hljs-string">&quot;LeftShoulder/Arm/Hand/Finger&quot;</span>);<br><br>aFinger.Rotate(Time.deltaTime*<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-12-IsChildOf函数"><a href="#4-12-IsChildOf函数" class="headerlink" title="4.12 IsChildOf函数"></a>4.12 IsChildOf函数</h2><p><code>public bool IsChildOf (parent : Transform) : bool</code></p><p>如果物体是<strong>parent</strong>的父子层级关系下的一员，返回<strong>true</strong>;</p><h1 id="5-组件使用注意事项"><a href="#5-组件使用注意事项" class="headerlink" title="5. 组件使用注意事项"></a>5. 组件使用注意事项</h1><h2 id="5-1-非等比缩放的问题"><a href="#5-1-非等比缩放的问题" class="headerlink" title="5.1 非等比缩放的问题"></a>5.1 非等比缩放的问题</h2><p>某些组件不完全支持非等比缩放，在非等比缩放的情况下可能会出现意想不到的结果。<br>因为当该游戏物体具有一个球体或者胶囊体的外壳，而这些外壳的大小是通过一个半径参数指定的。<br>在物体或者父物体被拉伸或压扁的时候，这些组件的球体范围并不会跟着压扁成椭球体，它们实际上仍然是球体或胶囊体。<br>所以当物体中具有这类组件时，由于组件形状和物体形状不一致，可能会导致穿透模型被意外阻挡等情况发生。</p><p>例如，碰撞体、角色控制器这些组件和灯光、音源。</p><p>这些问题不致命，但是会引起奇怪的bug。</p><h2 id="5-2-其它注意事项"><a href="#5-2-其它注意事项" class="headerlink" title="5.2 其它注意事项"></a>5.2 其它注意事项</h2><ul><li>当为一个物体添加子物体时， 可以考虑先将父物体的位置设置为原点，这样子物体的局部坐标系就和世界坐标系重合，方便我们指定子物体的准确位置。</li><li>粒子系统不会受变换组件的缩放系数的影响。要改变- -个粒子的整体比例，还是需要在粒子系统中适当改变相关参数。</li><li>修改物体缩放比例时不仅会直接影响子物体的比例，还会影响子物体的实际位置(因为要保证相对位置不变)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MonoBehaviour基类</title>
    <link href="/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/"/>
    <url>/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-脚本基类-MonoBehaviour"><a href="#Unity-脚本基类-MonoBehaviour" class="headerlink" title="Unity 脚本基类 MonoBehaviour"></a>Unity 脚本基类 MonoBehaviour</h1><h2 id="1-MonoBehaviour-简介"><a href="#1-MonoBehaviour-简介" class="headerlink" title="1. MonoBehaviour 简介"></a>1. MonoBehaviour 简介</h2><p><strong>MonoBehaviour</strong> 是 <strong>Unity</strong> 中所有脚本的基类。</p><p>如果你使用<strong>JS</strong>的话，脚本会自动继承<strong>MonoBehaviour</strong>。</p><p>如果使用<strong>C#**的话，你需要显式继承</strong>MonoBehaviour**。</p><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><p>下面用一张图来更形象地说明一下这几个类的在<strong>MonoBehaviour</strong>的<em>生命周期</em>中是如何被调用的：<br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125028717" srcset="/img/loading.gif" alt="这里写图片描述"></p><h2 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h2><h3 id="3-1-不可重写函数："><a href="#3-1-不可重写函数：" class="headerlink" title="3.1 不可重写函数："></a>3.1 不可重写函数：</h3><h4 id="3-1-1-Invoke函数"><a href="#3-1-1-Invoke函数" class="headerlink" title="3.1.1 Invoke函数"></a>3.1.1 Invoke函数</h4><p><code>function Invoke (methodName : string, time : float) : void</code><br>在 <strong>time</strong> 秒之后，调用 <strong>methodName</strong> 方法；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">example</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><span class="hljs-keyword">public</span> Rigidbody projectile;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchProjectile</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Rigidbody instance = Instantiate(projectile);<br>    instance.velocity = Random.insideUnitSphere * <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Invoke(<span class="hljs-string">&quot;LaunchProjectile&quot;</span>, <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-InvokeRepeating"><a href="#3-1-2-InvokeRepeating" class="headerlink" title="3.1.2 InvokeRepeating"></a>3.1.2 InvokeRepeating</h4><p><code>function InvokeRepeating (methodName : string, time : float, repeatRate : float) : void</code><br>从第一次调用开始,每隔<strong>repeatRate</strong>时间调用一次.</p><h4 id="3-1-3-CancelInvoke"><a href="#3-1-3-CancelInvoke" class="headerlink" title="3.1.3 CancelInvoke"></a>3.1.3 CancelInvoke</h4><p><code>function CancelInvoke () : void</code><br>取消这个<strong>MonoBehaviour</strong>上的所有调用<strong>Invoke</strong>。</p><h4 id="3-1-4-IsInvoking"><a href="#3-1-4-IsInvoking" class="headerlink" title="3.1.4 IsInvoking"></a>3.1.4 IsInvoking</h4><p><code>function IsInvoking (methodName : string) : bool</code><br>某指定函数是否在等候调用。</p><h4 id="3-1-5-StartCoroutine"><a href="#3-1-5-StartCoroutine" class="headerlink" title="3.1.5 StartCoroutine"></a>3.1.5 StartCoroutine</h4><p><code>function StartCoroutine (routine : IEnumerator) : Coroutine</code><br>一个协同程序在执行过程中,可以在任意位置使用 <strong>yield</strong> 语句。</p><p><strong>yield</strong> 的返回值控制何时恢复协同程序向下执行。</p><p>协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。</p><p><strong>StartCoroutine</strong>函数是立刻返回的,但是<strong>yield</strong>可以延迟结果。直到协同程序执行完毕。</p><h4 id="3-1-6-StopCoroutine-StopAllCoroutines"><a href="#3-1-6-StopCoroutine-StopAllCoroutines" class="headerlink" title="3.1.6 StopCoroutine / StopAllCoroutines"></a>3.1.6 StopCoroutine / StopAllCoroutines</h4><h3 id="3-2-可重写函数："><a href="#3-2-可重写函数：" class="headerlink" title="3.2 可重写函数："></a>3.2 可重写函数：</h3><p>可重写函数会在游戏中发生某些事件的时候被调用。</p><p>我们在<strong>Unity</strong>中最常用到的几个可重写函数是这几个：</p><table><thead><tr><th align="left">可重写函数</th><th>描述</th></tr></thead><tbody><tr><td align="left"><code>Awake</code></td><td>当一个脚本被实例化时，<strong>Awake</strong> 被调用。我们大多在这个类中完成成员变量的初始化。</td></tr><tr><td align="left"><code>Start</code></td><td>仅在 <strong>Update</strong> 函数第一次被调用前调用。因为它是在<strong>Awake</strong> 之后被调用的，我们可以把一些需要依赖 <strong>Awake</strong> 的变量放在<strong>Start</strong>里面初始化。 同时我们还大多在这个类中执行 <strong>StartCoroutine</strong> 进行一些协程的触发。要注意在用C#写脚本时，必须使用 <strong>StartCoroutine</strong> 开始一个协程，但是如果使用的是 <strong>JavaScript</strong>，则不需要这么做。</td></tr><tr><td align="left"><code>Update</code></td><td>当开始播放游戏帧时（此时，<strong>GameObject</strong> 已实例化完毕），其 **Update **在 每一帧 被调用。</td></tr><tr><td align="left"><code>LateUpdate</code></td><td><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。</td></tr><tr><td align="left"><code>FixedUpdate</code></td><td>当 <strong>MonoBehaviour</strong>启用时，其 <strong>FixedUpdate</strong> 在每一固定帧被调用</td></tr><tr><td align="left"><code>OnEnable</code></td><td>当对象变为可用或激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDisable</code></td><td>当对象变为不可用或非激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDestroy</code></td><td>当 <strong>MonoBehaviour</strong> 将被销毁时，这个函数被调用</td></tr></tbody></table><h4 id="3-2-1-Update"><a href="#3-2-1-Update" class="headerlink" title="3.2.1 Update"></a>3.2.1 Update</h4><p>当 <strong>MonoBehaviour</strong> 实例化完成之后，<strong>Update</strong> 在每一帧被调用。</p><p>所以Update函数可以用来实现用户输入、角色移动和角色行动等功能。</p><p>基本上大部分游戏逻辑都离不开Update函数。</p><p>Unity 提供了非常多的基本方法来读取输入、查找某个游戏物体、查找组件、修改组件信息等，这些方法都可以在Update函数中使用，用来完成实际的游戏功能。</p><h4 id="3-2-2-LateUpdate"><a href="#3-2-2-LateUpdate" class="headerlink" title="3.2.2 LateUpdate"></a>3.2.2 LateUpdate</h4><p><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。这可用于调整脚本执行顺序。</p><p>例如:当物体在Update里移动时，跟随物体的相机可以在<strong>LateUpdate</strong>里实现。</p><h4 id="3-2-3-FixedUpdate"><a href="#3-2-3-FixedUpdate" class="headerlink" title="3.2.3 FixedUpdate"></a>3.2.3 FixedUpdate</h4><p>处理 <strong>Rigidbody</strong> 时，需要用<strong>FixedUpdate</strong>代替<strong>Update</strong>。</p><p>例如:给刚体加一个作用力时，你必须应用作用力在<strong>FixedUpdate</strong>里的固定帧，而不是<strong>Update</strong>中的帧。(两者帧长不同)</p><h4 id="3-2-4-Awake"><a href="#3-2-4-Awake" class="headerlink" title="3.2.4 Awake"></a>3.2.4 Awake</h4><p><strong>Awake</strong> 用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次。<strong>Awake</strong> 在所有对象被初始化之后调用，所以你可以安全的与其他对象对话或用诸如 <strong>GameObject.FindWithTag</strong> 这样的函数搜索它们。</p><p>每个游戏物体上的<strong>Awke</strong>以随机的顺序被调用。因此，你应该用<strong>Awake</strong>来设置脚本间的引用，并用<strong>Start</strong>来传递信息<strong>Awake</strong>总是在<strong>Start</strong>之前被调用。它不能用来执行协同程序。</p><p>C#和Boo用户注意：<strong>Awake</strong> 不同于构造函数，物体被构造时并没有定义组件的序列化状态。<strong>Awake</strong>像构造函数一样只被调用一次。</p><h4 id="3-2-5-Start"><a href="#3-2-5-Start" class="headerlink" title="3.2.5 Start"></a>3.2.5 Start</h4><p><strong>Start</strong>在<strong>behaviour</strong>的生命周期中只被调用一次。<br>它和 <strong>Awake</strong> 的不同是，<strong>Start</strong> 只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。<strong>Awake</strong> 总是在<strong>Start</strong>之前执行。</p><p>Start函数适合用来做一些初始化工作。<br>对有经验的程序编写者来说，要注意脚本组件通常不使用构造函数来做初始化，因为构造函数可控制性较差，会导致调用时机和预想的不一致。 所以最好的方式是遵循Unity的设计惯例。</p><h4 id="3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag"><a href="#3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag" class="headerlink" title="3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag"></a>3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag</h4><p>当鼠标进入 ／ 悬浮 ／ 移出 ／ 点击 ／ 释放 ／ 拖拽<strong>GUIElement</strong>(GUI元素)或<strong>Collider</strong>(碰撞体)中时调用<strong>OnMouseEnter</strong>。</p><h4 id="3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay"><a href="#3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay" class="headerlink" title="3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay"></a>3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay</h4><p>当<strong>Collider</strong>(碰撞体)进入 ／ 退出 ／ 停留在 <strong>trigger</strong>(触发器)时调用<strong>OnTriggerEnter</strong>。</p><p><strong>OnTriggerStay</strong> 将会在每一帧被调用。</p><h4 id="3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay"><a href="#3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay" class="headerlink" title="3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay"></a>3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay</h4><p>当此<strong>collider/rigidbody</strong>触发另一个<strong>rigidbody/collider</strong>时，被调用。</p><p><strong>OnCollisionStay</strong> 将会在每一帧被调用。</p><h2 id="4-脚本与GameObject的关系"><a href="#4-脚本与GameObject的关系" class="headerlink" title="4. 脚本与GameObject的关系"></a>4. 脚本与GameObject的关系</h2><p>被显式添加到 <strong>Hierarchy</strong> 中的 <strong>GameObject</strong> 会被最先实例化，<strong>GameObject</strong> 被实例化的顺序是从下往上。<strong>GameObject</strong> 被实例化的同时，加载其组件 <strong>component</strong> 并实例化，如果挂载了脚本组件，则实例化脚本组件时，将调用脚本的 <strong>Awake</strong> 方法，组件的实例化顺序是也是从下往上。在所有显式的 <strong>GameObject</strong> 及其组件被实例化完成之前，游戏不会开始播放帧。</p><p>当 <strong>GameObject</strong> 实例化工作完成之后，将开始播放游戏帧。每个脚本的第一帧都是调用 <strong>Start</strong> 方法，其后每一帧调用 <strong>Update</strong>，而且每个脚本在每一帧中的调用顺序是从下往上。</p><blockquote><p>总结：被挂载到 <strong>GameObject</strong> 下面的脚本会被实例化成 <strong>GameObject</strong> 的一个成员。</p></blockquote><h3 id="4-1-脚本变量的引用"><a href="#4-1-脚本变量的引用" class="headerlink" title="4.1 脚本变量的引用"></a>4.1 脚本变量的引用</h3><p>在脚本中声明另一个脚本的变量。在 <strong>ClassA</strong> 中建立一个 <strong>public</strong> 的变量类型是 <strong>ClassB</strong>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-非同一个-GameObject-的脚本引用"><a href="#4-1-1-非同一个-GameObject-的脚本引用" class="headerlink" title="4.1.1 非同一个 GameObject 的脚本引用"></a>4.1.1 非同一个 GameObject 的脚本引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125148891" srcset="/img/loading.gif" alt="这里写图片描述"><br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125157563" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，如果 <strong>classA</strong> 中的成员 <strong>B</strong> 想要引用由 <strong>GameObjectB</strong> new 出来的 <strong>classB</strong> 对象，只需要将 <strong>GameObjectB</strong> 拖拽到 <strong>GameObjectA</strong> 中 <strong>classA</strong> 脚本即可。</p><h4 id="4-1-2-同一个-GameObject-中互相引用"><a href="#4-1-2-同一个-GameObject-中互相引用" class="headerlink" title="4.1.2 同一个 GameObject 中互相引用"></a>4.1.2 同一个 GameObject 中互相引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125328273" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，发现没法通过拖拽的方式建立 <strong>classA</strong> 和 <strong>classB</strong> 的引用。因为 <strong>Unity</strong> 编辑器里面的拖拽绑定方式是 <strong>GameObject</strong> 级别的。</p><p>那么此时如何解决互相引用的问题呢？此时，需要用到 <strong>gameObject</strong> 这个变量。</p><p>被挂载到 <strong>GameObject</strong> 中的脚本，被实例化时，其内部继承自 <strong>Monobehavior</strong> 的 <strong>gameObject</strong> 成员会绑定所挂载的 <strong>GameObject</strong> 对象。可以注意到，在本例中，<strong>classA</strong> 和 <strong>classB</strong> 都是同一个 <strong>GameObject</strong> 下的组件，所以通过 <strong>GetComponent</strong> 便可以获得另一个脚本变量的引用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>        b = gameObject.GetComponent (<span class="hljs-string">&quot;ClassB&quot;</span>) <span class="hljs-keyword">as</span> ClassB;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>       a = gameObject.GetComponent (<span class="hljs-string">&quot;ClassA&quot;</span>) <span class="hljs-keyword">as</span> ClassA;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-父子关系的-GameObject-中引用"><a href="#4-1-3-父子关系的-GameObject-中引用" class="headerlink" title="4.1.3 父子关系的 GameObject 中引用"></a>4.1.3 父子关系的 GameObject 中引用</h4><p>把问题引申一步,还是那两个脚本<strong>ClassA</strong>,<strong>ClassB</strong>,不过这回不是绑在同一个<strong>GameObject</strong>上面，而是分辨绑定在两个<strong>GameObject</strong>：Parent(ClassA),Child(ClassB)</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125418710" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>首先还是来尝试拖拽，虽然无法在Unity的编辑器中通过拖拽互相引用脚本(Componet),不过绑定 <strong>GameObject</strong> 是可以的。所以只需要建立两个<strong>public</strong>的变量，然后类型都是 <strong>GameObject</strong>，在Unity里面互相拖拽引用,最后在 <strong>Start</strong> 函数时候通过已经绑定好的 <strong>gameObject</strong> 调用其 <strong>GetComponent</strong> 方法即可。</p><p>的确，这个方法是可行，不过有个更好的方法就是使用 <strong>Transform</strong>。<strong>Transform</strong> 是一个很特殊的<strong>Component</strong>，其内部保留着 <strong>GameObject</strong>之间的显示树结构.所以就上面的例子来说，当要从 <strong>Child</strong> 访问到 <strong>Parent</strong>，只需要在 <strong>Child</strong> 对应的脚本里面写 <code>transform.parent.gameObject.GetComponent() </code>即可</p><p>返过来就相对麻烦一点,因为无法保证一个<strong>parent</strong>只有一个<strong>child</strong>，所以无法简单的使用 <strong>transform.child.gameObject</strong>这样访问, 但是Unity给我们提供了一个很方便的函数，那就是<strong>Find</strong>。</p><p>需要注意的是<strong>Find</strong>只能查找其<strong>Child</strong>,举个复杂点的例子</p><p><strong>Parent-&gt;ChildA-&gt;ChildB-&gt;ChildC</strong></p><p>当在 <strong>Patent</strong> 中想要找到 <strong>ChildC</strong>中的一个<strong>Component</strong>时候，调用 <code>transform.Find(“ChildA/ChildB/ChildC”).gameObject;</code></p><h2 id="5-普通类与继承MonoBehaviour类的区别："><a href="#5-普通类与继承MonoBehaviour类的区别：" class="headerlink" title="5. 普通类与继承MonoBehaviour类的区别："></a>5. 普通类与继承MonoBehaviour类的区别：</h2><ul><li><p>1.继承<strong>MonoBehaviour</strong>的类不需要创建它的实例，也不能自己创建(用new)，因为从<strong>MonoBehaviour</strong>继承过来的类Unity会自动创建实例，并且调用被重载的函数(Awake，Start…..)。</p><p>如果用new会出现警告，警告说的很明显，就是如果继承了MonoBehaviour就不允许你用new创建，你可以用添加组件的方式替代，或者根本没有基类(不继承MonoBehaviour的普通类)，但是好像并不影响程序，这点很奇怪。</p></li><li><p>2.不继承MonoBehaviour不能使用Invoke，Coroutine，print以及生命周期函数等。</p></li><li><p>3.不继承MonoBehaviour不能挂在到Inspector上，也就是说不能当组件使用也不能看到一些数据。</p></li></ul><h2 id="6-MonoBehaviour-的那些坑"><a href="#6-MonoBehaviour-的那些坑" class="headerlink" title="6. MonoBehaviour 的那些坑"></a>6. MonoBehaviour 的那些坑</h2><ul><li><strong>私有（private）</strong>和<strong>保护（protected）</strong>变量只能在<strong>专家模式</strong>中显示。属性不被序列化或显示在检视面板。</li><li>不要使用<strong>命名空间（namespace）</strong></li><li>记得使用 缓存组件查找， 即在<strong>MonoBehaviour</strong>的长远方法中经常被访问的组件最好在把它当作一个私有成员变量存储起来。</li><li>在游戏里经常出现需要检测敌人和我方距离的问题，这时如果要寻找所有的敌人，显然要消耗的运算量太大了，所以最好的办法是将攻击范围使用<strong>Collider</strong>表示，然后将<strong>Collider</strong>的<strong>isTrigger</strong>设置为<strong>True</strong>。最后使用<strong>OnTriggerEnter</strong>来做攻击范围内的距离检测，这样会极大提升程序性能。</li></ul><blockquote><p>整理自: <a href="https://blog.csdn.net/hihozoo/article/details/66970467">https://blog.csdn.net/hihozoo/article/details/66970467</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Unity基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客中添加音乐播放器</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是介绍基于网易云iframe插件在hexo博客中加装音乐播放器的方法，无需安装任何额外插件。</p><h1 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2.安装步骤"></a>2.安装步骤</h1><ol><li><p>在网易云音乐中打开你想要插入的音乐页面，点击 <strong>生成外联播放器</strong>。</p></li><li><p>在网页中调整好播放器插件后，复制下方的HTML代码。</p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">330</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=1488285208&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>打开本地架设hexo博客的文件夹，寻找正在使用主题文件夹下的layout文件夹。</p><p>例如我在使用的fluid主题的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">F:\MyBlog\node_modules\hexo-theme-fluid\layout<br></code></pre></td></tr></table></figure></li><li><p>在layout文件夹下寻找你想要添加音乐播放器位置的ejs文件。</p><p>例如我想放在所有页面的页脚，则ejs文件的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\layout\_partial\footer.ejs<br></code></pre></td></tr></table></figure></li><li><p>打开ejs文件(可以用vscode或者记事本)，找到生成相关位置html文件的代码。</p><p>这些ejs文件相当于是生成html文件的模板。</p></li><li><p>将复制来的HTML代码加上div加进相关的位置</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center mt-5 py-3&quot;</span>&gt;</span>//原本的页脚生成代码<br>--------------------------------------------------------<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;music-player&quot;</span>&gt;</span>//复制来的外链播放器插件代码<br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">530</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=572328440&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;&gt;</span><br>---------------------------------------------------------<br>  //原本的页脚生成代码<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer-content&quot;</span>&gt;</span><br>  &lt;%- theme.footer.content %&gt;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> &lt;%- partial(&#x27;_partial/statistics.ejs&#x27;) %&gt;<br> &lt;%- partial(&#x27;_partial/beian.ejs&#x27;) %&gt;<br> &lt;% if(theme.web_analytics.cnzz) &#123; %&gt;<br>  *<span class="hljs-comment">&lt;!-- cnzz Analytics Icon --&gt;</span>*<br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cnzz_stat_icon_&lt;%- theme.web_analytics.cnzz %&gt;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> &lt;% &#125; %&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>清理服务器缓存后再重新部署，音乐播放器就出现在对应位置了！</p></li></ol><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h1><blockquote><p>音乐不能是网易云里的VIP音乐，它是不会给你播的</p></blockquote><blockquote><p>当页面转换或者刷新时，播放器状态将被重置，目前还没有办法解决</p></blockquote><h1 id="4-其它的实现方法"><a href="#4-其它的实现方法" class="headerlink" title="4.其它的实现方法"></a>4.其它的实现方法</h1><p>在hexo框架的基础下，还可以用音乐播放插件<strong>Aplayer</strong>来实现。</p><p>相关链接：<a href="https://aplayer.js.org/#/zh-Hans/"><strong>Aplayer</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown快速入门</title>
    <link href="/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>.md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言。</p><p>本博客中的所有文章都是用.md文件编写的，而且很多企业也在在鼓励使用这种编辑方式。</p><h1 id="1-基本符号：-gt"><a href="#1-基本符号：-gt" class="headerlink" title="1.基本符号：* - +. &gt;"></a>1.基本符号：* - +. &gt;</h1><p>基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。</p><h1 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h1><p>分别表示h1-h6,只到h6，而且h1下面会有一条横线。</p><p>有两种方法，一种是只在前面加#，另一种是闭合式标签，两者效果相同。</p><p>例如：</p><p>方法一：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 </span><br><span class="hljs-section">## 二级标题 </span><br><span class="hljs-section">### 三级标题 </span><br><span class="hljs-section">#### 四级标题 </span><br><span class="hljs-section">##### 五级标题 </span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 # </span><br><span class="hljs-section">## 二级标题 ## </span><br><span class="hljs-section">### 三级标题 ### </span><br><span class="hljs-section">#### 四级标题 #### </span><br><span class="hljs-section">##### 五级标题 ##### </span><br><span class="hljs-section">###### 六级标题 #####</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h1><h2 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//形式一 <br><span class="hljs-bullet">+</span> a <br><span class="hljs-bullet">+</span> b <br><span class="hljs-bullet">+</span> c <br>//形式二<br><span class="hljs-bullet">-</span> d <br><span class="hljs-bullet">-</span> e <br><span class="hljs-bullet">-</span> f <br>//形式三 <br><span class="hljs-bullet">*</span> g <br><span class="hljs-bullet">*</span> h <br><span class="hljs-bullet">*</span> i<br></code></pre></td></tr></table></figure><p>以上三种形式，效果其实都是一样的：</p><ul><li>a </li><li>b </li><li>c </li></ul><ul><li>d </li><li>e </li><li>f </li></ul><ul><li>g </li><li>h </li><li>i</li></ul><h2 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//正常形式<br><span class="hljs-bullet">1.</span> abc<br><span class="hljs-bullet">2.</span> bcd<br><span class="hljs-bullet">3.</span> cde<br>//错序效果<br><span class="hljs-bullet">2.</span> fgh<br><span class="hljs-bullet">3.</span> ghi<br><span class="hljs-bullet">5.</span> hij<br></code></pre></td></tr></table></figure><p>效果如下：</p><ol><li><p>abc</p></li><li><p>bcd</p></li><li><p>cde</p></li><li><p>fgh</p></li><li><p>ghi</p></li><li><p>hij</p></li></ol><blockquote><p>注意，数字后面的点只能是英文的点，有序列表的序号是根据第一行列表的数字顺序来的，错序列表的序号本来是序号是乱的， 但是还是显示 4 5 6</p></blockquote><h1 id="4-引用说明区块"><a href="#4-引用说明区块" class="headerlink" title="4.引用说明区块"></a>4.引用说明区块</h1><p>对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。</p><h2 id="4-1-正常形式"><a href="#4-1-正常形式" class="headerlink" title="4.1 正常形式"></a>4.1 正常形式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 引用内容、说明内容。</span><br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>引用内容、说明内容。<br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</p></blockquote><h2 id="4-2-嵌套区块"><a href="#4-2-嵌套区块" class="headerlink" title="4.2 嵌套区块"></a>4.2 嵌套区块</h2><p>这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 一级引用 </span><br>&gt;&gt; 二级引用 <br>&gt;&gt;&gt; 三级引用 <br>&gt;&gt;&gt;&gt; 四级引用 <br>&gt;&gt;&gt;&gt;&gt; 五级引用 <br>&gt;&gt;&gt;&gt;&gt;&gt; 六级引用<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>一级引用 </p><blockquote><p>二级引用 </p><blockquote><p>三级引用 </p><blockquote><p>四级引用 </p><blockquote><p>五级引用 </p><blockquote><p>六级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5. 代码块"></a>5. 代码块</h1><p>在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。</p><h2 id="5-1-少量代码，单行使用，直接用-包裹起来就行了"><a href="#5-1-少量代码，单行使用，直接用-包裹起来就行了" class="headerlink" title="5.1 少量代码，单行使用，直接用`包裹起来就行了"></a>5.1 少量代码，单行使用，直接用`包裹起来就行了</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`shaoliangdaima,danhangshiyong`</span> <br></code></pre></td></tr></table></figure><p>效果如下：</p><p><code>shaoliangdaima,danhangshiyong</code></p><h2 id="5-2大量代码，需要多行使用，用-包裹起来"><a href="#5-2大量代码，需要多行使用，用-包裹起来" class="headerlink" title="5.2大量代码，需要多行使用，用```包裹起来"></a>5.2大量代码，需要多行使用，用```包裹起来</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">​<span class="hljs-code">```</span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong    </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong   </span><br><span class="hljs-code">​```</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong    <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong   <br></code></pre></td></tr></table></figure><h1 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h1><h2 id="6-1行内式"><a href="#6-1行内式" class="headerlink" title="6.1行内式"></a>6.1行内式</h2><p>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">烤麸的博客</span>](<span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot;</span>), 是烤麸自己学习用的博客<br></code></pre></td></tr></table></figure><h2 id="6-2参数式"><a href="#6-2参数式" class="headerlink" title="6.2参数式"></a>6.2参数式</h2><p>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot; </span><br>[烤麸的博客]是烤麸自己学习用的博客。 <br>//参数定义的其他写法 <br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ &#x27;烤麸的博客&#x27; </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ (烤麸的博客) </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">&lt;https://mycroftcooper.github.io/&gt; &quot;烤麸的博客&quot;</span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果都是一样的，如下：</p><p><a href="https://mycroftcooper.github.io/%22%E7%83%A4%E9%BA%B8%E7%9A%84%E5%8D%9A%E5%AE%A2%22">烤麸的博客</a>, 是烤麸自己学习用的博客</p><h1 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h1><h2 id="7-1-行内式"><a href="#7-1-行内式" class="headerlink" title="7.1 行内式"></a>7.1 行内式</h2><p>和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）</p><blockquote><p>注意的是[]前要加上!</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">markdown快速入门示例图.png</span>](<span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="7-2-参数式"><a href="#7-2-参数式" class="headerlink" title="7.2 参数式"></a>7.2 参数式</h2><p>图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">markdown快速入门示例图.png</span>]: <span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot; ![markdown快速入门示例图.png] </span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果图都是一样的，如下：</p><p><img src="/images/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="markdown快速入门示例图"></p><h1 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8. 分割线"></a>8. 分割线</h1><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">--- - - - ------ *** * * * ****** ___ _ _ _ ______<br></code></pre></td></tr></table></figure><p>以上代码的效果均为：</p><hr><h1 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h1><h2 id="9-1-强调字体"><a href="#9-1-强调字体" class="headerlink" title="9.1 强调字体"></a>9.1 强调字体</h2><p>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*md*</span>   <span class="hljs-strong">**md**</span> <span class="hljs-emphasis">_md_</span>   <span class="hljs-strong">__md__</span><br></code></pre></td></tr></table></figure><p>效果：<br><em>md</em><br><strong>md</strong><br><em>md</em><br><strong>md</strong></p><h2 id="9-2-转义"><a href="#9-2-转义" class="headerlink" title="9.2 转义"></a>9.2 转义</h2><p>基本上和js转义一样,\加需要转义的字符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\\ <br>\<span class="hljs-emphasis">* </span><br><span class="hljs-emphasis">\+ </span><br><span class="hljs-emphasis">\- </span><br><span class="hljs-emphasis">\` </span><br><span class="hljs-emphasis">\_</span><br></code></pre></td></tr></table></figure><h2 id="9-3-删除线"><a href="#9-3-删除线" class="headerlink" title="9.3 删除线"></a>9.3 删除线</h2><p>用~~把需要显示删除线的字符包裹起来</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">~~删除~~<br></code></pre></td></tr></table></figure><p>效果：</p><p><del>删除</del></p><h1 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//例子一 <br>|123|234|345| <br>|:-|:-:|-:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子二 <br>|123|234|345| <br>|:---|:---:|---:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子三 <br>123|234|345 <br>:-|:-:|-: <br>abc|bcd|cde <br>abc|bcd|cde <br>abc|bcd|cde<br></code></pre></td></tr></table></figure><p>上面三个例子的效果一样，由此可得：</p><ol><li><p>表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的</p></li><li><p>分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中</p></li></ol><p>效果如下：</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table><p>整理自：<a href="https://www.jianshu.com/p/399e5a3c7cc5">https://www.jianshu.com/p/399e5a3c7cc5</a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>博客使用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客使用手册</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是关于hexo框架下博客的使用方法总结，以便更好的学习与使用博客整理笔记。</p><h1 id="2-写作"><a href="#2-写作" class="headerlink" title="2. 写作"></a>2. 写作</h1><p>要创建新帖子或新页面，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>[layout]</code>是可选参数<code>布局</code>，<code>布局</code>分为以下几种：</p><table><thead><tr><th align="left">布局</th><th align="left">保存路径</th><th>用途</th></tr></thead><tbody><tr><td align="left">post</td><td align="left">source/_posts</td><td>创建新文章</td></tr><tr><td align="left">page</td><td align="left">source</td><td>创建新页面</td></tr><tr><td align="left">draft</td><td align="left">source/_drafts</td><td>创建新草稿</td></tr></tbody></table><p>该指令可以增加附加选项：</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--path</code></td><td align="left">发布路径。自定义帖子的路径。</td></tr><tr><td align="left"><code>-r</code>， <code>--replace</code></td><td align="left">替换当前帖子（如果存在）。</td></tr><tr><td align="left"><code>-s</code>， <code>--slug</code></td><td align="left">文章缩略名，自定义帖子的URL。</td></tr></tbody></table><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><h2 id="2-1-文档名称"><a href="#2-1-文档名称" class="headerlink" title="2.1 文档名称"></a>2.1 文档名称</h2><p>默认情况下，Hexo使用帖子标题作为其文件名。您可以在<code>_config.yml</code>中编辑<code>new_post_name</code>设置以更改默认文件名。</p><p>例如，<code>:year-:month-:day-:title.md</code>在文件名前加上创建日期。</p><p>您可以使用以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">帖子标题（小写，空格用连字符代替）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">创建年份，例如 <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">创建的月份（前导零），例如 <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">创建的月份（无前导零），例如 <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">创建日期（前导零），例如 <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">创建日期（无前导零），例如 <code>7</code></td></tr></tbody></table><h2 id="2-2-文档头"><a href="#2-2-文档头" class="headerlink" title="2.2 文档头"></a>2.2 文档头</h2><p>当新建.md文档后，打开文档可以看见如下文件头：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">title: hexo博客使用手册<br>date: 2021-02-18 14:11:04<br>tags: 博客使用手册<br>categories: 博客使用手册<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title:</code></td><td align="left">帖子标题</td></tr><tr><td align="left"><code>date:</code></td><td align="left">创建日期</td></tr><tr><td align="left"><code>tags:</code></td><td align="left">帖子所属标签</td></tr><tr><td align="left"><code>categories:</code></td><td align="left">帖子所属分类(需要手动添加)</td></tr></tbody></table><p>当想要新增标签与分类时，直接创建新的文档后在文件头填写参数即可。</p><p>多个标签时使用：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span>  <br><br>- [tag1]<br><br>- [tag2]<br></code></pre></td></tr></table></figure><p>含父子分类时，将父类写在前，子类写在后:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories: <br><span class="hljs-bullet">-</span> [categorie1]<br><span class="hljs-bullet">-</span> [categorie2]<br></code></pre></td></tr></table></figure><h2 id="2-3-添加图片"><a href="#2-3-添加图片" class="headerlink" title="2.3 添加图片"></a>2.3 添加图片</h2><p>关于图片和图片路径的设置，有以下教程。</p><p>事先声明，所有博客文件均保存在 <code>hexo/_posts/</code>文件夹下</p><p>首先在 <code>hexo &gt; source</code>目录下建一个文件夹叫images，用来保存博客中的图片。</p><p>然后打开Typora的 <code>文件 &gt; 偏好设置</code>，进行如下设置。</p><p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" alt="插入图片设置"></p><p>这样的话所有的博客中的图片都将会保存到 <code>/source/images/该博客md文件名/图片名称</code></p><p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p><p>在typora菜单栏点击 <code>格式-&gt;图像-&gt;设置图片根目录</code>，将<code>hexo/source</code>作为其根目录即可。</p><p><strong>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确喔！</strong></p><h2 id="2-4-草稿"><a href="#2-4-草稿" class="headerlink" title="2.4 草稿"></a>2.4 草稿</h2><p><code>draft</code>布局初始化的帖子将保存到该<code>source/_drafts</code>文件夹中。</p><p>您可以使用<code>publish</code>命令将草稿移至<code>source/_posts</code>文件夹。</p><p><code>publish</code>命令与<code>new</code>命令相似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>默认不显示草稿。</p><p>您可以在运行Hexo时添加选项<code>--draft</code>，也可以在<code>_config.yml</code>中启用<code>render_drafts</code>设置以渲染草稿。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --draft<br></code></pre></td></tr></table></figure><p>显示草稿（存储在<code>source/_drafts</code>文件夹中）。</p><h2 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h2><p>创建帖子时，Hexo将基于文件<code>scaffolds</code>夹中的相应模板文件来构建文件。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new photo <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>当您运行此命令时，Hexo将尝试在<code>scaffolds</code>文件夹中查找<code>photo.md</code>，并基于该文件构建帖子。模板中提供以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件创建日期</td></tr></tbody></table><h2 id="2-6-支持的格式"><a href="#2-6-支持的格式" class="headerlink" title="2.6 支持的格式"></a>2.6 支持的格式</h2><p>只要安装了相应的渲染器插件，Hexo支持帖子就可以以任何格式编写。、</p><p>本博客支持的编写格式：<code>markdown</code>，<code>ejs</code>。</p><h1 id="3-服务器指令"><a href="#3-服务器指令" class="headerlink" title="3. 服务器指令"></a>3. 服务器指令</h1><h2 id="3-1-init-安装指令"><a href="#3-1-init-安装指令" class="headerlink" title="3.1 init 安装指令"></a>3.1 init 安装指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init [folder]<br></code></pre></td></tr></table></figure><p>将hexo框架文件安装到当前/指定文件夹内。</p><h2 id="3-2-server-本地服务器启动指令"><a href="#3-2-server-本地服务器启动指令" class="headerlink" title="3.2 server 本地服务器启动指令"></a>3.2 server 本地服务器启动指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server 或 $ hexo s<br></code></pre></td></tr></table></figure><p>启动本地服务器。默认情况下，该位置为<code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--port</code></td><td align="left">覆盖默认端口</td></tr><tr><td align="left"><code>-s</code>， <code>--static</code></td><td align="left">仅提供静态文件</td></tr><tr><td align="left"><code>-l</code>， <code>--log</code></td><td align="left">启用记录器。覆盖记录器格式。</td></tr></tbody></table><h2 id="3-3-deploy-部署指令"><a href="#3-3-deploy-部署指令" class="headerlink" title="3.3 deploy 部署指令"></a>3.3 deploy 部署指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy 或 $ hexo d<br></code></pre></td></tr></table></figure><p>部署您的网站。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>， <code>--generate</code></td><td align="left">部署前生成</td></tr></tbody></table><h2 id="3-4-clean-清除缓存指令"><a href="#3-4-clean-清除缓存指令" class="headerlink" title="3.4 clean 清除缓存指令"></a>3.4 clean 清除缓存指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean <br></code></pre></td></tr></table></figure><p>清除缓存文件（<code>db.json</code>）和生成的文件（<code>public</code>）。</p><h2 id="3-5-version查看版本指令"><a href="#3-5-version查看版本指令" class="headerlink" title="3.5 version查看版本指令"></a>3.5 version查看版本指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo version 或 $ hexo v<br></code></pre></td></tr></table></figure><p>显示版本信息。</p><h2 id="3-6-选项"><a href="#3-6-选项" class="headerlink" title="3.6 选项"></a>3.6 选项</h2><h3 id="3-6-1-安全模式"><a href="#3-6-1-安全模式" class="headerlink" title="3.6.1 安全模式"></a>3.6.1 安全模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --safe<br></code></pre></td></tr></table></figure><p>禁用加载插件和脚本。如果在安装新插件后遇到问题，请尝试此操作。</p><h3 id="3-6-2-调试模式"><a href="#3-6-2-调试模式" class="headerlink" title="3.6.2 调试模式"></a>3.6.2 调试模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --debug<br></code></pre></td></tr></table></figure><p>将详细消息记录到终端和<code>debug.log</code>。如果遇到Hexo任何问题，请尝试此操作。如果看到错误，请<a href="https://github.com/hexojs/hexo/issues/new">提出GitHub问题</a>。</p><h3 id="3-6-3-静音模式"><a href="#3-6-3-静音模式" class="headerlink" title="3.6.3 静音模式"></a>3.6.3 静音模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --silent<br></code></pre></td></tr></table></figure><p>静音输出到终端。</p><h3 id="3-6-4-自定义配置文件路径"><a href="#3-6-4-自定义配置文件路径" class="headerlink" title="3.6.4 自定义配置文件路径"></a>3.6.4 自定义配置文件路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml<br></code></pre></td></tr></table></figure><p>使用自定义配置文件（而不是<code>_config.yml</code>）。</p><p>还接受以逗号分隔的JSON或YAML配置文件列表，该列表会将文件合并为一个<code>_multiconfig.yml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml，custom2.json<br></code></pre></td></tr></table></figure><h3 id="3-6-5-自定义CWD"><a href="#3-6-5-自定义CWD" class="headerlink" title="3.6.5 自定义CWD"></a>3.6.5 自定义CWD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --cwd / path / to / cwd<br></code></pre></td></tr></table></figure><p>自定义当前工作目录的路径。</p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
