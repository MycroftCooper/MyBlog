

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="是用来学习的！">
  <meta name="author" content="MycroftCooper">
  <meta name="keywords" content="Mycroft&#39;s Blog">
  <title>C#多线程 - Mycroft&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"mycroftcooper.github.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":true},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>卖烤麸烤饼儿的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/daily_news/">
                <i class="iconfont icon-rss"></i>
                每日新闻
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/daily_weather/">
                <i class="iconfont icon-codeforces"></i>
                每日天气
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/postBG.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C#多线程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-28 19:09" pubdate>
        2021年5月28日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      105
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C#多线程</h1>
            
            <div class="markdown-body">
              <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在学习本篇文章前你需要学习的相关知识：<br><a href="https://mycroftcooper.github.io/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">线程基本知识</a></p>
<p>此篇文章简单总结了C#中主要的多线程实现方法，包括：</p>
<ul>
<li>Thread<br>线程</li>
<li>ThreadPool<br>线程池</li>
<li>Parallel</li>
<li>Task<br>任务</li>
<li>BackgroundWorker组件</li>
</ul>
<h1 id="2-Thread类"><a href="#2-Thread类" class="headerlink" title="2. Thread类"></a>2. Thread类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul>
<li><p>使用Thread类通过ThreadStart（无参数）或ParameterizedThreadStart（一个输入参数）类型的委托创建一个Thread对象，开启一个新线程，执行该委托传递的任务，此时线程尚未处于运行状态。</p>
</li>
<li><p>调用Start()函数启动线程，当前线程继续执行。</p>
</li>
<li><p>调用Join()函数可以阻塞当前线程，直到调用Join()的线程终止。</p>
</li>
<li><p>调用Abort()方法，如需中止线程，在调用该方法的线程上抛出ThreadAbortException异常，以结束该线程</p>
</li>
<li><p>可以通过Thread.ResetAbort()方法阻止线程的中止。</p>
</li>
</ul>
<h2 id="2-1-属性表"><a href="#2-1-属性表" class="headerlink" title="2.1 属性表"></a>2.1 属性表</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Name</td>
<td>属性，获取或设置线程的名称</td>
</tr>
<tr>
<td>Priority</td>
<td>属性，获取或设置线程的优先级</td>
</tr>
<tr>
<td>ThreadState</td>
<td>属性，获取线程当前的状态</td>
</tr>
<tr>
<td>IsAlive</td>
<td>属性，获取当前线程是否处于启动状态</td>
</tr>
<tr>
<td>IsBackground</td>
<td>属性，获取或设置值，表示该线程是否为后台线程</td>
</tr>
<tr>
<td>CurrentThread</td>
<td>属性，获取当前正在运行的线程</td>
</tr>
</tbody></table>
<h2 id="2-2-方法表"><a href="#2-2-方法表" class="headerlink" title="2.2 方法表"></a>2.2 方法表</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Start()</td>
<td>方法，启动线程</td>
</tr>
<tr>
<td>Sleep(int millisecondsTimout)</td>
<td>方法，将当前线程暂停指定的毫秒数</td>
</tr>
<tr>
<td>Suspend()</td>
<td>方法，挂起当前线程（已经被弃用）</td>
</tr>
<tr>
<td>Join()</td>
<td>方法，阻塞调用线程，直到某个线程终止为止</td>
</tr>
<tr>
<td>Interrupt()</td>
<td>方法，中断当前线程</td>
</tr>
<tr>
<td>Resume()</td>
<td>方法，继续已经挂起的线程（已经被弃用）</td>
</tr>
<tr>
<td>Abort()</td>
<td>方法，终止线程（已经被弃用）</td>
</tr>
</tbody></table>
<h2 id="2-3-开启线程"><a href="#2-3-开启线程" class="headerlink" title="2.3 开启线程"></a>2.3 开启线程</h2><p>首先用new申请Thread对象，然后对象调用Start()方法启用线程。</p>
<p>代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Thread.CurrentThread.ManagedThreadId获取当前线程的ID，便于管理。</p>
</blockquote>
<p>用Lambda表达式代替函数调用，也能达到相同的效果</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>        &#125;);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-4-传递参数"><a href="#2-4-传递参数" class="headerlink" title="2.4 传递参数"></a>2.4 传递参数</h2><p>有两种为线程传递参数的方法：</p>
<ul>
<li><p>Start()函数传参法</p>
</li>
<li><p>对象成员方法传参法</p>
</li>
<li><p>匿名方法传参法</p>
<h3 id="2-4-1-Start-函数传参"><a href="#2-4-1-Start-函数传参" class="headerlink" title="2.4.1 Start()函数传参"></a>2.4.1 Start()函数传参</h3></li>
</ul>
<p>为某方法创建新线程后，在使用Start()方法启动线程时传递该方法需要的参数。</p>
<p>代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> name</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + name);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start(<span class="hljs-string">&quot;April&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-4-1-对象传递"><a href="#2-4-1-对象传递" class="headerlink" title="2.4.1 对象传递"></a>2.4.1 对象传递</h3><p>初始化一个对象，然后用对象的方法初始化Thread，这样该线程就可以使用这个对象的所有成员。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Download</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> Id;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> Name;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Download</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, <span class="hljs-built_in">string</span> name</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Id = id;<br>            Name = name;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownloadFile</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + <span class="hljs-string">&quot;ID: &quot;</span> + Id + <span class="hljs-string">&quot; Name: &quot;</span> + Name);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);              <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Download download = <span class="hljs-keyword">new</span> Download(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;人民日报&quot;</span>);<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(download.DownloadFile);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-4-5-匿名方法"><a href="#2-4-5-匿名方法" class="headerlink" title="2.4.5 匿名方法"></a>2.4.5 匿名方法</h3><p>需要接收多个参数的解决方案是使用一个匿名方法调用，方法如下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (<span class="hljs-string">&quot;Hello&quot;</span>); &#125;);<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure>
<p>它的优点是目标方法（这里是WriteText），可以接收任意数量的参数，并且没有装箱操作。</p>
<p>不过这需要将一个外部变量放入到匿名方法中，如下示例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">voidMain</span>(<span class="hljs-params"></span>)</span> &#123;<br>stringtext = <span class="hljs-string">&quot;Before&quot;</span>;<br><br>Threadt = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (text); &#125;);<br><br>text = <span class="hljs-string">&quot;After&quot;</span>;<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是:<br>当外部变量的值被修改，匿名方法可能进行无意的互动，导致一些古怪的现象。<br>一旦线程开始运行，外部变量最好被处理成只读的——除非有人愿意使用适当的锁。</p>
</blockquote>
<h2 id="2-5-线程命名"><a href="#2-5-线程命名" class="headerlink" title="2.5 线程命名"></a>2.5 线程命名</h2><p>线程可以通过它的Name属性进行命名，这非常有利于调试：<br>可以用Console.WriteLine打印出线程的名字<br>Microsoft Visual Studio可以将线程的名字显示在调试工具栏的位置上。</p>
<p>线程的名字可以在被任何时间设置——但只能设置一次，重命名会引发异常。</p>
<p>程序的主线程也可以被命名，下面例子里主线程通过CurrentThread命名：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#">Class ThreadNaming &#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread.CurrentThread.Name= <span class="hljs-string">&quot;main&quot;</span>;<br><br>Thread worker = <span class="hljs-keyword">new</span> Thread(Go);<br><br>worker.Name= <span class="hljs-string">&quot;worker&quot;</span>;<br><br>worker.Start();<br><br>Go();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Go</span>(<span class="hljs-params"></span>)</span> &#123;<br>Console.WriteLine (<span class="hljs-string">&quot;Hello from &quot;</span>+ Thread.CurrentThread.Name);<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出</p>
<p>Hellofrom main</p>
<p>Hellofrom worker</p>
<h2 id="2-6-前台线程和后台线程"><a href="#2-6-前台线程和后台线程" class="headerlink" title="2.6 前台线程和后台线程"></a>2.6 前台线程和后台线程</h2><ul>
<li>前台线程(用户界面线程)<br>只要存在有一个前台线程在运行，应用程序就在运行<br>通常用来处理用户的输入并响应各种事件和消息</li>
<li>后台线程(工作线程)<br>应用程序关闭时，如果后台线程没有执行完，会被强制性的关闭<br>用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等</li>
</ul>
<p>例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-built_in">string</span>[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//设为后台线程</span><br>        thread.IsBackground = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上例中，thread被设置为后台线程。<br>Main执行完后，没有前台线程了，应用程序就结束，虽然后台线程thread此时尚未执行完，也被终止。</p>
<blockquote>
<p>改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。</p>
</blockquote>
<p>拥有一个后台工作线程是有益的，<br>最直接的理由是当提到结束程序它总是可能有最后的发言权。<br>交织以不会消亡的前台线程，保证程序的正常退出。</p>
<p>抛弃一个前台工作线程是尤为险恶的，尤其对Windows Forms程序，<br>因为程序直到主线程结束时才退出（至少对用户来说），但是它的进程仍然运行着。<br>在Windows任务管理器它将从应用程序栏消失不见，但却可以在进程栏找到它。<br>除非用户找到并结束它，它将继续消耗资源，并可能阻止一个新的实例的运行从开始或影响它的特性。</p>
<p>对于程序失败退出的普遍原因就是存在“被忘记”的前台线程。</p>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>动作</th>
<th>结束</th>
<th>后续处理</th>
</tr>
</thead>
<tbody><tr>
<td>前台线程</td>
<td>主程序关闭</td>
<td>否</td>
<td>显示关闭线程/杀掉当前进程</td>
</tr>
<tr>
<td>后台线程</td>
<td>主程序关闭</td>
<td>是</td>
<td>无</td>
</tr>
</tbody></table>
<h2 id="2-7-注意事项"><a href="#2-7-注意事项" class="headerlink" title="2.7 注意事项"></a>2.7 注意事项</h2><ul>
<li><p>Thread类创建的线程默认为前台线程，可以通过IsBackground属性设置其为前台或后台线程。</p>
<blockquote>
<p>用Thread类创建的线程是前台线程，线程池中的线程总是后台线程</p>
</blockquote>
</li>
<li><p>可以通过Priority属性设置线程的优先级。</p>
</li>
<li><p>线程内部可以通过try catch捕获该异常，在catch模块中进行一些必要的处理<br>如释放持有的锁和文件资源等</p>
</li>
<li><p>慎重使用Abort()方法<br>如果在当前线程中抛出该异常，其结果是可预测的<br>但是对于其他线程，它会中断任何正在执行的代码，有可能中断静态对象的生成，造成不可预测的结果。</p>
</li>
</ul>
<h1 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>ThreadPool类维护一个线程的列表，提供给用户以执行不同的小任务，减少频繁创建线程的开销。<br>该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</p>
<p>线程池其实就是一个存放线程对象的“池子(pool)”，他提供了一些基本方法，如：设置pool中最小/最大线程数量、把要执行的方法排入队列等等。ThreadPool是一个静态类，因此可以直接使用，不用创建对象。</p>
<h2 id="3-2-线程池的优点"><a href="#3-2-线程池的优点" class="headerlink" title="3.2 线程池的优点"></a>3.2 线程池的优点</h2><p>每新建一个线程都需要占用内存空间和其他资源<br>而新建了那么多线程，有很多在休眠，或者在等待资源释放；<br>又有许多线程只是周期性的做一些小工作，如刷新数据等等，太浪费了，划不来。<br>实际编程中大量线程突发，然后在短时间内结束的情况很少见。</p>
<p>于是，就提出了线程池的概念。</p>
<p>线程池中的线程执行完指定的方法后并不会自动消除，而是以挂起状态返回线程池，如果应用程序再次向线程池发出请求，那么处以挂起状态的线程就会被激活并执行任务，而不会创建新线程，这就节约了很多开销。<br>只有当线程数达到最大线程数量，系统才会自动销毁线程。</p>
<p>因此，使用线程池可以避免大量的创建和销毁的开支，具有更好的性能和稳定性，其次，开发人员把线程交给系统管理，可以集中精力处理其他任务。</p>
<h2 id="3-3-线程池的使用"><a href="#3-3-线程池的使用" class="headerlink" title="3.3 线程池的使用"></a>3.3 线程池的使用</h2><ul>
<li><p>设置线程池最大最小：<br><strong>ThreadPool.SetMaxThreads (int workerThreads,int completionPortThreads)</strong><br>设置可以同时处于活动状态的线程池的请求数目。<br>所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。<br>还可以设置最小线程数。</p>
</li>
<li><p>将任务添加进线程池:<br><strong>ThreadPool.QueueUserWorkItem(new WaitCallback(方法名));**或<br>**ThreadPool.QueueUserWorkItem(new WaitCallback(方法名), 参数);</strong></p>
</li>
</ul>
<p>但是线程池的使用也有一些限制：</p>
<ul>
<li>线程池中的线程均为后台线程，并且不能修改为前台线程</li>
<li>不能给入池的线程设置优先级或名称</li>
<li>对于COM对象，入池的所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA）  线程</li>
<li>入池的线程只适合时间较短的任务，如果线程需要长时间运行，应使用Thread类创建线程或使用Task的LongRunning选项</li>
<li>.Net下线程池最小默认允许4个工作线程，最大允许2048个工作线程。<br>并发线程启动后，瞬间会启动4个线程。<br>而剩下的会依据环境每0.5秒或者1秒启动一个。<br>如果同时运行的线程达到Max工作线程，那么剩下的就会挂起<br>直到线程池中的线程有空闲得了，才会去执行。</li>
</ul>
<h1 id="4-Parallel类"><a href="#4-Parallel类" class="headerlink" title="4.  Parallel类"></a>4.  Parallel类</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>整理自<a target="_blank" rel="noopener" href="https://blog.csdn.net/honantic/article/details/46876871">https://blog.csdn.net/honantic/article/details/46876871</a></p>
<p>Parallel和Task类都位于System.Threading.Task命名空间中，是对Thread和ThreadPool类更高级的抽象。</p>
<p>Parrallel类有For()、ForEach()、Invoke()三个方法</p>
<ul>
<li><p>Invoke()<br>实现任务并行性<br>允许同时调用不同的方法，</p>
</li>
<li><p>Parallel.For()和 Parallel.ForEach()<br>实现数据并行性<br>在每次迭代中调用相同的代码</p>
</li>
</ul>
<h2 id="4-2-常用方法"><a href="#4-2-常用方法" class="headerlink" title="4.2 常用方法"></a>4.2 常用方法</h2><h3 id="4-2-1-Parallel-For"><a href="#4-2-1-Parallel-For" class="headerlink" title="4.2.1 Parallel.For()"></a>4.2.1 Parallel.For()</h3><p>Parallel.For()方法类似于 C#的 for循环语旬,也是多次执行一个任务。<br>使用Parallel.For()方法,可以并行运行迭代。 </p>
<p>迭代的顺序没有定义，不能保证。</p>
<p>在For()方法中：</p>
<ul>
<li>前两个参数定义了循环的开头和结束。示例从0迭代到 9。</li>
<li>第 3个参数是一个Action<int>委托<br>是要并行运行迭代的方法</li>
<li>整数参数是循环的迭代次数,该参数被传递给Action<int>委托引用的方法。</li>
<li>Parallel.For()方法的返回类型是ParalleLoopResult结构,它提供了循环是否结束的信息。</li>
</ul>
<p>案例如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    ParallelLoopResult result = Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, i =&gt;<br>    &#123;<br>        Console.WriteLine<br>        (<span class="hljs-string">&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;</span>, i, Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Console.WriteLine(<span class="hljs-string">&quot;Is completed: &#123;0&#125;&quot;</span>, result.IsCompleted);<br><br>    <span class="hljs-comment">//i: 0, thread id: 9</span><br>    <span class="hljs-comment">//i: 2, thread id: 10</span><br>    <span class="hljs-comment">//i: 1, thread id: 9</span><br>    <span class="hljs-comment">//i: 3, thread id: 10</span><br>    <span class="hljs-comment">//i: 4, thread id: 9</span><br>    <span class="hljs-comment">//i: 6, thread id: 11</span><br>    <span class="hljs-comment">//i: 7, thread id: 10</span><br>    <span class="hljs-comment">//i: 5, thread id: 9</span><br>    <span class="hljs-comment">//i: 8, thread id: 12</span><br>    <span class="hljs-comment">//i: 9, thread id: 11</span><br>    <span class="hljs-comment">//Is completed: True</span><br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同For()循环类似，Parallel.For()方法也可以中断循环的执行。</p>
<p>Parallel.For()方法的一个重载版本接受第3个Action&lt;int, ParallelLoopState&gt;类型的参数。<br>使用这些参数定义一个方法,就可以调用ParalleLoopState的Break()或Stop()方法,以影响循环的结果。</p>
<blockquote>
<p>注意,迭代的顺序没有定义</p>
</blockquote>
<p>案例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tsx">public static void Main()<br>&#123;<br>    ParallelLoopResult result &#x3D; Parallel.For(0, 100, (i, state) &#x3D;&gt;<br>    &#123;<br>        Console.WriteLine(&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;, i, Thread.CurrentThread.ManagedThreadId);<br><br>        if (i &gt; 10)<br>            state.Break();<br><br>        Thread.Sleep(10);<br>    &#125;);<br><br>    Console.WriteLine(&quot;Is completed: &#123;0&#125;&quot;, result.IsCompleted);<br>    Console.WriteLine(&quot;Lowest break iteration: &#123;0&#125;&quot;, result.LowestBreakIteration);<br><br>    &#x2F;&#x2F;i: 0, thread id: 10<br>    &#x2F;&#x2F;i: 25, thread id: 6<br>    &#x2F;&#x2F;i: 1, thread id: 10<br>    &#x2F;&#x2F;i: 2, thread id: 10<br>    &#x2F;&#x2F;i: 3, thread id: 10<br>    &#x2F;&#x2F;i: 4, thread id: 10<br>    &#x2F;&#x2F;i: 5, thread id: 10<br>    &#x2F;&#x2F;i: 6, thread id: 10<br>    &#x2F;&#x2F;i: 7, thread id: 10<br>    &#x2F;&#x2F;i: 8, thread id: 10<br>    &#x2F;&#x2F;i: 9, thread id: 10<br>    &#x2F;&#x2F;i: 10, thread id: 10<br>    &#x2F;&#x2F;i: 11, thread id: 10<br>    &#x2F;&#x2F;Is completed: False<br>    &#x2F;&#x2F;Lowest break iteration: 11<br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-2-Parallel-For-lt-TLocal-gt"><a href="#4-2-2-Parallel-For-lt-TLocal-gt" class="headerlink" title="4.2.2 Parallel.For &lt; TLocal &gt;"></a>4.2.2 Parallel.For &lt; TLocal &gt;</h3><p>Parallel.For()方法可能使用几个线程来执行循环 。</p>
<p>如果需要对每个线程进行初始化,就可以使用Parallel.For<TLocal>方法。<br>除了from和to对应的值之外,For()方法的泛型版本还接受3个委托参数:</p>
<ul>
<li><p>第一个参数的类型是Func&lt; TLocal &gt;<br>因为这里的例子对于TLocal使用字符串,所以该方法需要定义为Func&lt; string &gt;,即返回string的方法。<br>这个方法仅对于用于执行迭代的每个线程调用一次</p>
</li>
<li><p>第二个委托参数为循环体定义了委托<br>在示例中,该参数的类型是Func&lt;int, ParallelLoopState, string, string&gt;。<br>其中第一个参数是循环迭代,第二个参数 ParallelLoopstate允许停止循环,如前所述 。<br>循环体方法通过第3个参数接收从init方法返回的值,循环体方法还需要返回一个值,其类型是用泛型for参数定义的。</p>
</li>
<li><p>For()方法的最后一个参数指定一个委托Action&lt; TLocal &gt;;在该示例中,接收一个字符串。<br>这个方法仅对于每个线程调用一次,这是一个线程退出方法。</p>
</li>
</ul>
<p>案例如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">Parallel.For&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>,() =&gt;<br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;init thread &#123;0&#125;,\t task &#123;1&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;t&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);<br>                &#125;,<br>            (i, pls, str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;body i &#123;0&#125; \t str &#123;1&#125; \t thread &#123;2&#125; \t task &#123;3&#125;&quot;</span>, i, str, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                Thread.Sleep(<span class="hljs-number">10</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;i \t&#123;0&#125;&quot;</span>, i);<br>            &#125;,<br>            (str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;finally\t &#123;0&#125;&quot;</span>, str);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure>
<p><strong>Parallel.For<TLocal> 方法 (Int32, Int32, Func<TLocal>, Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;, Action<TLocal>)</strong></p>
<p>参数表：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>数据类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>TLoca</td>
<td>线程本地数据的类型</td>
</tr>
<tr>
<td>fromInclusive</td>
<td>System.Int32</td>
<td>开始索引（含）</td>
</tr>
<tr>
<td>toExclusive</td>
<td>System.Int32</td>
<td>结束索引（不含）</td>
</tr>
<tr>
<td>localInit</td>
<td>System.Func<TLocal></td>
<td>用于返回每个任务的本地数据的初始状态的函数委托</td>
</tr>
<tr>
<td>body</td>
<td>System.Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;</td>
<td>将为每个迭代调用一次的委托</td>
</tr>
<tr>
<td>localFinally</td>
<td>System.Action<TLocal></td>
<td>用于对每个任务的本地状态执行一个最终操作的委托</td>
</tr>
<tr>
<td>返回值</td>
<td>System.Threading.Tasks.ParallelLoopResult</td>
<td></td>
</tr>
</tbody></table>
<p>在迭代范围 (fromInclusive，toExclusive) ，为每个值调用一次body 委托。<br>为它提供以下参数：</p>
<ul>
<li>迭代次数 (Int32)</li>
<li>可用来提前退出循环的ParallelLoopState实例</li>
<li>可以在同一线程上执行的迭代之间共享的某些本地状态。</li>
</ul>
<p>对于参与循环执行的每个任务调用 localInit 委托一次，并返回每个任务的初始本地状态。<br>这些初始状态传递给第一个在该任务上 调用的 body。<br>然后，每个后续正文调用返回可能修改过的状态值，传递到下一个正文调用。<br>最后，每个任务上的最后正文调用返回传递给 localFinally 委托的状态值。<br>每个任务调用 localFinally 委托一次，以对每个任务的本地状态执行最终操作。<br>此委托可以被多个任务同步调用；<br>因此您必须同步对任何共享变量的访问。</p>
<p>Parallel.For方法比在它执行生存期的线程可能使用更多任务，作为现有的任务完成并被新任务替换。<br>这使基础 TaskScheduler 对象有机会添加、更改或移除服务循环的线程。</p>
<p>如果 fromInclusive 大于或等于 toExclusive，则该方法立即返回，而无需执行任何迭代。</p>
<h3 id="4-2-3-Parallel-ForEach"><a href="#4-2-3-Parallel-ForEach" class="headerlink" title="4.2.3 Parallel.ForEach()"></a>4.2.3 Parallel.ForEach()</h3><p>Parallel.ForEach()方法遍历实现了IEnumerable的集合,其方式类似于foreach语句,但以异步方式遍历。<br>这里也没有确定遍历顺序。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s) =&gt;<br>            &#123;<br>                Console.WriteLine(s);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure>


<p>中断循环<br>如果需要中断循环,就可以使用ForEach()方法的重载版本和ParallelLoopState参数。其方式与前面的For()方法相同。<br>ForEach()方法的一个重载版本也可以用于访问索引器,从而获得迭代次数<br>如下所示:　</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s, pls, l) =&gt;<br>             &#123;<br>                 Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;\t&#123;1&#125;&quot;</span>, s, l);<br>                 <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">10</span>)<br>                 &#123;<br>                     pls.Break();<br>                 &#125;<br>             &#125;);<br>            Console.WriteLine(<span class="hljs-string">&quot;Lowest break iteration: &#123;0&#125;&quot;</span>, result.LowestBreakIteration);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure>
<h3 id="4-2-4-Parallel-Invoke"><a href="#4-2-4-Parallel-Invoke" class="headerlink" title="4.2.4 Parallel.Invoke()"></a>4.2.4 Parallel.Invoke()</h3><p>如果多个任务应并行运行,就可以使用Parallel.Invoke()方法。<br>Parallel.Invoke()方法允许传递一个Action委托数组,在其中可以指定应运行的方法。<br>示例代码传递了要并行调用的Foo()和Bar()方法:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Foo, Bar);<br>    Console.ReadKey();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Foo&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Bar&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如需同时执行多个不同的任务，可以使用Parallel.Invoke()方法，它允许传递一个Action委托数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Func1, Func2, Func3);<br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="5-Task类"><a href="#5-Task类" class="headerlink" title="5. Task类"></a>5. Task类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>相比于Thread类，Task类为控制线程提供了更大的灵活性。</p>
<ul>
<li><p>Task类可以获取线程的返回值</p>
</li>
<li><p>可以定义连续的任务：在一个任务结束结束后开启下一个任务</p>
</li>
<li><p>可以在层次结构中安排任务，在父任务中可以创建子任务<br>这样就创建了一种依赖关系，如果父任务被取消，子任务也随之取消</p>
</li>
</ul>
<blockquote>
<p>注意：<br>Task类默认使用线程池中的线程，如果该任务需长期运行，应使用TaskCreationOptions.LongRunning属性告诉任务管理器创建一个新的线程，而不是使用线程池中的线程。</p>
</blockquote>
<h2 id="5-2-任务Task和线程Thread的区别："><a href="#5-2-任务Task和线程Thread的区别：" class="headerlink" title="5.2 任务Task和线程Thread的区别："></a>5.2 任务Task和线程Thread的区别：</h2><ul>
<li>任务是架构在线程之上的<br>也就是说任务最终还是要<strong>抛给线程</strong>去执行。</li>
<li><strong>任务跟线程不是一对一的关系</strong><br>比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。</li>
<li>Task和Thread一样，位于System.Threading命名空间下!</li>
</ul>
<h2 id="5-3-Task的生存周期与状态"><a href="#5-3-Task的生存周期与状态" class="headerlink" title="5.3 Task的生存周期与状态"></a>5.3 Task的生存周期与状态</h2><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Created</td>
<td>表示默认初始化任务，但是“工厂创建的”实例直接跳过。</td>
</tr>
<tr>
<td>WaitingToRun</td>
<td>这种状态表示等待任务调度器分配线程给任务执行。</td>
</tr>
<tr>
<td>RanToCompletion</td>
<td>任务执行完毕。</td>
</tr>
</tbody></table>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//查看Task中的状态</span><br>   <span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>         &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Begin&quot;</span>);<br>            System.Threading.Thread.Sleep(<span class="hljs-number">2000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;Finish&quot;</span>);<br>         &#125;);<br>         Console.WriteLine(<span class="hljs-string">&quot;Before start:&quot;</span> + task1.Status);<br>         task1.Start();<br>         Console.WriteLine(<span class="hljs-string">&quot;After start:&quot;</span> + task1.Status);<br>         task1.Wait();<br>         Console.WriteLine(<span class="hljs-string">&quot;After Finish:&quot;</span> + task1.Status);<br></code></pre></td></tr></table></figure>
<h2 id="5-4-Task的使用方法"><a href="#5-4-Task的使用方法" class="headerlink" title="5.4 Task的使用方法"></a>5.4 Task的使用方法</h2><h3 id="5-4-1-启动任务"><a href="#5-4-1-启动任务" class="headerlink" title="5.4.1 启动任务"></a>5.4.1 启动任务</h3><p>以下程序演示了几种通过Task类启动任务的方式：</p>
<ul>
<li><p>实例化后手动start()</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>    &#123;<br>       <span class="hljs-comment">//TODO you code</span><br>    &#125;);<br>   task1.Start();<br></code></pre></td></tr></table></figure></li>
<li><p>使用Task工厂对象创建新任务并执行</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>工厂创建，直接执行</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br></code></pre></td></tr></table></figure>


</li>
</ul>
<p>案例如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadExample</span><br> &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>     &#123;<br>         TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>         Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br><br>         Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br><br>         Task t3 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task constructor and start&quot;</span>);<br>         t3.Start();<br><br>         <span class="hljs-comment">//需要.NetFramework 4.5以上</span><br>         <span class="hljs-keyword">var</span> t4 = Task.Run(() =&gt; TaskMethod.DoTask(<span class="hljs-string">&quot;using Run method&quot;</span>));<br><br>         Console.ReadKey();<br>     &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">TaskMethod</span><br> &#123;<br>     <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> taskLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> msg</span>)</span><br><span class="hljs-function"></span>     &#123;<br>         <span class="hljs-keyword">lock</span> (taskLock)<br>         &#123;<br>             Console.WriteLine(msg);<br>             Console.WriteLine(<span class="hljs-string">&quot;Task id:&#123;0&#125;, Thread id :&#123;1&#125;&quot;</span>,<br>                            Task.CurrentId == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;no task&quot;</span> : Task.CurrentId.ToString(),<br>                            Thread.CurrentThread.ManagedThreadId);<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-4-2-任务控制"><a href="#5-4-2-任务控制" class="headerlink" title="5.4.2 任务控制"></a>5.4.2 任务控制</h3><h4 id="5-4-2-1-Task-Wait"><a href="#5-4-2-1-Task-Wait" class="headerlink" title="5.4.2.1 Task.Wait()"></a>5.4.2.1 Task.Wait()</h4><p>就是等待任务执行（task1）完成，task1的状态变为Completed。</p>
<h4 id="5-4-2-2-Task-WaitAll"><a href="#5-4-2-2-Task-WaitAll" class="headerlink" title="5.4.2.2 Task.WaitAll()"></a>5.4.2.2 Task.WaitAll()</h4><p>等待所有的任务都执行完成：<br>例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAll(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;All task finished!&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>即当task,task2,task3…N全部任务都执行完成之后才会往下执行代码（打印出：“All task finished!”）</p>
<h4 id="5-4-2-3-Task-WaitAny"><a href="#5-4-2-3-Task-WaitAny" class="headerlink" title="5.4.2.3 Task.WaitAny()"></a>5.4.2.3 Task.WaitAny()</h4><p>同Task.WaitAll，等待任何一个任务完成就继续向下执行，将上面的代码WaitAll替换为WaitAny</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAny(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;Any task finished!&quot;</span>);<br></code></pre></td></tr></table></figure>
<p> 即当task,task2,task3…N任意一个任务都执行完成之后就会往下执行代码（打印出：” Any task finished!”）</p>
<h4 id="5-4-2-4-Task-ContinueWith"><a href="#5-4-2-4-Task-ContinueWith" class="headerlink" title="5.4.2.4 Task.ContinueWith()"></a>5.4.2.4 Task.ContinueWith()</h4><p>在第一个Task完成后自动启动下一个Task，实现Task的延续，编写如下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>    Task t1 = tf.StartNew(()=&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务1\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t2 = t1.ContinueWith((t) =&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务2\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t3 = t2.ContinueWith(<span class="hljs-built_in">delegate</span>(Task t) <br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务3\r\n&quot;</span>);<br>    &#125;, TaskContinuationOptions.OnlyOnRanToCompletion);<br><br>    Console.ReadKey(); <br>&#125;<br>    <span class="hljs-comment">//执行结果</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//Current Task id = 1</span><br>    <span class="hljs-comment">//执行任务1</span><br><br>    <span class="hljs-comment">//Last Task id = 1</span><br>    <span class="hljs-comment">//Current Task id = 2</span><br>    <span class="hljs-comment">//执行任务2</span><br><br>    <span class="hljs-comment">//Last Task id = 2</span><br>    <span class="hljs-comment">//Current Task id = 3</span><br>    <span class="hljs-comment">//执行任务3</span><br></code></pre></td></tr></table></figure>
<p>从执行结果可以看出，任务1，2，3被顺序执行，同时通过 TaskContinuationOptions 还可以指定何种情况下继续执行该任务，常用的值包括OnlyOnFaulted, OnlyOnCanceled, NotOnFaulted, NotOnCanceled等。如将上例中的OnlyOnRanToCompletion改为OnlyOnFaulted，任务2结束之后，任务3将不被执行。</p>
<p>对于ContinueWith()的使用，MSDN演示了更加优雅的“流式”调用方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)  </span><br><span class="hljs-function"></span>&#123;  <br>   <span class="hljs-keyword">var</span> backgroundScheduler = TaskScheduler.Default;  <br>   <span class="hljs-keyword">var</span> uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  <br>   Task.Factory.StartNew(<span class="hljs-built_in">delegate</span> &#123; DoBackgroundComputation(); &#125;,  <br>                         backgroundScheduler).  <br>   ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUI(); &#125;, uiScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; DoAnotherBackgroundComputation(); &#125;,  <br>                             backgroundScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUIAgain(); &#125;, uiScheduler);  <br>&#125;  <br></code></pre></td></tr></table></figure>
<h4 id="5-4-2-5-RunSynchronously"><a href="#5-4-2-5-RunSynchronously" class="headerlink" title="5.4.2.5 RunSynchronously()"></a>5.4.2.5 RunSynchronously()</h4><p>用于实现同步调用，直接在当前线程上调用该任务。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskMethod.DoTask(<span class="hljs-string">&quot;Just Main thread&quot;</span>);<br>    Task t1 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using Run Sync&quot;</span>);<br>    t1.RunSynchronously();<br>    <span class="hljs-comment">//输出结果</span><br>    <span class="hljs-comment">//Just Main thread</span><br>    <span class="hljs-comment">//Task id: no task, Thread id: 9</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//using Run Sync</span><br>    <span class="hljs-comment">//Task id:1, Thread id :9</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-4-3-任务取消"><a href="#5-4-3-任务取消" class="headerlink" title="5.4.3 任务取消"></a>5.4.3 任务取消</h3><p>当我们启动了一个task,出现异常或者用户点击取消等等，我们可以取消这个任务。</p>
<p>我们通过cancellation的tokens来取消一个Task。<br>在很多Task的Body里面包含循环，我们可以在轮询的时候判断IsCancellationRequested属性是否为True<br>如果是True的话就return或者抛出异常，抛出异常后面再说，因为还没有说异常处理的东西。</p>
<p>下面在代码中看下如何实现任务的取消，代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#">　　　　<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br><span class="hljs-keyword">var</span> token = tokenSource.Token;<br><span class="hljs-keyword">var</span> task = Task.Factory.StartNew(() =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>    &#123;<br>        System.Threading.Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">if</span> (token.IsCancellationRequested)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Abort mission success!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;, token);<br>token.Register(() =&gt;<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>&#125;);<br>Console.WriteLine(<span class="hljs-string">&quot;Press enter to cancel task...&quot;</span>);<br>Console.ReadKey();<br>tokenSource.Cancel();<span class="hljs-number">123456789101112131415161718192021</span><br></code></pre></td></tr></table></figure>
<p>这里开启了一个Task,并给token注册了一个方法，输出一条信息，然后执行ReadKey开始等待用户输入，用户点击回车后，执行tokenSource.Cancel方法，取消任务。</p>
<blockquote>
<p>注意：<br>因为任务通常运行以异步方式在线程池线程上，创建并启动任务的线程将继续执行，一旦该任务已实例化。<br>在某些情况下，当调用线程的主应用程序线程，该应用程序可能会终止之前任何任务实际开始执行。<br>其他情况下，应用程序的逻辑可能需要调用线程继续执行，仅当一个或多个任务执行完毕。<br>您可以同步调用线程的执行，以及异步任务它启动通过调用 Wait 方法来等待要完成的一个或多个任务。<br>若要等待完成一项任务，可以调用其 Task.Wait 方法。<br>调用 Wait 方法将一直阻塞调用线程直到单一类实例都已完成执行。</p>
</blockquote>
<h3 id="5-4-4-接收任务的返回值"><a href="#5-4-4-接收任务的返回值" class="headerlink" title="5.4.4 接收任务的返回值"></a>5.4.4 接收任务的返回值</h3><p>对于任务有返回值的情况，可使用Task<TResult>泛型类，TResult定义了返回值的类型，以下代码演示了调用返回int值的任务的方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">var</span> t5 = <span class="hljs-keyword">new</span> Task&lt;<span class="hljs-built_in">int</span>&gt;(TaskWithResult, Tuple.Create&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    t5.Start();<br>    t5.Wait();<br>    Console.WriteLine(<span class="hljs-string">&quot;adder results: &#123;0&#125;&quot;</span>, t5.Result);<br><br>    Console.ReadKey(); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">TaskWithResult</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> o</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; adder = (Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;)o;<br>    <span class="hljs-keyword">return</span> adder.Item1 + adder.Item2;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-5-任务的层次结构"><a href="#5-5-任务的层次结构" class="headerlink" title="5.5 任务的层次结构"></a>5.5 任务的层次结构</h2><p>如果在一个Task内部创建了另一个任务，这两者间就存在父/子的层次结构，当父任务被取消时，子任务也会被取消。</p>
<p>如果不希望使用该层次结构，可在创建子任务时选择TaskCreationOptions.DetachedFromParent。</p>
<h1 id="6-BackgroundWorker控件"><a href="#6-BackgroundWorker控件" class="headerlink" title="6. BackgroundWorker控件"></a>6. BackgroundWorker控件</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>C#提供了BackgroundWorker控件帮助用户更简单、安全地实现多线程运算。</p>
<p>该控件提供了DoWork, ProgressChanged 和 RunWorkerCompleted事件<br>为DoWork添加事件处理函数，再调用RunWorkerAsync()方法，即可创建一个新的线程执行DoWork任务</p>
<p>ProgressChanged和RunWorkerCompleted事件均在UI线程中执行，添加相应的处理函数，即可完成任务线程与UI线程间的交互，可用于显示任务的执行状态（完成百分比）、执行结果等。</p>
<p>同时，该控件还提供了CancleAsync()方法，以中断线程的执行<br>需注意的是，调用该方法后，只是将控件的CancellationPending属性置True，用户需在程序执行过程中查询该属性以判定是否应中断线程。</p>
<p>具体用法可参考MSDN：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker?view=netframework-4.7.2">BackgroundWorker用法范例</a><br>可以看的出来，BackgroundWorker组件提供了一种执行异步操作（后台线程）的同时，并且还能妥妥的显示操作进度的解决方案。</p>
<h2 id="6-2-属性表"><a href="#6-2-属性表" class="headerlink" title="6.2 属性表"></a>6.2 属性表</h2><h3 id="6-2-1-WorkerReportsProgress"><a href="#6-2-1-WorkerReportsProgress" class="headerlink" title="6.2.1 WorkerReportsProgress"></a>6.2.1 WorkerReportsProgress</h3><p>bool类型，指示BackgroundWorker是否可以报告进度更新。</p>
<ul>
<li>True时，可以成功调用ReportProgress方法</li>
<li>否则将引发InvalidOperationException异常</li>
</ul>
<p>用法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> BackgroundWorker bgWorker = <span class="hljs-keyword">new</span> BackgroundWorker();<br>bgWorker.WorkerReportsProgress = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
<h3 id="6-2-2-WorkerSupportsCancellation"><a href="#6-2-2-WorkerSupportsCancellation" class="headerlink" title="6.2.2 WorkerSupportsCancellation"></a>6.2.2 WorkerSupportsCancellation</h3><p>bool类型，指示BackgroundWorker是否支持异步取消操作</p>
<ul>
<li><p>True时，将可以成功调用CancelAsync方法</p>
</li>
<li><p>否则将引发InvalidOperationException异<br>用法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">bgWorker.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
<h3 id="6-2-3-CancellationPending"><a href="#6-2-3-CancellationPending" class="headerlink" title="6.2.3 CancellationPending"></a>6.2.3 CancellationPending</h3><p>bool类型，指示应用程序是否已请求取消后台操作。<br>此属性通常放在用户执行的异步操作内部，用来判断用户是否取消执行异步操作。<br>当执行BackgroundWorker.CancelAsync()方法时，该属性值将变为True。<br>用法：</p>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在DoWork中键入如下代码</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (bgWorker.CancellationPending)<br>      &#123;<br>          e.Cancel = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>          bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>          System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>      &#125;<br>  &#125;   <br></code></pre></td></tr></table></figure>
<h3 id="6-2-4-IsBusy"><a href="#6-2-4-IsBusy" class="headerlink" title="6.2.4 IsBusy"></a>6.2.4 IsBusy</h3><p>bool类型，指示BackgroundWorker是否正在执行一个异步操作。<br>此属性通常放在BackgroundWorker.RunWorkerAsync()方法之前，避免多次调用RunWorkerAsync()方法引发异常。<br>当执行BackgroundWorker.RunWorkerAsync()方法是，该属性值将变为True。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//防止重复执行异步操作引发错误</span><br> <span class="hljs-keyword">if</span> (bgWorker.IsBusy)<br>     <span class="hljs-keyword">return</span>;<br> bgWorker.RunWorkerAsync();<br></code></pre></td></tr></table></figure>
<h2 id="6-3-方法表"><a href="#6-3-方法表" class="headerlink" title="6.3 方法表"></a>6.3 方法表</h2><h3 id="6-3-1-RunWorkerAsync"><a href="#6-3-1-RunWorkerAsync" class="headerlink" title="6.3.1 RunWorkerAsync()"></a>6.3.1 RunWorkerAsync()</h3><p>开始执行一个后台操作。</p>
<p>调用该方法后，将触发BackgroundWorker.DoWork事件，并以异步的方式执行DoWork事件中的代码。<br>该方法还有一个带参数的重载方法：RunWorkerAsync(Object)。<br>该方法允许传递一个Object类型的参数到后台操作中，并且可以通过DoWork事件的DoWorkEventArgs.Argument属性将该参数提取出来。</p>
<blockquote>
<p>注：当BackgroundWorker的IsBusy属性为True时，调用该方法将引发InvalidOperationException异常。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在启动异步操作的地方键入代码</span><br>bgWorker.RunWorkerAsync(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="6-3-2-ReportProgress-Int-percentProgress"><a href="#6-3-2-ReportProgress-Int-percentProgress" class="headerlink" title="6.3.2 ReportProgress(Int percentProgress)"></a>6.3.2 ReportProgress(Int percentProgress)</h3><p>报告操作进度。</p>
<p>调用该方法后，将触发BackgroundWorker. ProgressChanged事件。<br>另外，该方法包含了一个int类型的参数percentProgress，用来表示当前异步操作所执行的进度百分比。</p>
<p>该方法还有一个重载方法：ReportProgress(Int percentProgress, Object userState)。<br>允许传递一个Object类型的状态对象到 ProgressChanged事件中<br>并且可以通过ProgressChanged事件的ProgressChangedEventArgs.UserState属性取得参数值。</p>
<blockquote>
<p>注：调用该方法之前需确保WorkerReportsProgress属性值为True，否则将引发InvalidOperationException异常。</p>
</blockquote>
<p>用法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>&#123;c<br>    <span class="hljs-comment">//向ProgressChanged报告进度</span><br>    bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>    System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-3-3-CancelAsync"><a href="#6-3-3-CancelAsync" class="headerlink" title="6.3.3 CancelAsync()"></a>6.3.3 CancelAsync()</h3><p>请求取消当前正在执行的异步操作。</p>
<p>调用该方法将使BackgroundWorker.CancellationPending属性设置为True。<br>但需要注意的是，并非每次调用CancelAsync()都能确保异步操作，CancelAsync()通常不适用于取消一个紧密执行的操作，更适用于在循环体中执行。<br>用法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在需要执行取消操作的地方键入以下代码</span><br>bgWorker.CancelAsync();<br></code></pre></td></tr></table></figure>
<h2 id="6-4-事件表"><a href="#6-4-事件表" class="headerlink" title="6.4 事件表"></a>6.4 事件表</h2><h3 id="6-4-1-DoWork"><a href="#6-4-1-DoWork" class="headerlink" title="6.4.1 DoWork"></a>6.4.1 DoWork</h3><p>用于承载异步操作。当调用BackgroundWorker.RunWorkerAsync()时触发。</p>
<p>需要注意的是：<br>由于DoWork事件内部的代码运行在非UI线程之上，所以在DoWork事件内部应避免于用户界面交互，<br>而于用户界面交互的操作应放置在ProgressChanged和RunWorkerCompleted事件中。</p>
<h3 id="6-4-2-ProgressChanged"><a href="#6-4-2-ProgressChanged" class="headerlink" title="6.4.2 ProgressChanged"></a>6.4.2 ProgressChanged</h3><p>当调用BackgroundWorker.ReportProgress(int percentProgress)方式时触发该事件。<br>该事件的ProgressChangedEventArgs.ProgressPercentage属性可以接收来自ReportProgress方法传递的percentProgress参数值,ProgressChangedEventArgs.UserState属性可以接收来自ReportProgress方法传递的userState参数。</p>
<h3 id="6-4-3-RunWorkerCompleted"><a href="#6-4-3-RunWorkerCompleted" class="headerlink" title="6.4.3 RunWorkerCompleted"></a>6.4.3 RunWorkerCompleted</h3><p>异步操作完成或取消时执行的操作，当调用DoWork事件执行完成时触发。</p>
<p>该事件的RunWorkerCompletedEventArgs参数包含三个常用的属性Error,Cancelled,Result。其中，Error表示在执行异步操作期间发生的错误；Cancelled用于判断用户是否取消了异步操作；Result属性接收来自DoWork事件的DoWorkEventArgs参数的Result属性值，可用于传递异步操作的执行结果。</p>
<h2 id="6-3-案例"><a href="#6-3-案例" class="headerlink" title="6.3 案例"></a>6.3 案例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.ComponentModel;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br> <br><span class="hljs-keyword">namespace</span> <span class="hljs-title">bcworker</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br>        <span class="hljs-comment">//后台工作</span><br>        <span class="hljs-keyword">private</span> BackgroundWorker bw = <span class="hljs-keyword">new</span> BackgroundWorker();<br> <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>            <span class="hljs-comment">//后台工作初始化</span><br>            bw.WorkerReportsProgress = <span class="hljs-literal">true</span>;<span class="hljs-comment">//报告进度</span><br>            bw.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<span class="hljs-comment">//支持取消</span><br>            bw.DoWork += <span class="hljs-keyword">new</span> DoWorkEventHandler(bgWorker_DoWork);<span class="hljs-comment">//开始工作</span><br>            bw.ProgressChanged += <span class="hljs-keyword">new</span> ProgressChangedEventHandler(bgWorker_ProgessChanged);<span class="hljs-comment">//进度改变事件</span><br>            bw.RunWorkerCompleted += <span class="hljs-keyword">new</span> RunWorkerCompletedEventHandler(bgWorker_WorkerCompleted);<span class="hljs-comment">//进度完成事件</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnStart_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//后台工作运行中，避免重入</span><br>            <span class="hljs-keyword">if</span> (bw.IsBusy) <span class="hljs-keyword">return</span>;<br>            bw.RunWorkerAsync(<span class="hljs-string">&quot;参数&quot;</span>);<span class="hljs-comment">//触发DoWork事件并异步执行，IsBusy置为True</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作将异步执行</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_DoWork</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, DoWorkEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.Argument == &quot;参数&quot;;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>            &#123;<br> <br>                <span class="hljs-keyword">if</span> (bw.CancellationPending)<br>                &#123;<span class="hljs-comment">//用户取消了工作</span><br>                    e.Cancel = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    bw.ReportProgress(i, <span class="hljs-string">&quot;Working&quot;</span>);<span class="hljs-comment">//报告进度，触发ProgressChanged事件</span><br>                    Thread.Sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//模拟工作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//进度改变事件</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_ProgessChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, ProgressChangedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.UserState==&quot;Working&quot;</span><br>            progressBar1.Value = e.ProgressPercentage;<span class="hljs-comment">//取得进度更新控件，不用Invoke了</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作执行完毕,IsBusy置为False</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_WorkerCompleted</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//e.Error == null 是否发生错误</span><br>            <span class="hljs-comment">//e.Cancelled 完成是由于取消还是正常完成</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span> (bw.IsBusy) bw.CancelAsync();<span class="hljs-comment">//设置CancellationPending属性为True</span><br>        &#125;<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/C/">C#</a>
                    
                      <a class="hover-with-bg" href="/categories/C/C-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">C#高级特性</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">C#高级特性</a>
                    
                      <a class="hover-with-bg" href="/tags/C/">C#</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%80%BB%E7%BB%93/">总结</a>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">线程基本知识</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/05/23/InvalidOperationException/">
                        <span class="hidden-mobile">InvalidOperationException</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'MycroftCooper/MycroftCooper.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="music-player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=415793349&auto=0&height=66"></iframe>
  </div>>
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    
      <script  src="/js/lazyload.js" ></script>
    
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>














  
<script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
